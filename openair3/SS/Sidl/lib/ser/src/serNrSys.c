/*
 * Copyright 2022 Sequans Communications.
 *
 * Licensed to the OpenAirInterface (OAI) Software Alliance under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The OpenAirInterface Software Alliance licenses this file to You under
 * the OAI Public License, Version 1.0  (the "License"); you may not use this file
 * except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.openairinterface.org/?page_id=698
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * For more information about the OpenAirInterface (OAI) Software Alliance:
 *      contact@openairinterface.org
 */

#include <string.h>
#include "serNrSys.h"
#include "serMem.h"
#include "serUtils.h"

void serNrSysProcessInitClt(unsigned char* _arena, size_t _aSize, struct NR_SYSTEM_CTRL_REQ** FromSS)
{
	serMem_t _mem = serMemInit(_arena, _aSize);

	*FromSS = (struct NR_SYSTEM_CTRL_REQ*)serMalloc(_mem, sizeof(struct NR_SYSTEM_CTRL_REQ));
	memset(*FromSS, 0, sizeof(struct NR_SYSTEM_CTRL_REQ));
}

static int _serNrSysEncNR_RadioBearerId_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union NR_RadioBearerId_Type_Value* p, enum NR_RadioBearerId_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_RadioBearerId_Type_Srb) {
		HTON_8(&_buffer[*_lidx], p->Srb, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == NR_RadioBearerId_Type_Drb) {
		HTON_8(&_buffer[*_lidx], p->Drb, _lidx);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncNR_RadioBearerId_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_RadioBearerId_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncNR_RadioBearerId_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncQosFlow_Identification_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct QosFlow_Identification_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_32(&_buffer[*_lidx], p->PDU_SessionId, _lidx);
	HTON_32(&_buffer[*_lidx], p->QFI, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_RoutingInfo_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union NR_RoutingInfo_Type_Value* p, enum NR_RoutingInfo_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_RoutingInfo_Type_None) {
		HTON_8(&_buffer[*_lidx], p->None, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == NR_RoutingInfo_Type_RadioBearerId) {
		_serNrSysEncNR_RadioBearerId_Type(_buffer, _size, _lidx, &p->RadioBearerId);
		return SIDL_STATUS_OK;
	}
	if (d == NR_RoutingInfo_Type_QosFlow) {
		_serNrSysEncQosFlow_Identification_Type(_buffer, _size, _lidx, &p->QosFlow);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncNR_RoutingInfo_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_RoutingInfo_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncNR_RoutingInfo_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncRlcBearerRouting_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union RlcBearerRouting_Type_Value* p, enum RlcBearerRouting_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == RlcBearerRouting_Type_EUTRA) {
		{
			size_t _tmp = (size_t)p->EUTRA;
			HTON_32(&_buffer[*_lidx], _tmp, _lidx);
		}
		return SIDL_STATUS_OK;
	}
	if (d == RlcBearerRouting_Type_NR) {
		{
			size_t _tmp = (size_t)p->NR;
			HTON_32(&_buffer[*_lidx], _tmp, _lidx);
		}
		return SIDL_STATUS_OK;
	}
	if (d == RlcBearerRouting_Type_None) {
		HTON_8(&_buffer[*_lidx], p->None, _lidx);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncRlcBearerRouting_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct RlcBearerRouting_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncRlcBearerRouting_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSystemFrameNumberInfo_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SystemFrameNumberInfo_Type_Value* p, enum SystemFrameNumberInfo_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SystemFrameNumberInfo_Type_Number) {
		HTON_16(&_buffer[*_lidx], p->Number, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SystemFrameNumberInfo_Type_Any) {
		HTON_8(&_buffer[*_lidx], p->Any, _lidx);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncSystemFrameNumberInfo_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SystemFrameNumberInfo_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSystemFrameNumberInfo_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSubFrameInfo_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SubFrameInfo_Type_Value* p, enum SubFrameInfo_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SubFrameInfo_Type_Number) {
		HTON_8(&_buffer[*_lidx], p->Number, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SubFrameInfo_Type_Any) {
		HTON_8(&_buffer[*_lidx], p->Any, _lidx);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncSubFrameInfo_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SubFrameInfo_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSubFrameInfo_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncHyperSystemFrameNumberInfo_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const HyperSystemFrameNumberInfo_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSystemFrameNumberInfo_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSlotOffset_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SlotOffset_Type_Value* p, enum SlotOffset_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SlotOffset_Type_Numerology0) {
		HTON_8(&_buffer[*_lidx], p->Numerology0, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SlotOffset_Type_Numerology1) {
		HTON_8(&_buffer[*_lidx], p->Numerology1, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SlotOffset_Type_Numerology2) {
		HTON_8(&_buffer[*_lidx], p->Numerology2, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SlotOffset_Type_Numerology3) {
		HTON_8(&_buffer[*_lidx], p->Numerology3, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SlotOffset_Type_Numerology4) {
		HTON_8(&_buffer[*_lidx], p->Numerology4, _lidx);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncSlotOffset_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SlotOffset_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSlotOffset_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSlotTimingInfo_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SlotTimingInfo_Type_Value* p, enum SlotTimingInfo_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SlotTimingInfo_Type_SlotOffset) {
		_serNrSysEncSlotOffset_Type(_buffer, _size, _lidx, &p->SlotOffset);
		return SIDL_STATUS_OK;
	}
	if (d == SlotTimingInfo_Type_FirstSlot) {
		HTON_8(&_buffer[*_lidx], p->FirstSlot, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SlotTimingInfo_Type_Any) {
		HTON_8(&_buffer[*_lidx], p->Any, _lidx);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncSlotTimingInfo_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SlotTimingInfo_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSlotTimingInfo_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSubFrameTiming_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SubFrameTiming_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncSystemFrameNumberInfo_Type(_buffer, _size, _lidx, &p->SFN);
	_serNrSysEncSubFrameInfo_Type(_buffer, _size, _lidx, &p->Subframe);
	_serNrSysEncHyperSystemFrameNumberInfo_Type(_buffer, _size, _lidx, &p->HSFN);
	_serNrSysEncSlotTimingInfo_Type(_buffer, _size, _lidx, &p->Slot);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncTimingInfo_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union TimingInfo_Type_Value* p, enum TimingInfo_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == TimingInfo_Type_SubFrame) {
		_serNrSysEncSubFrameTiming_Type(_buffer, _size, _lidx, &p->SubFrame);
		return SIDL_STATUS_OK;
	}
	if (d == TimingInfo_Type_Now) {
		HTON_8(&_buffer[*_lidx], p->Now, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == TimingInfo_Type_None) {
		HTON_8(&_buffer[*_lidx], p->None, _lidx);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncTimingInfo_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct TimingInfo_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncTimingInfo_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncReqAspControlInfo_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct ReqAspControlInfo_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->CnfFlag, _lidx);
	HTON_8(&_buffer[*_lidx], p->FollowOnFlag, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_ReqAspCommonPart_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_ReqAspCommonPart_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->CellId;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncNR_RoutingInfo_Type(_buffer, _size, _lidx, &p->RoutingInfo);
	_serNrSysEncRlcBearerRouting_Type(_buffer, _size, _lidx, &p->RlcBearerRouting);
	_serNrSysEncTimingInfo_Type(_buffer, _size, _lidx, &p->TimingInfo);
	_serNrSysEncReqAspControlInfo_Type(_buffer, _size, _lidx, &p->ControlInfo);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_SS_StaticCellResourceConfig_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_SS_StaticCellResourceConfig_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->CellCapability;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	{
		size_t _tmp = (size_t)p->CarrierAggregation;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_SS_StaticCellResourceConfig_Type_StaticResourceConfig_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_SS_StaticCellResourceConfig_Type_StaticResourceConfig_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncNR_SS_StaticCellResourceConfig_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncRNTI_Value_Type_C_RNTI_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct RNTI_Value_Type_C_RNTI_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_16(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncUint8_t_TcOffset_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint8_t_TcOffset_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncCellTimingInfo_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CellTimingInfo_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncUint8_t_TcOffset_Optional(_buffer, _size, _lidx, &p->TcOffset);
	HTON_32(&_buffer[*_lidx], p->Tcell, _lidx);
	HTON_16(&_buffer[*_lidx], p->SfnOffset, _lidx);
	HTON_16(&_buffer[*_lidx], p->HsfnOffset, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncCellTimingInfo_Type_CellTimingInfo_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct CellTimingInfo_Type_CellTimingInfo_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncCellTimingInfo_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_Attenuation_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union NR_Attenuation_Type_Value* p, enum NR_Attenuation_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_Attenuation_Type_Value) {
		HTON_8(&_buffer[*_lidx], p->Value, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == NR_Attenuation_Type_Off) {
		HTON_8(&_buffer[*_lidx], p->Off, _lidx);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncNR_InitialAttenuation_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const NR_InitialAttenuation_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncNR_Attenuation_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_InitialCellPower_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_InitialCellPower_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_32(&_buffer[*_lidx], p->MaxReferencePower, _lidx);
	_serNrSysEncNR_InitialAttenuation_Type(_buffer, _size, _lidx, &p->Attenuation);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_InitialCellPower_Type_InitialCellPower_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_InitialCellPower_Type_InitialCellPower_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncNR_InitialCellPower_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_CellConfigCommon_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_CellConfigCommon_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncRNTI_Value_Type_C_RNTI_Optional(_buffer, _size, _lidx, &p->C_RNTI);
	_serNrSysEncCellTimingInfo_Type_CellTimingInfo_Optional(_buffer, _size, _lidx, &p->CellTimingInfo);
	_serNrSysEncNR_InitialCellPower_Type_InitialCellPower_Optional(_buffer, _size, _lidx, &p->InitialCellPower);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_CellConfigCommon_Type_CellConfigCommon_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_CellConfigCommon_Type_CellConfigCommon_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncNR_CellConfigCommon_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PhysCellId_PhysicalCellId_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PhysCellId_PhysicalCellId_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_16(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_FDD_Info_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_FDD_Info_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	(void)_buffer;
	(void)_size;
	(void)_lidx;
	(void)p;

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_TDD_UL_DL_Pattern_dl_UL_TransmissionPeriodicity_v1530_e_dl_UL_TransmissionPeriodicity_v1530_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_TDD_UL_DL_Pattern_dl_UL_TransmissionPeriodicity_v1530_e_dl_UL_TransmissionPeriodicity_v1530_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_TDD_UL_DL_Pattern(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_TDD_UL_DL_Pattern* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->dl_UL_TransmissionPeriodicity;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	HTON_16(&_buffer[*_lidx], p->nrofDownlinkSlots, _lidx);
	HTON_8(&_buffer[*_lidx], p->nrofDownlinkSymbols, _lidx);
	HTON_16(&_buffer[*_lidx], p->nrofUplinkSlots, _lidx);
	HTON_8(&_buffer[*_lidx], p->nrofUplinkSymbols, _lidx);
	_serNrSysEncSQN_NR_TDD_UL_DL_Pattern_dl_UL_TransmissionPeriodicity_v1530_e_dl_UL_TransmissionPeriodicity_v1530_Optional(_buffer, _size, _lidx, &p->dl_UL_TransmissionPeriodicity_v1530);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_TDD_UL_DL_Pattern_SQN_NR_TDD_UL_DL_ConfigCommon_pattern2_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_TDD_UL_DL_Pattern_SQN_NR_TDD_UL_DL_ConfigCommon_pattern2_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_TDD_UL_DL_Pattern(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_TDD_UL_DL_ConfigCommon(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_TDD_UL_DL_ConfigCommon* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->referenceSubcarrierSpacing;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_TDD_UL_DL_Pattern(_buffer, _size, _lidx, &p->pattern1);
	_serNrSysEncSQN_NR_TDD_UL_DL_Pattern_SQN_NR_TDD_UL_DL_ConfigCommon_pattern2_Optional(_buffer, _size, _lidx, &p->pattern2);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_ASN1_TDD_UL_DL_ConfigCommon_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union NR_ASN1_TDD_UL_DL_ConfigCommon_Type_Value* p, enum NR_ASN1_TDD_UL_DL_ConfigCommon_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_ASN1_TDD_UL_DL_ConfigCommon_Type_R15) {
		_serNrSysEncSQN_NR_TDD_UL_DL_ConfigCommon(_buffer, _size, _lidx, &p->R15);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncNR_ASN1_TDD_UL_DL_ConfigCommon_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_ASN1_TDD_UL_DL_ConfigCommon_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncNR_ASN1_TDD_UL_DL_ConfigCommon_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_ASN1_TDD_UL_DL_ConfigCommon_Type_Common_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_ASN1_TDD_UL_DL_ConfigCommon_Type_Common_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncNR_ASN1_TDD_UL_DL_ConfigCommon_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncUint8_t_SQN_NR_TDD_UL_DL_SlotConfig_symbols_explicit__nrofDownlinkSymbols_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint8_t_SQN_NR_TDD_UL_DL_SlotConfig_symbols_explicit__nrofDownlinkSymbols_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncUint8_t_SQN_NR_TDD_UL_DL_SlotConfig_symbols_explicit__nrofUplinkSymbols_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint8_t_SQN_NR_TDD_UL_DL_SlotConfig_symbols_explicit__nrofUplinkSymbols_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_TDD_UL_DL_SlotConfig_symbols_explicit_(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_TDD_UL_DL_SlotConfig_symbols_explicit_* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncUint8_t_SQN_NR_TDD_UL_DL_SlotConfig_symbols_explicit__nrofDownlinkSymbols_Optional(_buffer, _size, _lidx, &p->nrofDownlinkSymbols);
	_serNrSysEncUint8_t_SQN_NR_TDD_UL_DL_SlotConfig_symbols_explicit__nrofUplinkSymbols_Optional(_buffer, _size, _lidx, &p->nrofUplinkSymbols);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_TDD_UL_DL_SlotConfig_symbols_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SQN_NR_TDD_UL_DL_SlotConfig_symbols_Value* p, enum SQN_NR_TDD_UL_DL_SlotConfig_symbols_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_TDD_UL_DL_SlotConfig_symbols_allDownlink) {
		HTON_8(&_buffer[*_lidx], p->allDownlink, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_TDD_UL_DL_SlotConfig_symbols_allUplink) {
		HTON_8(&_buffer[*_lidx], p->allUplink, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_TDD_UL_DL_SlotConfig_symbols_explicit_) {
		_serNrSysEncSQN_NR_TDD_UL_DL_SlotConfig_symbols_explicit_(_buffer, _size, _lidx, &p->explicit_);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncSQN_NR_TDD_UL_DL_SlotConfig_symbols(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_TDD_UL_DL_SlotConfig_symbols* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_TDD_UL_DL_SlotConfig_symbols_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_TDD_UL_DL_SlotConfig(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_TDD_UL_DL_SlotConfig* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_16(&_buffer[*_lidx], p->slotIndex, _lidx);
	_serNrSysEncSQN_NR_TDD_UL_DL_SlotConfig_symbols(_buffer, _size, _lidx, &p->symbols);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_ASN1_TDD_UL_DL_SlotConfig_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union NR_ASN1_TDD_UL_DL_SlotConfig_Type_Value* p, enum NR_ASN1_TDD_UL_DL_SlotConfig_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_ASN1_TDD_UL_DL_SlotConfig_Type_R15) {
		_serNrSysEncSQN_NR_TDD_UL_DL_SlotConfig(_buffer, _size, _lidx, &p->R15);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncNR_ASN1_TDD_UL_DL_SlotConfig_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_ASN1_TDD_UL_DL_SlotConfig_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncNR_ASN1_TDD_UL_DL_SlotConfig_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_TDD_UL_DL_SlotConfigList_Type_Dedicated_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_TDD_UL_DL_SlotConfigList_Type_Dedicated_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i1 = 0; i1 < p->v.d; i1++) {
		_serNrSysEncNR_ASN1_TDD_UL_DL_SlotConfig_Type(_buffer, _size, _lidx, &p->v.v[i1]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_TDD_Config_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_TDD_Config_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncNR_ASN1_TDD_UL_DL_ConfigCommon_Type_Common_Optional(_buffer, _size, _lidx, &p->Common);
	_serNrSysEncNR_TDD_UL_DL_SlotConfigList_Type_Dedicated_Optional(_buffer, _size, _lidx, &p->Dedicated);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_TDD_Info_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union NR_TDD_Info_Type_Value* p, enum NR_TDD_Info_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_TDD_Info_Type_Config) {
		_serNrSysEncNR_TDD_Config_Type(_buffer, _size, _lidx, &p->Config);
		return SIDL_STATUS_OK;
	}
	if (d == NR_TDD_Info_Type_FullFlexible) {
		HTON_8(&_buffer[*_lidx], p->FullFlexible, _lidx);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncNR_TDD_Info_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_TDD_Info_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncNR_TDD_Info_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_DuplexMode_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union NR_DuplexMode_Type_Value* p, enum NR_DuplexMode_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_DuplexMode_Type_FDD) {
		_serNrSysEncNR_FDD_Info_Type(_buffer, _size, _lidx, &p->FDD);
		return SIDL_STATUS_OK;
	}
	if (d == NR_DuplexMode_Type_TDD) {
		_serNrSysEncNR_TDD_Info_Type(_buffer, _size, _lidx, &p->TDD);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncNR_DuplexMode_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_DuplexMode_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncNR_DuplexMode_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_DuplexMode_Type_DuplexMode_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_DuplexMode_Type_DuplexMode_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncNR_DuplexMode_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_CellConfigPhysicalLayerCommon_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_CellConfigPhysicalLayerCommon_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncSQN_NR_PhysCellId_PhysicalCellId_Optional(_buffer, _size, _lidx, &p->PhysicalCellId);
	_serNrSysEncNR_DuplexMode_Type_DuplexMode_Optional(_buffer, _size, _lidx, &p->DuplexMode);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_CellConfigPhysicalLayerCommon_Type_Common_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_CellConfigPhysicalLayerCommon_Type_Common_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncNR_CellConfigPhysicalLayerCommon_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_ARFCN_ValueNR_SQN_NR_FrequencyInfoDL_absoluteFrequencySSB_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_ARFCN_ValueNR_SQN_NR_FrequencyInfoDL_absoluteFrequencySSB_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncUint16_t_SQN_NR_SCS_SpecificCarrier_txDirectCurrentLocation_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint16_t_SQN_NR_SCS_SpecificCarrier_txDirectCurrentLocation_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_16(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SCS_SpecificCarrier(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SCS_SpecificCarrier* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_16(&_buffer[*_lidx], p->offsetToCarrier, _lidx);
	{
		size_t _tmp = (size_t)p->subcarrierSpacing;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	HTON_16(&_buffer[*_lidx], p->carrierBandwidth, _lidx);
	_serNrSysEncUint16_t_SQN_NR_SCS_SpecificCarrier_txDirectCurrentLocation_Optional(_buffer, _size, _lidx, &p->txDirectCurrentLocation);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_FrequencyInfoDL(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_FrequencyInfoDL* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncSQN_NR_ARFCN_ValueNR_SQN_NR_FrequencyInfoDL_absoluteFrequencySSB_Optional(_buffer, _size, _lidx, &p->absoluteFrequencySSB);
	HTON_32(&_buffer[*_lidx], p->frequencyBandList.d, _lidx);
	for (size_t i1 = 0; i1 < p->frequencyBandList.d; i1++) {
		HTON_16(&_buffer[*_lidx], p->frequencyBandList.v[i1], _lidx);
	}
	HTON_32(&_buffer[*_lidx], p->absoluteFrequencyPointA, _lidx);
	HTON_32(&_buffer[*_lidx], p->scs_SpecificCarrierList.d, _lidx);
	for (size_t i1 = 0; i1 < p->scs_SpecificCarrierList.d; i1++) {
		_serNrSysEncSQN_NR_SCS_SpecificCarrier(_buffer, _size, _lidx, &p->scs_SpecificCarrierList.v[i1]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_ASN1_FrequencyInfoDL_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union NR_ASN1_FrequencyInfoDL_Type_Value* p, enum NR_ASN1_FrequencyInfoDL_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_ASN1_FrequencyInfoDL_Type_R15) {
		_serNrSysEncSQN_NR_FrequencyInfoDL(_buffer, _size, _lidx, &p->R15);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncNR_ASN1_FrequencyInfoDL_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_ASN1_FrequencyInfoDL_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncNR_ASN1_FrequencyInfoDL_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_ASN1_FrequencyInfoDL_Type_FrequencyInfoDL_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_ASN1_FrequencyInfoDL_Type_FrequencyInfoDL_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncNR_ASN1_FrequencyInfoDL_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SubcarrierSpacing_e_SubCarrierSpacing_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SubcarrierSpacing_e_SubCarrierSpacing_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncInt32_t_NR_SSB_Config_Type_SubcarrierOffset_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct int32_t_NR_SSB_Config_Type_SubcarrierOffset_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_SSB_Periodicity_Type_Periodicity_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_SSB_Periodicity_Type_Periodicity_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncInt32_t_NR_SSB_Config_Type_HalfFrameOffset_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct int32_t_NR_SSB_Config_Type_HalfFrameOffset_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_SS_BlockPattern_Type_BlockPattern_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_SS_BlockPattern_Type_BlockPattern_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_ServingCellConfigCommon_ssb_PositionsInBurst_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SQN_NR_ServingCellConfigCommon_ssb_PositionsInBurst_Value* p, enum SQN_NR_ServingCellConfigCommon_ssb_PositionsInBurst_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_ServingCellConfigCommon_ssb_PositionsInBurst_shortBitmap) {
		for (size_t i1 = 0; i1 < 4; i1++) {
			HTON_8(&_buffer[*_lidx], p->shortBitmap[i1], _lidx);
		}
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_ServingCellConfigCommon_ssb_PositionsInBurst_mediumBitmap) {
		for (size_t i1 = 0; i1 < 8; i1++) {
			HTON_8(&_buffer[*_lidx], p->mediumBitmap[i1], _lidx);
		}
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_ServingCellConfigCommon_ssb_PositionsInBurst_longBitmap) {
		for (size_t i1 = 0; i1 < 64; i1++) {
			HTON_8(&_buffer[*_lidx], p->longBitmap[i1], _lidx);
		}
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncNR_SSB_PositionsInBurst_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const NR_SSB_PositionsInBurst_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_ServingCellConfigCommon_ssb_PositionsInBurst_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_SSB_PositionsInBurst_Type_PositionsInBurst_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_SSB_PositionsInBurst_Type_PositionsInBurst_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncNR_SSB_PositionsInBurst_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncInt32_t_NR_SSB_Beam_Type_SsbIndex_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct int32_t_NR_SSB_Beam_Type_SsbIndex_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncInt32_t_NR_SSB_Beam_Type_Attenuation_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct int32_t_NR_SSB_Beam_Type_Attenuation_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_SSB_Beam_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_SSB_Beam_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncInt32_t_NR_SSB_Beam_Type_SsbIndex_Optional(_buffer, _size, _lidx, &p->SsbIndex);
	_serNrSysEncInt32_t_NR_SSB_Beam_Type_Attenuation_Optional(_buffer, _size, _lidx, &p->Attenuation);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_SSB_BeamArray_Type_BeamArray_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_SSB_BeamArray_Type_BeamArray_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i1 = 0; i1 < p->v.d; i1++) {
		_serNrSysEncNR_SSB_Beam_Type(_buffer, _size, _lidx, &p->v.v[i1]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_SSB_BurstConfig_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_SSB_BurstConfig_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncNR_SS_BlockPattern_Type_BlockPattern_Optional(_buffer, _size, _lidx, &p->BlockPattern);
	_serNrSysEncNR_SSB_PositionsInBurst_Type_PositionsInBurst_Optional(_buffer, _size, _lidx, &p->PositionsInBurst);
	_serNrSysEncNR_SSB_BeamArray_Type_BeamArray_Optional(_buffer, _size, _lidx, &p->BeamArray);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_SSB_BurstConfig_Type_BurstConfig_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_SSB_BurstConfig_Type_BurstConfig_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncNR_SSB_BurstConfig_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_EPRE_Ratio_Type_PbchToDmrs_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_EPRE_Ratio_Type_PbchToDmrs_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_EPRE_Ratio_Type_PssToSss_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_EPRE_Ratio_Type_PssToSss_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_EPRE_Ratio_Type_SssToSsbBeam_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_EPRE_Ratio_Type_SssToSsbBeam_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_EPRE_Ratio_Type_DmrsToSss_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_EPRE_Ratio_Type_DmrsToSss_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_SSB_EPREs_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_SSB_EPREs_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncNR_EPRE_Ratio_Type_PbchToDmrs_Optional(_buffer, _size, _lidx, &p->PbchToDmrs);
	_serNrSysEncNR_EPRE_Ratio_Type_PssToSss_Optional(_buffer, _size, _lidx, &p->PssToSss);
	_serNrSysEncNR_EPRE_Ratio_Type_SssToSsbBeam_Optional(_buffer, _size, _lidx, &p->SssToSsbBeam);
	_serNrSysEncNR_EPRE_Ratio_Type_DmrsToSss_Optional(_buffer, _size, _lidx, &p->DmrsToSss);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_SSB_EPREs_Type_RelativeTxPower_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_SSB_EPREs_Type_RelativeTxPower_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncNR_SSB_EPREs_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_SSB_Config_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_SSB_Config_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncSQN_NR_SubcarrierSpacing_e_SubCarrierSpacing_Optional(_buffer, _size, _lidx, &p->SubCarrierSpacing);
	_serNrSysEncInt32_t_NR_SSB_Config_Type_SubcarrierOffset_Optional(_buffer, _size, _lidx, &p->SubcarrierOffset);
	_serNrSysEncNR_SSB_Periodicity_Type_Periodicity_Optional(_buffer, _size, _lidx, &p->Periodicity);
	_serNrSysEncInt32_t_NR_SSB_Config_Type_HalfFrameOffset_Optional(_buffer, _size, _lidx, &p->HalfFrameOffset);
	_serNrSysEncNR_SSB_BurstConfig_Type_BurstConfig_Optional(_buffer, _size, _lidx, &p->BurstConfig);
	_serNrSysEncNR_SSB_EPREs_Type_RelativeTxPower_Optional(_buffer, _size, _lidx, &p->RelativeTxPower);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_SSB_Config_Type_SSPbchBlock_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_SSB_Config_Type_SSPbchBlock_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncNR_SSB_Config_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_PDSCH_DMRS_TypeA_Position_Type_DMRS_TypeA_Position_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_PDSCH_DMRS_TypeA_Position_Type_DMRS_TypeA_Position_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_RateMatchPattern_patternType_bitmaps_symbolsInResourceBlock_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SQN_NR_RateMatchPattern_patternType_bitmaps_symbolsInResourceBlock_Value* p, enum SQN_NR_RateMatchPattern_patternType_bitmaps_symbolsInResourceBlock_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_RateMatchPattern_patternType_bitmaps_symbolsInResourceBlock_oneSlot) {
		for (size_t i2 = 0; i2 < 14; i2++) {
			HTON_8(&_buffer[*_lidx], p->oneSlot[i2], _lidx);
		}
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_RateMatchPattern_patternType_bitmaps_symbolsInResourceBlock_twoSlots) {
		for (size_t i2 = 0; i2 < 28; i2++) {
			HTON_8(&_buffer[*_lidx], p->twoSlots[i2], _lidx);
		}
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncSQN_NR_RateMatchPattern_patternType_bitmaps_symbolsInResourceBlock(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_RateMatchPattern_patternType_bitmaps_symbolsInResourceBlock* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_RateMatchPattern_patternType_bitmaps_symbolsInResourceBlock_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_RateMatchPattern_patternType_bitmaps_periodicityAndPattern_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SQN_NR_RateMatchPattern_patternType_bitmaps_periodicityAndPattern_Value* p, enum SQN_NR_RateMatchPattern_patternType_bitmaps_periodicityAndPattern_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_RateMatchPattern_patternType_bitmaps_periodicityAndPattern_n2) {
		for (size_t i2 = 0; i2 < 2; i2++) {
			HTON_8(&_buffer[*_lidx], p->n2[i2], _lidx);
		}
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_RateMatchPattern_patternType_bitmaps_periodicityAndPattern_n4) {
		for (size_t i2 = 0; i2 < 4; i2++) {
			HTON_8(&_buffer[*_lidx], p->n4[i2], _lidx);
		}
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_RateMatchPattern_patternType_bitmaps_periodicityAndPattern_n5) {
		for (size_t i2 = 0; i2 < 5; i2++) {
			HTON_8(&_buffer[*_lidx], p->n5[i2], _lidx);
		}
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_RateMatchPattern_patternType_bitmaps_periodicityAndPattern_n8) {
		for (size_t i2 = 0; i2 < 8; i2++) {
			HTON_8(&_buffer[*_lidx], p->n8[i2], _lidx);
		}
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_RateMatchPattern_patternType_bitmaps_periodicityAndPattern_n10) {
		for (size_t i2 = 0; i2 < 10; i2++) {
			HTON_8(&_buffer[*_lidx], p->n10[i2], _lidx);
		}
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_RateMatchPattern_patternType_bitmaps_periodicityAndPattern_n20) {
		for (size_t i2 = 0; i2 < 20; i2++) {
			HTON_8(&_buffer[*_lidx], p->n20[i2], _lidx);
		}
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_RateMatchPattern_patternType_bitmaps_periodicityAndPattern_n40) {
		for (size_t i2 = 0; i2 < 40; i2++) {
			HTON_8(&_buffer[*_lidx], p->n40[i2], _lidx);
		}
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncSQN_NR_RateMatchPattern_patternType_bitmaps_periodicityAndPattern(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_RateMatchPattern_patternType_bitmaps_periodicityAndPattern* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_RateMatchPattern_patternType_bitmaps_periodicityAndPattern_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_RateMatchPattern_patternType_bitmaps_periodicityAndPattern_periodicityAndPattern_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_RateMatchPattern_patternType_bitmaps_periodicityAndPattern_periodicityAndPattern_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_RateMatchPattern_patternType_bitmaps_periodicityAndPattern(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_RateMatchPattern_patternType_bitmaps(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_RateMatchPattern_patternType_bitmaps* p)
{
	(void)_size; // TODO: generate boundaries checking

	for (size_t i2 = 0; i2 < 275; i2++) {
		HTON_8(&_buffer[*_lidx], p->resourceBlocks[i2], _lidx);
	}
	_serNrSysEncSQN_NR_RateMatchPattern_patternType_bitmaps_symbolsInResourceBlock(_buffer, _size, _lidx, &p->symbolsInResourceBlock);
	_serNrSysEncSQN_NR_RateMatchPattern_patternType_bitmaps_periodicityAndPattern_periodicityAndPattern_Optional(_buffer, _size, _lidx, &p->periodicityAndPattern);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_RateMatchPattern_patternType_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SQN_NR_RateMatchPattern_patternType_Value* p, enum SQN_NR_RateMatchPattern_patternType_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_RateMatchPattern_patternType_bitmaps) {
		_serNrSysEncSQN_NR_RateMatchPattern_patternType_bitmaps(_buffer, _size, _lidx, &p->bitmaps);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_RateMatchPattern_patternType_controlResourceSet) {
		HTON_8(&_buffer[*_lidx], p->controlResourceSet, _lidx);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncSQN_NR_RateMatchPattern_patternType(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_RateMatchPattern_patternType* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_RateMatchPattern_patternType_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SubcarrierSpacing_e_SQN_NR_RateMatchPattern_subcarrierSpacing_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SubcarrierSpacing_e_SQN_NR_RateMatchPattern_subcarrierSpacing_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_ControlResourceSetId_r16_SQN_NR_RateMatchPattern_controlResourceSet_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_ControlResourceSetId_r16_SQN_NR_RateMatchPattern_controlResourceSet_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_RateMatchPattern(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_RateMatchPattern* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->rateMatchPatternId, _lidx);
	_serNrSysEncSQN_NR_RateMatchPattern_patternType(_buffer, _size, _lidx, &p->patternType);
	_serNrSysEncSQN_NR_SubcarrierSpacing_e_SQN_NR_RateMatchPattern_subcarrierSpacing_Optional(_buffer, _size, _lidx, &p->subcarrierSpacing);
	{
		size_t _tmp = (size_t)p->dummy;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_ControlResourceSetId_r16_SQN_NR_RateMatchPattern_controlResourceSet_r16_Optional(_buffer, _size, _lidx, &p->controlResourceSet_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_ASN1_RateMatchPattern_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union NR_ASN1_RateMatchPattern_Type_Value* p, enum NR_ASN1_RateMatchPattern_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_ASN1_RateMatchPattern_Type_R15) {
		_serNrSysEncSQN_NR_RateMatchPattern(_buffer, _size, _lidx, &p->R15);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncNR_ASN1_RateMatchPattern_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_ASN1_RateMatchPattern_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncNR_ASN1_RateMatchPattern_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_RateMatchPatternList_Type_PatternList_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_RateMatchPatternList_Type_PatternList_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i1 = 0; i1 < p->v.d; i1++) {
		_serNrSysEncNR_ASN1_RateMatchPattern_Type(_buffer, _size, _lidx, &p->v.v[i1]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_EUTRA_MBSFN_SubframeConfig_subframeAllocation1_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SQN_NR_EUTRA_MBSFN_SubframeConfig_subframeAllocation1_Value* p, enum SQN_NR_EUTRA_MBSFN_SubframeConfig_subframeAllocation1_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_EUTRA_MBSFN_SubframeConfig_subframeAllocation1_oneFrame) {
		for (size_t i3 = 0; i3 < 6; i3++) {
			HTON_8(&_buffer[*_lidx], p->oneFrame[i3], _lidx);
		}
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_EUTRA_MBSFN_SubframeConfig_subframeAllocation1_fourFrames) {
		for (size_t i3 = 0; i3 < 24; i3++) {
			HTON_8(&_buffer[*_lidx], p->fourFrames[i3], _lidx);
		}
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncSQN_NR_EUTRA_MBSFN_SubframeConfig_subframeAllocation1(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_EUTRA_MBSFN_SubframeConfig_subframeAllocation1* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_EUTRA_MBSFN_SubframeConfig_subframeAllocation1_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_EUTRA_MBSFN_SubframeConfig_subframeAllocation2_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SQN_NR_EUTRA_MBSFN_SubframeConfig_subframeAllocation2_Value* p, enum SQN_NR_EUTRA_MBSFN_SubframeConfig_subframeAllocation2_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_EUTRA_MBSFN_SubframeConfig_subframeAllocation2_oneFrame) {
		for (size_t i3 = 0; i3 < 2; i3++) {
			HTON_8(&_buffer[*_lidx], p->oneFrame[i3], _lidx);
		}
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_EUTRA_MBSFN_SubframeConfig_subframeAllocation2_fourFrames) {
		for (size_t i3 = 0; i3 < 8; i3++) {
			HTON_8(&_buffer[*_lidx], p->fourFrames[i3], _lidx);
		}
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncSQN_NR_EUTRA_MBSFN_SubframeConfig_subframeAllocation2(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_EUTRA_MBSFN_SubframeConfig_subframeAllocation2* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_EUTRA_MBSFN_SubframeConfig_subframeAllocation2_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_EUTRA_MBSFN_SubframeConfig_subframeAllocation2_subframeAllocation2_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_EUTRA_MBSFN_SubframeConfig_subframeAllocation2_subframeAllocation2_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_EUTRA_MBSFN_SubframeConfig_subframeAllocation2(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_EUTRA_MBSFN_SubframeConfig(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_EUTRA_MBSFN_SubframeConfig* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->radioframeAllocationPeriod;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	HTON_8(&_buffer[*_lidx], p->radioframeAllocationOffset, _lidx);
	_serNrSysEncSQN_NR_EUTRA_MBSFN_SubframeConfig_subframeAllocation1(_buffer, _size, _lidx, &p->subframeAllocation1);
	_serNrSysEncSQN_NR_EUTRA_MBSFN_SubframeConfig_subframeAllocation2_subframeAllocation2_Optional(_buffer, _size, _lidx, &p->subframeAllocation2);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_EUTRA_MBSFN_SubframeConfigList_SQN_NR_RateMatchPatternLTE_CRS_mbsfn_SubframeConfigList_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_EUTRA_MBSFN_SubframeConfigList_SQN_NR_RateMatchPatternLTE_CRS_mbsfn_SubframeConfigList_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serNrSysEncSQN_NR_EUTRA_MBSFN_SubframeConfig(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_RateMatchPatternLTE_CRS(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_RateMatchPatternLTE_CRS* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_16(&_buffer[*_lidx], p->carrierFreqDL, _lidx);
	{
		size_t _tmp = (size_t)p->carrierBandwidthDL;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_EUTRA_MBSFN_SubframeConfigList_SQN_NR_RateMatchPatternLTE_CRS_mbsfn_SubframeConfigList_Optional(_buffer, _size, _lidx, &p->mbsfn_SubframeConfigList);
	{
		size_t _tmp = (size_t)p->nrofCRS_Ports;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	{
		size_t _tmp = (size_t)p->v_Shift;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_ASN1_RateMatchPatternLTE_CRS_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union NR_ASN1_RateMatchPatternLTE_CRS_Type_Value* p, enum NR_ASN1_RateMatchPatternLTE_CRS_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_ASN1_RateMatchPatternLTE_CRS_Type_R15) {
		_serNrSysEncSQN_NR_RateMatchPatternLTE_CRS(_buffer, _size, _lidx, &p->R15);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncNR_ASN1_RateMatchPatternLTE_CRS_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_ASN1_RateMatchPatternLTE_CRS_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncNR_ASN1_RateMatchPatternLTE_CRS_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_RateMatchPatternLteCrsList_Type_PatternListLteCrs_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_RateMatchPatternLteCrsList_Type_PatternListLteCrs_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i1 = 0; i1 < p->v.d; i1++) {
		_serNrSysEncNR_ASN1_RateMatchPatternLTE_CRS_Type(_buffer, _size, _lidx, &p->v.v[i1]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_CellLevelRateMatchPattern_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_CellLevelRateMatchPattern_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncNR_RateMatchPatternList_Type_PatternList_Optional(_buffer, _size, _lidx, &p->PatternList);
	_serNrSysEncNR_RateMatchPatternLteCrsList_Type_PatternListLteCrs_Optional(_buffer, _size, _lidx, &p->PatternListLteCrs);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_CellLevelRateMatchPattern_Type_RateMatchPattern_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_CellLevelRateMatchPattern_Type_RateMatchPattern_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncNR_CellLevelRateMatchPattern_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PDSCH_CodeBlockGroupTransmission(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PDSCH_CodeBlockGroupTransmission* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->maxCodeBlockGroupsPerTransportBlock;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	HTON_8(&_buffer[*_lidx], p->codeBlockGroupFlushIndicator, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SetupRelease_PDSCH_ServingCellConfig_codeBlockGroupTransmission_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SQN_NR_SetupRelease_PDSCH_ServingCellConfig_codeBlockGroupTransmission_Value* p, enum SQN_NR_SetupRelease_PDSCH_ServingCellConfig_codeBlockGroupTransmission_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SetupRelease_PDSCH_ServingCellConfig_codeBlockGroupTransmission_release) {
		HTON_8(&_buffer[*_lidx], p->release, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SetupRelease_PDSCH_ServingCellConfig_codeBlockGroupTransmission_setup) {
		_serNrSysEncSQN_NR_PDSCH_CodeBlockGroupTransmission(_buffer, _size, _lidx, &p->setup);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncSQN_NR_SetupRelease_PDSCH_ServingCellConfig_codeBlockGroupTransmission(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SetupRelease_PDSCH_ServingCellConfig_codeBlockGroupTransmission* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_SetupRelease_PDSCH_ServingCellConfig_codeBlockGroupTransmission_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SetupRelease_PDSCH_ServingCellConfig_codeBlockGroupTransmission_SQN_NR_PDSCH_ServingCellConfig_codeBlockGroupTransmission_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SetupRelease_PDSCH_ServingCellConfig_codeBlockGroupTransmission_SQN_NR_PDSCH_ServingCellConfig_codeBlockGroupTransmission_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_SetupRelease_PDSCH_ServingCellConfig_codeBlockGroupTransmission(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PDSCH_ServingCellConfig_xOverhead_e_xOverhead_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PDSCH_ServingCellConfig_xOverhead_e_xOverhead_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PDSCH_ServingCellConfig_nrofHARQ_ProcessesForPDSCH_e_nrofHARQ_ProcessesForPDSCH_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PDSCH_ServingCellConfig_nrofHARQ_ProcessesForPDSCH_e_nrofHARQ_ProcessesForPDSCH_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_ServCellIndex_SQN_NR_PDSCH_ServingCellConfig_pucch_Cell_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_ServCellIndex_SQN_NR_PDSCH_ServingCellConfig_pucch_Cell_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncUint8_t_SQN_NR_PDSCH_ServingCellConfig_maxMIMO_Layers_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint8_t_SQN_NR_PDSCH_ServingCellConfig_maxMIMO_Layers_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncBool_SQN_NR_PDSCH_ServingCellConfig_processingType2Enabled_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct bool_SQN_NR_PDSCH_ServingCellConfig_processingType2Enabled_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SetupRelease_PDSCH_ServingCellConfig_pdsch_CodeBlockGroupTransmissionList_r16_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SQN_NR_SetupRelease_PDSCH_ServingCellConfig_pdsch_CodeBlockGroupTransmissionList_r16_Value* p, enum SQN_NR_SetupRelease_PDSCH_ServingCellConfig_pdsch_CodeBlockGroupTransmissionList_r16_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SetupRelease_PDSCH_ServingCellConfig_pdsch_CodeBlockGroupTransmissionList_r16_release) {
		HTON_8(&_buffer[*_lidx], p->release, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SetupRelease_PDSCH_ServingCellConfig_pdsch_CodeBlockGroupTransmissionList_r16_setup) {
		HTON_32(&_buffer[*_lidx], p->setup.d, _lidx);
		for (size_t i1 = 0; i1 < p->setup.d; i1++) {
			_serNrSysEncSQN_NR_PDSCH_CodeBlockGroupTransmission(_buffer, _size, _lidx, &p->setup.v[i1]);
		}
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncSQN_NR_SetupRelease_PDSCH_ServingCellConfig_pdsch_CodeBlockGroupTransmissionList_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SetupRelease_PDSCH_ServingCellConfig_pdsch_CodeBlockGroupTransmissionList_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_SetupRelease_PDSCH_ServingCellConfig_pdsch_CodeBlockGroupTransmissionList_r16_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SetupRelease_PDSCH_ServingCellConfig_pdsch_CodeBlockGroupTransmissionList_r16_SQN_NR_PDSCH_ServingCellConfig_pdsch_CodeBlockGroupTransmissionList_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SetupRelease_PDSCH_ServingCellConfig_pdsch_CodeBlockGroupTransmissionList_r16_SQN_NR_PDSCH_ServingCellConfig_pdsch_CodeBlockGroupTransmissionList_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_SetupRelease_PDSCH_ServingCellConfig_pdsch_CodeBlockGroupTransmissionList_r16(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PDSCH_ServingCellConfig(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PDSCH_ServingCellConfig* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncSQN_NR_SetupRelease_PDSCH_ServingCellConfig_codeBlockGroupTransmission_SQN_NR_PDSCH_ServingCellConfig_codeBlockGroupTransmission_Optional(_buffer, _size, _lidx, &p->codeBlockGroupTransmission);
	_serNrSysEncSQN_NR_PDSCH_ServingCellConfig_xOverhead_e_xOverhead_Optional(_buffer, _size, _lidx, &p->xOverhead);
	_serNrSysEncSQN_NR_PDSCH_ServingCellConfig_nrofHARQ_ProcessesForPDSCH_e_nrofHARQ_ProcessesForPDSCH_Optional(_buffer, _size, _lidx, &p->nrofHARQ_ProcessesForPDSCH);
	_serNrSysEncSQN_NR_ServCellIndex_SQN_NR_PDSCH_ServingCellConfig_pucch_Cell_Optional(_buffer, _size, _lidx, &p->pucch_Cell);
	_serNrSysEncUint8_t_SQN_NR_PDSCH_ServingCellConfig_maxMIMO_Layers_Optional(_buffer, _size, _lidx, &p->maxMIMO_Layers);
	_serNrSysEncBool_SQN_NR_PDSCH_ServingCellConfig_processingType2Enabled_Optional(_buffer, _size, _lidx, &p->processingType2Enabled);
	_serNrSysEncSQN_NR_SetupRelease_PDSCH_ServingCellConfig_pdsch_CodeBlockGroupTransmissionList_r16_SQN_NR_PDSCH_ServingCellConfig_pdsch_CodeBlockGroupTransmissionList_r16_Optional(_buffer, _size, _lidx, &p->pdsch_CodeBlockGroupTransmissionList_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_ASN1_PDSCH_ServingCellConfig_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union NR_ASN1_PDSCH_ServingCellConfig_Type_Value* p, enum NR_ASN1_PDSCH_ServingCellConfig_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_ASN1_PDSCH_ServingCellConfig_Type_R15) {
		_serNrSysEncSQN_NR_PDSCH_ServingCellConfig(_buffer, _size, _lidx, &p->R15);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncNR_ASN1_PDSCH_ServingCellConfig_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_ASN1_PDSCH_ServingCellConfig_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncNR_ASN1_PDSCH_ServingCellConfig_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_ASN1_PDSCH_ServingCellConfig_Type_ServingCellConfig_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_ASN1_PDSCH_ServingCellConfig_Type_ServingCellConfig_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncNR_ASN1_PDSCH_ServingCellConfig_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_PDSCH_CellLevelConfig_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_PDSCH_CellLevelConfig_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncNR_PDSCH_DMRS_TypeA_Position_Type_DMRS_TypeA_Position_Optional(_buffer, _size, _lidx, &p->DMRS_TypeA_Position);
	_serNrSysEncNR_CellLevelRateMatchPattern_Type_RateMatchPattern_Optional(_buffer, _size, _lidx, &p->RateMatchPattern);
	_serNrSysEncNR_ASN1_PDSCH_ServingCellConfig_Type_ServingCellConfig_Optional(_buffer, _size, _lidx, &p->ServingCellConfig);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_PDSCH_CellLevelConfig_Type_PdschCellLevelConfig_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_PDSCH_CellLevelConfig_Type_PdschCellLevelConfig_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncNR_PDSCH_CellLevelConfig_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_BWP_Id_ActiveBWP_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_BWP_Id_ActiveBWP_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_BWP_Id_NR_DownlinkBWP_Type_Id_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_BWP_Id_NR_DownlinkBWP_Type_Id_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_BWP_cyclicPrefix_e_cyclicPrefix_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_BWP_cyclicPrefix_e_cyclicPrefix_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_BWP(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_BWP* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_16(&_buffer[*_lidx], p->locationAndBandwidth, _lidx);
	{
		size_t _tmp = (size_t)p->subcarrierSpacing;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_BWP_cyclicPrefix_e_cyclicPrefix_Optional(_buffer, _size, _lidx, &p->cyclicPrefix);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_ASN1_BWP_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union NR_ASN1_BWP_Type_Value* p, enum NR_ASN1_BWP_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_ASN1_BWP_Type_R15) {
		_serNrSysEncSQN_NR_BWP(_buffer, _size, _lidx, &p->R15);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncNR_ASN1_BWP_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_ASN1_BWP_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncNR_ASN1_BWP_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_ASN1_BWP_Type_BWP_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_ASN1_BWP_Type_BWP_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncNR_ASN1_BWP_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_SearchSpaceTypeAndPriority_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_SearchSpaceTypeAndPriority_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->Type;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	HTON_32(&_buffer[*_lidx], p->CandidatePriority, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_ControlResourceSetId_SQN_NR_SearchSpace_controlResourceSetId_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_ControlResourceSetId_SQN_NR_SearchSpace_controlResourceSetId_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SearchSpace_monitoringSlotPeriodicityAndOffset_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SQN_NR_SearchSpace_monitoringSlotPeriodicityAndOffset_Value* p, enum SQN_NR_SearchSpace_monitoringSlotPeriodicityAndOffset_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SearchSpace_monitoringSlotPeriodicityAndOffset_sl1) {
		HTON_8(&_buffer[*_lidx], p->sl1, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SearchSpace_monitoringSlotPeriodicityAndOffset_sl2) {
		HTON_8(&_buffer[*_lidx], p->sl2, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SearchSpace_monitoringSlotPeriodicityAndOffset_sl4) {
		HTON_8(&_buffer[*_lidx], p->sl4, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SearchSpace_monitoringSlotPeriodicityAndOffset_sl5) {
		HTON_8(&_buffer[*_lidx], p->sl5, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SearchSpace_monitoringSlotPeriodicityAndOffset_sl8) {
		HTON_8(&_buffer[*_lidx], p->sl8, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SearchSpace_monitoringSlotPeriodicityAndOffset_sl10) {
		HTON_8(&_buffer[*_lidx], p->sl10, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SearchSpace_monitoringSlotPeriodicityAndOffset_sl16) {
		HTON_8(&_buffer[*_lidx], p->sl16, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SearchSpace_monitoringSlotPeriodicityAndOffset_sl20) {
		HTON_8(&_buffer[*_lidx], p->sl20, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SearchSpace_monitoringSlotPeriodicityAndOffset_sl40) {
		HTON_8(&_buffer[*_lidx], p->sl40, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SearchSpace_monitoringSlotPeriodicityAndOffset_sl80) {
		HTON_8(&_buffer[*_lidx], p->sl80, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SearchSpace_monitoringSlotPeriodicityAndOffset_sl160) {
		HTON_8(&_buffer[*_lidx], p->sl160, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SearchSpace_monitoringSlotPeriodicityAndOffset_sl320) {
		HTON_16(&_buffer[*_lidx], p->sl320, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SearchSpace_monitoringSlotPeriodicityAndOffset_sl640) {
		HTON_16(&_buffer[*_lidx], p->sl640, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SearchSpace_monitoringSlotPeriodicityAndOffset_sl1280) {
		HTON_16(&_buffer[*_lidx], p->sl1280, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SearchSpace_monitoringSlotPeriodicityAndOffset_sl2560) {
		HTON_16(&_buffer[*_lidx], p->sl2560, _lidx);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncSQN_NR_SearchSpace_monitoringSlotPeriodicityAndOffset(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SearchSpace_monitoringSlotPeriodicityAndOffset* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_SearchSpace_monitoringSlotPeriodicityAndOffset_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SearchSpace_monitoringSlotPeriodicityAndOffset_monitoringSlotPeriodicityAndOffset_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SearchSpace_monitoringSlotPeriodicityAndOffset_monitoringSlotPeriodicityAndOffset_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_SearchSpace_monitoringSlotPeriodicityAndOffset(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncUint16_t_SQN_NR_SearchSpace_duration_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint16_t_SQN_NR_SearchSpace_duration_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_16(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncB14_SQN_NR_SearchSpace_monitoringSymbolsWithinSlot_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct B14_SQN_NR_SearchSpace_monitoringSymbolsWithinSlot_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	for (size_t i3 = 0; i3 < 14; i3++) {
		HTON_8(&_buffer[*_lidx], p->v[i3], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SearchSpace_nrofCandidates(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SearchSpace_nrofCandidates* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->aggregationLevel1;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	{
		size_t _tmp = (size_t)p->aggregationLevel2;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	{
		size_t _tmp = (size_t)p->aggregationLevel4;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	{
		size_t _tmp = (size_t)p->aggregationLevel8;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	{
		size_t _tmp = (size_t)p->aggregationLevel16;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SearchSpace_nrofCandidates_nrofCandidates_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SearchSpace_nrofCandidates_nrofCandidates_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_SearchSpace_nrofCandidates(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SearchSpace_searchSpaceType_common_dci_Format0_0_AndFormat1_0(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SearchSpace_searchSpaceType_common_dci_Format0_0_AndFormat1_0* p)
{
	(void)_size; // TODO: generate boundaries checking

	(void)_buffer;
	(void)_size;
	(void)_lidx;
	(void)p;

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SearchSpace_searchSpaceType_common_dci_Format0_0_AndFormat1_0_dci_Format0_0_AndFormat1_0_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SearchSpace_searchSpaceType_common_dci_Format0_0_AndFormat1_0_dci_Format0_0_AndFormat1_0_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_SearchSpace_searchSpaceType_common_dci_Format0_0_AndFormat1_0(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SearchSpace_searchSpaceType_common_dci_Format2_0nrofCandidates_SFIaggregationLevel1_e_aggregationLevel1_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SearchSpace_searchSpaceType_common_dci_Format2_0nrofCandidates_SFIaggregationLevel1_e_aggregationLevel1_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SearchSpace_searchSpaceType_common_dci_Format2_0nrofCandidates_SFIaggregationLevel2_e_aggregationLevel2_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SearchSpace_searchSpaceType_common_dci_Format2_0nrofCandidates_SFIaggregationLevel2_e_aggregationLevel2_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SearchSpace_searchSpaceType_common_dci_Format2_0nrofCandidates_SFIaggregationLevel4_e_aggregationLevel4_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SearchSpace_searchSpaceType_common_dci_Format2_0nrofCandidates_SFIaggregationLevel4_e_aggregationLevel4_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SearchSpace_searchSpaceType_common_dci_Format2_0nrofCandidates_SFIaggregationLevel8_e_aggregationLevel8_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SearchSpace_searchSpaceType_common_dci_Format2_0nrofCandidates_SFIaggregationLevel8_e_aggregationLevel8_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SearchSpace_searchSpaceType_common_dci_Format2_0nrofCandidates_SFIaggregationLevel16_e_aggregationLevel16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SearchSpace_searchSpaceType_common_dci_Format2_0nrofCandidates_SFIaggregationLevel16_e_aggregationLevel16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SearchSpace_searchSpaceType_common_dci_Format2_0nrofCandidates_SFI(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SearchSpace_searchSpaceType_common_dci_Format2_0nrofCandidates_SFI* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncSQN_NR_SearchSpace_searchSpaceType_common_dci_Format2_0nrofCandidates_SFIaggregationLevel1_e_aggregationLevel1_Optional(_buffer, _size, _lidx, &p->aggregationLevel1);
	_serNrSysEncSQN_NR_SearchSpace_searchSpaceType_common_dci_Format2_0nrofCandidates_SFIaggregationLevel2_e_aggregationLevel2_Optional(_buffer, _size, _lidx, &p->aggregationLevel2);
	_serNrSysEncSQN_NR_SearchSpace_searchSpaceType_common_dci_Format2_0nrofCandidates_SFIaggregationLevel4_e_aggregationLevel4_Optional(_buffer, _size, _lidx, &p->aggregationLevel4);
	_serNrSysEncSQN_NR_SearchSpace_searchSpaceType_common_dci_Format2_0nrofCandidates_SFIaggregationLevel8_e_aggregationLevel8_Optional(_buffer, _size, _lidx, &p->aggregationLevel8);
	_serNrSysEncSQN_NR_SearchSpace_searchSpaceType_common_dci_Format2_0nrofCandidates_SFIaggregationLevel16_e_aggregationLevel16_Optional(_buffer, _size, _lidx, &p->aggregationLevel16);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SearchSpace_searchSpaceType_common_dci_Format2_0(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SearchSpace_searchSpaceType_common_dci_Format2_0* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncSQN_NR_SearchSpace_searchSpaceType_common_dci_Format2_0nrofCandidates_SFI(_buffer, _size, _lidx, &p->nrofCandidates_SFI);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SearchSpace_searchSpaceType_common_dci_Format2_0_dci_Format2_0_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SearchSpace_searchSpaceType_common_dci_Format2_0_dci_Format2_0_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_SearchSpace_searchSpaceType_common_dci_Format2_0(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SearchSpace_searchSpaceType_common_dci_Format2_1(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SearchSpace_searchSpaceType_common_dci_Format2_1* p)
{
	(void)_size; // TODO: generate boundaries checking

	(void)_buffer;
	(void)_size;
	(void)_lidx;
	(void)p;

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SearchSpace_searchSpaceType_common_dci_Format2_1_dci_Format2_1_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SearchSpace_searchSpaceType_common_dci_Format2_1_dci_Format2_1_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_SearchSpace_searchSpaceType_common_dci_Format2_1(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SearchSpace_searchSpaceType_common_dci_Format2_2(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SearchSpace_searchSpaceType_common_dci_Format2_2* p)
{
	(void)_size; // TODO: generate boundaries checking

	(void)_buffer;
	(void)_size;
	(void)_lidx;
	(void)p;

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SearchSpace_searchSpaceType_common_dci_Format2_2_dci_Format2_2_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SearchSpace_searchSpaceType_common_dci_Format2_2_dci_Format2_2_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_SearchSpace_searchSpaceType_common_dci_Format2_2(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SearchSpace_searchSpaceType_common_dci_Format2_3dummy1_e_dummy1_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SearchSpace_searchSpaceType_common_dci_Format2_3dummy1_e_dummy1_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SearchSpace_searchSpaceType_common_dci_Format2_3(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SearchSpace_searchSpaceType_common_dci_Format2_3* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncSQN_NR_SearchSpace_searchSpaceType_common_dci_Format2_3dummy1_e_dummy1_Optional(_buffer, _size, _lidx, &p->dummy1);
	{
		size_t _tmp = (size_t)p->dummy2;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SearchSpace_searchSpaceType_common_dci_Format2_3_dci_Format2_3_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SearchSpace_searchSpaceType_common_dci_Format2_3_dci_Format2_3_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_SearchSpace_searchSpaceType_common_dci_Format2_3(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SearchSpace_searchSpaceType_common(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SearchSpace_searchSpaceType_common* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncSQN_NR_SearchSpace_searchSpaceType_common_dci_Format0_0_AndFormat1_0_dci_Format0_0_AndFormat1_0_Optional(_buffer, _size, _lidx, &p->dci_Format0_0_AndFormat1_0);
	_serNrSysEncSQN_NR_SearchSpace_searchSpaceType_common_dci_Format2_0_dci_Format2_0_Optional(_buffer, _size, _lidx, &p->dci_Format2_0);
	_serNrSysEncSQN_NR_SearchSpace_searchSpaceType_common_dci_Format2_1_dci_Format2_1_Optional(_buffer, _size, _lidx, &p->dci_Format2_1);
	_serNrSysEncSQN_NR_SearchSpace_searchSpaceType_common_dci_Format2_2_dci_Format2_2_Optional(_buffer, _size, _lidx, &p->dci_Format2_2);
	_serNrSysEncSQN_NR_SearchSpace_searchSpaceType_common_dci_Format2_3_dci_Format2_3_Optional(_buffer, _size, _lidx, &p->dci_Format2_3);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SearchSpace_searchSpaceType_ue_Specific_dci_Formats_MT_r16_e_dci_Formats_MT_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SearchSpace_searchSpaceType_ue_Specific_dci_Formats_MT_r16_e_dci_Formats_MT_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SearchSpace_searchSpaceType_ue_Specific_dci_FormatsSL_r16_e_dci_FormatsSL_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SearchSpace_searchSpaceType_ue_Specific_dci_FormatsSL_r16_e_dci_FormatsSL_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SearchSpace_searchSpaceType_ue_Specific_dci_FormatsExt_r16_e_dci_FormatsExt_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SearchSpace_searchSpaceType_ue_Specific_dci_FormatsExt_r16_e_dci_FormatsExt_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SearchSpace_searchSpaceType_ue_Specific(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SearchSpace_searchSpaceType_ue_Specific* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->dci_Formats;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_SearchSpace_searchSpaceType_ue_Specific_dci_Formats_MT_r16_e_dci_Formats_MT_r16_Optional(_buffer, _size, _lidx, &p->dci_Formats_MT_r16);
	_serNrSysEncSQN_NR_SearchSpace_searchSpaceType_ue_Specific_dci_FormatsSL_r16_e_dci_FormatsSL_r16_Optional(_buffer, _size, _lidx, &p->dci_FormatsSL_r16);
	_serNrSysEncSQN_NR_SearchSpace_searchSpaceType_ue_Specific_dci_FormatsExt_r16_e_dci_FormatsExt_r16_Optional(_buffer, _size, _lidx, &p->dci_FormatsExt_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SearchSpace_searchSpaceType_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SQN_NR_SearchSpace_searchSpaceType_Value* p, enum SQN_NR_SearchSpace_searchSpaceType_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SearchSpace_searchSpaceType_common) {
		_serNrSysEncSQN_NR_SearchSpace_searchSpaceType_common(_buffer, _size, _lidx, &p->common);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SearchSpace_searchSpaceType_ue_Specific) {
		_serNrSysEncSQN_NR_SearchSpace_searchSpaceType_ue_Specific(_buffer, _size, _lidx, &p->ue_Specific);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncSQN_NR_SearchSpace_searchSpaceType(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SearchSpace_searchSpaceType* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_SearchSpace_searchSpaceType_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SearchSpace_searchSpaceType_searchSpaceType_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SearchSpace_searchSpaceType_searchSpaceType_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_SearchSpace_searchSpaceType(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SearchSpace(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SearchSpace* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->searchSpaceId, _lidx);
	_serNrSysEncSQN_NR_ControlResourceSetId_SQN_NR_SearchSpace_controlResourceSetId_Optional(_buffer, _size, _lidx, &p->controlResourceSetId);
	_serNrSysEncSQN_NR_SearchSpace_monitoringSlotPeriodicityAndOffset_monitoringSlotPeriodicityAndOffset_Optional(_buffer, _size, _lidx, &p->monitoringSlotPeriodicityAndOffset);
	_serNrSysEncUint16_t_SQN_NR_SearchSpace_duration_Optional(_buffer, _size, _lidx, &p->duration);
	_serNrSysEncB14_SQN_NR_SearchSpace_monitoringSymbolsWithinSlot_Optional(_buffer, _size, _lidx, &p->monitoringSymbolsWithinSlot);
	_serNrSysEncSQN_NR_SearchSpace_nrofCandidates_nrofCandidates_Optional(_buffer, _size, _lidx, &p->nrofCandidates);
	_serNrSysEncSQN_NR_SearchSpace_searchSpaceType_searchSpaceType_Optional(_buffer, _size, _lidx, &p->searchSpaceType);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_ASN1_SearchSpace_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union NR_ASN1_SearchSpace_Type_Value* p, enum NR_ASN1_SearchSpace_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_ASN1_SearchSpace_Type_R15) {
		_serNrSysEncSQN_NR_SearchSpace(_buffer, _size, _lidx, &p->R15);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncNR_ASN1_SearchSpace_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_ASN1_SearchSpace_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncNR_ASN1_SearchSpace_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_BWP_SearchSpaceConfig_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_BWP_SearchSpaceConfig_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_32(&_buffer[*_lidx], p->TypeAndPriorityList.d, _lidx);
	for (size_t i3 = 0; i3 < p->TypeAndPriorityList.d; i3++) {
		_serNrSysEncNR_SearchSpaceTypeAndPriority_Type(_buffer, _size, _lidx, &p->TypeAndPriorityList.v[i3]);
	}
	{
		size_t _tmp = (size_t)p->AggregationLevel;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncNR_ASN1_SearchSpace_Type(_buffer, _size, _lidx, &p->SearchSpaceConfigAtUE);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_BWP_SearchSpaceList_Type_SearchSpaceArray_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_BWP_SearchSpaceList_Type_SearchSpaceArray_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serNrSysEncNR_BWP_SearchSpaceConfig_Type(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncUint16_t_SQN_NR_ControlResourceSet_cce_REG_MappingType_interleaved_shiftIndex_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint16_t_SQN_NR_ControlResourceSet_cce_REG_MappingType_interleaved_shiftIndex_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_16(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_ControlResourceSet_cce_REG_MappingType_interleaved(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_ControlResourceSet_cce_REG_MappingType_interleaved* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->reg_BundleSize;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	{
		size_t _tmp = (size_t)p->interleaverSize;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncUint16_t_SQN_NR_ControlResourceSet_cce_REG_MappingType_interleaved_shiftIndex_Optional(_buffer, _size, _lidx, &p->shiftIndex);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_ControlResourceSet_cce_REG_MappingType_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SQN_NR_ControlResourceSet_cce_REG_MappingType_Value* p, enum SQN_NR_ControlResourceSet_cce_REG_MappingType_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_ControlResourceSet_cce_REG_MappingType_interleaved) {
		_serNrSysEncSQN_NR_ControlResourceSet_cce_REG_MappingType_interleaved(_buffer, _size, _lidx, &p->interleaved);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_ControlResourceSet_cce_REG_MappingType_nonInterleaved) {
		HTON_8(&_buffer[*_lidx], p->nonInterleaved, _lidx);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncSQN_NR_ControlResourceSet_cce_REG_MappingType(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_ControlResourceSet_cce_REG_MappingType* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_ControlResourceSet_cce_REG_MappingType_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_TCI_StateId_SQN_NR_ControlResourceSet_tci_StatesPDCCH_ToAddList_DynamicOptional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_TCI_StateId_SQN_NR_ControlResourceSet_tci_StatesPDCCH_ToAddList_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i3 = 0; i3 < p->v.d; i3++) {
		HTON_8(&_buffer[*_lidx], p->v.v[i3], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_TCI_StateId_SQN_NR_ControlResourceSet_tci_StatesPDCCH_ToReleaseList_DynamicOptional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_TCI_StateId_SQN_NR_ControlResourceSet_tci_StatesPDCCH_ToReleaseList_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i3 = 0; i3 < p->v.d; i3++) {
		HTON_8(&_buffer[*_lidx], p->v.v[i3], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_ControlResourceSet_tci_PresentInDCI_e_tci_PresentInDCI_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_ControlResourceSet_tci_PresentInDCI_e_tci_PresentInDCI_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncUint16_t_SQN_NR_ControlResourceSet_pdcch_DMRS_ScramblingID_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint16_t_SQN_NR_ControlResourceSet_pdcch_DMRS_ScramblingID_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_16(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncUint8_t_SQN_NR_ControlResourceSet_rb_Offset_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint8_t_SQN_NR_ControlResourceSet_rb_Offset_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncUint8_t_SQN_NR_ControlResourceSet_tci_PresentDCI_1_2_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint8_t_SQN_NR_ControlResourceSet_tci_PresentDCI_1_2_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncUint8_t_SQN_NR_ControlResourceSet_coresetPoolIndex_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint8_t_SQN_NR_ControlResourceSet_coresetPoolIndex_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_ControlResourceSetId_v1610_SQN_NR_ControlResourceSet_controlResourceSetId_v1610_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_ControlResourceSetId_v1610_SQN_NR_ControlResourceSet_controlResourceSetId_v1610_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_ControlResourceSet(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_ControlResourceSet* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->controlResourceSetId, _lidx);
	for (size_t i3 = 0; i3 < 45; i3++) {
		HTON_8(&_buffer[*_lidx], p->frequencyDomainResources[i3], _lidx);
	}
	HTON_8(&_buffer[*_lidx], p->duration, _lidx);
	_serNrSysEncSQN_NR_ControlResourceSet_cce_REG_MappingType(_buffer, _size, _lidx, &p->cce_REG_MappingType);
	{
		size_t _tmp = (size_t)p->precoderGranularity;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_TCI_StateId_SQN_NR_ControlResourceSet_tci_StatesPDCCH_ToAddList_DynamicOptional(_buffer, _size, _lidx, &p->tci_StatesPDCCH_ToAddList);
	_serNrSysEncSQN_NR_TCI_StateId_SQN_NR_ControlResourceSet_tci_StatesPDCCH_ToReleaseList_DynamicOptional(_buffer, _size, _lidx, &p->tci_StatesPDCCH_ToReleaseList);
	_serNrSysEncSQN_NR_ControlResourceSet_tci_PresentInDCI_e_tci_PresentInDCI_Optional(_buffer, _size, _lidx, &p->tci_PresentInDCI);
	_serNrSysEncUint16_t_SQN_NR_ControlResourceSet_pdcch_DMRS_ScramblingID_Optional(_buffer, _size, _lidx, &p->pdcch_DMRS_ScramblingID);
	_serNrSysEncUint8_t_SQN_NR_ControlResourceSet_rb_Offset_r16_Optional(_buffer, _size, _lidx, &p->rb_Offset_r16);
	_serNrSysEncUint8_t_SQN_NR_ControlResourceSet_tci_PresentDCI_1_2_r16_Optional(_buffer, _size, _lidx, &p->tci_PresentDCI_1_2_r16);
	_serNrSysEncUint8_t_SQN_NR_ControlResourceSet_coresetPoolIndex_r16_Optional(_buffer, _size, _lidx, &p->coresetPoolIndex_r16);
	_serNrSysEncSQN_NR_ControlResourceSetId_v1610_SQN_NR_ControlResourceSet_controlResourceSetId_v1610_Optional(_buffer, _size, _lidx, &p->controlResourceSetId_v1610);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_ASN1_ControlResourceSet_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union NR_ASN1_ControlResourceSet_Type_Value* p, enum NR_ASN1_ControlResourceSet_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_ASN1_ControlResourceSet_Type_R15) {
		_serNrSysEncSQN_NR_ControlResourceSet(_buffer, _size, _lidx, &p->R15);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncNR_ASN1_ControlResourceSet_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_ASN1_ControlResourceSet_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncNR_ASN1_ControlResourceSet_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_BWP_CoresetList_Type_CoresetArray_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_BWP_CoresetList_Type_CoresetArray_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serNrSysEncNR_ASN1_ControlResourceSet_Type(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_EPRE_Ratio_Type_PdcchToCell_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_EPRE_Ratio_Type_PdcchToCell_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_EPRE_Ratio_Type_PdcchToDmrs_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_EPRE_Ratio_Type_PdcchToDmrs_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_PDCCH_EPREs_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_PDCCH_EPREs_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncNR_EPRE_Ratio_Type_PdcchToCell_Optional(_buffer, _size, _lidx, &p->PdcchToCell);
	_serNrSysEncNR_EPRE_Ratio_Type_PdcchToDmrs_Optional(_buffer, _size, _lidx, &p->PdcchToDmrs);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_PDCCH_EPREs_Type_RelativeTxPower_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_PDCCH_EPREs_Type_RelativeTxPower_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncNR_PDCCH_EPREs_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncInt32_t_NR_BWP_PDCCH_Configuration_Type_Coreset0_OffsetRBs_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct int32_t_NR_BWP_PDCCH_Configuration_Type_Coreset0_OffsetRBs_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_BWP_PDCCH_Configuration_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_BWP_PDCCH_Configuration_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncNR_BWP_SearchSpaceList_Type_SearchSpaceArray_Optional(_buffer, _size, _lidx, &p->SearchSpaceArray);
	_serNrSysEncNR_BWP_CoresetList_Type_CoresetArray_Optional(_buffer, _size, _lidx, &p->CoresetArray);
	_serNrSysEncNR_PDCCH_EPREs_Type_RelativeTxPower_Optional(_buffer, _size, _lidx, &p->RelativeTxPower);
	_serNrSysEncInt32_t_NR_BWP_PDCCH_Configuration_Type_Coreset0_OffsetRBs_Optional(_buffer, _size, _lidx, &p->Coreset0_OffsetRBs);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_BWP_PDCCH_Configuration_Type_Pdcch_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_BWP_PDCCH_Configuration_Type_Pdcch_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncNR_BWP_PDCCH_Configuration_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncUint8_t_SQN_NR_PDSCH_TimeDomainResourceAllocation_k0_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint8_t_SQN_NR_PDSCH_TimeDomainResourceAllocation_k0_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PDSCH_TimeDomainResourceAllocation(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PDSCH_TimeDomainResourceAllocation* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncUint8_t_SQN_NR_PDSCH_TimeDomainResourceAllocation_k0_Optional(_buffer, _size, _lidx, &p->k0);
	{
		size_t _tmp = (size_t)p->mappingType;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	HTON_8(&_buffer[*_lidx], p->startSymbolAndLength, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PDSCH_TimeDomainResourceAllocationList_SQN_NR_PDSCH_ConfigCommon_pdsch_TimeDomainAllocationList_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PDSCH_TimeDomainResourceAllocationList_SQN_NR_PDSCH_ConfigCommon_pdsch_TimeDomainAllocationList_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serNrSysEncSQN_NR_PDSCH_TimeDomainResourceAllocation(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PDSCH_ConfigCommon(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PDSCH_ConfigCommon* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncSQN_NR_PDSCH_TimeDomainResourceAllocationList_SQN_NR_PDSCH_ConfigCommon_pdsch_TimeDomainAllocationList_Optional(_buffer, _size, _lidx, &p->pdsch_TimeDomainAllocationList);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_ASN1_PDSCH_ConfigCommon_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union NR_ASN1_PDSCH_ConfigCommon_Type_Value* p, enum NR_ASN1_PDSCH_ConfigCommon_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_ASN1_PDSCH_ConfigCommon_Type_R15) {
		_serNrSysEncSQN_NR_PDSCH_ConfigCommon(_buffer, _size, _lidx, &p->R15);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncNR_ASN1_PDSCH_ConfigCommon_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_ASN1_PDSCH_ConfigCommon_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncNR_ASN1_PDSCH_ConfigCommon_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_ASN1_PDSCH_ConfigCommon_Type_ConfigCommon_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_ASN1_PDSCH_ConfigCommon_Type_ConfigCommon_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncNR_ASN1_PDSCH_ConfigCommon_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncUint16_t_SQN_NR_PDSCH_Config_dataScramblingIdentityPDSCH_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint16_t_SQN_NR_PDSCH_Config_dataScramblingIdentityPDSCH_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_16(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_DMRS_DownlinkConfig_dmrs_Type_e_dmrs_Type_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_DMRS_DownlinkConfig_dmrs_Type_e_dmrs_Type_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_DMRS_DownlinkConfig_dmrs_AdditionalPosition_e_dmrs_AdditionalPosition_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_DMRS_DownlinkConfig_dmrs_AdditionalPosition_e_dmrs_AdditionalPosition_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_DMRS_DownlinkConfig_maxLength_e_maxLength_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_DMRS_DownlinkConfig_maxLength_e_maxLength_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncUint16_t_SQN_NR_DMRS_DownlinkConfig_scramblingID0_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint16_t_SQN_NR_DMRS_DownlinkConfig_scramblingID0_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_16(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncUint16_t_SQN_NR_DMRS_DownlinkConfig_scramblingID1_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint16_t_SQN_NR_DMRS_DownlinkConfig_scramblingID1_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_16(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncUint16_t_SQN_NR_PTRS_DownlinkConfig_frequencyDensity_ArrayOptional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint16_t_SQN_NR_PTRS_DownlinkConfig_frequencyDensity_ArrayOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	for (size_t i2 = 0; i2 < 2; i2++) {
		HTON_16(&_buffer[*_lidx], p->v[i2], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncUint8_t_SQN_NR_PTRS_DownlinkConfig_timeDensity_ArrayOptional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint8_t_SQN_NR_PTRS_DownlinkConfig_timeDensity_ArrayOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	for (size_t i2 = 0; i2 < 3; i2++) {
		HTON_8(&_buffer[*_lidx], p->v[i2], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncUint8_t_SQN_NR_PTRS_DownlinkConfig_epre_Ratio_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint8_t_SQN_NR_PTRS_DownlinkConfig_epre_Ratio_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PTRS_DownlinkConfig_resourceElementOffset_e_resourceElementOffset_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PTRS_DownlinkConfig_resourceElementOffset_e_resourceElementOffset_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PTRS_DownlinkConfig_maxNrofPorts_r16_e_maxNrofPorts_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PTRS_DownlinkConfig_maxNrofPorts_r16_e_maxNrofPorts_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PTRS_DownlinkConfig(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PTRS_DownlinkConfig* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncUint16_t_SQN_NR_PTRS_DownlinkConfig_frequencyDensity_ArrayOptional(_buffer, _size, _lidx, &p->frequencyDensity);
	_serNrSysEncUint8_t_SQN_NR_PTRS_DownlinkConfig_timeDensity_ArrayOptional(_buffer, _size, _lidx, &p->timeDensity);
	_serNrSysEncUint8_t_SQN_NR_PTRS_DownlinkConfig_epre_Ratio_Optional(_buffer, _size, _lidx, &p->epre_Ratio);
	_serNrSysEncSQN_NR_PTRS_DownlinkConfig_resourceElementOffset_e_resourceElementOffset_Optional(_buffer, _size, _lidx, &p->resourceElementOffset);
	_serNrSysEncSQN_NR_PTRS_DownlinkConfig_maxNrofPorts_r16_e_maxNrofPorts_r16_Optional(_buffer, _size, _lidx, &p->maxNrofPorts_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SetupRelease_DMRS_DownlinkConfig_phaseTrackingRS_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SQN_NR_SetupRelease_DMRS_DownlinkConfig_phaseTrackingRS_Value* p, enum SQN_NR_SetupRelease_DMRS_DownlinkConfig_phaseTrackingRS_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SetupRelease_DMRS_DownlinkConfig_phaseTrackingRS_release) {
		HTON_8(&_buffer[*_lidx], p->release, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SetupRelease_DMRS_DownlinkConfig_phaseTrackingRS_setup) {
		_serNrSysEncSQN_NR_PTRS_DownlinkConfig(_buffer, _size, _lidx, &p->setup);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncSQN_NR_SetupRelease_DMRS_DownlinkConfig_phaseTrackingRS(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SetupRelease_DMRS_DownlinkConfig_phaseTrackingRS* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_SetupRelease_DMRS_DownlinkConfig_phaseTrackingRS_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SetupRelease_DMRS_DownlinkConfig_phaseTrackingRS_SQN_NR_DMRS_DownlinkConfig_phaseTrackingRS_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SetupRelease_DMRS_DownlinkConfig_phaseTrackingRS_SQN_NR_DMRS_DownlinkConfig_phaseTrackingRS_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_SetupRelease_DMRS_DownlinkConfig_phaseTrackingRS(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_DMRS_DownlinkConfig_dmrs_Downlink_r16_e_dmrs_Downlink_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_DMRS_DownlinkConfig_dmrs_Downlink_r16_e_dmrs_Downlink_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_DMRS_DownlinkConfig(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_DMRS_DownlinkConfig* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncSQN_NR_DMRS_DownlinkConfig_dmrs_Type_e_dmrs_Type_Optional(_buffer, _size, _lidx, &p->dmrs_Type);
	_serNrSysEncSQN_NR_DMRS_DownlinkConfig_dmrs_AdditionalPosition_e_dmrs_AdditionalPosition_Optional(_buffer, _size, _lidx, &p->dmrs_AdditionalPosition);
	_serNrSysEncSQN_NR_DMRS_DownlinkConfig_maxLength_e_maxLength_Optional(_buffer, _size, _lidx, &p->maxLength);
	_serNrSysEncUint16_t_SQN_NR_DMRS_DownlinkConfig_scramblingID0_Optional(_buffer, _size, _lidx, &p->scramblingID0);
	_serNrSysEncUint16_t_SQN_NR_DMRS_DownlinkConfig_scramblingID1_Optional(_buffer, _size, _lidx, &p->scramblingID1);
	_serNrSysEncSQN_NR_SetupRelease_DMRS_DownlinkConfig_phaseTrackingRS_SQN_NR_DMRS_DownlinkConfig_phaseTrackingRS_Optional(_buffer, _size, _lidx, &p->phaseTrackingRS);
	_serNrSysEncSQN_NR_DMRS_DownlinkConfig_dmrs_Downlink_r16_e_dmrs_Downlink_r16_Optional(_buffer, _size, _lidx, &p->dmrs_Downlink_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SetupRelease_PDSCH_Config_dmrs_DownlinkForPDSCH_MappingTypeA_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SQN_NR_SetupRelease_PDSCH_Config_dmrs_DownlinkForPDSCH_MappingTypeA_Value* p, enum SQN_NR_SetupRelease_PDSCH_Config_dmrs_DownlinkForPDSCH_MappingTypeA_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SetupRelease_PDSCH_Config_dmrs_DownlinkForPDSCH_MappingTypeA_release) {
		HTON_8(&_buffer[*_lidx], p->release, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SetupRelease_PDSCH_Config_dmrs_DownlinkForPDSCH_MappingTypeA_setup) {
		_serNrSysEncSQN_NR_DMRS_DownlinkConfig(_buffer, _size, _lidx, &p->setup);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncSQN_NR_SetupRelease_PDSCH_Config_dmrs_DownlinkForPDSCH_MappingTypeA(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SetupRelease_PDSCH_Config_dmrs_DownlinkForPDSCH_MappingTypeA* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_SetupRelease_PDSCH_Config_dmrs_DownlinkForPDSCH_MappingTypeA_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SetupRelease_PDSCH_Config_dmrs_DownlinkForPDSCH_MappingTypeA_SQN_NR_PDSCH_Config_dmrs_DownlinkForPDSCH_MappingTypeA_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SetupRelease_PDSCH_Config_dmrs_DownlinkForPDSCH_MappingTypeA_SQN_NR_PDSCH_Config_dmrs_DownlinkForPDSCH_MappingTypeA_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_SetupRelease_PDSCH_Config_dmrs_DownlinkForPDSCH_MappingTypeA(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SetupRelease_PDSCH_Config_dmrs_DownlinkForPDSCH_MappingTypeB_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SQN_NR_SetupRelease_PDSCH_Config_dmrs_DownlinkForPDSCH_MappingTypeB_Value* p, enum SQN_NR_SetupRelease_PDSCH_Config_dmrs_DownlinkForPDSCH_MappingTypeB_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SetupRelease_PDSCH_Config_dmrs_DownlinkForPDSCH_MappingTypeB_release) {
		HTON_8(&_buffer[*_lidx], p->release, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SetupRelease_PDSCH_Config_dmrs_DownlinkForPDSCH_MappingTypeB_setup) {
		_serNrSysEncSQN_NR_DMRS_DownlinkConfig(_buffer, _size, _lidx, &p->setup);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncSQN_NR_SetupRelease_PDSCH_Config_dmrs_DownlinkForPDSCH_MappingTypeB(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SetupRelease_PDSCH_Config_dmrs_DownlinkForPDSCH_MappingTypeB* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_SetupRelease_PDSCH_Config_dmrs_DownlinkForPDSCH_MappingTypeB_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SetupRelease_PDSCH_Config_dmrs_DownlinkForPDSCH_MappingTypeB_SQN_NR_PDSCH_Config_dmrs_DownlinkForPDSCH_MappingTypeB_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SetupRelease_PDSCH_Config_dmrs_DownlinkForPDSCH_MappingTypeB_SQN_NR_PDSCH_Config_dmrs_DownlinkForPDSCH_MappingTypeB_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_SetupRelease_PDSCH_Config_dmrs_DownlinkForPDSCH_MappingTypeB(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_ServCellIndex_SQN_NR_QCL_Info_cell_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_ServCellIndex_SQN_NR_QCL_Info_cell_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_BWP_Id_SQN_NR_QCL_Info_bwp_Id_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_BWP_Id_SQN_NR_QCL_Info_bwp_Id_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_QCL_Info_referenceSignal_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SQN_NR_QCL_Info_referenceSignal_Value* p, enum SQN_NR_QCL_Info_referenceSignal_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_QCL_Info_referenceSignal_csi_rs) {
		HTON_8(&_buffer[*_lidx], p->csi_rs, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_QCL_Info_referenceSignal_ssb) {
		HTON_8(&_buffer[*_lidx], p->ssb, _lidx);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncSQN_NR_QCL_Info_referenceSignal(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_QCL_Info_referenceSignal* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_QCL_Info_referenceSignal_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_QCL_Info(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_QCL_Info* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncSQN_NR_ServCellIndex_SQN_NR_QCL_Info_cell_Optional(_buffer, _size, _lidx, &p->cell);
	_serNrSysEncSQN_NR_BWP_Id_SQN_NR_QCL_Info_bwp_Id_Optional(_buffer, _size, _lidx, &p->bwp_Id);
	_serNrSysEncSQN_NR_QCL_Info_referenceSignal(_buffer, _size, _lidx, &p->referenceSignal);
	{
		size_t _tmp = (size_t)p->qcl_Type;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_QCL_Info_SQN_NR_TCI_State_qcl_Type2_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_QCL_Info_SQN_NR_TCI_State_qcl_Type2_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_QCL_Info(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_TCI_State(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_TCI_State* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->tci_StateId, _lidx);
	_serNrSysEncSQN_NR_QCL_Info(_buffer, _size, _lidx, &p->qcl_Type1);
	_serNrSysEncSQN_NR_QCL_Info_SQN_NR_TCI_State_qcl_Type2_Optional(_buffer, _size, _lidx, &p->qcl_Type2);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_TCI_State_SQN_NR_PDSCH_Config_tci_StatesToAddModList_DynamicOptional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_TCI_State_SQN_NR_PDSCH_Config_tci_StatesToAddModList_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serNrSysEncSQN_NR_TCI_State(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_TCI_StateId_SQN_NR_PDSCH_Config_tci_StatesToReleaseList_DynamicOptional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_TCI_StateId_SQN_NR_PDSCH_Config_tci_StatesToReleaseList_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		HTON_8(&_buffer[*_lidx], p->v.v[i2], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PDSCH_Config_vrb_ToPRB_Interleaver_e_vrb_ToPRB_Interleaver_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PDSCH_Config_vrb_ToPRB_Interleaver_e_vrb_ToPRB_Interleaver_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SetupRelease_PDSCH_Config_pdsch_TimeDomainAllocationList_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SQN_NR_SetupRelease_PDSCH_Config_pdsch_TimeDomainAllocationList_Value* p, enum SQN_NR_SetupRelease_PDSCH_Config_pdsch_TimeDomainAllocationList_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SetupRelease_PDSCH_Config_pdsch_TimeDomainAllocationList_release) {
		HTON_8(&_buffer[*_lidx], p->release, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SetupRelease_PDSCH_Config_pdsch_TimeDomainAllocationList_setup) {
		HTON_32(&_buffer[*_lidx], p->setup.d, _lidx);
		for (size_t i2 = 0; i2 < p->setup.d; i2++) {
			_serNrSysEncSQN_NR_PDSCH_TimeDomainResourceAllocation(_buffer, _size, _lidx, &p->setup.v[i2]);
		}
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncSQN_NR_SetupRelease_PDSCH_Config_pdsch_TimeDomainAllocationList(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SetupRelease_PDSCH_Config_pdsch_TimeDomainAllocationList* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_SetupRelease_PDSCH_Config_pdsch_TimeDomainAllocationList_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SetupRelease_PDSCH_Config_pdsch_TimeDomainAllocationList_SQN_NR_PDSCH_Config_pdsch_TimeDomainAllocationList_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SetupRelease_PDSCH_Config_pdsch_TimeDomainAllocationList_SQN_NR_PDSCH_Config_pdsch_TimeDomainAllocationList_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_SetupRelease_PDSCH_Config_pdsch_TimeDomainAllocationList(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PDSCH_Config_pdsch_AggregationFactor_e_pdsch_AggregationFactor_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PDSCH_Config_pdsch_AggregationFactor_e_pdsch_AggregationFactor_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_RateMatchPattern_SQN_NR_PDSCH_Config_rateMatchPatternToAddModList_DynamicOptional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_RateMatchPattern_SQN_NR_PDSCH_Config_rateMatchPatternToAddModList_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serNrSysEncSQN_NR_RateMatchPattern(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_RateMatchPatternId_SQN_NR_PDSCH_Config_rateMatchPatternToReleaseList_DynamicOptional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_RateMatchPatternId_SQN_NR_PDSCH_Config_rateMatchPatternToReleaseList_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		HTON_8(&_buffer[*_lidx], p->v.v[i2], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_RateMatchPatternGroup_s_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SQN_NR_RateMatchPatternGroup_s_Value* p, enum SQN_NR_RateMatchPatternGroup_s_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_RateMatchPatternGroup_s_cellLevel) {
		HTON_8(&_buffer[*_lidx], p->cellLevel, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_RateMatchPatternGroup_s_bwpLevel) {
		HTON_8(&_buffer[*_lidx], p->bwpLevel, _lidx);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncSQN_NR_RateMatchPatternGroup_s(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_RateMatchPatternGroup_s* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_RateMatchPatternGroup_s_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_RateMatchPatternGroup_SQN_NR_PDSCH_Config_rateMatchPatternGroup1_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_RateMatchPatternGroup_SQN_NR_PDSCH_Config_rateMatchPatternGroup1_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serNrSysEncSQN_NR_RateMatchPatternGroup_s(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_RateMatchPatternGroup_SQN_NR_PDSCH_Config_rateMatchPatternGroup2_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_RateMatchPatternGroup_SQN_NR_PDSCH_Config_rateMatchPatternGroup2_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serNrSysEncSQN_NR_RateMatchPatternGroup_s(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PDSCH_Config_mcs_Table_e_mcs_Table_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PDSCH_Config_mcs_Table_e_mcs_Table_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PDSCH_Config_maxNrofCodeWordsScheduledByDCI_e_maxNrofCodeWordsScheduledByDCI_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PDSCH_Config_maxNrofCodeWordsScheduledByDCI_e_maxNrofCodeWordsScheduledByDCI_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PDSCH_Config_prb_BundlingType_staticBundling_bundleSize_e_bundleSize_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PDSCH_Config_prb_BundlingType_staticBundling_bundleSize_e_bundleSize_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PDSCH_Config_prb_BundlingType_staticBundling(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PDSCH_Config_prb_BundlingType_staticBundling* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncSQN_NR_PDSCH_Config_prb_BundlingType_staticBundling_bundleSize_e_bundleSize_Optional(_buffer, _size, _lidx, &p->bundleSize);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PDSCH_Config_prb_BundlingType_dynamicBundling_bundleSizeSet1_e_bundleSizeSet1_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PDSCH_Config_prb_BundlingType_dynamicBundling_bundleSizeSet1_e_bundleSizeSet1_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PDSCH_Config_prb_BundlingType_dynamicBundling_bundleSizeSet2_e_bundleSizeSet2_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PDSCH_Config_prb_BundlingType_dynamicBundling_bundleSizeSet2_e_bundleSizeSet2_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PDSCH_Config_prb_BundlingType_dynamicBundling(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PDSCH_Config_prb_BundlingType_dynamicBundling* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncSQN_NR_PDSCH_Config_prb_BundlingType_dynamicBundling_bundleSizeSet1_e_bundleSizeSet1_Optional(_buffer, _size, _lidx, &p->bundleSizeSet1);
	_serNrSysEncSQN_NR_PDSCH_Config_prb_BundlingType_dynamicBundling_bundleSizeSet2_e_bundleSizeSet2_Optional(_buffer, _size, _lidx, &p->bundleSizeSet2);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PDSCH_Config_prb_BundlingType_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SQN_NR_PDSCH_Config_prb_BundlingType_Value* p, enum SQN_NR_PDSCH_Config_prb_BundlingType_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_PDSCH_Config_prb_BundlingType_staticBundling) {
		_serNrSysEncSQN_NR_PDSCH_Config_prb_BundlingType_staticBundling(_buffer, _size, _lidx, &p->staticBundling);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_PDSCH_Config_prb_BundlingType_dynamicBundling) {
		_serNrSysEncSQN_NR_PDSCH_Config_prb_BundlingType_dynamicBundling(_buffer, _size, _lidx, &p->dynamicBundling);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncSQN_NR_PDSCH_Config_prb_BundlingType(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PDSCH_Config_prb_BundlingType* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_PDSCH_Config_prb_BundlingType_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_CSI_RS_ResourceMapping_frequencyDomainAllocation_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SQN_NR_CSI_RS_ResourceMapping_frequencyDomainAllocation_Value* p, enum SQN_NR_CSI_RS_ResourceMapping_frequencyDomainAllocation_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_CSI_RS_ResourceMapping_frequencyDomainAllocation_row1) {
		for (size_t i3 = 0; i3 < 4; i3++) {
			HTON_8(&_buffer[*_lidx], p->row1[i3], _lidx);
		}
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_CSI_RS_ResourceMapping_frequencyDomainAllocation_row2) {
		for (size_t i3 = 0; i3 < 12; i3++) {
			HTON_8(&_buffer[*_lidx], p->row2[i3], _lidx);
		}
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_CSI_RS_ResourceMapping_frequencyDomainAllocation_row4) {
		for (size_t i3 = 0; i3 < 3; i3++) {
			HTON_8(&_buffer[*_lidx], p->row4[i3], _lidx);
		}
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_CSI_RS_ResourceMapping_frequencyDomainAllocation_other) {
		for (size_t i3 = 0; i3 < 6; i3++) {
			HTON_8(&_buffer[*_lidx], p->other[i3], _lidx);
		}
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncSQN_NR_CSI_RS_ResourceMapping_frequencyDomainAllocation(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_CSI_RS_ResourceMapping_frequencyDomainAllocation* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_CSI_RS_ResourceMapping_frequencyDomainAllocation_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncUint8_t_SQN_NR_CSI_RS_ResourceMapping_firstOFDMSymbolInTimeDomain2_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint8_t_SQN_NR_CSI_RS_ResourceMapping_firstOFDMSymbolInTimeDomain2_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_CSI_RS_ResourceMapping_density_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SQN_NR_CSI_RS_ResourceMapping_density_Value* p, enum SQN_NR_CSI_RS_ResourceMapping_density_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_CSI_RS_ResourceMapping_density_dot5) {
		{
			size_t _tmp = (size_t)p->dot5;
			HTON_32(&_buffer[*_lidx], _tmp, _lidx);
		}
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_CSI_RS_ResourceMapping_density_one) {
		HTON_8(&_buffer[*_lidx], p->one, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_CSI_RS_ResourceMapping_density_three) {
		HTON_8(&_buffer[*_lidx], p->three, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_CSI_RS_ResourceMapping_density_spare) {
		HTON_8(&_buffer[*_lidx], p->spare, _lidx);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncSQN_NR_CSI_RS_ResourceMapping_density(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_CSI_RS_ResourceMapping_density* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_CSI_RS_ResourceMapping_density_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_CSI_FrequencyOccupation(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_CSI_FrequencyOccupation* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_16(&_buffer[*_lidx], p->startingRB, _lidx);
	HTON_16(&_buffer[*_lidx], p->nrofRBs, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_CSI_RS_ResourceMapping(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_CSI_RS_ResourceMapping* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncSQN_NR_CSI_RS_ResourceMapping_frequencyDomainAllocation(_buffer, _size, _lidx, &p->frequencyDomainAllocation);
	{
		size_t _tmp = (size_t)p->nrofPorts;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	HTON_8(&_buffer[*_lidx], p->firstOFDMSymbolInTimeDomain, _lidx);
	_serNrSysEncUint8_t_SQN_NR_CSI_RS_ResourceMapping_firstOFDMSymbolInTimeDomain2_Optional(_buffer, _size, _lidx, &p->firstOFDMSymbolInTimeDomain2);
	{
		size_t _tmp = (size_t)p->cdm_Type;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_CSI_RS_ResourceMapping_density(_buffer, _size, _lidx, &p->density);
	_serNrSysEncSQN_NR_CSI_FrequencyOccupation(_buffer, _size, _lidx, &p->freqBand);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_CSI_ResourcePeriodicityAndOffset_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SQN_NR_CSI_ResourcePeriodicityAndOffset_Value* p, enum SQN_NR_CSI_ResourcePeriodicityAndOffset_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_CSI_ResourcePeriodicityAndOffset_slots4) {
		HTON_8(&_buffer[*_lidx], p->slots4, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_CSI_ResourcePeriodicityAndOffset_slots5) {
		HTON_8(&_buffer[*_lidx], p->slots5, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_CSI_ResourcePeriodicityAndOffset_slots8) {
		HTON_8(&_buffer[*_lidx], p->slots8, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_CSI_ResourcePeriodicityAndOffset_slots10) {
		HTON_8(&_buffer[*_lidx], p->slots10, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_CSI_ResourcePeriodicityAndOffset_slots16) {
		HTON_8(&_buffer[*_lidx], p->slots16, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_CSI_ResourcePeriodicityAndOffset_slots20) {
		HTON_8(&_buffer[*_lidx], p->slots20, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_CSI_ResourcePeriodicityAndOffset_slots32) {
		HTON_8(&_buffer[*_lidx], p->slots32, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_CSI_ResourcePeriodicityAndOffset_slots40) {
		HTON_8(&_buffer[*_lidx], p->slots40, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_CSI_ResourcePeriodicityAndOffset_slots64) {
		HTON_8(&_buffer[*_lidx], p->slots64, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_CSI_ResourcePeriodicityAndOffset_slots80) {
		HTON_8(&_buffer[*_lidx], p->slots80, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_CSI_ResourcePeriodicityAndOffset_slots160) {
		HTON_8(&_buffer[*_lidx], p->slots160, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_CSI_ResourcePeriodicityAndOffset_slots320) {
		HTON_16(&_buffer[*_lidx], p->slots320, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_CSI_ResourcePeriodicityAndOffset_slots640) {
		HTON_16(&_buffer[*_lidx], p->slots640, _lidx);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncSQN_NR_CSI_ResourcePeriodicityAndOffset(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_CSI_ResourcePeriodicityAndOffset* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_CSI_ResourcePeriodicityAndOffset_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_CSI_ResourcePeriodicityAndOffset_SQN_NR_ZP_CSI_RS_Resource_periodicityAndOffset_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_CSI_ResourcePeriodicityAndOffset_SQN_NR_ZP_CSI_RS_Resource_periodicityAndOffset_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_CSI_ResourcePeriodicityAndOffset(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_ZP_CSI_RS_Resource(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_ZP_CSI_RS_Resource* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->zp_CSI_RS_ResourceId, _lidx);
	_serNrSysEncSQN_NR_CSI_RS_ResourceMapping(_buffer, _size, _lidx, &p->resourceMapping);
	_serNrSysEncSQN_NR_CSI_ResourcePeriodicityAndOffset_SQN_NR_ZP_CSI_RS_Resource_periodicityAndOffset_Optional(_buffer, _size, _lidx, &p->periodicityAndOffset);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_ZP_CSI_RS_Resource_SQN_NR_PDSCH_Config_zp_CSI_RS_ResourceToAddModList_DynamicOptional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_ZP_CSI_RS_Resource_SQN_NR_PDSCH_Config_zp_CSI_RS_ResourceToAddModList_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serNrSysEncSQN_NR_ZP_CSI_RS_Resource(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_ZP_CSI_RS_ResourceId_SQN_NR_PDSCH_Config_zp_CSI_RS_ResourceToReleaseList_DynamicOptional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_ZP_CSI_RS_ResourceId_SQN_NR_PDSCH_Config_zp_CSI_RS_ResourceToReleaseList_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		HTON_8(&_buffer[*_lidx], p->v.v[i2], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_ZP_CSI_RS_ResourceSet(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_ZP_CSI_RS_ResourceSet* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->zp_CSI_RS_ResourceSetId, _lidx);
	HTON_32(&_buffer[*_lidx], p->zp_CSI_RS_ResourceIdList.d, _lidx);
	for (size_t i3 = 0; i3 < p->zp_CSI_RS_ResourceIdList.d; i3++) {
		HTON_8(&_buffer[*_lidx], p->zp_CSI_RS_ResourceIdList.v[i3], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_ZP_CSI_RS_ResourceSet_SQN_NR_PDSCH_Config_aperiodic_ZP_CSI_RS_ResourceSetsToAddModList_DynamicOptional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_ZP_CSI_RS_ResourceSet_SQN_NR_PDSCH_Config_aperiodic_ZP_CSI_RS_ResourceSetsToAddModList_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serNrSysEncSQN_NR_ZP_CSI_RS_ResourceSet(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_ZP_CSI_RS_ResourceSetId_SQN_NR_PDSCH_Config_aperiodic_ZP_CSI_RS_ResourceSetsToReleaseList_DynamicOptional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_ZP_CSI_RS_ResourceSetId_SQN_NR_PDSCH_Config_aperiodic_ZP_CSI_RS_ResourceSetsToReleaseList_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		HTON_8(&_buffer[*_lidx], p->v.v[i2], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_ZP_CSI_RS_ResourceSet_SQN_NR_PDSCH_Config_sp_ZP_CSI_RS_ResourceSetsToAddModList_DynamicOptional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_ZP_CSI_RS_ResourceSet_SQN_NR_PDSCH_Config_sp_ZP_CSI_RS_ResourceSetsToAddModList_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serNrSysEncSQN_NR_ZP_CSI_RS_ResourceSet(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_ZP_CSI_RS_ResourceSetId_SQN_NR_PDSCH_Config_sp_ZP_CSI_RS_ResourceSetsToReleaseList_DynamicOptional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_ZP_CSI_RS_ResourceSetId_SQN_NR_PDSCH_Config_sp_ZP_CSI_RS_ResourceSetsToReleaseList_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		HTON_8(&_buffer[*_lidx], p->v.v[i2], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SetupRelease_PDSCH_Config_p_ZP_CSI_RS_ResourceSet_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SQN_NR_SetupRelease_PDSCH_Config_p_ZP_CSI_RS_ResourceSet_Value* p, enum SQN_NR_SetupRelease_PDSCH_Config_p_ZP_CSI_RS_ResourceSet_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SetupRelease_PDSCH_Config_p_ZP_CSI_RS_ResourceSet_release) {
		HTON_8(&_buffer[*_lidx], p->release, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SetupRelease_PDSCH_Config_p_ZP_CSI_RS_ResourceSet_setup) {
		_serNrSysEncSQN_NR_ZP_CSI_RS_ResourceSet(_buffer, _size, _lidx, &p->setup);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncSQN_NR_SetupRelease_PDSCH_Config_p_ZP_CSI_RS_ResourceSet(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SetupRelease_PDSCH_Config_p_ZP_CSI_RS_ResourceSet* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_SetupRelease_PDSCH_Config_p_ZP_CSI_RS_ResourceSet_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SetupRelease_PDSCH_Config_p_ZP_CSI_RS_ResourceSet_SQN_NR_PDSCH_Config_p_ZP_CSI_RS_ResourceSet_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SetupRelease_PDSCH_Config_p_ZP_CSI_RS_ResourceSet_SQN_NR_PDSCH_Config_p_ZP_CSI_RS_ResourceSet_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_SetupRelease_PDSCH_Config_p_ZP_CSI_RS_ResourceSet(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SetupRelease_PDSCH_Config_maxMIMO_Layers_r16_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SQN_NR_SetupRelease_PDSCH_Config_maxMIMO_Layers_r16_Value* p, enum SQN_NR_SetupRelease_PDSCH_Config_maxMIMO_Layers_r16_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SetupRelease_PDSCH_Config_maxMIMO_Layers_r16_release) {
		HTON_8(&_buffer[*_lidx], p->release, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SetupRelease_PDSCH_Config_maxMIMO_Layers_r16_setup) {
		HTON_8(&_buffer[*_lidx], p->setup, _lidx);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncSQN_NR_SetupRelease_PDSCH_Config_maxMIMO_Layers_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SetupRelease_PDSCH_Config_maxMIMO_Layers_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_SetupRelease_PDSCH_Config_maxMIMO_Layers_r16_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SetupRelease_PDSCH_Config_maxMIMO_Layers_r16_SQN_NR_PDSCH_Config_maxMIMO_Layers_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SetupRelease_PDSCH_Config_maxMIMO_Layers_r16_SQN_NR_PDSCH_Config_maxMIMO_Layers_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_SetupRelease_PDSCH_Config_maxMIMO_Layers_r16(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SetupRelease_PDSCH_Config_minimumSchedulingOffsetK0_r16_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SQN_NR_SetupRelease_PDSCH_Config_minimumSchedulingOffsetK0_r16_Value* p, enum SQN_NR_SetupRelease_PDSCH_Config_minimumSchedulingOffsetK0_r16_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SetupRelease_PDSCH_Config_minimumSchedulingOffsetK0_r16_release) {
		HTON_8(&_buffer[*_lidx], p->release, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SetupRelease_PDSCH_Config_minimumSchedulingOffsetK0_r16_setup) {
		HTON_32(&_buffer[*_lidx], p->setup.d, _lidx);
		for (size_t i2 = 0; i2 < p->setup.d; i2++) {
			HTON_8(&_buffer[*_lidx], p->setup.v[i2], _lidx);
		}
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncSQN_NR_SetupRelease_PDSCH_Config_minimumSchedulingOffsetK0_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SetupRelease_PDSCH_Config_minimumSchedulingOffsetK0_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_SetupRelease_PDSCH_Config_minimumSchedulingOffsetK0_r16_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SetupRelease_PDSCH_Config_minimumSchedulingOffsetK0_r16_SQN_NR_PDSCH_Config_minimumSchedulingOffsetK0_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SetupRelease_PDSCH_Config_minimumSchedulingOffsetK0_r16_SQN_NR_PDSCH_Config_minimumSchedulingOffsetK0_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_SetupRelease_PDSCH_Config_minimumSchedulingOffsetK0_r16(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PDSCH_Config_antennaPortsFieldPresenceDCI_1_2_r16_e_antennaPortsFieldPresenceDCI_1_2_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PDSCH_Config_antennaPortsFieldPresenceDCI_1_2_r16_e_antennaPortsFieldPresenceDCI_1_2_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_ZP_CSI_RS_ResourceSet_SQN_NR_PDSCH_Config_aperiodicZP_CSI_RS_ResourceSetsToAddModListDCI_1_2_r16_DynamicOptional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_ZP_CSI_RS_ResourceSet_SQN_NR_PDSCH_Config_aperiodicZP_CSI_RS_ResourceSetsToAddModListDCI_1_2_r16_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serNrSysEncSQN_NR_ZP_CSI_RS_ResourceSet(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_ZP_CSI_RS_ResourceSetId_SQN_NR_PDSCH_Config_aperiodicZP_CSI_RS_ResourceSetsToReleaseListDCI_1_2_r16_DynamicOptional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_ZP_CSI_RS_ResourceSetId_SQN_NR_PDSCH_Config_aperiodicZP_CSI_RS_ResourceSetsToReleaseListDCI_1_2_r16_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		HTON_8(&_buffer[*_lidx], p->v.v[i2], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SetupRelease_PDSCH_Config_dmrs_DownlinkForPDSCH_MappingTypeA_DCI_1_2_r16_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SQN_NR_SetupRelease_PDSCH_Config_dmrs_DownlinkForPDSCH_MappingTypeA_DCI_1_2_r16_Value* p, enum SQN_NR_SetupRelease_PDSCH_Config_dmrs_DownlinkForPDSCH_MappingTypeA_DCI_1_2_r16_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SetupRelease_PDSCH_Config_dmrs_DownlinkForPDSCH_MappingTypeA_DCI_1_2_r16_release) {
		HTON_8(&_buffer[*_lidx], p->release, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SetupRelease_PDSCH_Config_dmrs_DownlinkForPDSCH_MappingTypeA_DCI_1_2_r16_setup) {
		_serNrSysEncSQN_NR_DMRS_DownlinkConfig(_buffer, _size, _lidx, &p->setup);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncSQN_NR_SetupRelease_PDSCH_Config_dmrs_DownlinkForPDSCH_MappingTypeA_DCI_1_2_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SetupRelease_PDSCH_Config_dmrs_DownlinkForPDSCH_MappingTypeA_DCI_1_2_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_SetupRelease_PDSCH_Config_dmrs_DownlinkForPDSCH_MappingTypeA_DCI_1_2_r16_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SetupRelease_PDSCH_Config_dmrs_DownlinkForPDSCH_MappingTypeA_DCI_1_2_r16_SQN_NR_PDSCH_Config_dmrs_DownlinkForPDSCH_MappingTypeA_DCI_1_2_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SetupRelease_PDSCH_Config_dmrs_DownlinkForPDSCH_MappingTypeA_DCI_1_2_r16_SQN_NR_PDSCH_Config_dmrs_DownlinkForPDSCH_MappingTypeA_DCI_1_2_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_SetupRelease_PDSCH_Config_dmrs_DownlinkForPDSCH_MappingTypeA_DCI_1_2_r16(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SetupRelease_PDSCH_Config_dmrs_DownlinkForPDSCH_MappingTypeB_DCI_1_2_r16_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SQN_NR_SetupRelease_PDSCH_Config_dmrs_DownlinkForPDSCH_MappingTypeB_DCI_1_2_r16_Value* p, enum SQN_NR_SetupRelease_PDSCH_Config_dmrs_DownlinkForPDSCH_MappingTypeB_DCI_1_2_r16_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SetupRelease_PDSCH_Config_dmrs_DownlinkForPDSCH_MappingTypeB_DCI_1_2_r16_release) {
		HTON_8(&_buffer[*_lidx], p->release, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SetupRelease_PDSCH_Config_dmrs_DownlinkForPDSCH_MappingTypeB_DCI_1_2_r16_setup) {
		_serNrSysEncSQN_NR_DMRS_DownlinkConfig(_buffer, _size, _lidx, &p->setup);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncSQN_NR_SetupRelease_PDSCH_Config_dmrs_DownlinkForPDSCH_MappingTypeB_DCI_1_2_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SetupRelease_PDSCH_Config_dmrs_DownlinkForPDSCH_MappingTypeB_DCI_1_2_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_SetupRelease_PDSCH_Config_dmrs_DownlinkForPDSCH_MappingTypeB_DCI_1_2_r16_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SetupRelease_PDSCH_Config_dmrs_DownlinkForPDSCH_MappingTypeB_DCI_1_2_r16_SQN_NR_PDSCH_Config_dmrs_DownlinkForPDSCH_MappingTypeB_DCI_1_2_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SetupRelease_PDSCH_Config_dmrs_DownlinkForPDSCH_MappingTypeB_DCI_1_2_r16_SQN_NR_PDSCH_Config_dmrs_DownlinkForPDSCH_MappingTypeB_DCI_1_2_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_SetupRelease_PDSCH_Config_dmrs_DownlinkForPDSCH_MappingTypeB_DCI_1_2_r16(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PDSCH_Config_dmrs_SequenceInitializationDCI_1_2_r16_e_dmrs_SequenceInitializationDCI_1_2_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PDSCH_Config_dmrs_SequenceInitializationDCI_1_2_r16_e_dmrs_SequenceInitializationDCI_1_2_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncUint8_t_SQN_NR_PDSCH_Config_harq_ProcessNumberSizeDCI_1_2_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint8_t_SQN_NR_PDSCH_Config_harq_ProcessNumberSizeDCI_1_2_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PDSCH_Config_mcs_TableDCI_1_2_r16_e_mcs_TableDCI_1_2_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PDSCH_Config_mcs_TableDCI_1_2_r16_e_mcs_TableDCI_1_2_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncUint8_t_SQN_NR_PDSCH_Config_numberOfBitsForRV_DCI_1_2_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint8_t_SQN_NR_PDSCH_Config_numberOfBitsForRV_DCI_1_2_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncUint8_t_SQN_NR_PDSCH_TimeDomainResourceAllocation_r16_k0_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint8_t_SQN_NR_PDSCH_TimeDomainResourceAllocation_r16_k0_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PDSCH_TimeDomainResourceAllocation_r16_repetitionNumber_r16_e_repetitionNumber_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PDSCH_TimeDomainResourceAllocation_r16_repetitionNumber_r16_e_repetitionNumber_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PDSCH_TimeDomainResourceAllocation_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PDSCH_TimeDomainResourceAllocation_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncUint8_t_SQN_NR_PDSCH_TimeDomainResourceAllocation_r16_k0_r16_Optional(_buffer, _size, _lidx, &p->k0_r16);
	{
		size_t _tmp = (size_t)p->mappingType_r16;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	HTON_8(&_buffer[*_lidx], p->startSymbolAndLength_r16, _lidx);
	_serNrSysEncSQN_NR_PDSCH_TimeDomainResourceAllocation_r16_repetitionNumber_r16_e_repetitionNumber_r16_Optional(_buffer, _size, _lidx, &p->repetitionNumber_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SetupRelease_PDSCH_Config_pdsch_TimeDomainAllocationListDCI_1_2_r16_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SQN_NR_SetupRelease_PDSCH_Config_pdsch_TimeDomainAllocationListDCI_1_2_r16_Value* p, enum SQN_NR_SetupRelease_PDSCH_Config_pdsch_TimeDomainAllocationListDCI_1_2_r16_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SetupRelease_PDSCH_Config_pdsch_TimeDomainAllocationListDCI_1_2_r16_release) {
		HTON_8(&_buffer[*_lidx], p->release, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SetupRelease_PDSCH_Config_pdsch_TimeDomainAllocationListDCI_1_2_r16_setup) {
		HTON_32(&_buffer[*_lidx], p->setup.d, _lidx);
		for (size_t i2 = 0; i2 < p->setup.d; i2++) {
			_serNrSysEncSQN_NR_PDSCH_TimeDomainResourceAllocation_r16(_buffer, _size, _lidx, &p->setup.v[i2]);
		}
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncSQN_NR_SetupRelease_PDSCH_Config_pdsch_TimeDomainAllocationListDCI_1_2_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SetupRelease_PDSCH_Config_pdsch_TimeDomainAllocationListDCI_1_2_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_SetupRelease_PDSCH_Config_pdsch_TimeDomainAllocationListDCI_1_2_r16_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SetupRelease_PDSCH_Config_pdsch_TimeDomainAllocationListDCI_1_2_r16_SQN_NR_PDSCH_Config_pdsch_TimeDomainAllocationListDCI_1_2_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SetupRelease_PDSCH_Config_pdsch_TimeDomainAllocationListDCI_1_2_r16_SQN_NR_PDSCH_Config_pdsch_TimeDomainAllocationListDCI_1_2_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_SetupRelease_PDSCH_Config_pdsch_TimeDomainAllocationListDCI_1_2_r16(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PDSCH_Config_prb_BundlingTypeDCI_1_2_r16_staticBundling_r16_bundleSize_r16_e_bundleSize_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PDSCH_Config_prb_BundlingTypeDCI_1_2_r16_staticBundling_r16_bundleSize_r16_e_bundleSize_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PDSCH_Config_prb_BundlingTypeDCI_1_2_r16_staticBundling_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PDSCH_Config_prb_BundlingTypeDCI_1_2_r16_staticBundling_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncSQN_NR_PDSCH_Config_prb_BundlingTypeDCI_1_2_r16_staticBundling_r16_bundleSize_r16_e_bundleSize_r16_Optional(_buffer, _size, _lidx, &p->bundleSize_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PDSCH_Config_prb_BundlingTypeDCI_1_2_r16_dynamicBundling_r16_bundleSizeSet1_r16_e_bundleSizeSet1_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PDSCH_Config_prb_BundlingTypeDCI_1_2_r16_dynamicBundling_r16_bundleSizeSet1_r16_e_bundleSizeSet1_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PDSCH_Config_prb_BundlingTypeDCI_1_2_r16_dynamicBundling_r16_bundleSizeSet2_r16_e_bundleSizeSet2_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PDSCH_Config_prb_BundlingTypeDCI_1_2_r16_dynamicBundling_r16_bundleSizeSet2_r16_e_bundleSizeSet2_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PDSCH_Config_prb_BundlingTypeDCI_1_2_r16_dynamicBundling_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PDSCH_Config_prb_BundlingTypeDCI_1_2_r16_dynamicBundling_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncSQN_NR_PDSCH_Config_prb_BundlingTypeDCI_1_2_r16_dynamicBundling_r16_bundleSizeSet1_r16_e_bundleSizeSet1_r16_Optional(_buffer, _size, _lidx, &p->bundleSizeSet1_r16);
	_serNrSysEncSQN_NR_PDSCH_Config_prb_BundlingTypeDCI_1_2_r16_dynamicBundling_r16_bundleSizeSet2_r16_e_bundleSizeSet2_r16_Optional(_buffer, _size, _lidx, &p->bundleSizeSet2_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PDSCH_Config_prb_BundlingTypeDCI_1_2_r16_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SQN_NR_PDSCH_Config_prb_BundlingTypeDCI_1_2_r16_Value* p, enum SQN_NR_PDSCH_Config_prb_BundlingTypeDCI_1_2_r16_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_PDSCH_Config_prb_BundlingTypeDCI_1_2_r16_staticBundling_r16) {
		_serNrSysEncSQN_NR_PDSCH_Config_prb_BundlingTypeDCI_1_2_r16_staticBundling_r16(_buffer, _size, _lidx, &p->staticBundling_r16);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_PDSCH_Config_prb_BundlingTypeDCI_1_2_r16_dynamicBundling_r16) {
		_serNrSysEncSQN_NR_PDSCH_Config_prb_BundlingTypeDCI_1_2_r16_dynamicBundling_r16(_buffer, _size, _lidx, &p->dynamicBundling_r16);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncSQN_NR_PDSCH_Config_prb_BundlingTypeDCI_1_2_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PDSCH_Config_prb_BundlingTypeDCI_1_2_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_PDSCH_Config_prb_BundlingTypeDCI_1_2_r16_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PDSCH_Config_prb_BundlingTypeDCI_1_2_r16_prb_BundlingTypeDCI_1_2_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PDSCH_Config_prb_BundlingTypeDCI_1_2_r16_prb_BundlingTypeDCI_1_2_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_PDSCH_Config_prb_BundlingTypeDCI_1_2_r16(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PDSCH_Config_priorityIndicatorDCI_1_2_r16_e_priorityIndicatorDCI_1_2_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PDSCH_Config_priorityIndicatorDCI_1_2_r16_e_priorityIndicatorDCI_1_2_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_RateMatchPatternGroup_SQN_NR_PDSCH_Config_rateMatchPatternGroup1DCI_1_2_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_RateMatchPatternGroup_SQN_NR_PDSCH_Config_rateMatchPatternGroup1DCI_1_2_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serNrSysEncSQN_NR_RateMatchPatternGroup_s(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_RateMatchPatternGroup_SQN_NR_PDSCH_Config_rateMatchPatternGroup2DCI_1_2_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_RateMatchPatternGroup_SQN_NR_PDSCH_Config_rateMatchPatternGroup2DCI_1_2_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serNrSysEncSQN_NR_RateMatchPatternGroup_s(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PDSCH_Config_resourceAllocationType1GranularityDCI_1_2_r16_e_resourceAllocationType1GranularityDCI_1_2_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PDSCH_Config_resourceAllocationType1GranularityDCI_1_2_r16_e_resourceAllocationType1GranularityDCI_1_2_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PDSCH_Config_vrb_ToPRB_InterleaverDCI_1_2_r16_e_vrb_ToPRB_InterleaverDCI_1_2_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PDSCH_Config_vrb_ToPRB_InterleaverDCI_1_2_r16_e_vrb_ToPRB_InterleaverDCI_1_2_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PDSCH_Config_referenceOfSLIVDCI_1_2_r16_e_referenceOfSLIVDCI_1_2_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PDSCH_Config_referenceOfSLIVDCI_1_2_r16_e_referenceOfSLIVDCI_1_2_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PDSCH_Config_resourceAllocationDCI_1_2_r16_e_resourceAllocationDCI_1_2_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PDSCH_Config_resourceAllocationDCI_1_2_r16_e_resourceAllocationDCI_1_2_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PDSCH_Config_priorityIndicatorDCI_1_1_r16_e_priorityIndicatorDCI_1_1_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PDSCH_Config_priorityIndicatorDCI_1_1_r16_e_priorityIndicatorDCI_1_1_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncUint16_t_SQN_NR_PDSCH_Config_dataScramblingIdentityPDSCH2_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint16_t_SQN_NR_PDSCH_Config_dataScramblingIdentityPDSCH2_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_16(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SetupRelease_PDSCH_Config_pdsch_TimeDomainAllocationList_r16_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SQN_NR_SetupRelease_PDSCH_Config_pdsch_TimeDomainAllocationList_r16_Value* p, enum SQN_NR_SetupRelease_PDSCH_Config_pdsch_TimeDomainAllocationList_r16_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SetupRelease_PDSCH_Config_pdsch_TimeDomainAllocationList_r16_release) {
		HTON_8(&_buffer[*_lidx], p->release, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SetupRelease_PDSCH_Config_pdsch_TimeDomainAllocationList_r16_setup) {
		HTON_32(&_buffer[*_lidx], p->setup.d, _lidx);
		for (size_t i2 = 0; i2 < p->setup.d; i2++) {
			_serNrSysEncSQN_NR_PDSCH_TimeDomainResourceAllocation_r16(_buffer, _size, _lidx, &p->setup.v[i2]);
		}
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncSQN_NR_SetupRelease_PDSCH_Config_pdsch_TimeDomainAllocationList_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SetupRelease_PDSCH_Config_pdsch_TimeDomainAllocationList_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_SetupRelease_PDSCH_Config_pdsch_TimeDomainAllocationList_r16_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SetupRelease_PDSCH_Config_pdsch_TimeDomainAllocationList_r16_SQN_NR_PDSCH_Config_pdsch_TimeDomainAllocationList_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SetupRelease_PDSCH_Config_pdsch_TimeDomainAllocationList_r16_SQN_NR_PDSCH_Config_pdsch_TimeDomainAllocationList_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_SetupRelease_PDSCH_Config_pdsch_TimeDomainAllocationList_r16(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncUint8_t_SQN_NR_FDM_TDM_r16_startingSymbolOffsetK_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint8_t_SQN_NR_FDM_TDM_r16_startingSymbolOffsetK_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_FDM_TDM_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_FDM_TDM_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->repetitionScheme_r16;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncUint8_t_SQN_NR_FDM_TDM_r16_startingSymbolOffsetK_r16_Optional(_buffer, _size, _lidx, &p->startingSymbolOffsetK_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SetupRelease_RepetitionSchemeConfig_r16_fdm_TDM_r16_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SQN_NR_SetupRelease_RepetitionSchemeConfig_r16_fdm_TDM_r16_Value* p, enum SQN_NR_SetupRelease_RepetitionSchemeConfig_r16_fdm_TDM_r16_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SetupRelease_RepetitionSchemeConfig_r16_fdm_TDM_r16_release) {
		HTON_8(&_buffer[*_lidx], p->release, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SetupRelease_RepetitionSchemeConfig_r16_fdm_TDM_r16_setup) {
		_serNrSysEncSQN_NR_FDM_TDM_r16(_buffer, _size, _lidx, &p->setup);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncSQN_NR_SetupRelease_RepetitionSchemeConfig_r16_fdm_TDM_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SetupRelease_RepetitionSchemeConfig_r16_fdm_TDM_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_SetupRelease_RepetitionSchemeConfig_r16_fdm_TDM_r16_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SlotBased_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SlotBased_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->tciMapping_r16;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	HTON_8(&_buffer[*_lidx], p->sequenceOffsetforRV_r16, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SetupRelease_RepetitionSchemeConfig_r16_slotBased_r16_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SQN_NR_SetupRelease_RepetitionSchemeConfig_r16_slotBased_r16_Value* p, enum SQN_NR_SetupRelease_RepetitionSchemeConfig_r16_slotBased_r16_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SetupRelease_RepetitionSchemeConfig_r16_slotBased_r16_release) {
		HTON_8(&_buffer[*_lidx], p->release, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SetupRelease_RepetitionSchemeConfig_r16_slotBased_r16_setup) {
		_serNrSysEncSQN_NR_SlotBased_r16(_buffer, _size, _lidx, &p->setup);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncSQN_NR_SetupRelease_RepetitionSchemeConfig_r16_slotBased_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SetupRelease_RepetitionSchemeConfig_r16_slotBased_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_SetupRelease_RepetitionSchemeConfig_r16_slotBased_r16_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_RepetitionSchemeConfig_r16_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SQN_NR_RepetitionSchemeConfig_r16_Value* p, enum SQN_NR_RepetitionSchemeConfig_r16_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_RepetitionSchemeConfig_r16_fdm_TDM_r16) {
		_serNrSysEncSQN_NR_SetupRelease_RepetitionSchemeConfig_r16_fdm_TDM_r16(_buffer, _size, _lidx, &p->fdm_TDM_r16);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_RepetitionSchemeConfig_r16_slotBased_r16) {
		_serNrSysEncSQN_NR_SetupRelease_RepetitionSchemeConfig_r16_slotBased_r16(_buffer, _size, _lidx, &p->slotBased_r16);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncSQN_NR_RepetitionSchemeConfig_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_RepetitionSchemeConfig_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_RepetitionSchemeConfig_r16_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SetupRelease_PDSCH_Config_repetitionSchemeConfig_r16_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SQN_NR_SetupRelease_PDSCH_Config_repetitionSchemeConfig_r16_Value* p, enum SQN_NR_SetupRelease_PDSCH_Config_repetitionSchemeConfig_r16_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SetupRelease_PDSCH_Config_repetitionSchemeConfig_r16_release) {
		HTON_8(&_buffer[*_lidx], p->release, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SetupRelease_PDSCH_Config_repetitionSchemeConfig_r16_setup) {
		_serNrSysEncSQN_NR_RepetitionSchemeConfig_r16(_buffer, _size, _lidx, &p->setup);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncSQN_NR_SetupRelease_PDSCH_Config_repetitionSchemeConfig_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SetupRelease_PDSCH_Config_repetitionSchemeConfig_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_SetupRelease_PDSCH_Config_repetitionSchemeConfig_r16_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SetupRelease_PDSCH_Config_repetitionSchemeConfig_r16_SQN_NR_PDSCH_Config_repetitionSchemeConfig_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SetupRelease_PDSCH_Config_repetitionSchemeConfig_r16_SQN_NR_PDSCH_Config_repetitionSchemeConfig_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_SetupRelease_PDSCH_Config_repetitionSchemeConfig_r16(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PDSCH_Config(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PDSCH_Config* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncUint16_t_SQN_NR_PDSCH_Config_dataScramblingIdentityPDSCH_Optional(_buffer, _size, _lidx, &p->dataScramblingIdentityPDSCH);
	_serNrSysEncSQN_NR_SetupRelease_PDSCH_Config_dmrs_DownlinkForPDSCH_MappingTypeA_SQN_NR_PDSCH_Config_dmrs_DownlinkForPDSCH_MappingTypeA_Optional(_buffer, _size, _lidx, &p->dmrs_DownlinkForPDSCH_MappingTypeA);
	_serNrSysEncSQN_NR_SetupRelease_PDSCH_Config_dmrs_DownlinkForPDSCH_MappingTypeB_SQN_NR_PDSCH_Config_dmrs_DownlinkForPDSCH_MappingTypeB_Optional(_buffer, _size, _lidx, &p->dmrs_DownlinkForPDSCH_MappingTypeB);
	_serNrSysEncSQN_NR_TCI_State_SQN_NR_PDSCH_Config_tci_StatesToAddModList_DynamicOptional(_buffer, _size, _lidx, &p->tci_StatesToAddModList);
	_serNrSysEncSQN_NR_TCI_StateId_SQN_NR_PDSCH_Config_tci_StatesToReleaseList_DynamicOptional(_buffer, _size, _lidx, &p->tci_StatesToReleaseList);
	_serNrSysEncSQN_NR_PDSCH_Config_vrb_ToPRB_Interleaver_e_vrb_ToPRB_Interleaver_Optional(_buffer, _size, _lidx, &p->vrb_ToPRB_Interleaver);
	{
		size_t _tmp = (size_t)p->resourceAllocation;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_SetupRelease_PDSCH_Config_pdsch_TimeDomainAllocationList_SQN_NR_PDSCH_Config_pdsch_TimeDomainAllocationList_Optional(_buffer, _size, _lidx, &p->pdsch_TimeDomainAllocationList);
	_serNrSysEncSQN_NR_PDSCH_Config_pdsch_AggregationFactor_e_pdsch_AggregationFactor_Optional(_buffer, _size, _lidx, &p->pdsch_AggregationFactor);
	_serNrSysEncSQN_NR_RateMatchPattern_SQN_NR_PDSCH_Config_rateMatchPatternToAddModList_DynamicOptional(_buffer, _size, _lidx, &p->rateMatchPatternToAddModList);
	_serNrSysEncSQN_NR_RateMatchPatternId_SQN_NR_PDSCH_Config_rateMatchPatternToReleaseList_DynamicOptional(_buffer, _size, _lidx, &p->rateMatchPatternToReleaseList);
	_serNrSysEncSQN_NR_RateMatchPatternGroup_SQN_NR_PDSCH_Config_rateMatchPatternGroup1_Optional(_buffer, _size, _lidx, &p->rateMatchPatternGroup1);
	_serNrSysEncSQN_NR_RateMatchPatternGroup_SQN_NR_PDSCH_Config_rateMatchPatternGroup2_Optional(_buffer, _size, _lidx, &p->rateMatchPatternGroup2);
	{
		size_t _tmp = (size_t)p->rbg_Size;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_PDSCH_Config_mcs_Table_e_mcs_Table_Optional(_buffer, _size, _lidx, &p->mcs_Table);
	_serNrSysEncSQN_NR_PDSCH_Config_maxNrofCodeWordsScheduledByDCI_e_maxNrofCodeWordsScheduledByDCI_Optional(_buffer, _size, _lidx, &p->maxNrofCodeWordsScheduledByDCI);
	_serNrSysEncSQN_NR_PDSCH_Config_prb_BundlingType(_buffer, _size, _lidx, &p->prb_BundlingType);
	_serNrSysEncSQN_NR_ZP_CSI_RS_Resource_SQN_NR_PDSCH_Config_zp_CSI_RS_ResourceToAddModList_DynamicOptional(_buffer, _size, _lidx, &p->zp_CSI_RS_ResourceToAddModList);
	_serNrSysEncSQN_NR_ZP_CSI_RS_ResourceId_SQN_NR_PDSCH_Config_zp_CSI_RS_ResourceToReleaseList_DynamicOptional(_buffer, _size, _lidx, &p->zp_CSI_RS_ResourceToReleaseList);
	_serNrSysEncSQN_NR_ZP_CSI_RS_ResourceSet_SQN_NR_PDSCH_Config_aperiodic_ZP_CSI_RS_ResourceSetsToAddModList_DynamicOptional(_buffer, _size, _lidx, &p->aperiodic_ZP_CSI_RS_ResourceSetsToAddModList);
	_serNrSysEncSQN_NR_ZP_CSI_RS_ResourceSetId_SQN_NR_PDSCH_Config_aperiodic_ZP_CSI_RS_ResourceSetsToReleaseList_DynamicOptional(_buffer, _size, _lidx, &p->aperiodic_ZP_CSI_RS_ResourceSetsToReleaseList);
	_serNrSysEncSQN_NR_ZP_CSI_RS_ResourceSet_SQN_NR_PDSCH_Config_sp_ZP_CSI_RS_ResourceSetsToAddModList_DynamicOptional(_buffer, _size, _lidx, &p->sp_ZP_CSI_RS_ResourceSetsToAddModList);
	_serNrSysEncSQN_NR_ZP_CSI_RS_ResourceSetId_SQN_NR_PDSCH_Config_sp_ZP_CSI_RS_ResourceSetsToReleaseList_DynamicOptional(_buffer, _size, _lidx, &p->sp_ZP_CSI_RS_ResourceSetsToReleaseList);
	_serNrSysEncSQN_NR_SetupRelease_PDSCH_Config_p_ZP_CSI_RS_ResourceSet_SQN_NR_PDSCH_Config_p_ZP_CSI_RS_ResourceSet_Optional(_buffer, _size, _lidx, &p->p_ZP_CSI_RS_ResourceSet);
	_serNrSysEncSQN_NR_SetupRelease_PDSCH_Config_maxMIMO_Layers_r16_SQN_NR_PDSCH_Config_maxMIMO_Layers_r16_Optional(_buffer, _size, _lidx, &p->maxMIMO_Layers_r16);
	_serNrSysEncSQN_NR_SetupRelease_PDSCH_Config_minimumSchedulingOffsetK0_r16_SQN_NR_PDSCH_Config_minimumSchedulingOffsetK0_r16_Optional(_buffer, _size, _lidx, &p->minimumSchedulingOffsetK0_r16);
	_serNrSysEncSQN_NR_PDSCH_Config_antennaPortsFieldPresenceDCI_1_2_r16_e_antennaPortsFieldPresenceDCI_1_2_r16_Optional(_buffer, _size, _lidx, &p->antennaPortsFieldPresenceDCI_1_2_r16);
	_serNrSysEncSQN_NR_ZP_CSI_RS_ResourceSet_SQN_NR_PDSCH_Config_aperiodicZP_CSI_RS_ResourceSetsToAddModListDCI_1_2_r16_DynamicOptional(_buffer, _size, _lidx, &p->aperiodicZP_CSI_RS_ResourceSetsToAddModListDCI_1_2_r16);
	_serNrSysEncSQN_NR_ZP_CSI_RS_ResourceSetId_SQN_NR_PDSCH_Config_aperiodicZP_CSI_RS_ResourceSetsToReleaseListDCI_1_2_r16_DynamicOptional(_buffer, _size, _lidx, &p->aperiodicZP_CSI_RS_ResourceSetsToReleaseListDCI_1_2_r16);
	_serNrSysEncSQN_NR_SetupRelease_PDSCH_Config_dmrs_DownlinkForPDSCH_MappingTypeA_DCI_1_2_r16_SQN_NR_PDSCH_Config_dmrs_DownlinkForPDSCH_MappingTypeA_DCI_1_2_r16_Optional(_buffer, _size, _lidx, &p->dmrs_DownlinkForPDSCH_MappingTypeA_DCI_1_2_r16);
	_serNrSysEncSQN_NR_SetupRelease_PDSCH_Config_dmrs_DownlinkForPDSCH_MappingTypeB_DCI_1_2_r16_SQN_NR_PDSCH_Config_dmrs_DownlinkForPDSCH_MappingTypeB_DCI_1_2_r16_Optional(_buffer, _size, _lidx, &p->dmrs_DownlinkForPDSCH_MappingTypeB_DCI_1_2_r16);
	_serNrSysEncSQN_NR_PDSCH_Config_dmrs_SequenceInitializationDCI_1_2_r16_e_dmrs_SequenceInitializationDCI_1_2_r16_Optional(_buffer, _size, _lidx, &p->dmrs_SequenceInitializationDCI_1_2_r16);
	_serNrSysEncUint8_t_SQN_NR_PDSCH_Config_harq_ProcessNumberSizeDCI_1_2_r16_Optional(_buffer, _size, _lidx, &p->harq_ProcessNumberSizeDCI_1_2_r16);
	_serNrSysEncSQN_NR_PDSCH_Config_mcs_TableDCI_1_2_r16_e_mcs_TableDCI_1_2_r16_Optional(_buffer, _size, _lidx, &p->mcs_TableDCI_1_2_r16);
	_serNrSysEncUint8_t_SQN_NR_PDSCH_Config_numberOfBitsForRV_DCI_1_2_r16_Optional(_buffer, _size, _lidx, &p->numberOfBitsForRV_DCI_1_2_r16);
	_serNrSysEncSQN_NR_SetupRelease_PDSCH_Config_pdsch_TimeDomainAllocationListDCI_1_2_r16_SQN_NR_PDSCH_Config_pdsch_TimeDomainAllocationListDCI_1_2_r16_Optional(_buffer, _size, _lidx, &p->pdsch_TimeDomainAllocationListDCI_1_2_r16);
	_serNrSysEncSQN_NR_PDSCH_Config_prb_BundlingTypeDCI_1_2_r16_prb_BundlingTypeDCI_1_2_r16_Optional(_buffer, _size, _lidx, &p->prb_BundlingTypeDCI_1_2_r16);
	_serNrSysEncSQN_NR_PDSCH_Config_priorityIndicatorDCI_1_2_r16_e_priorityIndicatorDCI_1_2_r16_Optional(_buffer, _size, _lidx, &p->priorityIndicatorDCI_1_2_r16);
	_serNrSysEncSQN_NR_RateMatchPatternGroup_SQN_NR_PDSCH_Config_rateMatchPatternGroup1DCI_1_2_r16_Optional(_buffer, _size, _lidx, &p->rateMatchPatternGroup1DCI_1_2_r16);
	_serNrSysEncSQN_NR_RateMatchPatternGroup_SQN_NR_PDSCH_Config_rateMatchPatternGroup2DCI_1_2_r16_Optional(_buffer, _size, _lidx, &p->rateMatchPatternGroup2DCI_1_2_r16);
	_serNrSysEncSQN_NR_PDSCH_Config_resourceAllocationType1GranularityDCI_1_2_r16_e_resourceAllocationType1GranularityDCI_1_2_r16_Optional(_buffer, _size, _lidx, &p->resourceAllocationType1GranularityDCI_1_2_r16);
	_serNrSysEncSQN_NR_PDSCH_Config_vrb_ToPRB_InterleaverDCI_1_2_r16_e_vrb_ToPRB_InterleaverDCI_1_2_r16_Optional(_buffer, _size, _lidx, &p->vrb_ToPRB_InterleaverDCI_1_2_r16);
	_serNrSysEncSQN_NR_PDSCH_Config_referenceOfSLIVDCI_1_2_r16_e_referenceOfSLIVDCI_1_2_r16_Optional(_buffer, _size, _lidx, &p->referenceOfSLIVDCI_1_2_r16);
	_serNrSysEncSQN_NR_PDSCH_Config_resourceAllocationDCI_1_2_r16_e_resourceAllocationDCI_1_2_r16_Optional(_buffer, _size, _lidx, &p->resourceAllocationDCI_1_2_r16);
	_serNrSysEncSQN_NR_PDSCH_Config_priorityIndicatorDCI_1_1_r16_e_priorityIndicatorDCI_1_1_r16_Optional(_buffer, _size, _lidx, &p->priorityIndicatorDCI_1_1_r16);
	_serNrSysEncUint16_t_SQN_NR_PDSCH_Config_dataScramblingIdentityPDSCH2_r16_Optional(_buffer, _size, _lidx, &p->dataScramblingIdentityPDSCH2_r16);
	_serNrSysEncSQN_NR_SetupRelease_PDSCH_Config_pdsch_TimeDomainAllocationList_r16_SQN_NR_PDSCH_Config_pdsch_TimeDomainAllocationList_r16_Optional(_buffer, _size, _lidx, &p->pdsch_TimeDomainAllocationList_r16);
	_serNrSysEncSQN_NR_SetupRelease_PDSCH_Config_repetitionSchemeConfig_r16_SQN_NR_PDSCH_Config_repetitionSchemeConfig_r16_Optional(_buffer, _size, _lidx, &p->repetitionSchemeConfig_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_ASN1_PDSCH_Config_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union NR_ASN1_PDSCH_Config_Type_Value* p, enum NR_ASN1_PDSCH_Config_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_ASN1_PDSCH_Config_Type_R15) {
		_serNrSysEncSQN_NR_PDSCH_Config(_buffer, _size, _lidx, &p->R15);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncNR_ASN1_PDSCH_Config_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_ASN1_PDSCH_Config_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncNR_ASN1_PDSCH_Config_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_ASN1_PDSCH_Config_Type_ConfigDedicated_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_ASN1_PDSCH_Config_Type_ConfigDedicated_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncNR_ASN1_PDSCH_Config_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_EPRE_Ratio_Type_PdschToCell_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_EPRE_Ratio_Type_PdschToCell_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_EPRE_Ratio_Type_PdschToDmrs_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_EPRE_Ratio_Type_PdschToDmrs_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_EPRE_Ratio_Type_PdschToPtrs_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_EPRE_Ratio_Type_PdschToPtrs_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_PDSCH_EPREs_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_PDSCH_EPREs_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncNR_EPRE_Ratio_Type_PdschToCell_Optional(_buffer, _size, _lidx, &p->PdschToCell);
	_serNrSysEncNR_EPRE_Ratio_Type_PdschToDmrs_Optional(_buffer, _size, _lidx, &p->PdschToDmrs);
	_serNrSysEncNR_EPRE_Ratio_Type_PdschToPtrs_Optional(_buffer, _size, _lidx, &p->PdschToPtrs);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_PDSCH_EPREs_Type_RelativeTxPower_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_PDSCH_EPREs_Type_RelativeTxPower_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncNR_PDSCH_EPREs_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_BWP_PDSCH_Configuration_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_BWP_PDSCH_Configuration_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncNR_ASN1_PDSCH_ConfigCommon_Type_ConfigCommon_Optional(_buffer, _size, _lidx, &p->ConfigCommon);
	_serNrSysEncNR_ASN1_PDSCH_Config_Type_ConfigDedicated_Optional(_buffer, _size, _lidx, &p->ConfigDedicated);
	_serNrSysEncNR_PDSCH_EPREs_Type_RelativeTxPower_Optional(_buffer, _size, _lidx, &p->RelativeTxPower);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_BWP_PDSCH_Configuration_Type_Pdsch_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_BWP_PDSCH_Configuration_Type_Pdsch_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncNR_BWP_PDSCH_Configuration_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PUCCH_ResourceId_SQN_NR_SPS_Config_n1PUCCH_AN_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PUCCH_ResourceId_SQN_NR_SPS_Config_n1PUCCH_AN_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SPS_Config_mcs_Table_e_mcs_Table_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SPS_Config_mcs_Table_e_mcs_Table_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SPS_ConfigIndex_r16_SQN_NR_SPS_Config_sps_ConfigIndex_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SPS_ConfigIndex_r16_SQN_NR_SPS_Config_sps_ConfigIndex_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncUint8_t_SQN_NR_SPS_Config_harq_ProcID_Offset_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint8_t_SQN_NR_SPS_Config_harq_ProcID_Offset_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncUint16_t_SQN_NR_SPS_Config_periodicityExt_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint16_t_SQN_NR_SPS_Config_periodicityExt_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_16(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncUint8_t_SQN_NR_SPS_Config_harq_CodebookID_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint8_t_SQN_NR_SPS_Config_harq_CodebookID_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SPS_Config_pdsch_AggregationFactor_r16_e_pdsch_AggregationFactor_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SPS_Config_pdsch_AggregationFactor_r16_e_pdsch_AggregationFactor_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SPS_Config(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SPS_Config* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->periodicity;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	HTON_8(&_buffer[*_lidx], p->nrofHARQ_Processes, _lidx);
	_serNrSysEncSQN_NR_PUCCH_ResourceId_SQN_NR_SPS_Config_n1PUCCH_AN_Optional(_buffer, _size, _lidx, &p->n1PUCCH_AN);
	_serNrSysEncSQN_NR_SPS_Config_mcs_Table_e_mcs_Table_Optional(_buffer, _size, _lidx, &p->mcs_Table);
	_serNrSysEncSQN_NR_SPS_ConfigIndex_r16_SQN_NR_SPS_Config_sps_ConfigIndex_r16_Optional(_buffer, _size, _lidx, &p->sps_ConfigIndex_r16);
	_serNrSysEncUint8_t_SQN_NR_SPS_Config_harq_ProcID_Offset_r16_Optional(_buffer, _size, _lidx, &p->harq_ProcID_Offset_r16);
	_serNrSysEncUint16_t_SQN_NR_SPS_Config_periodicityExt_r16_Optional(_buffer, _size, _lidx, &p->periodicityExt_r16);
	_serNrSysEncUint8_t_SQN_NR_SPS_Config_harq_CodebookID_r16_Optional(_buffer, _size, _lidx, &p->harq_CodebookID_r16);
	_serNrSysEncSQN_NR_SPS_Config_pdsch_AggregationFactor_r16_e_pdsch_AggregationFactor_r16_Optional(_buffer, _size, _lidx, &p->pdsch_AggregationFactor_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_ASN1_SPS_Config_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union NR_ASN1_SPS_Config_Type_Value* p, enum NR_ASN1_SPS_Config_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_ASN1_SPS_Config_Type_R15) {
		_serNrSysEncSQN_NR_SPS_Config(_buffer, _size, _lidx, &p->R15);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncNR_ASN1_SPS_Config_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_ASN1_SPS_Config_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncNR_ASN1_SPS_Config_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_ASN1_SPS_Config_Type_Sps_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_ASN1_SPS_Config_Type_Sps_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncNR_ASN1_SPS_Config_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_DownlinkBWP_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_DownlinkBWP_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncSQN_NR_BWP_Id_NR_DownlinkBWP_Type_Id_Optional(_buffer, _size, _lidx, &p->Id);
	_serNrSysEncNR_ASN1_BWP_Type_BWP_Optional(_buffer, _size, _lidx, &p->BWP);
	_serNrSysEncNR_BWP_PDCCH_Configuration_Type_Pdcch_Optional(_buffer, _size, _lidx, &p->Pdcch);
	_serNrSysEncNR_BWP_PDSCH_Configuration_Type_Pdsch_Optional(_buffer, _size, _lidx, &p->Pdsch);
	_serNrSysEncNR_ASN1_SPS_Config_Type_Sps_Optional(_buffer, _size, _lidx, &p->Sps);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_DownlinkBWP_List_Type_BwpArray_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_DownlinkBWP_List_Type_BwpArray_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i1 = 0; i1 < p->v.d; i1++) {
		_serNrSysEncNR_DownlinkBWP_Type(_buffer, _size, _lidx, &p->v.v[i1]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_DownlinkBWPs_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_DownlinkBWPs_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncSQN_NR_BWP_Id_ActiveBWP_Optional(_buffer, _size, _lidx, &p->ActiveBWP);
	_serNrSysEncNR_DownlinkBWP_List_Type_BwpArray_Optional(_buffer, _size, _lidx, &p->BwpArray);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_DownlinkBWPs_Type_BWPs_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_DownlinkBWPs_Type_BWPs_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncNR_DownlinkBWPs_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_ScramblingId_ScramblingId_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_ScramblingId_ScramblingId_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_16(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_CSI_RS_ResourceMapping_ResourceMapping_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_CSI_RS_ResourceMapping_ResourceMapping_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_CSI_RS_ResourceMapping(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncInt32_t_NR_NZP_CSI_RS_Config_Type_OffsetToFreqBand_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct int32_t_NR_NZP_CSI_RS_Config_Type_OffsetToFreqBand_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_CSI_RS_Periodicity_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union NR_CSI_RS_Periodicity_Type_Value* p, enum NR_CSI_RS_Periodicity_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_CSI_RS_Periodicity_Type_PeriodicityAndOffset) {
		_serNrSysEncSQN_NR_CSI_ResourcePeriodicityAndOffset(_buffer, _size, _lidx, &p->PeriodicityAndOffset);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncNR_CSI_RS_Periodicity_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_CSI_RS_Periodicity_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncNR_CSI_RS_Periodicity_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_CSI_RS_Periodicity_Type_Periodicity_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_CSI_RS_Periodicity_Type_Periodicity_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncNR_CSI_RS_Periodicity_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncInt32_t_NR_NZP_CSI_RS_Config_Type_Attenuation_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct int32_t_NR_NZP_CSI_RS_Config_Type_Attenuation_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_NZP_CSI_RS_Config_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_NZP_CSI_RS_Config_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncSQN_NR_ScramblingId_ScramblingId_Optional(_buffer, _size, _lidx, &p->ScramblingId);
	_serNrSysEncSQN_NR_CSI_RS_ResourceMapping_ResourceMapping_Optional(_buffer, _size, _lidx, &p->ResourceMapping);
	_serNrSysEncInt32_t_NR_NZP_CSI_RS_Config_Type_OffsetToFreqBand_Optional(_buffer, _size, _lidx, &p->OffsetToFreqBand);
	_serNrSysEncNR_CSI_RS_Periodicity_Type_Periodicity_Optional(_buffer, _size, _lidx, &p->Periodicity);
	_serNrSysEncInt32_t_NR_NZP_CSI_RS_Config_Type_Attenuation_Optional(_buffer, _size, _lidx, &p->Attenuation);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_CSI_Config_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union NR_CSI_Config_Type_Value* p, enum NR_CSI_Config_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_CSI_Config_Type_CSI_RS) {
		HTON_32(&_buffer[*_lidx], p->CSI_RS.d, _lidx);
		for (size_t i1 = 0; i1 < p->CSI_RS.d; i1++) {
			_serNrSysEncNR_NZP_CSI_RS_Config_Type(_buffer, _size, _lidx, &p->CSI_RS.v[i1]);
		}
		return SIDL_STATUS_OK;
	}
	if (d == NR_CSI_Config_Type_None) {
		HTON_8(&_buffer[*_lidx], p->None, _lidx);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncNR_CSI_Config_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_CSI_Config_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncNR_CSI_Config_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_CSI_Config_Type_CsiConfig_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_CSI_Config_Type_CsiConfig_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncNR_CSI_Config_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_CellConfigPhysicalLayerDownlink_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_CellConfigPhysicalLayerDownlink_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncNR_ASN1_FrequencyInfoDL_Type_FrequencyInfoDL_Optional(_buffer, _size, _lidx, &p->FrequencyInfoDL);
	_serNrSysEncNR_SSB_Config_Type_SSPbchBlock_Optional(_buffer, _size, _lidx, &p->SSPbchBlock);
	_serNrSysEncNR_PDSCH_CellLevelConfig_Type_PdschCellLevelConfig_Optional(_buffer, _size, _lidx, &p->PdschCellLevelConfig);
	_serNrSysEncNR_DownlinkBWPs_Type_BWPs_Optional(_buffer, _size, _lidx, &p->BWPs);
	_serNrSysEncNR_CSI_Config_Type_CsiConfig_Optional(_buffer, _size, _lidx, &p->CsiConfig);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_CellConfigPhysicalLayerDownlink_Type_Downlink_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_CellConfigPhysicalLayerDownlink_Type_Downlink_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncNR_CellConfigPhysicalLayerDownlink_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_MultiFrequencyBandListNR_SQN_NR_FrequencyInfoUL_frequencyBandList_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_MultiFrequencyBandListNR_SQN_NR_FrequencyInfoUL_frequencyBandList_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i1 = 0; i1 < p->v.d; i1++) {
		HTON_16(&_buffer[*_lidx], p->v.v[i1], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_ARFCN_ValueNR_SQN_NR_FrequencyInfoUL_absoluteFrequencyPointA_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_ARFCN_ValueNR_SQN_NR_FrequencyInfoUL_absoluteFrequencyPointA_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_AdditionalSpectrumEmission_SQN_NR_FrequencyInfoUL_additionalSpectrumEmission_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_AdditionalSpectrumEmission_SQN_NR_FrequencyInfoUL_additionalSpectrumEmission_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_P_Max_SQN_NR_FrequencyInfoUL_p_Max_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_P_Max_SQN_NR_FrequencyInfoUL_p_Max_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_FrequencyInfoUL_frequencyShift7p5khz_e_frequencyShift7p5khz_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_FrequencyInfoUL_frequencyShift7p5khz_e_frequencyShift7p5khz_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_FrequencyInfoUL(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_FrequencyInfoUL* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncSQN_NR_MultiFrequencyBandListNR_SQN_NR_FrequencyInfoUL_frequencyBandList_Optional(_buffer, _size, _lidx, &p->frequencyBandList);
	_serNrSysEncSQN_NR_ARFCN_ValueNR_SQN_NR_FrequencyInfoUL_absoluteFrequencyPointA_Optional(_buffer, _size, _lidx, &p->absoluteFrequencyPointA);
	HTON_32(&_buffer[*_lidx], p->scs_SpecificCarrierList.d, _lidx);
	for (size_t i1 = 0; i1 < p->scs_SpecificCarrierList.d; i1++) {
		_serNrSysEncSQN_NR_SCS_SpecificCarrier(_buffer, _size, _lidx, &p->scs_SpecificCarrierList.v[i1]);
	}
	_serNrSysEncSQN_NR_AdditionalSpectrumEmission_SQN_NR_FrequencyInfoUL_additionalSpectrumEmission_Optional(_buffer, _size, _lidx, &p->additionalSpectrumEmission);
	_serNrSysEncSQN_NR_P_Max_SQN_NR_FrequencyInfoUL_p_Max_Optional(_buffer, _size, _lidx, &p->p_Max);
	_serNrSysEncSQN_NR_FrequencyInfoUL_frequencyShift7p5khz_e_frequencyShift7p5khz_Optional(_buffer, _size, _lidx, &p->frequencyShift7p5khz);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_ASN1_FrequencyInfoUL_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union NR_ASN1_FrequencyInfoUL_Type_Value* p, enum NR_ASN1_FrequencyInfoUL_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_ASN1_FrequencyInfoUL_Type_R15) {
		_serNrSysEncSQN_NR_FrequencyInfoUL(_buffer, _size, _lidx, &p->R15);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncNR_ASN1_FrequencyInfoUL_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_ASN1_FrequencyInfoUL_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncNR_ASN1_FrequencyInfoUL_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_ASN1_FrequencyInfoUL_Type_FrequencyInfoUL_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_ASN1_FrequencyInfoUL_Type_FrequencyInfoUL_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncNR_ASN1_FrequencyInfoUL_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_ActiveUplinkBWP_Id_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union NR_ActiveUplinkBWP_Id_Type_Value* p, enum NR_ActiveUplinkBWP_Id_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_ActiveUplinkBWP_Id_Type_Explicit) {
		HTON_8(&_buffer[*_lidx], p->Explicit, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == NR_ActiveUplinkBWP_Id_Type_SameIdAsDL) {
		HTON_8(&_buffer[*_lidx], p->SameIdAsDL, _lidx);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncNR_ActiveUplinkBWP_Id_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_ActiveUplinkBWP_Id_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncNR_ActiveUplinkBWP_Id_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_ActiveUplinkBWP_Id_Type_ActiveBWP_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_ActiveUplinkBWP_Id_Type_ActiveBWP_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncNR_ActiveUplinkBWP_Id_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_BWP_Id_NR_UplinkBWP_Type_Id_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_BWP_Id_NR_UplinkBWP_Type_Id_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_RACH_ConfigGeneric_prach_ConfigurationPeriodScaling_IAB_r16_e_prach_ConfigurationPeriodScaling_IAB_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_RACH_ConfigGeneric_prach_ConfigurationPeriodScaling_IAB_r16_e_prach_ConfigurationPeriodScaling_IAB_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncUint8_t_SQN_NR_RACH_ConfigGeneric_prach_ConfigurationFrameOffset_IAB_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint8_t_SQN_NR_RACH_ConfigGeneric_prach_ConfigurationFrameOffset_IAB_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncUint8_t_SQN_NR_RACH_ConfigGeneric_prach_ConfigurationSOffset_IAB_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint8_t_SQN_NR_RACH_ConfigGeneric_prach_ConfigurationSOffset_IAB_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_RACH_ConfigGeneric_ra_ResponseWindow_v1610_e_ra_ResponseWindow_v1610_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_RACH_ConfigGeneric_ra_ResponseWindow_v1610_e_ra_ResponseWindow_v1610_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncUint16_t_SQN_NR_RACH_ConfigGeneric_prach_ConfigurationIndex_v1610_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint16_t_SQN_NR_RACH_ConfigGeneric_prach_ConfigurationIndex_v1610_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_16(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_RACH_ConfigGeneric(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_RACH_ConfigGeneric* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->prach_ConfigurationIndex, _lidx);
	{
		size_t _tmp = (size_t)p->msg1_FDM;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	HTON_16(&_buffer[*_lidx], p->msg1_FrequencyStart, _lidx);
	HTON_8(&_buffer[*_lidx], p->zeroCorrelationZoneConfig, _lidx);
	HTON_16(&_buffer[*_lidx], p->preambleReceivedTargetPower, _lidx);
	{
		size_t _tmp = (size_t)p->preambleTransMax;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	{
		size_t _tmp = (size_t)p->powerRampingStep;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	{
		size_t _tmp = (size_t)p->ra_ResponseWindow;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_RACH_ConfigGeneric_prach_ConfigurationPeriodScaling_IAB_r16_e_prach_ConfigurationPeriodScaling_IAB_r16_Optional(_buffer, _size, _lidx, &p->prach_ConfigurationPeriodScaling_IAB_r16);
	_serNrSysEncUint8_t_SQN_NR_RACH_ConfigGeneric_prach_ConfigurationFrameOffset_IAB_r16_Optional(_buffer, _size, _lidx, &p->prach_ConfigurationFrameOffset_IAB_r16);
	_serNrSysEncUint8_t_SQN_NR_RACH_ConfigGeneric_prach_ConfigurationSOffset_IAB_r16_Optional(_buffer, _size, _lidx, &p->prach_ConfigurationSOffset_IAB_r16);
	_serNrSysEncSQN_NR_RACH_ConfigGeneric_ra_ResponseWindow_v1610_e_ra_ResponseWindow_v1610_Optional(_buffer, _size, _lidx, &p->ra_ResponseWindow_v1610);
	_serNrSysEncUint16_t_SQN_NR_RACH_ConfigGeneric_prach_ConfigurationIndex_v1610_Optional(_buffer, _size, _lidx, &p->prach_ConfigurationIndex_v1610);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncUint8_t_SQN_NR_RACH_ConfigCommon_totalNumberOfRA_Preambles_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint8_t_SQN_NR_RACH_ConfigCommon_totalNumberOfRA_Preambles_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_RACH_ConfigCommon_ssb_perRACH_OccasionAndCB_PreamblesPerSSB_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SQN_NR_RACH_ConfigCommon_ssb_perRACH_OccasionAndCB_PreamblesPerSSB_Value* p, enum SQN_NR_RACH_ConfigCommon_ssb_perRACH_OccasionAndCB_PreamblesPerSSB_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_RACH_ConfigCommon_ssb_perRACH_OccasionAndCB_PreamblesPerSSB_oneEighth) {
		{
			size_t _tmp = (size_t)p->oneEighth;
			HTON_32(&_buffer[*_lidx], _tmp, _lidx);
		}
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_RACH_ConfigCommon_ssb_perRACH_OccasionAndCB_PreamblesPerSSB_oneFourth) {
		{
			size_t _tmp = (size_t)p->oneFourth;
			HTON_32(&_buffer[*_lidx], _tmp, _lidx);
		}
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_RACH_ConfigCommon_ssb_perRACH_OccasionAndCB_PreamblesPerSSB_oneHalf) {
		{
			size_t _tmp = (size_t)p->oneHalf;
			HTON_32(&_buffer[*_lidx], _tmp, _lidx);
		}
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_RACH_ConfigCommon_ssb_perRACH_OccasionAndCB_PreamblesPerSSB_one) {
		{
			size_t _tmp = (size_t)p->one;
			HTON_32(&_buffer[*_lidx], _tmp, _lidx);
		}
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_RACH_ConfigCommon_ssb_perRACH_OccasionAndCB_PreamblesPerSSB_two) {
		{
			size_t _tmp = (size_t)p->two;
			HTON_32(&_buffer[*_lidx], _tmp, _lidx);
		}
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_RACH_ConfigCommon_ssb_perRACH_OccasionAndCB_PreamblesPerSSB_four) {
		HTON_8(&_buffer[*_lidx], p->four, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_RACH_ConfigCommon_ssb_perRACH_OccasionAndCB_PreamblesPerSSB_eight) {
		HTON_8(&_buffer[*_lidx], p->eight, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_RACH_ConfigCommon_ssb_perRACH_OccasionAndCB_PreamblesPerSSB_sixteen) {
		HTON_8(&_buffer[*_lidx], p->sixteen, _lidx);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncSQN_NR_RACH_ConfigCommon_ssb_perRACH_OccasionAndCB_PreamblesPerSSB(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_RACH_ConfigCommon_ssb_perRACH_OccasionAndCB_PreamblesPerSSB* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_RACH_ConfigCommon_ssb_perRACH_OccasionAndCB_PreamblesPerSSB_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_RACH_ConfigCommon_ssb_perRACH_OccasionAndCB_PreamblesPerSSB_ssb_perRACH_OccasionAndCB_PreamblesPerSSB_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_RACH_ConfigCommon_ssb_perRACH_OccasionAndCB_PreamblesPerSSB_ssb_perRACH_OccasionAndCB_PreamblesPerSSB_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_RACH_ConfigCommon_ssb_perRACH_OccasionAndCB_PreamblesPerSSB(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_RACH_ConfigCommon_groupBconfigured(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_RACH_ConfigCommon_groupBconfigured* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->ra_Msg3SizeGroupA;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	{
		size_t _tmp = (size_t)p->messagePowerOffsetGroupB;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	HTON_8(&_buffer[*_lidx], p->numberOfRA_PreamblesGroupA, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_RACH_ConfigCommon_groupBconfigured_groupBconfigured_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_RACH_ConfigCommon_groupBconfigured_groupBconfigured_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_RACH_ConfigCommon_groupBconfigured(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_RSRP_Range_SQN_NR_RACH_ConfigCommon_rsrp_ThresholdSSB_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_RSRP_Range_SQN_NR_RACH_ConfigCommon_rsrp_ThresholdSSB_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_RSRP_Range_SQN_NR_RACH_ConfigCommon_rsrp_ThresholdSSB_SUL_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_RSRP_Range_SQN_NR_RACH_ConfigCommon_rsrp_ThresholdSSB_SUL_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_RACH_ConfigCommon_prach_RootSequenceIndex_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SQN_NR_RACH_ConfigCommon_prach_RootSequenceIndex_Value* p, enum SQN_NR_RACH_ConfigCommon_prach_RootSequenceIndex_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_RACH_ConfigCommon_prach_RootSequenceIndex_l839) {
		HTON_16(&_buffer[*_lidx], p->l839, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_RACH_ConfigCommon_prach_RootSequenceIndex_l139) {
		HTON_8(&_buffer[*_lidx], p->l139, _lidx);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncSQN_NR_RACH_ConfigCommon_prach_RootSequenceIndex(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_RACH_ConfigCommon_prach_RootSequenceIndex* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_RACH_ConfigCommon_prach_RootSequenceIndex_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SubcarrierSpacing_e_SQN_NR_RACH_ConfigCommon_msg1_SubcarrierSpacing_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SubcarrierSpacing_e_SQN_NR_RACH_ConfigCommon_msg1_SubcarrierSpacing_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_RACH_ConfigCommon_msg3_transformPrecoder_e_msg3_transformPrecoder_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_RACH_ConfigCommon_msg3_transformPrecoder_e_msg3_transformPrecoder_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_RA_Prioritization_scalingFactorBI_e_scalingFactorBI_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_RA_Prioritization_scalingFactorBI_e_scalingFactorBI_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_RA_Prioritization(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_RA_Prioritization* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->powerRampingStepHighPriority;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_RA_Prioritization_scalingFactorBI_e_scalingFactorBI_Optional(_buffer, _size, _lidx, &p->scalingFactorBI);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_RACH_ConfigCommon_ra_PrioritizationForAccessIdentity_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_RACH_ConfigCommon_ra_PrioritizationForAccessIdentity_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncSQN_NR_RA_Prioritization(_buffer, _size, _lidx, &p->ra_Prioritization_r16);
	for (size_t i2 = 0; i2 < 2; i2++) {
		HTON_8(&_buffer[*_lidx], p->ra_PrioritizationForAI_r16[i2], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_RACH_ConfigCommon_ra_PrioritizationForAccessIdentity_r16_ra_PrioritizationForAccessIdentity_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_RACH_ConfigCommon_ra_PrioritizationForAccessIdentity_r16_ra_PrioritizationForAccessIdentity_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_RACH_ConfigCommon_ra_PrioritizationForAccessIdentity_r16(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_RACH_ConfigCommon_prach_RootSequenceIndex_r16_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SQN_NR_RACH_ConfigCommon_prach_RootSequenceIndex_r16_Value* p, enum SQN_NR_RACH_ConfigCommon_prach_RootSequenceIndex_r16_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_RACH_ConfigCommon_prach_RootSequenceIndex_r16_l571) {
		HTON_16(&_buffer[*_lidx], p->l571, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_RACH_ConfigCommon_prach_RootSequenceIndex_r16_l1151) {
		HTON_16(&_buffer[*_lidx], p->l1151, _lidx);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncSQN_NR_RACH_ConfigCommon_prach_RootSequenceIndex_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_RACH_ConfigCommon_prach_RootSequenceIndex_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_RACH_ConfigCommon_prach_RootSequenceIndex_r16_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_RACH_ConfigCommon_prach_RootSequenceIndex_r16_prach_RootSequenceIndex_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_RACH_ConfigCommon_prach_RootSequenceIndex_r16_prach_RootSequenceIndex_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_RACH_ConfigCommon_prach_RootSequenceIndex_r16(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_RACH_ConfigCommon(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_RACH_ConfigCommon* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncSQN_NR_RACH_ConfigGeneric(_buffer, _size, _lidx, &p->rach_ConfigGeneric);
	_serNrSysEncUint8_t_SQN_NR_RACH_ConfigCommon_totalNumberOfRA_Preambles_Optional(_buffer, _size, _lidx, &p->totalNumberOfRA_Preambles);
	_serNrSysEncSQN_NR_RACH_ConfigCommon_ssb_perRACH_OccasionAndCB_PreamblesPerSSB_ssb_perRACH_OccasionAndCB_PreamblesPerSSB_Optional(_buffer, _size, _lidx, &p->ssb_perRACH_OccasionAndCB_PreamblesPerSSB);
	_serNrSysEncSQN_NR_RACH_ConfigCommon_groupBconfigured_groupBconfigured_Optional(_buffer, _size, _lidx, &p->groupBconfigured);
	{
		size_t _tmp = (size_t)p->ra_ContentionResolutionTimer;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_RSRP_Range_SQN_NR_RACH_ConfigCommon_rsrp_ThresholdSSB_Optional(_buffer, _size, _lidx, &p->rsrp_ThresholdSSB);
	_serNrSysEncSQN_NR_RSRP_Range_SQN_NR_RACH_ConfigCommon_rsrp_ThresholdSSB_SUL_Optional(_buffer, _size, _lidx, &p->rsrp_ThresholdSSB_SUL);
	_serNrSysEncSQN_NR_RACH_ConfigCommon_prach_RootSequenceIndex(_buffer, _size, _lidx, &p->prach_RootSequenceIndex);
	_serNrSysEncSQN_NR_SubcarrierSpacing_e_SQN_NR_RACH_ConfigCommon_msg1_SubcarrierSpacing_Optional(_buffer, _size, _lidx, &p->msg1_SubcarrierSpacing);
	{
		size_t _tmp = (size_t)p->restrictedSetConfig;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_RACH_ConfigCommon_msg3_transformPrecoder_e_msg3_transformPrecoder_Optional(_buffer, _size, _lidx, &p->msg3_transformPrecoder);
	_serNrSysEncSQN_NR_RACH_ConfigCommon_ra_PrioritizationForAccessIdentity_r16_ra_PrioritizationForAccessIdentity_r16_Optional(_buffer, _size, _lidx, &p->ra_PrioritizationForAccessIdentity_r16);
	_serNrSysEncSQN_NR_RACH_ConfigCommon_prach_RootSequenceIndex_r16_prach_RootSequenceIndex_r16_Optional(_buffer, _size, _lidx, &p->prach_RootSequenceIndex_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SetupRelease_BWP_UplinkCommon_rach_ConfigCommon_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SQN_NR_SetupRelease_BWP_UplinkCommon_rach_ConfigCommon_Value* p, enum SQN_NR_SetupRelease_BWP_UplinkCommon_rach_ConfigCommon_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SetupRelease_BWP_UplinkCommon_rach_ConfigCommon_release) {
		HTON_8(&_buffer[*_lidx], p->release, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SetupRelease_BWP_UplinkCommon_rach_ConfigCommon_setup) {
		_serNrSysEncSQN_NR_RACH_ConfigCommon(_buffer, _size, _lidx, &p->setup);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncSQN_NR_SetupRelease_BWP_UplinkCommon_rach_ConfigCommon(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SetupRelease_BWP_UplinkCommon_rach_ConfigCommon* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_SetupRelease_BWP_UplinkCommon_rach_ConfigCommon_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SetupRelease_BWP_UplinkCommon_rach_ConfigCommon_SQN_NR_BWP_UplinkCommon_rach_ConfigCommon_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SetupRelease_BWP_UplinkCommon_rach_ConfigCommon_SQN_NR_BWP_UplinkCommon_rach_ConfigCommon_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_SetupRelease_BWP_UplinkCommon_rach_ConfigCommon(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PUSCH_ConfigCommon_groupHoppingEnabledTransformPrecoding_e_groupHoppingEnabledTransformPrecoding_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PUSCH_ConfigCommon_groupHoppingEnabledTransformPrecoding_e_groupHoppingEnabledTransformPrecoding_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncUint8_t_SQN_NR_PUSCH_TimeDomainResourceAllocation_k2_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint8_t_SQN_NR_PUSCH_TimeDomainResourceAllocation_k2_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PUSCH_TimeDomainResourceAllocation(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PUSCH_TimeDomainResourceAllocation* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncUint8_t_SQN_NR_PUSCH_TimeDomainResourceAllocation_k2_Optional(_buffer, _size, _lidx, &p->k2);
	{
		size_t _tmp = (size_t)p->mappingType;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	HTON_8(&_buffer[*_lidx], p->startSymbolAndLength, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PUSCH_TimeDomainResourceAllocationList_SQN_NR_PUSCH_ConfigCommon_pusch_TimeDomainAllocationList_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PUSCH_TimeDomainResourceAllocationList_SQN_NR_PUSCH_ConfigCommon_pusch_TimeDomainAllocationList_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serNrSysEncSQN_NR_PUSCH_TimeDomainResourceAllocation(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncInt8_t_SQN_NR_PUSCH_ConfigCommon_msg3_DeltaPreamble_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct int8_t_SQN_NR_PUSCH_ConfigCommon_msg3_DeltaPreamble_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncInt16_t_SQN_NR_PUSCH_ConfigCommon_p0_NominalWithGrant_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct int16_t_SQN_NR_PUSCH_ConfigCommon_p0_NominalWithGrant_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_16(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PUSCH_ConfigCommon(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PUSCH_ConfigCommon* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncSQN_NR_PUSCH_ConfigCommon_groupHoppingEnabledTransformPrecoding_e_groupHoppingEnabledTransformPrecoding_Optional(_buffer, _size, _lidx, &p->groupHoppingEnabledTransformPrecoding);
	_serNrSysEncSQN_NR_PUSCH_TimeDomainResourceAllocationList_SQN_NR_PUSCH_ConfigCommon_pusch_TimeDomainAllocationList_Optional(_buffer, _size, _lidx, &p->pusch_TimeDomainAllocationList);
	_serNrSysEncInt8_t_SQN_NR_PUSCH_ConfigCommon_msg3_DeltaPreamble_Optional(_buffer, _size, _lidx, &p->msg3_DeltaPreamble);
	_serNrSysEncInt16_t_SQN_NR_PUSCH_ConfigCommon_p0_NominalWithGrant_Optional(_buffer, _size, _lidx, &p->p0_NominalWithGrant);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SetupRelease_BWP_UplinkCommon_pusch_ConfigCommon_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SQN_NR_SetupRelease_BWP_UplinkCommon_pusch_ConfigCommon_Value* p, enum SQN_NR_SetupRelease_BWP_UplinkCommon_pusch_ConfigCommon_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SetupRelease_BWP_UplinkCommon_pusch_ConfigCommon_release) {
		HTON_8(&_buffer[*_lidx], p->release, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SetupRelease_BWP_UplinkCommon_pusch_ConfigCommon_setup) {
		_serNrSysEncSQN_NR_PUSCH_ConfigCommon(_buffer, _size, _lidx, &p->setup);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncSQN_NR_SetupRelease_BWP_UplinkCommon_pusch_ConfigCommon(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SetupRelease_BWP_UplinkCommon_pusch_ConfigCommon* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_SetupRelease_BWP_UplinkCommon_pusch_ConfigCommon_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SetupRelease_BWP_UplinkCommon_pusch_ConfigCommon_SQN_NR_BWP_UplinkCommon_pusch_ConfigCommon_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SetupRelease_BWP_UplinkCommon_pusch_ConfigCommon_SQN_NR_BWP_UplinkCommon_pusch_ConfigCommon_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_SetupRelease_BWP_UplinkCommon_pusch_ConfigCommon(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncUint8_t_SQN_NR_PUCCH_ConfigCommon_pucch_ResourceCommon_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint8_t_SQN_NR_PUCCH_ConfigCommon_pucch_ResourceCommon_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncUint16_t_SQN_NR_PUCCH_ConfigCommon_hoppingId_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint16_t_SQN_NR_PUCCH_ConfigCommon_hoppingId_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_16(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncInt16_t_SQN_NR_PUCCH_ConfigCommon_p0_nominal_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct int16_t_SQN_NR_PUCCH_ConfigCommon_p0_nominal_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_16(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PUCCH_ConfigCommon(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PUCCH_ConfigCommon* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncUint8_t_SQN_NR_PUCCH_ConfigCommon_pucch_ResourceCommon_Optional(_buffer, _size, _lidx, &p->pucch_ResourceCommon);
	{
		size_t _tmp = (size_t)p->pucch_GroupHopping;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncUint16_t_SQN_NR_PUCCH_ConfigCommon_hoppingId_Optional(_buffer, _size, _lidx, &p->hoppingId);
	_serNrSysEncInt16_t_SQN_NR_PUCCH_ConfigCommon_p0_nominal_Optional(_buffer, _size, _lidx, &p->p0_nominal);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SetupRelease_BWP_UplinkCommon_pucch_ConfigCommon_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SQN_NR_SetupRelease_BWP_UplinkCommon_pucch_ConfigCommon_Value* p, enum SQN_NR_SetupRelease_BWP_UplinkCommon_pucch_ConfigCommon_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SetupRelease_BWP_UplinkCommon_pucch_ConfigCommon_release) {
		HTON_8(&_buffer[*_lidx], p->release, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SetupRelease_BWP_UplinkCommon_pucch_ConfigCommon_setup) {
		_serNrSysEncSQN_NR_PUCCH_ConfigCommon(_buffer, _size, _lidx, &p->setup);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncSQN_NR_SetupRelease_BWP_UplinkCommon_pucch_ConfigCommon(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SetupRelease_BWP_UplinkCommon_pucch_ConfigCommon* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_SetupRelease_BWP_UplinkCommon_pucch_ConfigCommon_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SetupRelease_BWP_UplinkCommon_pucch_ConfigCommon_SQN_NR_BWP_UplinkCommon_pucch_ConfigCommon_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SetupRelease_BWP_UplinkCommon_pucch_ConfigCommon_SQN_NR_BWP_UplinkCommon_pucch_ConfigCommon_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_SetupRelease_BWP_UplinkCommon_pucch_ConfigCommon(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SetupRelease_BWP_UplinkCommon_rach_ConfigCommonIAB_r16_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SQN_NR_SetupRelease_BWP_UplinkCommon_rach_ConfigCommonIAB_r16_Value* p, enum SQN_NR_SetupRelease_BWP_UplinkCommon_rach_ConfigCommonIAB_r16_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SetupRelease_BWP_UplinkCommon_rach_ConfigCommonIAB_r16_release) {
		HTON_8(&_buffer[*_lidx], p->release, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SetupRelease_BWP_UplinkCommon_rach_ConfigCommonIAB_r16_setup) {
		_serNrSysEncSQN_NR_RACH_ConfigCommon(_buffer, _size, _lidx, &p->setup);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncSQN_NR_SetupRelease_BWP_UplinkCommon_rach_ConfigCommonIAB_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SetupRelease_BWP_UplinkCommon_rach_ConfigCommonIAB_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_SetupRelease_BWP_UplinkCommon_rach_ConfigCommonIAB_r16_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SetupRelease_BWP_UplinkCommon_rach_ConfigCommonIAB_r16_SQN_NR_BWP_UplinkCommon_rach_ConfigCommonIAB_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SetupRelease_BWP_UplinkCommon_rach_ConfigCommonIAB_r16_SQN_NR_BWP_UplinkCommon_rach_ConfigCommonIAB_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_SetupRelease_BWP_UplinkCommon_rach_ConfigCommonIAB_r16(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_BWP_UplinkCommon_useInterlacePUCCH_PUSCH_r16_e_useInterlacePUCCH_PUSCH_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_BWP_UplinkCommon_useInterlacePUCCH_PUSCH_r16_e_useInterlacePUCCH_PUSCH_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncUint16_t_SQN_NR_RACH_ConfigGenericTwoStepRA_r16_msgA_PRACH_ConfigurationIndex_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint16_t_SQN_NR_RACH_ConfigGenericTwoStepRA_r16_msgA_PRACH_ConfigurationIndex_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_16(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_RACH_ConfigGenericTwoStepRA_r16_msgA_RO_FDM_r16_e_msgA_RO_FDM_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_RACH_ConfigGenericTwoStepRA_r16_msgA_RO_FDM_r16_e_msgA_RO_FDM_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncUint16_t_SQN_NR_RACH_ConfigGenericTwoStepRA_r16_msgA_RO_FrequencyStart_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint16_t_SQN_NR_RACH_ConfigGenericTwoStepRA_r16_msgA_RO_FrequencyStart_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_16(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncUint8_t_SQN_NR_RACH_ConfigGenericTwoStepRA_r16_msgA_ZeroCorrelationZoneConfig_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint8_t_SQN_NR_RACH_ConfigGenericTwoStepRA_r16_msgA_ZeroCorrelationZoneConfig_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_RACH_ConfigGenericTwoStepRA_r16_msgA_PreamblePowerRampingStep_r16_e_msgA_PreamblePowerRampingStep_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_RACH_ConfigGenericTwoStepRA_r16_msgA_PreamblePowerRampingStep_r16_e_msgA_PreamblePowerRampingStep_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncInt16_t_SQN_NR_RACH_ConfigGenericTwoStepRA_r16_msgA_PreambleReceivedTargetPower_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct int16_t_SQN_NR_RACH_ConfigGenericTwoStepRA_r16_msgA_PreambleReceivedTargetPower_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_16(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_RACH_ConfigGenericTwoStepRA_r16_msgB_ResponseWindow_r16_e_msgB_ResponseWindow_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_RACH_ConfigGenericTwoStepRA_r16_msgB_ResponseWindow_r16_e_msgB_ResponseWindow_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_RACH_ConfigGenericTwoStepRA_r16_preambleTransMax_r16_e_preambleTransMax_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_RACH_ConfigGenericTwoStepRA_r16_preambleTransMax_r16_e_preambleTransMax_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_RACH_ConfigGenericTwoStepRA_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_RACH_ConfigGenericTwoStepRA_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncUint16_t_SQN_NR_RACH_ConfigGenericTwoStepRA_r16_msgA_PRACH_ConfigurationIndex_r16_Optional(_buffer, _size, _lidx, &p->msgA_PRACH_ConfigurationIndex_r16);
	_serNrSysEncSQN_NR_RACH_ConfigGenericTwoStepRA_r16_msgA_RO_FDM_r16_e_msgA_RO_FDM_r16_Optional(_buffer, _size, _lidx, &p->msgA_RO_FDM_r16);
	_serNrSysEncUint16_t_SQN_NR_RACH_ConfigGenericTwoStepRA_r16_msgA_RO_FrequencyStart_r16_Optional(_buffer, _size, _lidx, &p->msgA_RO_FrequencyStart_r16);
	_serNrSysEncUint8_t_SQN_NR_RACH_ConfigGenericTwoStepRA_r16_msgA_ZeroCorrelationZoneConfig_r16_Optional(_buffer, _size, _lidx, &p->msgA_ZeroCorrelationZoneConfig_r16);
	_serNrSysEncSQN_NR_RACH_ConfigGenericTwoStepRA_r16_msgA_PreamblePowerRampingStep_r16_e_msgA_PreamblePowerRampingStep_r16_Optional(_buffer, _size, _lidx, &p->msgA_PreamblePowerRampingStep_r16);
	_serNrSysEncInt16_t_SQN_NR_RACH_ConfigGenericTwoStepRA_r16_msgA_PreambleReceivedTargetPower_r16_Optional(_buffer, _size, _lidx, &p->msgA_PreambleReceivedTargetPower_r16);
	_serNrSysEncSQN_NR_RACH_ConfigGenericTwoStepRA_r16_msgB_ResponseWindow_r16_e_msgB_ResponseWindow_r16_Optional(_buffer, _size, _lidx, &p->msgB_ResponseWindow_r16);
	_serNrSysEncSQN_NR_RACH_ConfigGenericTwoStepRA_r16_preambleTransMax_r16_e_preambleTransMax_r16_Optional(_buffer, _size, _lidx, &p->preambleTransMax_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncUint8_t_SQN_NR_RACH_ConfigCommonTwoStepRA_r16_msgA_TotalNumberOfRA_Preambles_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint8_t_SQN_NR_RACH_ConfigCommonTwoStepRA_r16_msgA_TotalNumberOfRA_Preambles_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_RACH_ConfigCommonTwoStepRA_r16_msgA_SSB_PerRACH_OccasionAndCB_PreamblesPerSSB_r16_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SQN_NR_RACH_ConfigCommonTwoStepRA_r16_msgA_SSB_PerRACH_OccasionAndCB_PreamblesPerSSB_r16_Value* p, enum SQN_NR_RACH_ConfigCommonTwoStepRA_r16_msgA_SSB_PerRACH_OccasionAndCB_PreamblesPerSSB_r16_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_RACH_ConfigCommonTwoStepRA_r16_msgA_SSB_PerRACH_OccasionAndCB_PreamblesPerSSB_r16_oneEighth) {
		{
			size_t _tmp = (size_t)p->oneEighth;
			HTON_32(&_buffer[*_lidx], _tmp, _lidx);
		}
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_RACH_ConfigCommonTwoStepRA_r16_msgA_SSB_PerRACH_OccasionAndCB_PreamblesPerSSB_r16_oneFourth) {
		{
			size_t _tmp = (size_t)p->oneFourth;
			HTON_32(&_buffer[*_lidx], _tmp, _lidx);
		}
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_RACH_ConfigCommonTwoStepRA_r16_msgA_SSB_PerRACH_OccasionAndCB_PreamblesPerSSB_r16_oneHalf) {
		{
			size_t _tmp = (size_t)p->oneHalf;
			HTON_32(&_buffer[*_lidx], _tmp, _lidx);
		}
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_RACH_ConfigCommonTwoStepRA_r16_msgA_SSB_PerRACH_OccasionAndCB_PreamblesPerSSB_r16_one) {
		{
			size_t _tmp = (size_t)p->one;
			HTON_32(&_buffer[*_lidx], _tmp, _lidx);
		}
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_RACH_ConfigCommonTwoStepRA_r16_msgA_SSB_PerRACH_OccasionAndCB_PreamblesPerSSB_r16_two) {
		{
			size_t _tmp = (size_t)p->two;
			HTON_32(&_buffer[*_lidx], _tmp, _lidx);
		}
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_RACH_ConfigCommonTwoStepRA_r16_msgA_SSB_PerRACH_OccasionAndCB_PreamblesPerSSB_r16_four) {
		HTON_8(&_buffer[*_lidx], p->four, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_RACH_ConfigCommonTwoStepRA_r16_msgA_SSB_PerRACH_OccasionAndCB_PreamblesPerSSB_r16_eight) {
		HTON_8(&_buffer[*_lidx], p->eight, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_RACH_ConfigCommonTwoStepRA_r16_msgA_SSB_PerRACH_OccasionAndCB_PreamblesPerSSB_r16_sixteen) {
		HTON_8(&_buffer[*_lidx], p->sixteen, _lidx);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncSQN_NR_RACH_ConfigCommonTwoStepRA_r16_msgA_SSB_PerRACH_OccasionAndCB_PreamblesPerSSB_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_RACH_ConfigCommonTwoStepRA_r16_msgA_SSB_PerRACH_OccasionAndCB_PreamblesPerSSB_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_RACH_ConfigCommonTwoStepRA_r16_msgA_SSB_PerRACH_OccasionAndCB_PreamblesPerSSB_r16_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_RACH_ConfigCommonTwoStepRA_r16_msgA_SSB_PerRACH_OccasionAndCB_PreamblesPerSSB_r16_msgA_SSB_PerRACH_OccasionAndCB_PreamblesPerSSB_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_RACH_ConfigCommonTwoStepRA_r16_msgA_SSB_PerRACH_OccasionAndCB_PreamblesPerSSB_r16_msgA_SSB_PerRACH_OccasionAndCB_PreamblesPerSSB_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_RACH_ConfigCommonTwoStepRA_r16_msgA_SSB_PerRACH_OccasionAndCB_PreamblesPerSSB_r16(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncUint8_t_SQN_NR_RACH_ConfigCommonTwoStepRA_r16_msgA_CB_PreamblesPerSSB_PerSharedRO_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint8_t_SQN_NR_RACH_ConfigCommonTwoStepRA_r16_msgA_CB_PreamblesPerSSB_PerSharedRO_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncUint8_t_SQN_NR_RACH_ConfigCommonTwoStepRA_r16_msgA_SSB_SharedRO_MaskIndex_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint8_t_SQN_NR_RACH_ConfigCommonTwoStepRA_r16_msgA_SSB_SharedRO_MaskIndex_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_GroupB_ConfiguredTwoStepRA_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_GroupB_ConfiguredTwoStepRA_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->ra_MsgA_SizeGroupA;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	{
		size_t _tmp = (size_t)p->messagePowerOffsetGroupB;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	HTON_8(&_buffer[*_lidx], p->numberofRA_PreamblesGroupA, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_GroupB_ConfiguredTwoStepRA_r16_SQN_NR_RACH_ConfigCommonTwoStepRA_r16_groupB_ConfiguredTwoStepRA_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_GroupB_ConfiguredTwoStepRA_r16_SQN_NR_RACH_ConfigCommonTwoStepRA_r16_groupB_ConfiguredTwoStepRA_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_GroupB_ConfiguredTwoStepRA_r16(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_RACH_ConfigCommonTwoStepRA_r16_msgA_PRACH_RootSequenceIndex_r16_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SQN_NR_RACH_ConfigCommonTwoStepRA_r16_msgA_PRACH_RootSequenceIndex_r16_Value* p, enum SQN_NR_RACH_ConfigCommonTwoStepRA_r16_msgA_PRACH_RootSequenceIndex_r16_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_RACH_ConfigCommonTwoStepRA_r16_msgA_PRACH_RootSequenceIndex_r16_l839) {
		HTON_16(&_buffer[*_lidx], p->l839, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_RACH_ConfigCommonTwoStepRA_r16_msgA_PRACH_RootSequenceIndex_r16_l139) {
		HTON_8(&_buffer[*_lidx], p->l139, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_RACH_ConfigCommonTwoStepRA_r16_msgA_PRACH_RootSequenceIndex_r16_l571) {
		HTON_16(&_buffer[*_lidx], p->l571, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_RACH_ConfigCommonTwoStepRA_r16_msgA_PRACH_RootSequenceIndex_r16_l1151) {
		HTON_16(&_buffer[*_lidx], p->l1151, _lidx);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncSQN_NR_RACH_ConfigCommonTwoStepRA_r16_msgA_PRACH_RootSequenceIndex_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_RACH_ConfigCommonTwoStepRA_r16_msgA_PRACH_RootSequenceIndex_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_RACH_ConfigCommonTwoStepRA_r16_msgA_PRACH_RootSequenceIndex_r16_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_RACH_ConfigCommonTwoStepRA_r16_msgA_PRACH_RootSequenceIndex_r16_msgA_PRACH_RootSequenceIndex_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_RACH_ConfigCommonTwoStepRA_r16_msgA_PRACH_RootSequenceIndex_r16_msgA_PRACH_RootSequenceIndex_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_RACH_ConfigCommonTwoStepRA_r16_msgA_PRACH_RootSequenceIndex_r16(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_RACH_ConfigCommonTwoStepRA_r16_msgA_TransMax_r16_e_msgA_TransMax_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_RACH_ConfigCommonTwoStepRA_r16_msgA_TransMax_r16_e_msgA_TransMax_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_RSRP_Range_SQN_NR_RACH_ConfigCommonTwoStepRA_r16_msgA_RSRP_Threshold_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_RSRP_Range_SQN_NR_RACH_ConfigCommonTwoStepRA_r16_msgA_RSRP_Threshold_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_RSRP_Range_SQN_NR_RACH_ConfigCommonTwoStepRA_r16_msgA_RSRP_ThresholdSSB_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_RSRP_Range_SQN_NR_RACH_ConfigCommonTwoStepRA_r16_msgA_RSRP_ThresholdSSB_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SubcarrierSpacing_e_SQN_NR_RACH_ConfigCommonTwoStepRA_r16_msgA_SubcarrierSpacing_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SubcarrierSpacing_e_SQN_NR_RACH_ConfigCommonTwoStepRA_r16_msgA_SubcarrierSpacing_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_RACH_ConfigCommonTwoStepRA_r16_msgA_RestrictedSetConfig_r16_e_msgA_RestrictedSetConfig_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_RACH_ConfigCommonTwoStepRA_r16_msgA_RestrictedSetConfig_r16_e_msgA_RestrictedSetConfig_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_RACH_ConfigCommonTwoStepRA_r16_ra_PrioritizationForAccessIdentityTwoStep_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_RACH_ConfigCommonTwoStepRA_r16_ra_PrioritizationForAccessIdentityTwoStep_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncSQN_NR_RA_Prioritization(_buffer, _size, _lidx, &p->ra_Prioritization_r16);
	for (size_t i2 = 0; i2 < 2; i2++) {
		HTON_8(&_buffer[*_lidx], p->ra_PrioritizationForAI_r16[i2], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_RACH_ConfigCommonTwoStepRA_r16_ra_PrioritizationForAccessIdentityTwoStep_r16_ra_PrioritizationForAccessIdentityTwoStep_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_RACH_ConfigCommonTwoStepRA_r16_ra_PrioritizationForAccessIdentityTwoStep_r16_ra_PrioritizationForAccessIdentityTwoStep_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_RACH_ConfigCommonTwoStepRA_r16_ra_PrioritizationForAccessIdentityTwoStep_r16(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_RACH_ConfigCommonTwoStepRA_r16_ra_ContentionResolutionTimer_r16_e_ra_ContentionResolutionTimer_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_RACH_ConfigCommonTwoStepRA_r16_ra_ContentionResolutionTimer_r16_e_ra_ContentionResolutionTimer_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_RACH_ConfigCommonTwoStepRA_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_RACH_ConfigCommonTwoStepRA_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncSQN_NR_RACH_ConfigGenericTwoStepRA_r16(_buffer, _size, _lidx, &p->rach_ConfigGenericTwoStepRA_r16);
	_serNrSysEncUint8_t_SQN_NR_RACH_ConfigCommonTwoStepRA_r16_msgA_TotalNumberOfRA_Preambles_r16_Optional(_buffer, _size, _lidx, &p->msgA_TotalNumberOfRA_Preambles_r16);
	_serNrSysEncSQN_NR_RACH_ConfigCommonTwoStepRA_r16_msgA_SSB_PerRACH_OccasionAndCB_PreamblesPerSSB_r16_msgA_SSB_PerRACH_OccasionAndCB_PreamblesPerSSB_r16_Optional(_buffer, _size, _lidx, &p->msgA_SSB_PerRACH_OccasionAndCB_PreamblesPerSSB_r16);
	_serNrSysEncUint8_t_SQN_NR_RACH_ConfigCommonTwoStepRA_r16_msgA_CB_PreamblesPerSSB_PerSharedRO_r16_Optional(_buffer, _size, _lidx, &p->msgA_CB_PreamblesPerSSB_PerSharedRO_r16);
	_serNrSysEncUint8_t_SQN_NR_RACH_ConfigCommonTwoStepRA_r16_msgA_SSB_SharedRO_MaskIndex_r16_Optional(_buffer, _size, _lidx, &p->msgA_SSB_SharedRO_MaskIndex_r16);
	_serNrSysEncSQN_NR_GroupB_ConfiguredTwoStepRA_r16_SQN_NR_RACH_ConfigCommonTwoStepRA_r16_groupB_ConfiguredTwoStepRA_r16_Optional(_buffer, _size, _lidx, &p->groupB_ConfiguredTwoStepRA_r16);
	_serNrSysEncSQN_NR_RACH_ConfigCommonTwoStepRA_r16_msgA_PRACH_RootSequenceIndex_r16_msgA_PRACH_RootSequenceIndex_r16_Optional(_buffer, _size, _lidx, &p->msgA_PRACH_RootSequenceIndex_r16);
	_serNrSysEncSQN_NR_RACH_ConfigCommonTwoStepRA_r16_msgA_TransMax_r16_e_msgA_TransMax_r16_Optional(_buffer, _size, _lidx, &p->msgA_TransMax_r16);
	_serNrSysEncSQN_NR_RSRP_Range_SQN_NR_RACH_ConfigCommonTwoStepRA_r16_msgA_RSRP_Threshold_r16_Optional(_buffer, _size, _lidx, &p->msgA_RSRP_Threshold_r16);
	_serNrSysEncSQN_NR_RSRP_Range_SQN_NR_RACH_ConfigCommonTwoStepRA_r16_msgA_RSRP_ThresholdSSB_r16_Optional(_buffer, _size, _lidx, &p->msgA_RSRP_ThresholdSSB_r16);
	_serNrSysEncSQN_NR_SubcarrierSpacing_e_SQN_NR_RACH_ConfigCommonTwoStepRA_r16_msgA_SubcarrierSpacing_r16_Optional(_buffer, _size, _lidx, &p->msgA_SubcarrierSpacing_r16);
	_serNrSysEncSQN_NR_RACH_ConfigCommonTwoStepRA_r16_msgA_RestrictedSetConfig_r16_e_msgA_RestrictedSetConfig_r16_Optional(_buffer, _size, _lidx, &p->msgA_RestrictedSetConfig_r16);
	_serNrSysEncSQN_NR_RACH_ConfigCommonTwoStepRA_r16_ra_PrioritizationForAccessIdentityTwoStep_r16_ra_PrioritizationForAccessIdentityTwoStep_r16_Optional(_buffer, _size, _lidx, &p->ra_PrioritizationForAccessIdentityTwoStep_r16);
	_serNrSysEncSQN_NR_RACH_ConfigCommonTwoStepRA_r16_ra_ContentionResolutionTimer_r16_e_ra_ContentionResolutionTimer_r16_Optional(_buffer, _size, _lidx, &p->ra_ContentionResolutionTimer_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncUint8_t_SQN_NR_MsgA_PUSCH_Resource_r16_msgA_PUSCH_TimeDomainAllocation_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint8_t_SQN_NR_MsgA_PUSCH_Resource_r16_msgA_PUSCH_TimeDomainAllocation_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncUint8_t_SQN_NR_MsgA_PUSCH_Resource_r16_startSymbolAndLengthMsgA_PO_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint8_t_SQN_NR_MsgA_PUSCH_Resource_r16_startSymbolAndLengthMsgA_PO_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_MsgA_PUSCH_Resource_r16_mappingTypeMsgA_PUSCH_r16_e_mappingTypeMsgA_PUSCH_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_MsgA_PUSCH_Resource_r16_mappingTypeMsgA_PUSCH_r16_e_mappingTypeMsgA_PUSCH_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncUint8_t_SQN_NR_MsgA_PUSCH_Resource_r16_guardPeriodMsgA_PUSCH_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint8_t_SQN_NR_MsgA_PUSCH_Resource_r16_guardPeriodMsgA_PUSCH_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_MsgA_PUSCH_Resource_r16_msgA_IntraSlotFrequencyHopping_r16_e_msgA_IntraSlotFrequencyHopping_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_MsgA_PUSCH_Resource_r16_msgA_IntraSlotFrequencyHopping_r16_e_msgA_IntraSlotFrequencyHopping_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncB2_SQN_NR_MsgA_PUSCH_Resource_r16_msgA_HoppingBits_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct B2_SQN_NR_MsgA_PUSCH_Resource_r16_msgA_HoppingBits_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	for (size_t i2 = 0; i2 < 2; i2++) {
		HTON_8(&_buffer[*_lidx], p->v[i2], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_MsgA_DMRS_Config_r16_msgA_DMRS_AdditionalPosition_r16_e_msgA_DMRS_AdditionalPosition_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_MsgA_DMRS_Config_r16_msgA_DMRS_AdditionalPosition_r16_e_msgA_DMRS_AdditionalPosition_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_MsgA_DMRS_Config_r16_msgA_MaxLength_r16_e_msgA_MaxLength_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_MsgA_DMRS_Config_r16_msgA_MaxLength_r16_e_msgA_MaxLength_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncUint8_t_SQN_NR_MsgA_DMRS_Config_r16_msgA_PUSCH_DMRS_CDM_Group_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint8_t_SQN_NR_MsgA_DMRS_Config_r16_msgA_PUSCH_DMRS_CDM_Group_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncUint8_t_SQN_NR_MsgA_DMRS_Config_r16_msgA_PUSCH_NrofPorts_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint8_t_SQN_NR_MsgA_DMRS_Config_r16_msgA_PUSCH_NrofPorts_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncUint16_t_SQN_NR_MsgA_DMRS_Config_r16_msgA_ScramblingID0_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint16_t_SQN_NR_MsgA_DMRS_Config_r16_msgA_ScramblingID0_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_16(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncUint16_t_SQN_NR_MsgA_DMRS_Config_r16_msgA_ScramblingID1_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint16_t_SQN_NR_MsgA_DMRS_Config_r16_msgA_ScramblingID1_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_16(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_MsgA_DMRS_Config_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_MsgA_DMRS_Config_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncSQN_NR_MsgA_DMRS_Config_r16_msgA_DMRS_AdditionalPosition_r16_e_msgA_DMRS_AdditionalPosition_r16_Optional(_buffer, _size, _lidx, &p->msgA_DMRS_AdditionalPosition_r16);
	_serNrSysEncSQN_NR_MsgA_DMRS_Config_r16_msgA_MaxLength_r16_e_msgA_MaxLength_r16_Optional(_buffer, _size, _lidx, &p->msgA_MaxLength_r16);
	_serNrSysEncUint8_t_SQN_NR_MsgA_DMRS_Config_r16_msgA_PUSCH_DMRS_CDM_Group_r16_Optional(_buffer, _size, _lidx, &p->msgA_PUSCH_DMRS_CDM_Group_r16);
	_serNrSysEncUint8_t_SQN_NR_MsgA_DMRS_Config_r16_msgA_PUSCH_NrofPorts_r16_Optional(_buffer, _size, _lidx, &p->msgA_PUSCH_NrofPorts_r16);
	_serNrSysEncUint16_t_SQN_NR_MsgA_DMRS_Config_r16_msgA_ScramblingID0_r16_Optional(_buffer, _size, _lidx, &p->msgA_ScramblingID0_r16);
	_serNrSysEncUint16_t_SQN_NR_MsgA_DMRS_Config_r16_msgA_ScramblingID1_r16_Optional(_buffer, _size, _lidx, &p->msgA_ScramblingID1_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_MsgA_PUSCH_Resource_r16_msgA_Alpha_r16_e_msgA_Alpha_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_MsgA_PUSCH_Resource_r16_msgA_Alpha_r16_e_msgA_Alpha_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncUint8_t_SQN_NR_MsgA_PUSCH_Resource_r16_interlaceIndexFirstPO_MsgA_PUSCH_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint8_t_SQN_NR_MsgA_PUSCH_Resource_r16_interlaceIndexFirstPO_MsgA_PUSCH_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncUint8_t_SQN_NR_MsgA_PUSCH_Resource_r16_nrofInterlacesPerMsgA_PO_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint8_t_SQN_NR_MsgA_PUSCH_Resource_r16_nrofInterlacesPerMsgA_PO_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_MsgA_PUSCH_Resource_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_MsgA_PUSCH_Resource_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->msgA_MCS_r16, _lidx);
	HTON_8(&_buffer[*_lidx], p->nrofSlotsMsgA_PUSCH_r16, _lidx);
	{
		size_t _tmp = (size_t)p->nrofMsgA_PO_PerSlot_r16;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	HTON_8(&_buffer[*_lidx], p->msgA_PUSCH_TimeDomainOffset_r16, _lidx);
	_serNrSysEncUint8_t_SQN_NR_MsgA_PUSCH_Resource_r16_msgA_PUSCH_TimeDomainAllocation_r16_Optional(_buffer, _size, _lidx, &p->msgA_PUSCH_TimeDomainAllocation_r16);
	_serNrSysEncUint8_t_SQN_NR_MsgA_PUSCH_Resource_r16_startSymbolAndLengthMsgA_PO_r16_Optional(_buffer, _size, _lidx, &p->startSymbolAndLengthMsgA_PO_r16);
	_serNrSysEncSQN_NR_MsgA_PUSCH_Resource_r16_mappingTypeMsgA_PUSCH_r16_e_mappingTypeMsgA_PUSCH_r16_Optional(_buffer, _size, _lidx, &p->mappingTypeMsgA_PUSCH_r16);
	_serNrSysEncUint8_t_SQN_NR_MsgA_PUSCH_Resource_r16_guardPeriodMsgA_PUSCH_r16_Optional(_buffer, _size, _lidx, &p->guardPeriodMsgA_PUSCH_r16);
	HTON_8(&_buffer[*_lidx], p->guardBandMsgA_PUSCH_r16, _lidx);
	HTON_16(&_buffer[*_lidx], p->frequencyStartMsgA_PUSCH_r16, _lidx);
	HTON_8(&_buffer[*_lidx], p->nrofPRBs_PerMsgA_PO_r16, _lidx);
	{
		size_t _tmp = (size_t)p->nrofMsgA_PO_FDM_r16;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_MsgA_PUSCH_Resource_r16_msgA_IntraSlotFrequencyHopping_r16_e_msgA_IntraSlotFrequencyHopping_r16_Optional(_buffer, _size, _lidx, &p->msgA_IntraSlotFrequencyHopping_r16);
	_serNrSysEncB2_SQN_NR_MsgA_PUSCH_Resource_r16_msgA_HoppingBits_r16_Optional(_buffer, _size, _lidx, &p->msgA_HoppingBits_r16);
	_serNrSysEncSQN_NR_MsgA_DMRS_Config_r16(_buffer, _size, _lidx, &p->msgA_DMRS_Config_r16);
	HTON_8(&_buffer[*_lidx], p->nrofDMRS_Sequences_r16, _lidx);
	_serNrSysEncSQN_NR_MsgA_PUSCH_Resource_r16_msgA_Alpha_r16_e_msgA_Alpha_r16_Optional(_buffer, _size, _lidx, &p->msgA_Alpha_r16);
	_serNrSysEncUint8_t_SQN_NR_MsgA_PUSCH_Resource_r16_interlaceIndexFirstPO_MsgA_PUSCH_r16_Optional(_buffer, _size, _lidx, &p->interlaceIndexFirstPO_MsgA_PUSCH_r16);
	_serNrSysEncUint8_t_SQN_NR_MsgA_PUSCH_Resource_r16_nrofInterlacesPerMsgA_PO_r16_Optional(_buffer, _size, _lidx, &p->nrofInterlacesPerMsgA_PO_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_MsgA_PUSCH_Resource_r16_SQN_NR_MsgA_PUSCH_Config_r16_msgA_PUSCH_ResourceGroupA_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_MsgA_PUSCH_Resource_r16_SQN_NR_MsgA_PUSCH_Config_r16_msgA_PUSCH_ResourceGroupA_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_MsgA_PUSCH_Resource_r16(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_MsgA_PUSCH_Resource_r16_SQN_NR_MsgA_PUSCH_Config_r16_msgA_PUSCH_ResourceGroupB_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_MsgA_PUSCH_Resource_r16_SQN_NR_MsgA_PUSCH_Config_r16_msgA_PUSCH_ResourceGroupB_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_MsgA_PUSCH_Resource_r16(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_MsgA_PUSCH_Config_r16_msgA_TransformPrecoder_r16_e_msgA_TransformPrecoder_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_MsgA_PUSCH_Config_r16_msgA_TransformPrecoder_r16_e_msgA_TransformPrecoder_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncUint16_t_SQN_NR_MsgA_PUSCH_Config_r16_msgA_DataScramblingIndex_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint16_t_SQN_NR_MsgA_PUSCH_Config_r16_msgA_DataScramblingIndex_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_16(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncInt8_t_SQN_NR_MsgA_PUSCH_Config_r16_msgA_DeltaPreamble_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct int8_t_SQN_NR_MsgA_PUSCH_Config_r16_msgA_DeltaPreamble_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_MsgA_PUSCH_Config_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_MsgA_PUSCH_Config_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncSQN_NR_MsgA_PUSCH_Resource_r16_SQN_NR_MsgA_PUSCH_Config_r16_msgA_PUSCH_ResourceGroupA_r16_Optional(_buffer, _size, _lidx, &p->msgA_PUSCH_ResourceGroupA_r16);
	_serNrSysEncSQN_NR_MsgA_PUSCH_Resource_r16_SQN_NR_MsgA_PUSCH_Config_r16_msgA_PUSCH_ResourceGroupB_r16_Optional(_buffer, _size, _lidx, &p->msgA_PUSCH_ResourceGroupB_r16);
	_serNrSysEncSQN_NR_MsgA_PUSCH_Config_r16_msgA_TransformPrecoder_r16_e_msgA_TransformPrecoder_r16_Optional(_buffer, _size, _lidx, &p->msgA_TransformPrecoder_r16);
	_serNrSysEncUint16_t_SQN_NR_MsgA_PUSCH_Config_r16_msgA_DataScramblingIndex_r16_Optional(_buffer, _size, _lidx, &p->msgA_DataScramblingIndex_r16);
	_serNrSysEncInt8_t_SQN_NR_MsgA_PUSCH_Config_r16_msgA_DeltaPreamble_r16_Optional(_buffer, _size, _lidx, &p->msgA_DeltaPreamble_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_MsgA_PUSCH_Config_r16_SQN_NR_MsgA_ConfigCommon_r16_msgA_PUSCH_Config_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_MsgA_PUSCH_Config_r16_SQN_NR_MsgA_ConfigCommon_r16_msgA_PUSCH_Config_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_MsgA_PUSCH_Config_r16(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_MsgA_ConfigCommon_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_MsgA_ConfigCommon_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncSQN_NR_RACH_ConfigCommonTwoStepRA_r16(_buffer, _size, _lidx, &p->rach_ConfigCommonTwoStepRA_r16);
	_serNrSysEncSQN_NR_MsgA_PUSCH_Config_r16_SQN_NR_MsgA_ConfigCommon_r16_msgA_PUSCH_Config_r16_Optional(_buffer, _size, _lidx, &p->msgA_PUSCH_Config_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SetupRelease_BWP_UplinkCommon_msgA_ConfigCommon_r16_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SQN_NR_SetupRelease_BWP_UplinkCommon_msgA_ConfigCommon_r16_Value* p, enum SQN_NR_SetupRelease_BWP_UplinkCommon_msgA_ConfigCommon_r16_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SetupRelease_BWP_UplinkCommon_msgA_ConfigCommon_r16_release) {
		HTON_8(&_buffer[*_lidx], p->release, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SetupRelease_BWP_UplinkCommon_msgA_ConfigCommon_r16_setup) {
		_serNrSysEncSQN_NR_MsgA_ConfigCommon_r16(_buffer, _size, _lidx, &p->setup);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncSQN_NR_SetupRelease_BWP_UplinkCommon_msgA_ConfigCommon_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SetupRelease_BWP_UplinkCommon_msgA_ConfigCommon_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_SetupRelease_BWP_UplinkCommon_msgA_ConfigCommon_r16_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SetupRelease_BWP_UplinkCommon_msgA_ConfigCommon_r16_SQN_NR_BWP_UplinkCommon_msgA_ConfigCommon_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SetupRelease_BWP_UplinkCommon_msgA_ConfigCommon_r16_SQN_NR_BWP_UplinkCommon_msgA_ConfigCommon_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_SetupRelease_BWP_UplinkCommon_msgA_ConfigCommon_r16(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_BWP_UplinkCommon(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_BWP_UplinkCommon* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncSQN_NR_BWP(_buffer, _size, _lidx, &p->genericParameters);
	_serNrSysEncSQN_NR_SetupRelease_BWP_UplinkCommon_rach_ConfigCommon_SQN_NR_BWP_UplinkCommon_rach_ConfigCommon_Optional(_buffer, _size, _lidx, &p->rach_ConfigCommon);
	_serNrSysEncSQN_NR_SetupRelease_BWP_UplinkCommon_pusch_ConfigCommon_SQN_NR_BWP_UplinkCommon_pusch_ConfigCommon_Optional(_buffer, _size, _lidx, &p->pusch_ConfigCommon);
	_serNrSysEncSQN_NR_SetupRelease_BWP_UplinkCommon_pucch_ConfigCommon_SQN_NR_BWP_UplinkCommon_pucch_ConfigCommon_Optional(_buffer, _size, _lidx, &p->pucch_ConfigCommon);
	_serNrSysEncSQN_NR_SetupRelease_BWP_UplinkCommon_rach_ConfigCommonIAB_r16_SQN_NR_BWP_UplinkCommon_rach_ConfigCommonIAB_r16_Optional(_buffer, _size, _lidx, &p->rach_ConfigCommonIAB_r16);
	_serNrSysEncSQN_NR_BWP_UplinkCommon_useInterlacePUCCH_PUSCH_r16_e_useInterlacePUCCH_PUSCH_r16_Optional(_buffer, _size, _lidx, &p->useInterlacePUCCH_PUSCH_r16);
	_serNrSysEncSQN_NR_SetupRelease_BWP_UplinkCommon_msgA_ConfigCommon_r16_SQN_NR_BWP_UplinkCommon_msgA_ConfigCommon_r16_Optional(_buffer, _size, _lidx, &p->msgA_ConfigCommon_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_ASN1_BWP_UplinkCommon_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union NR_ASN1_BWP_UplinkCommon_Type_Value* p, enum NR_ASN1_BWP_UplinkCommon_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_ASN1_BWP_UplinkCommon_Type_R15) {
		_serNrSysEncSQN_NR_BWP_UplinkCommon(_buffer, _size, _lidx, &p->R15);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncNR_ASN1_BWP_UplinkCommon_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_ASN1_BWP_UplinkCommon_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncNR_ASN1_BWP_UplinkCommon_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_ASN1_BWP_UplinkCommon_Type_Common_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_ASN1_BWP_UplinkCommon_Type_Common_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncNR_ASN1_BWP_UplinkCommon_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncUint16_t_SQN_NR_PUCCH_ResourceSet_maxPayloadSize_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint16_t_SQN_NR_PUCCH_ResourceSet_maxPayloadSize_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_16(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PUCCH_ResourceSet(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PUCCH_ResourceSet* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->pucch_ResourceSetId, _lidx);
	HTON_32(&_buffer[*_lidx], p->resourceList.d, _lidx);
	for (size_t i3 = 0; i3 < p->resourceList.d; i3++) {
		HTON_8(&_buffer[*_lidx], p->resourceList.v[i3], _lidx);
	}
	_serNrSysEncUint16_t_SQN_NR_PUCCH_ResourceSet_maxPayloadSize_Optional(_buffer, _size, _lidx, &p->maxPayloadSize);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PUCCH_ResourceSet_SQN_NR_PUCCH_Config_resourceSetToAddModList_DynamicOptional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PUCCH_ResourceSet_SQN_NR_PUCCH_Config_resourceSetToAddModList_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serNrSysEncSQN_NR_PUCCH_ResourceSet(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PUCCH_ResourceSetId_SQN_NR_PUCCH_Config_resourceSetToReleaseList_DynamicOptional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PUCCH_ResourceSetId_SQN_NR_PUCCH_Config_resourceSetToReleaseList_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		HTON_8(&_buffer[*_lidx], p->v.v[i2], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PUCCH_Resource_intraSlotFrequencyHopping_e_intraSlotFrequencyHopping_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PUCCH_Resource_intraSlotFrequencyHopping_e_intraSlotFrequencyHopping_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PRB_Id_SQN_NR_PUCCH_Resource_secondHopPRB_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PRB_Id_SQN_NR_PUCCH_Resource_secondHopPRB_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_16(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PUCCH_format0(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PUCCH_format0* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->initialCyclicShift, _lidx);
	HTON_8(&_buffer[*_lidx], p->nrofSymbols, _lidx);
	HTON_8(&_buffer[*_lidx], p->startingSymbolIndex, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PUCCH_format1(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PUCCH_format1* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->initialCyclicShift, _lidx);
	HTON_8(&_buffer[*_lidx], p->nrofSymbols, _lidx);
	HTON_8(&_buffer[*_lidx], p->startingSymbolIndex, _lidx);
	HTON_8(&_buffer[*_lidx], p->timeDomainOCC, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PUCCH_format2(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PUCCH_format2* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->nrofPRBs, _lidx);
	HTON_8(&_buffer[*_lidx], p->nrofSymbols, _lidx);
	HTON_8(&_buffer[*_lidx], p->startingSymbolIndex, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PUCCH_format3(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PUCCH_format3* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->nrofPRBs, _lidx);
	HTON_8(&_buffer[*_lidx], p->nrofSymbols, _lidx);
	HTON_8(&_buffer[*_lidx], p->startingSymbolIndex, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PUCCH_format4(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PUCCH_format4* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->nrofSymbols, _lidx);
	{
		size_t _tmp = (size_t)p->occ_Length;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	{
		size_t _tmp = (size_t)p->occ_Index;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	HTON_8(&_buffer[*_lidx], p->startingSymbolIndex, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PUCCH_Resource_format_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SQN_NR_PUCCH_Resource_format_Value* p, enum SQN_NR_PUCCH_Resource_format_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_PUCCH_Resource_format_format0) {
		_serNrSysEncSQN_NR_PUCCH_format0(_buffer, _size, _lidx, &p->format0);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_PUCCH_Resource_format_format1) {
		_serNrSysEncSQN_NR_PUCCH_format1(_buffer, _size, _lidx, &p->format1);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_PUCCH_Resource_format_format2) {
		_serNrSysEncSQN_NR_PUCCH_format2(_buffer, _size, _lidx, &p->format2);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_PUCCH_Resource_format_format3) {
		_serNrSysEncSQN_NR_PUCCH_format3(_buffer, _size, _lidx, &p->format3);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_PUCCH_Resource_format_format4) {
		_serNrSysEncSQN_NR_PUCCH_format4(_buffer, _size, _lidx, &p->format4);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncSQN_NR_PUCCH_Resource_format(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PUCCH_Resource_format* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_PUCCH_Resource_format_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PUCCH_Resource(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PUCCH_Resource* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->pucch_ResourceId, _lidx);
	HTON_16(&_buffer[*_lidx], p->startingPRB, _lidx);
	_serNrSysEncSQN_NR_PUCCH_Resource_intraSlotFrequencyHopping_e_intraSlotFrequencyHopping_Optional(_buffer, _size, _lidx, &p->intraSlotFrequencyHopping);
	_serNrSysEncSQN_NR_PRB_Id_SQN_NR_PUCCH_Resource_secondHopPRB_Optional(_buffer, _size, _lidx, &p->secondHopPRB);
	_serNrSysEncSQN_NR_PUCCH_Resource_format(_buffer, _size, _lidx, &p->format);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PUCCH_Resource_SQN_NR_PUCCH_Config_resourceToAddModList_DynamicOptional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PUCCH_Resource_SQN_NR_PUCCH_Config_resourceToAddModList_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serNrSysEncSQN_NR_PUCCH_Resource(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PUCCH_ResourceId_SQN_NR_PUCCH_Config_resourceToReleaseList_DynamicOptional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PUCCH_ResourceId_SQN_NR_PUCCH_Config_resourceToReleaseList_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		HTON_8(&_buffer[*_lidx], p->v.v[i2], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PUCCH_FormatConfig_interslotFrequencyHopping_e_interslotFrequencyHopping_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PUCCH_FormatConfig_interslotFrequencyHopping_e_interslotFrequencyHopping_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PUCCH_FormatConfig_additionalDMRS_e_additionalDMRS_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PUCCH_FormatConfig_additionalDMRS_e_additionalDMRS_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PUCCH_MaxCodeRate_e_SQN_NR_PUCCH_FormatConfig_maxCodeRate_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PUCCH_MaxCodeRate_e_SQN_NR_PUCCH_FormatConfig_maxCodeRate_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PUCCH_FormatConfig_nrofSlots_e_nrofSlots_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PUCCH_FormatConfig_nrofSlots_e_nrofSlots_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PUCCH_FormatConfig_pi2BPSK_e_pi2BPSK_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PUCCH_FormatConfig_pi2BPSK_e_pi2BPSK_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PUCCH_FormatConfig_simultaneousHARQ_ACK_CSI_e_simultaneousHARQ_ACK_CSI_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PUCCH_FormatConfig_simultaneousHARQ_ACK_CSI_e_simultaneousHARQ_ACK_CSI_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PUCCH_FormatConfig(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PUCCH_FormatConfig* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncSQN_NR_PUCCH_FormatConfig_interslotFrequencyHopping_e_interslotFrequencyHopping_Optional(_buffer, _size, _lidx, &p->interslotFrequencyHopping);
	_serNrSysEncSQN_NR_PUCCH_FormatConfig_additionalDMRS_e_additionalDMRS_Optional(_buffer, _size, _lidx, &p->additionalDMRS);
	_serNrSysEncSQN_NR_PUCCH_MaxCodeRate_e_SQN_NR_PUCCH_FormatConfig_maxCodeRate_Optional(_buffer, _size, _lidx, &p->maxCodeRate);
	_serNrSysEncSQN_NR_PUCCH_FormatConfig_nrofSlots_e_nrofSlots_Optional(_buffer, _size, _lidx, &p->nrofSlots);
	_serNrSysEncSQN_NR_PUCCH_FormatConfig_pi2BPSK_e_pi2BPSK_Optional(_buffer, _size, _lidx, &p->pi2BPSK);
	_serNrSysEncSQN_NR_PUCCH_FormatConfig_simultaneousHARQ_ACK_CSI_e_simultaneousHARQ_ACK_CSI_Optional(_buffer, _size, _lidx, &p->simultaneousHARQ_ACK_CSI);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SetupRelease_PUCCH_Config_format1_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SQN_NR_SetupRelease_PUCCH_Config_format1_Value* p, enum SQN_NR_SetupRelease_PUCCH_Config_format1_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SetupRelease_PUCCH_Config_format1_release) {
		HTON_8(&_buffer[*_lidx], p->release, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SetupRelease_PUCCH_Config_format1_setup) {
		_serNrSysEncSQN_NR_PUCCH_FormatConfig(_buffer, _size, _lidx, &p->setup);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncSQN_NR_SetupRelease_PUCCH_Config_format1(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SetupRelease_PUCCH_Config_format1* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_SetupRelease_PUCCH_Config_format1_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SetupRelease_PUCCH_Config_format1_SQN_NR_PUCCH_Config_format1_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SetupRelease_PUCCH_Config_format1_SQN_NR_PUCCH_Config_format1_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_SetupRelease_PUCCH_Config_format1(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SetupRelease_PUCCH_Config_format2_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SQN_NR_SetupRelease_PUCCH_Config_format2_Value* p, enum SQN_NR_SetupRelease_PUCCH_Config_format2_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SetupRelease_PUCCH_Config_format2_release) {
		HTON_8(&_buffer[*_lidx], p->release, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SetupRelease_PUCCH_Config_format2_setup) {
		_serNrSysEncSQN_NR_PUCCH_FormatConfig(_buffer, _size, _lidx, &p->setup);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncSQN_NR_SetupRelease_PUCCH_Config_format2(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SetupRelease_PUCCH_Config_format2* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_SetupRelease_PUCCH_Config_format2_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SetupRelease_PUCCH_Config_format2_SQN_NR_PUCCH_Config_format2_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SetupRelease_PUCCH_Config_format2_SQN_NR_PUCCH_Config_format2_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_SetupRelease_PUCCH_Config_format2(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SetupRelease_PUCCH_Config_format3_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SQN_NR_SetupRelease_PUCCH_Config_format3_Value* p, enum SQN_NR_SetupRelease_PUCCH_Config_format3_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SetupRelease_PUCCH_Config_format3_release) {
		HTON_8(&_buffer[*_lidx], p->release, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SetupRelease_PUCCH_Config_format3_setup) {
		_serNrSysEncSQN_NR_PUCCH_FormatConfig(_buffer, _size, _lidx, &p->setup);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncSQN_NR_SetupRelease_PUCCH_Config_format3(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SetupRelease_PUCCH_Config_format3* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_SetupRelease_PUCCH_Config_format3_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SetupRelease_PUCCH_Config_format3_SQN_NR_PUCCH_Config_format3_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SetupRelease_PUCCH_Config_format3_SQN_NR_PUCCH_Config_format3_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_SetupRelease_PUCCH_Config_format3(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SetupRelease_PUCCH_Config_format4_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SQN_NR_SetupRelease_PUCCH_Config_format4_Value* p, enum SQN_NR_SetupRelease_PUCCH_Config_format4_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SetupRelease_PUCCH_Config_format4_release) {
		HTON_8(&_buffer[*_lidx], p->release, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SetupRelease_PUCCH_Config_format4_setup) {
		_serNrSysEncSQN_NR_PUCCH_FormatConfig(_buffer, _size, _lidx, &p->setup);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncSQN_NR_SetupRelease_PUCCH_Config_format4(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SetupRelease_PUCCH_Config_format4* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_SetupRelease_PUCCH_Config_format4_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SetupRelease_PUCCH_Config_format4_SQN_NR_PUCCH_Config_format4_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SetupRelease_PUCCH_Config_format4_SQN_NR_PUCCH_Config_format4_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_SetupRelease_PUCCH_Config_format4(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SchedulingRequestResourceConfig_periodicityAndOffset_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SQN_NR_SchedulingRequestResourceConfig_periodicityAndOffset_Value* p, enum SQN_NR_SchedulingRequestResourceConfig_periodicityAndOffset_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SchedulingRequestResourceConfig_periodicityAndOffset_sym2) {
		HTON_8(&_buffer[*_lidx], p->sym2, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SchedulingRequestResourceConfig_periodicityAndOffset_sym6or7) {
		HTON_8(&_buffer[*_lidx], p->sym6or7, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SchedulingRequestResourceConfig_periodicityAndOffset_sl1) {
		HTON_8(&_buffer[*_lidx], p->sl1, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SchedulingRequestResourceConfig_periodicityAndOffset_sl2) {
		HTON_8(&_buffer[*_lidx], p->sl2, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SchedulingRequestResourceConfig_periodicityAndOffset_sl4) {
		HTON_8(&_buffer[*_lidx], p->sl4, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SchedulingRequestResourceConfig_periodicityAndOffset_sl5) {
		HTON_8(&_buffer[*_lidx], p->sl5, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SchedulingRequestResourceConfig_periodicityAndOffset_sl8) {
		HTON_8(&_buffer[*_lidx], p->sl8, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SchedulingRequestResourceConfig_periodicityAndOffset_sl10) {
		HTON_8(&_buffer[*_lidx], p->sl10, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SchedulingRequestResourceConfig_periodicityAndOffset_sl16) {
		HTON_8(&_buffer[*_lidx], p->sl16, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SchedulingRequestResourceConfig_periodicityAndOffset_sl20) {
		HTON_8(&_buffer[*_lidx], p->sl20, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SchedulingRequestResourceConfig_periodicityAndOffset_sl40) {
		HTON_8(&_buffer[*_lidx], p->sl40, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SchedulingRequestResourceConfig_periodicityAndOffset_sl80) {
		HTON_8(&_buffer[*_lidx], p->sl80, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SchedulingRequestResourceConfig_periodicityAndOffset_sl160) {
		HTON_8(&_buffer[*_lidx], p->sl160, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SchedulingRequestResourceConfig_periodicityAndOffset_sl320) {
		HTON_16(&_buffer[*_lidx], p->sl320, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SchedulingRequestResourceConfig_periodicityAndOffset_sl640) {
		HTON_16(&_buffer[*_lidx], p->sl640, _lidx);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncSQN_NR_SchedulingRequestResourceConfig_periodicityAndOffset(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SchedulingRequestResourceConfig_periodicityAndOffset* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_SchedulingRequestResourceConfig_periodicityAndOffset_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SchedulingRequestResourceConfig_periodicityAndOffset_periodicityAndOffset_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SchedulingRequestResourceConfig_periodicityAndOffset_periodicityAndOffset_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_SchedulingRequestResourceConfig_periodicityAndOffset(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PUCCH_ResourceId_SQN_NR_SchedulingRequestResourceConfig_resource_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PUCCH_ResourceId_SQN_NR_SchedulingRequestResourceConfig_resource_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SchedulingRequestResourceConfig(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SchedulingRequestResourceConfig* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->schedulingRequestResourceId, _lidx);
	HTON_8(&_buffer[*_lidx], p->schedulingRequestID, _lidx);
	_serNrSysEncSQN_NR_SchedulingRequestResourceConfig_periodicityAndOffset_periodicityAndOffset_Optional(_buffer, _size, _lidx, &p->periodicityAndOffset);
	_serNrSysEncSQN_NR_PUCCH_ResourceId_SQN_NR_SchedulingRequestResourceConfig_resource_Optional(_buffer, _size, _lidx, &p->resource);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SchedulingRequestResourceConfig_SQN_NR_PUCCH_Config_schedulingRequestResourceToAddModList_DynamicOptional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SchedulingRequestResourceConfig_SQN_NR_PUCCH_Config_schedulingRequestResourceToAddModList_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serNrSysEncSQN_NR_SchedulingRequestResourceConfig(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SchedulingRequestResourceId_SQN_NR_PUCCH_Config_schedulingRequestResourceToReleaseList_DynamicOptional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SchedulingRequestResourceId_SQN_NR_PUCCH_Config_schedulingRequestResourceToReleaseList_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		HTON_8(&_buffer[*_lidx], p->v.v[i2], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PUCCH_ResourceId_SQN_NR_PUCCH_Config_multi_CSI_PUCCH_ResourceList_DynamicOptional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PUCCH_ResourceId_SQN_NR_PUCCH_Config_multi_CSI_PUCCH_ResourceList_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		HTON_8(&_buffer[*_lidx], p->v.v[i2], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncUint8_t_SQN_NR_PUCCH_Config_dl_DataToUL_ACK_DynamicOptional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint8_t_SQN_NR_PUCCH_Config_dl_DataToUL_ACK_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		HTON_8(&_buffer[*_lidx], p->v.v[i2], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_ServCellIndex_SQN_NR_PUCCH_SpatialRelationInfo_servingCellId_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_ServCellIndex_SQN_NR_PUCCH_SpatialRelationInfo_servingCellId_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PUCCH_SRS(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PUCCH_SRS* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->resource, _lidx);
	HTON_8(&_buffer[*_lidx], p->uplinkBWP, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PUCCH_SpatialRelationInfo_referenceSignal_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SQN_NR_PUCCH_SpatialRelationInfo_referenceSignal_Value* p, enum SQN_NR_PUCCH_SpatialRelationInfo_referenceSignal_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_PUCCH_SpatialRelationInfo_referenceSignal_ssb_Index) {
		HTON_8(&_buffer[*_lidx], p->ssb_Index, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_PUCCH_SpatialRelationInfo_referenceSignal_csi_RS_Index) {
		HTON_8(&_buffer[*_lidx], p->csi_RS_Index, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_PUCCH_SpatialRelationInfo_referenceSignal_srs) {
		_serNrSysEncSQN_NR_PUCCH_SRS(_buffer, _size, _lidx, &p->srs);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncSQN_NR_PUCCH_SpatialRelationInfo_referenceSignal(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PUCCH_SpatialRelationInfo_referenceSignal* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_PUCCH_SpatialRelationInfo_referenceSignal_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PUCCH_SpatialRelationInfo(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PUCCH_SpatialRelationInfo* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->pucch_SpatialRelationInfoId, _lidx);
	_serNrSysEncSQN_NR_ServCellIndex_SQN_NR_PUCCH_SpatialRelationInfo_servingCellId_Optional(_buffer, _size, _lidx, &p->servingCellId);
	_serNrSysEncSQN_NR_PUCCH_SpatialRelationInfo_referenceSignal(_buffer, _size, _lidx, &p->referenceSignal);
	HTON_8(&_buffer[*_lidx], p->pucch_PathlossReferenceRS_Id, _lidx);
	HTON_8(&_buffer[*_lidx], p->p0_PUCCH_Id, _lidx);
	{
		size_t _tmp = (size_t)p->closedLoopIndex;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PUCCH_SpatialRelationInfo_SQN_NR_PUCCH_Config_spatialRelationInfoToAddModList_DynamicOptional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PUCCH_SpatialRelationInfo_SQN_NR_PUCCH_Config_spatialRelationInfoToAddModList_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serNrSysEncSQN_NR_PUCCH_SpatialRelationInfo(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PUCCH_SpatialRelationInfoId_SQN_NR_PUCCH_Config_spatialRelationInfoToReleaseList_DynamicOptional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PUCCH_SpatialRelationInfoId_SQN_NR_PUCCH_Config_spatialRelationInfoToReleaseList_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		HTON_8(&_buffer[*_lidx], p->v.v[i2], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncInt8_t_SQN_NR_PUCCH_PowerControl_deltaF_PUCCH_f0_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct int8_t_SQN_NR_PUCCH_PowerControl_deltaF_PUCCH_f0_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncInt8_t_SQN_NR_PUCCH_PowerControl_deltaF_PUCCH_f1_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct int8_t_SQN_NR_PUCCH_PowerControl_deltaF_PUCCH_f1_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncInt8_t_SQN_NR_PUCCH_PowerControl_deltaF_PUCCH_f2_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct int8_t_SQN_NR_PUCCH_PowerControl_deltaF_PUCCH_f2_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncInt8_t_SQN_NR_PUCCH_PowerControl_deltaF_PUCCH_f3_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct int8_t_SQN_NR_PUCCH_PowerControl_deltaF_PUCCH_f3_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncInt8_t_SQN_NR_PUCCH_PowerControl_deltaF_PUCCH_f4_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct int8_t_SQN_NR_PUCCH_PowerControl_deltaF_PUCCH_f4_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_P0_PUCCH(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_P0_PUCCH* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->p0_PUCCH_Id, _lidx);
	HTON_8(&_buffer[*_lidx], p->p0_PUCCH_Value, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_P0_PUCCH_SQN_NR_PUCCH_PowerControl_p0_Set_DynamicOptional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_P0_PUCCH_SQN_NR_PUCCH_PowerControl_p0_Set_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serNrSysEncSQN_NR_P0_PUCCH(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PUCCH_PathlossReferenceRS_referenceSignal_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SQN_NR_PUCCH_PathlossReferenceRS_referenceSignal_Value* p, enum SQN_NR_PUCCH_PathlossReferenceRS_referenceSignal_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_PUCCH_PathlossReferenceRS_referenceSignal_ssb_Index) {
		HTON_8(&_buffer[*_lidx], p->ssb_Index, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_PUCCH_PathlossReferenceRS_referenceSignal_csi_RS_Index) {
		HTON_8(&_buffer[*_lidx], p->csi_RS_Index, _lidx);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncSQN_NR_PUCCH_PathlossReferenceRS_referenceSignal(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PUCCH_PathlossReferenceRS_referenceSignal* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_PUCCH_PathlossReferenceRS_referenceSignal_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PUCCH_PathlossReferenceRS(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PUCCH_PathlossReferenceRS* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->pucch_PathlossReferenceRS_Id, _lidx);
	_serNrSysEncSQN_NR_PUCCH_PathlossReferenceRS_referenceSignal(_buffer, _size, _lidx, &p->referenceSignal);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PUCCH_PathlossReferenceRS_SQN_NR_PUCCH_PowerControl_pathlossReferenceRSs_DynamicOptional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PUCCH_PathlossReferenceRS_SQN_NR_PUCCH_PowerControl_pathlossReferenceRSs_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serNrSysEncSQN_NR_PUCCH_PathlossReferenceRS(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PUCCH_PowerControl_twoPUCCH_PC_AdjustmentStates_e_twoPUCCH_PC_AdjustmentStates_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PUCCH_PowerControl_twoPUCCH_PC_AdjustmentStates_e_twoPUCCH_PC_AdjustmentStates_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PUCCH_PathlossReferenceRS_r16_referenceSignal_r16_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SQN_NR_PUCCH_PathlossReferenceRS_r16_referenceSignal_r16_Value* p, enum SQN_NR_PUCCH_PathlossReferenceRS_r16_referenceSignal_r16_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_PUCCH_PathlossReferenceRS_r16_referenceSignal_r16_ssb_Index_r16) {
		HTON_8(&_buffer[*_lidx], p->ssb_Index_r16, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_PUCCH_PathlossReferenceRS_r16_referenceSignal_r16_csi_RS_Index_r16) {
		HTON_8(&_buffer[*_lidx], p->csi_RS_Index_r16, _lidx);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncSQN_NR_PUCCH_PathlossReferenceRS_r16_referenceSignal_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PUCCH_PathlossReferenceRS_r16_referenceSignal_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_PUCCH_PathlossReferenceRS_r16_referenceSignal_r16_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PUCCH_PathlossReferenceRS_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PUCCH_PathlossReferenceRS_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->pucch_PathlossReferenceRS_Id_r16, _lidx);
	_serNrSysEncSQN_NR_PUCCH_PathlossReferenceRS_r16_referenceSignal_r16(_buffer, _size, _lidx, &p->referenceSignal_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SetupRelease_PUCCH_PowerControl_pathlossReferenceRSs_v1610_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SQN_NR_SetupRelease_PUCCH_PowerControl_pathlossReferenceRSs_v1610_Value* p, enum SQN_NR_SetupRelease_PUCCH_PowerControl_pathlossReferenceRSs_v1610_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SetupRelease_PUCCH_PowerControl_pathlossReferenceRSs_v1610_release) {
		HTON_8(&_buffer[*_lidx], p->release, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SetupRelease_PUCCH_PowerControl_pathlossReferenceRSs_v1610_setup) {
		HTON_32(&_buffer[*_lidx], p->setup.d, _lidx);
		for (size_t i2 = 0; i2 < p->setup.d; i2++) {
			_serNrSysEncSQN_NR_PUCCH_PathlossReferenceRS_r16(_buffer, _size, _lidx, &p->setup.v[i2]);
		}
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncSQN_NR_SetupRelease_PUCCH_PowerControl_pathlossReferenceRSs_v1610(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SetupRelease_PUCCH_PowerControl_pathlossReferenceRSs_v1610* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_SetupRelease_PUCCH_PowerControl_pathlossReferenceRSs_v1610_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SetupRelease_PUCCH_PowerControl_pathlossReferenceRSs_v1610_SQN_NR_PUCCH_PowerControl_pathlossReferenceRSs_v1610_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SetupRelease_PUCCH_PowerControl_pathlossReferenceRSs_v1610_SQN_NR_PUCCH_PowerControl_pathlossReferenceRSs_v1610_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_SetupRelease_PUCCH_PowerControl_pathlossReferenceRSs_v1610(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PUCCH_PowerControl(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PUCCH_PowerControl* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncInt8_t_SQN_NR_PUCCH_PowerControl_deltaF_PUCCH_f0_Optional(_buffer, _size, _lidx, &p->deltaF_PUCCH_f0);
	_serNrSysEncInt8_t_SQN_NR_PUCCH_PowerControl_deltaF_PUCCH_f1_Optional(_buffer, _size, _lidx, &p->deltaF_PUCCH_f1);
	_serNrSysEncInt8_t_SQN_NR_PUCCH_PowerControl_deltaF_PUCCH_f2_Optional(_buffer, _size, _lidx, &p->deltaF_PUCCH_f2);
	_serNrSysEncInt8_t_SQN_NR_PUCCH_PowerControl_deltaF_PUCCH_f3_Optional(_buffer, _size, _lidx, &p->deltaF_PUCCH_f3);
	_serNrSysEncInt8_t_SQN_NR_PUCCH_PowerControl_deltaF_PUCCH_f4_Optional(_buffer, _size, _lidx, &p->deltaF_PUCCH_f4);
	_serNrSysEncSQN_NR_P0_PUCCH_SQN_NR_PUCCH_PowerControl_p0_Set_DynamicOptional(_buffer, _size, _lidx, &p->p0_Set);
	_serNrSysEncSQN_NR_PUCCH_PathlossReferenceRS_SQN_NR_PUCCH_PowerControl_pathlossReferenceRSs_DynamicOptional(_buffer, _size, _lidx, &p->pathlossReferenceRSs);
	_serNrSysEncSQN_NR_PUCCH_PowerControl_twoPUCCH_PC_AdjustmentStates_e_twoPUCCH_PC_AdjustmentStates_Optional(_buffer, _size, _lidx, &p->twoPUCCH_PC_AdjustmentStates);
	_serNrSysEncSQN_NR_SetupRelease_PUCCH_PowerControl_pathlossReferenceRSs_v1610_SQN_NR_PUCCH_PowerControl_pathlossReferenceRSs_v1610_Optional(_buffer, _size, _lidx, &p->pathlossReferenceRSs_v1610);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PUCCH_PowerControl_SQN_NR_PUCCH_Config_pucch_PowerControl_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PUCCH_PowerControl_SQN_NR_PUCCH_Config_pucch_PowerControl_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_PUCCH_PowerControl(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PUCCH_ResourceExt_r16_interlaceAllocation_r16_interlace0_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SQN_NR_PUCCH_ResourceExt_r16_interlaceAllocation_r16_interlace0_Value* p, enum SQN_NR_PUCCH_ResourceExt_r16_interlaceAllocation_r16_interlace0_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_PUCCH_ResourceExt_r16_interlaceAllocation_r16_interlace0_scs15) {
		HTON_8(&_buffer[*_lidx], p->scs15, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_PUCCH_ResourceExt_r16_interlaceAllocation_r16_interlace0_scs30) {
		HTON_8(&_buffer[*_lidx], p->scs30, _lidx);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncSQN_NR_PUCCH_ResourceExt_r16_interlaceAllocation_r16_interlace0(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PUCCH_ResourceExt_r16_interlaceAllocation_r16_interlace0* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_PUCCH_ResourceExt_r16_interlaceAllocation_r16_interlace0_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PUCCH_ResourceExt_r16_interlaceAllocation_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PUCCH_ResourceExt_r16_interlaceAllocation_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->rb_SetIndex, _lidx);
	_serNrSysEncSQN_NR_PUCCH_ResourceExt_r16_interlaceAllocation_r16_interlace0(_buffer, _size, _lidx, &p->interlace0);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PUCCH_ResourceExt_r16_interlaceAllocation_r16_interlaceAllocation_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PUCCH_ResourceExt_r16_interlaceAllocation_r16_interlaceAllocation_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_PUCCH_ResourceExt_r16_interlaceAllocation_r16(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PUCCH_ResourceExt_r16_formatExt_v1610_occ_v1610_occ_Length_v1610_e_occ_Length_v1610_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PUCCH_ResourceExt_r16_formatExt_v1610_occ_v1610_occ_Length_v1610_e_occ_Length_v1610_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PUCCH_ResourceExt_r16_formatExt_v1610_occ_v1610_occ_Index_v1610_e_occ_Index_v1610_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PUCCH_ResourceExt_r16_formatExt_v1610_occ_v1610_occ_Index_v1610_e_occ_Index_v1610_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PUCCH_ResourceExt_r16_formatExt_v1610_occ_v1610(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PUCCH_ResourceExt_r16_formatExt_v1610_occ_v1610* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncSQN_NR_PUCCH_ResourceExt_r16_formatExt_v1610_occ_v1610_occ_Length_v1610_e_occ_Length_v1610_Optional(_buffer, _size, _lidx, &p->occ_Length_v1610);
	_serNrSysEncSQN_NR_PUCCH_ResourceExt_r16_formatExt_v1610_occ_v1610_occ_Index_v1610_e_occ_Index_v1610_Optional(_buffer, _size, _lidx, &p->occ_Index_v1610);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PUCCH_ResourceExt_r16_formatExt_v1610_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SQN_NR_PUCCH_ResourceExt_r16_formatExt_v1610_Value* p, enum SQN_NR_PUCCH_ResourceExt_r16_formatExt_v1610_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_PUCCH_ResourceExt_r16_formatExt_v1610_interlace1_v1610) {
		HTON_8(&_buffer[*_lidx], p->interlace1_v1610, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_PUCCH_ResourceExt_r16_formatExt_v1610_occ_v1610) {
		_serNrSysEncSQN_NR_PUCCH_ResourceExt_r16_formatExt_v1610_occ_v1610(_buffer, _size, _lidx, &p->occ_v1610);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncSQN_NR_PUCCH_ResourceExt_r16_formatExt_v1610(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PUCCH_ResourceExt_r16_formatExt_v1610* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_PUCCH_ResourceExt_r16_formatExt_v1610_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PUCCH_ResourceExt_r16_formatExt_v1610_formatExt_v1610_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PUCCH_ResourceExt_r16_formatExt_v1610_formatExt_v1610_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_PUCCH_ResourceExt_r16_formatExt_v1610(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PUCCH_ResourceExt_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PUCCH_ResourceExt_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncSQN_NR_PUCCH_ResourceExt_r16_interlaceAllocation_r16_interlaceAllocation_r16_Optional(_buffer, _size, _lidx, &p->interlaceAllocation_r16);
	_serNrSysEncSQN_NR_PUCCH_ResourceExt_r16_formatExt_v1610_formatExt_v1610_Optional(_buffer, _size, _lidx, &p->formatExt_v1610);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PUCCH_ResourceExt_r16_SQN_NR_PUCCH_Config_resourceToAddModListExt_r16_DynamicOptional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PUCCH_ResourceExt_r16_SQN_NR_PUCCH_Config_resourceToAddModListExt_r16_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serNrSysEncSQN_NR_PUCCH_ResourceExt_r16(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SetupRelease_PUCCH_Config_dl_DataToUL_ACK_r16_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SQN_NR_SetupRelease_PUCCH_Config_dl_DataToUL_ACK_r16_Value* p, enum SQN_NR_SetupRelease_PUCCH_Config_dl_DataToUL_ACK_r16_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SetupRelease_PUCCH_Config_dl_DataToUL_ACK_r16_release) {
		HTON_8(&_buffer[*_lidx], p->release, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SetupRelease_PUCCH_Config_dl_DataToUL_ACK_r16_setup) {
		HTON_32(&_buffer[*_lidx], p->setup.d, _lidx);
		for (size_t i2 = 0; i2 < p->setup.d; i2++) {
			HTON_8(&_buffer[*_lidx], p->setup.v[i2], _lidx);
		}
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncSQN_NR_SetupRelease_PUCCH_Config_dl_DataToUL_ACK_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SetupRelease_PUCCH_Config_dl_DataToUL_ACK_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_SetupRelease_PUCCH_Config_dl_DataToUL_ACK_r16_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SetupRelease_PUCCH_Config_dl_DataToUL_ACK_r16_SQN_NR_PUCCH_Config_dl_DataToUL_ACK_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SetupRelease_PUCCH_Config_dl_DataToUL_ACK_r16_SQN_NR_PUCCH_Config_dl_DataToUL_ACK_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_SetupRelease_PUCCH_Config_dl_DataToUL_ACK_r16(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SetupRelease_PUCCH_Config_ul_AccessConfigListDCI_1_1_r16_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SQN_NR_SetupRelease_PUCCH_Config_ul_AccessConfigListDCI_1_1_r16_Value* p, enum SQN_NR_SetupRelease_PUCCH_Config_ul_AccessConfigListDCI_1_1_r16_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SetupRelease_PUCCH_Config_ul_AccessConfigListDCI_1_1_r16_release) {
		HTON_8(&_buffer[*_lidx], p->release, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SetupRelease_PUCCH_Config_ul_AccessConfigListDCI_1_1_r16_setup) {
		HTON_32(&_buffer[*_lidx], p->setup.d, _lidx);
		for (size_t i2 = 0; i2 < p->setup.d; i2++) {
			HTON_8(&_buffer[*_lidx], p->setup.v[i2], _lidx);
		}
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncSQN_NR_SetupRelease_PUCCH_Config_ul_AccessConfigListDCI_1_1_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SetupRelease_PUCCH_Config_ul_AccessConfigListDCI_1_1_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_SetupRelease_PUCCH_Config_ul_AccessConfigListDCI_1_1_r16_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SetupRelease_PUCCH_Config_ul_AccessConfigListDCI_1_1_r16_SQN_NR_PUCCH_Config_ul_AccessConfigListDCI_1_1_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SetupRelease_PUCCH_Config_ul_AccessConfigListDCI_1_1_r16_SQN_NR_PUCCH_Config_ul_AccessConfigListDCI_1_1_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_SetupRelease_PUCCH_Config_ul_AccessConfigListDCI_1_1_r16(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PUCCH_Config_subslotLengthForPUCCH_r16_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SQN_NR_PUCCH_Config_subslotLengthForPUCCH_r16_Value* p, enum SQN_NR_PUCCH_Config_subslotLengthForPUCCH_r16_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_PUCCH_Config_subslotLengthForPUCCH_r16_normalCP_r16) {
		{
			size_t _tmp = (size_t)p->normalCP_r16;
			HTON_32(&_buffer[*_lidx], _tmp, _lidx);
		}
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_PUCCH_Config_subslotLengthForPUCCH_r16_extendedCP_r16) {
		{
			size_t _tmp = (size_t)p->extendedCP_r16;
			HTON_32(&_buffer[*_lidx], _tmp, _lidx);
		}
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncSQN_NR_PUCCH_Config_subslotLengthForPUCCH_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PUCCH_Config_subslotLengthForPUCCH_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_PUCCH_Config_subslotLengthForPUCCH_r16_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PUCCH_Config_subslotLengthForPUCCH_r16_subslotLengthForPUCCH_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PUCCH_Config_subslotLengthForPUCCH_r16_subslotLengthForPUCCH_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_PUCCH_Config_subslotLengthForPUCCH_r16(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SetupRelease_PUCCH_Config_dl_DataToUL_ACK_DCI_1_2_r16_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SQN_NR_SetupRelease_PUCCH_Config_dl_DataToUL_ACK_DCI_1_2_r16_Value* p, enum SQN_NR_SetupRelease_PUCCH_Config_dl_DataToUL_ACK_DCI_1_2_r16_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SetupRelease_PUCCH_Config_dl_DataToUL_ACK_DCI_1_2_r16_release) {
		HTON_8(&_buffer[*_lidx], p->release, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SetupRelease_PUCCH_Config_dl_DataToUL_ACK_DCI_1_2_r16_setup) {
		HTON_32(&_buffer[*_lidx], p->setup.d, _lidx);
		for (size_t i2 = 0; i2 < p->setup.d; i2++) {
			HTON_8(&_buffer[*_lidx], p->setup.v[i2], _lidx);
		}
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncSQN_NR_SetupRelease_PUCCH_Config_dl_DataToUL_ACK_DCI_1_2_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SetupRelease_PUCCH_Config_dl_DataToUL_ACK_DCI_1_2_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_SetupRelease_PUCCH_Config_dl_DataToUL_ACK_DCI_1_2_r16_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SetupRelease_PUCCH_Config_dl_DataToUL_ACK_DCI_1_2_r16_SQN_NR_PUCCH_Config_dl_DataToUL_ACK_DCI_1_2_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SetupRelease_PUCCH_Config_dl_DataToUL_ACK_DCI_1_2_r16_SQN_NR_PUCCH_Config_dl_DataToUL_ACK_DCI_1_2_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_SetupRelease_PUCCH_Config_dl_DataToUL_ACK_DCI_1_2_r16(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncUint8_t_SQN_NR_PUCCH_Config_numberOfBitsForPUCCH_ResourceIndicatorDCI_1_2_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint8_t_SQN_NR_PUCCH_Config_numberOfBitsForPUCCH_ResourceIndicatorDCI_1_2_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PUCCH_Config_dmrs_UplinkTransformPrecodingPUCCH_r16_e_dmrs_UplinkTransformPrecodingPUCCH_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PUCCH_Config_dmrs_UplinkTransformPrecodingPUCCH_r16_e_dmrs_UplinkTransformPrecodingPUCCH_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PUCCH_SpatialRelationInfo_SQN_NR_PUCCH_Config_spatialRelationInfoToAddModList2_r16_DynamicOptional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PUCCH_SpatialRelationInfo_SQN_NR_PUCCH_Config_spatialRelationInfoToAddModList2_r16_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serNrSysEncSQN_NR_PUCCH_SpatialRelationInfo(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PUCCH_SpatialRelationInfoId_SQN_NR_PUCCH_Config_spatialRelationInfoToReleaseList2_r16_DynamicOptional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PUCCH_SpatialRelationInfoId_SQN_NR_PUCCH_Config_spatialRelationInfoToReleaseList2_r16_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		HTON_8(&_buffer[*_lidx], p->v.v[i2], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PUCCH_SpatialRelationInfoId_v1610_SQN_NR_PUCCH_SpatialRelationInfoExt_r16_pucch_SpatialRelationInfoId_v1610_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PUCCH_SpatialRelationInfoId_v1610_SQN_NR_PUCCH_SpatialRelationInfoExt_r16_pucch_SpatialRelationInfoId_v1610_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PUCCH_PathlossReferenceRS_Id_v1610_SQN_NR_PUCCH_SpatialRelationInfoExt_r16_pucch_PathlossReferenceRS_Id_v1610_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PUCCH_PathlossReferenceRS_Id_v1610_SQN_NR_PUCCH_SpatialRelationInfoExt_r16_pucch_PathlossReferenceRS_Id_v1610_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PUCCH_SpatialRelationInfoExt_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PUCCH_SpatialRelationInfoExt_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncSQN_NR_PUCCH_SpatialRelationInfoId_v1610_SQN_NR_PUCCH_SpatialRelationInfoExt_r16_pucch_SpatialRelationInfoId_v1610_Optional(_buffer, _size, _lidx, &p->pucch_SpatialRelationInfoId_v1610);
	_serNrSysEncSQN_NR_PUCCH_PathlossReferenceRS_Id_v1610_SQN_NR_PUCCH_SpatialRelationInfoExt_r16_pucch_PathlossReferenceRS_Id_v1610_Optional(_buffer, _size, _lidx, &p->pucch_PathlossReferenceRS_Id_v1610);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PUCCH_SpatialRelationInfoExt_r16_SQN_NR_PUCCH_Config_spatialRelationInfoToAddModListExt_r16_DynamicOptional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PUCCH_SpatialRelationInfoExt_r16_SQN_NR_PUCCH_Config_spatialRelationInfoToAddModListExt_r16_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serNrSysEncSQN_NR_PUCCH_SpatialRelationInfoExt_r16(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PUCCH_SpatialRelationInfoId_r16_SQN_NR_PUCCH_Config_spatialRelationInfoToReleaseList_r16_DynamicOptional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PUCCH_SpatialRelationInfoId_r16_SQN_NR_PUCCH_Config_spatialRelationInfoToReleaseList_r16_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		HTON_8(&_buffer[*_lidx], p->v.v[i2], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PUCCH_ResourceGroup_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PUCCH_ResourceGroup_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->pucch_ResourceGroupId_r16, _lidx);
	HTON_32(&_buffer[*_lidx], p->resourcePerGroupList_r16.d, _lidx);
	for (size_t i3 = 0; i3 < p->resourcePerGroupList_r16.d; i3++) {
		HTON_8(&_buffer[*_lidx], p->resourcePerGroupList_r16.v[i3], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PUCCH_ResourceGroup_r16_SQN_NR_PUCCH_Config_resourceGroupToAddModList_r16_DynamicOptional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PUCCH_ResourceGroup_r16_SQN_NR_PUCCH_Config_resourceGroupToAddModList_r16_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serNrSysEncSQN_NR_PUCCH_ResourceGroup_r16(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PUCCH_ResourceGroupId_r16_SQN_NR_PUCCH_Config_resourceGroupToReleaseList_r16_DynamicOptional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PUCCH_ResourceGroupId_r16_SQN_NR_PUCCH_Config_resourceGroupToReleaseList_r16_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		HTON_8(&_buffer[*_lidx], p->v.v[i2], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncUint16_t_SQN_NR_SPS_PUCCH_AN_r16_maxPayloadSize_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint16_t_SQN_NR_SPS_PUCCH_AN_r16_maxPayloadSize_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_16(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SPS_PUCCH_AN_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SPS_PUCCH_AN_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->sps_PUCCH_AN_ResourceID_r16, _lidx);
	_serNrSysEncUint16_t_SQN_NR_SPS_PUCCH_AN_r16_maxPayloadSize_r16_Optional(_buffer, _size, _lidx, &p->maxPayloadSize_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SetupRelease_PUCCH_Config_sps_PUCCH_AN_List_r16_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SQN_NR_SetupRelease_PUCCH_Config_sps_PUCCH_AN_List_r16_Value* p, enum SQN_NR_SetupRelease_PUCCH_Config_sps_PUCCH_AN_List_r16_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SetupRelease_PUCCH_Config_sps_PUCCH_AN_List_r16_release) {
		HTON_8(&_buffer[*_lidx], p->release, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SetupRelease_PUCCH_Config_sps_PUCCH_AN_List_r16_setup) {
		HTON_32(&_buffer[*_lidx], p->setup.d, _lidx);
		for (size_t i2 = 0; i2 < p->setup.d; i2++) {
			_serNrSysEncSQN_NR_SPS_PUCCH_AN_r16(_buffer, _size, _lidx, &p->setup.v[i2]);
		}
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncSQN_NR_SetupRelease_PUCCH_Config_sps_PUCCH_AN_List_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SetupRelease_PUCCH_Config_sps_PUCCH_AN_List_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_SetupRelease_PUCCH_Config_sps_PUCCH_AN_List_r16_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SetupRelease_PUCCH_Config_sps_PUCCH_AN_List_r16_SQN_NR_PUCCH_Config_sps_PUCCH_AN_List_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SetupRelease_PUCCH_Config_sps_PUCCH_AN_List_r16_SQN_NR_PUCCH_Config_sps_PUCCH_AN_List_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_SetupRelease_PUCCH_Config_sps_PUCCH_AN_List_r16(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SchedulingRequestResourceConfig_v1610_phy_PriorityIndex_r16_e_phy_PriorityIndex_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SchedulingRequestResourceConfig_v1610_phy_PriorityIndex_r16_e_phy_PriorityIndex_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SchedulingRequestResourceConfig_v1610(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SchedulingRequestResourceConfig_v1610* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncSQN_NR_SchedulingRequestResourceConfig_v1610_phy_PriorityIndex_r16_e_phy_PriorityIndex_r16_Optional(_buffer, _size, _lidx, &p->phy_PriorityIndex_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SchedulingRequestResourceConfig_v1610_SQN_NR_PUCCH_Config_schedulingRequestResourceToAddModList_v1610_DynamicOptional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SchedulingRequestResourceConfig_v1610_SQN_NR_PUCCH_Config_schedulingRequestResourceToAddModList_v1610_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serNrSysEncSQN_NR_SchedulingRequestResourceConfig_v1610(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PUCCH_Config(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PUCCH_Config* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncSQN_NR_PUCCH_ResourceSet_SQN_NR_PUCCH_Config_resourceSetToAddModList_DynamicOptional(_buffer, _size, _lidx, &p->resourceSetToAddModList);
	_serNrSysEncSQN_NR_PUCCH_ResourceSetId_SQN_NR_PUCCH_Config_resourceSetToReleaseList_DynamicOptional(_buffer, _size, _lidx, &p->resourceSetToReleaseList);
	_serNrSysEncSQN_NR_PUCCH_Resource_SQN_NR_PUCCH_Config_resourceToAddModList_DynamicOptional(_buffer, _size, _lidx, &p->resourceToAddModList);
	_serNrSysEncSQN_NR_PUCCH_ResourceId_SQN_NR_PUCCH_Config_resourceToReleaseList_DynamicOptional(_buffer, _size, _lidx, &p->resourceToReleaseList);
	_serNrSysEncSQN_NR_SetupRelease_PUCCH_Config_format1_SQN_NR_PUCCH_Config_format1_Optional(_buffer, _size, _lidx, &p->format1);
	_serNrSysEncSQN_NR_SetupRelease_PUCCH_Config_format2_SQN_NR_PUCCH_Config_format2_Optional(_buffer, _size, _lidx, &p->format2);
	_serNrSysEncSQN_NR_SetupRelease_PUCCH_Config_format3_SQN_NR_PUCCH_Config_format3_Optional(_buffer, _size, _lidx, &p->format3);
	_serNrSysEncSQN_NR_SetupRelease_PUCCH_Config_format4_SQN_NR_PUCCH_Config_format4_Optional(_buffer, _size, _lidx, &p->format4);
	_serNrSysEncSQN_NR_SchedulingRequestResourceConfig_SQN_NR_PUCCH_Config_schedulingRequestResourceToAddModList_DynamicOptional(_buffer, _size, _lidx, &p->schedulingRequestResourceToAddModList);
	_serNrSysEncSQN_NR_SchedulingRequestResourceId_SQN_NR_PUCCH_Config_schedulingRequestResourceToReleaseList_DynamicOptional(_buffer, _size, _lidx, &p->schedulingRequestResourceToReleaseList);
	_serNrSysEncSQN_NR_PUCCH_ResourceId_SQN_NR_PUCCH_Config_multi_CSI_PUCCH_ResourceList_DynamicOptional(_buffer, _size, _lidx, &p->multi_CSI_PUCCH_ResourceList);
	_serNrSysEncUint8_t_SQN_NR_PUCCH_Config_dl_DataToUL_ACK_DynamicOptional(_buffer, _size, _lidx, &p->dl_DataToUL_ACK);
	_serNrSysEncSQN_NR_PUCCH_SpatialRelationInfo_SQN_NR_PUCCH_Config_spatialRelationInfoToAddModList_DynamicOptional(_buffer, _size, _lidx, &p->spatialRelationInfoToAddModList);
	_serNrSysEncSQN_NR_PUCCH_SpatialRelationInfoId_SQN_NR_PUCCH_Config_spatialRelationInfoToReleaseList_DynamicOptional(_buffer, _size, _lidx, &p->spatialRelationInfoToReleaseList);
	_serNrSysEncSQN_NR_PUCCH_PowerControl_SQN_NR_PUCCH_Config_pucch_PowerControl_Optional(_buffer, _size, _lidx, &p->pucch_PowerControl);
	_serNrSysEncSQN_NR_PUCCH_ResourceExt_r16_SQN_NR_PUCCH_Config_resourceToAddModListExt_r16_DynamicOptional(_buffer, _size, _lidx, &p->resourceToAddModListExt_r16);
	_serNrSysEncSQN_NR_SetupRelease_PUCCH_Config_dl_DataToUL_ACK_r16_SQN_NR_PUCCH_Config_dl_DataToUL_ACK_r16_Optional(_buffer, _size, _lidx, &p->dl_DataToUL_ACK_r16);
	_serNrSysEncSQN_NR_SetupRelease_PUCCH_Config_ul_AccessConfigListDCI_1_1_r16_SQN_NR_PUCCH_Config_ul_AccessConfigListDCI_1_1_r16_Optional(_buffer, _size, _lidx, &p->ul_AccessConfigListDCI_1_1_r16);
	_serNrSysEncSQN_NR_PUCCH_Config_subslotLengthForPUCCH_r16_subslotLengthForPUCCH_r16_Optional(_buffer, _size, _lidx, &p->subslotLengthForPUCCH_r16);
	_serNrSysEncSQN_NR_SetupRelease_PUCCH_Config_dl_DataToUL_ACK_DCI_1_2_r16_SQN_NR_PUCCH_Config_dl_DataToUL_ACK_DCI_1_2_r16_Optional(_buffer, _size, _lidx, &p->dl_DataToUL_ACK_DCI_1_2_r16);
	_serNrSysEncUint8_t_SQN_NR_PUCCH_Config_numberOfBitsForPUCCH_ResourceIndicatorDCI_1_2_r16_Optional(_buffer, _size, _lidx, &p->numberOfBitsForPUCCH_ResourceIndicatorDCI_1_2_r16);
	_serNrSysEncSQN_NR_PUCCH_Config_dmrs_UplinkTransformPrecodingPUCCH_r16_e_dmrs_UplinkTransformPrecodingPUCCH_r16_Optional(_buffer, _size, _lidx, &p->dmrs_UplinkTransformPrecodingPUCCH_r16);
	_serNrSysEncSQN_NR_PUCCH_SpatialRelationInfo_SQN_NR_PUCCH_Config_spatialRelationInfoToAddModList2_r16_DynamicOptional(_buffer, _size, _lidx, &p->spatialRelationInfoToAddModList2_r16);
	_serNrSysEncSQN_NR_PUCCH_SpatialRelationInfoId_SQN_NR_PUCCH_Config_spatialRelationInfoToReleaseList2_r16_DynamicOptional(_buffer, _size, _lidx, &p->spatialRelationInfoToReleaseList2_r16);
	_serNrSysEncSQN_NR_PUCCH_SpatialRelationInfoExt_r16_SQN_NR_PUCCH_Config_spatialRelationInfoToAddModListExt_r16_DynamicOptional(_buffer, _size, _lidx, &p->spatialRelationInfoToAddModListExt_r16);
	_serNrSysEncSQN_NR_PUCCH_SpatialRelationInfoId_r16_SQN_NR_PUCCH_Config_spatialRelationInfoToReleaseList_r16_DynamicOptional(_buffer, _size, _lidx, &p->spatialRelationInfoToReleaseList_r16);
	_serNrSysEncSQN_NR_PUCCH_ResourceGroup_r16_SQN_NR_PUCCH_Config_resourceGroupToAddModList_r16_DynamicOptional(_buffer, _size, _lidx, &p->resourceGroupToAddModList_r16);
	_serNrSysEncSQN_NR_PUCCH_ResourceGroupId_r16_SQN_NR_PUCCH_Config_resourceGroupToReleaseList_r16_DynamicOptional(_buffer, _size, _lidx, &p->resourceGroupToReleaseList_r16);
	_serNrSysEncSQN_NR_SetupRelease_PUCCH_Config_sps_PUCCH_AN_List_r16_SQN_NR_PUCCH_Config_sps_PUCCH_AN_List_r16_Optional(_buffer, _size, _lidx, &p->sps_PUCCH_AN_List_r16);
	_serNrSysEncSQN_NR_SchedulingRequestResourceConfig_v1610_SQN_NR_PUCCH_Config_schedulingRequestResourceToAddModList_v1610_DynamicOptional(_buffer, _size, _lidx, &p->schedulingRequestResourceToAddModList_v1610);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SetupRelease_BWP_UplinkDedicated_pucch_Config_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SQN_NR_SetupRelease_BWP_UplinkDedicated_pucch_Config_Value* p, enum SQN_NR_SetupRelease_BWP_UplinkDedicated_pucch_Config_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SetupRelease_BWP_UplinkDedicated_pucch_Config_release) {
		HTON_8(&_buffer[*_lidx], p->release, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SetupRelease_BWP_UplinkDedicated_pucch_Config_setup) {
		_serNrSysEncSQN_NR_PUCCH_Config(_buffer, _size, _lidx, &p->setup);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncSQN_NR_SetupRelease_BWP_UplinkDedicated_pucch_Config(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SetupRelease_BWP_UplinkDedicated_pucch_Config* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_SetupRelease_BWP_UplinkDedicated_pucch_Config_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SetupRelease_BWP_UplinkDedicated_pucch_Config_SQN_NR_BWP_UplinkDedicated_pucch_Config_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SetupRelease_BWP_UplinkDedicated_pucch_Config_SQN_NR_BWP_UplinkDedicated_pucch_Config_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_SetupRelease_BWP_UplinkDedicated_pucch_Config(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncUint16_t_SQN_NR_PUSCH_Config_dataScramblingIdentityPUSCH_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint16_t_SQN_NR_PUSCH_Config_dataScramblingIdentityPUSCH_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_16(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PUSCH_Config_txConfig_e_txConfig_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PUSCH_Config_txConfig_e_txConfig_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_DMRS_UplinkConfig_dmrs_Type_e_dmrs_Type_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_DMRS_UplinkConfig_dmrs_Type_e_dmrs_Type_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_DMRS_UplinkConfig_dmrs_AdditionalPosition_e_dmrs_AdditionalPosition_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_DMRS_UplinkConfig_dmrs_AdditionalPosition_e_dmrs_AdditionalPosition_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncUint16_t_SQN_NR_PTRS_UplinkConfig_transformPrecoderDisabled_frequencyDensity_ArrayOptional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint16_t_SQN_NR_PTRS_UplinkConfig_transformPrecoderDisabled_frequencyDensity_ArrayOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	for (size_t i2 = 0; i2 < 2; i2++) {
		HTON_16(&_buffer[*_lidx], p->v[i2], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncUint8_t_SQN_NR_PTRS_UplinkConfig_transformPrecoderDisabled_timeDensity_ArrayOptional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint8_t_SQN_NR_PTRS_UplinkConfig_transformPrecoderDisabled_timeDensity_ArrayOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	for (size_t i2 = 0; i2 < 3; i2++) {
		HTON_8(&_buffer[*_lidx], p->v[i2], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PTRS_UplinkConfig_transformPrecoderDisabled_resourceElementOffset_e_resourceElementOffset_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PTRS_UplinkConfig_transformPrecoderDisabled_resourceElementOffset_e_resourceElementOffset_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PTRS_UplinkConfig_transformPrecoderDisabled(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PTRS_UplinkConfig_transformPrecoderDisabled* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncUint16_t_SQN_NR_PTRS_UplinkConfig_transformPrecoderDisabled_frequencyDensity_ArrayOptional(_buffer, _size, _lidx, &p->frequencyDensity);
	_serNrSysEncUint8_t_SQN_NR_PTRS_UplinkConfig_transformPrecoderDisabled_timeDensity_ArrayOptional(_buffer, _size, _lidx, &p->timeDensity);
	{
		size_t _tmp = (size_t)p->maxNrofPorts;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_PTRS_UplinkConfig_transformPrecoderDisabled_resourceElementOffset_e_resourceElementOffset_Optional(_buffer, _size, _lidx, &p->resourceElementOffset);
	{
		size_t _tmp = (size_t)p->ptrs_Power;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PTRS_UplinkConfig_transformPrecoderDisabled_transformPrecoderDisabled_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PTRS_UplinkConfig_transformPrecoderDisabled_transformPrecoderDisabled_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_PTRS_UplinkConfig_transformPrecoderDisabled(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PTRS_UplinkConfig_transformPrecoderEnabled_timeDensityTransformPrecoding_e_timeDensityTransformPrecoding_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PTRS_UplinkConfig_transformPrecoderEnabled_timeDensityTransformPrecoding_e_timeDensityTransformPrecoding_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PTRS_UplinkConfig_transformPrecoderEnabled(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PTRS_UplinkConfig_transformPrecoderEnabled* p)
{
	(void)_size; // TODO: generate boundaries checking

	for (size_t i2 = 0; i2 < 5; i2++) {
		HTON_16(&_buffer[*_lidx], p->sampleDensity[i2], _lidx);
	}
	_serNrSysEncSQN_NR_PTRS_UplinkConfig_transformPrecoderEnabled_timeDensityTransformPrecoding_e_timeDensityTransformPrecoding_Optional(_buffer, _size, _lidx, &p->timeDensityTransformPrecoding);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PTRS_UplinkConfig_transformPrecoderEnabled_transformPrecoderEnabled_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PTRS_UplinkConfig_transformPrecoderEnabled_transformPrecoderEnabled_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_PTRS_UplinkConfig_transformPrecoderEnabled(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PTRS_UplinkConfig(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PTRS_UplinkConfig* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncSQN_NR_PTRS_UplinkConfig_transformPrecoderDisabled_transformPrecoderDisabled_Optional(_buffer, _size, _lidx, &p->transformPrecoderDisabled);
	_serNrSysEncSQN_NR_PTRS_UplinkConfig_transformPrecoderEnabled_transformPrecoderEnabled_Optional(_buffer, _size, _lidx, &p->transformPrecoderEnabled);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SetupRelease_DMRS_UplinkConfig_phaseTrackingRS_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SQN_NR_SetupRelease_DMRS_UplinkConfig_phaseTrackingRS_Value* p, enum SQN_NR_SetupRelease_DMRS_UplinkConfig_phaseTrackingRS_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SetupRelease_DMRS_UplinkConfig_phaseTrackingRS_release) {
		HTON_8(&_buffer[*_lidx], p->release, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SetupRelease_DMRS_UplinkConfig_phaseTrackingRS_setup) {
		_serNrSysEncSQN_NR_PTRS_UplinkConfig(_buffer, _size, _lidx, &p->setup);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncSQN_NR_SetupRelease_DMRS_UplinkConfig_phaseTrackingRS(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SetupRelease_DMRS_UplinkConfig_phaseTrackingRS* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_SetupRelease_DMRS_UplinkConfig_phaseTrackingRS_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SetupRelease_DMRS_UplinkConfig_phaseTrackingRS_SQN_NR_DMRS_UplinkConfig_phaseTrackingRS_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SetupRelease_DMRS_UplinkConfig_phaseTrackingRS_SQN_NR_DMRS_UplinkConfig_phaseTrackingRS_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_SetupRelease_DMRS_UplinkConfig_phaseTrackingRS(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_DMRS_UplinkConfig_maxLength_e_maxLength_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_DMRS_UplinkConfig_maxLength_e_maxLength_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncUint16_t_SQN_NR_DMRS_UplinkConfig_transformPrecodingDisabled_scramblingID0_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint16_t_SQN_NR_DMRS_UplinkConfig_transformPrecodingDisabled_scramblingID0_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_16(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncUint16_t_SQN_NR_DMRS_UplinkConfig_transformPrecodingDisabled_scramblingID1_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint16_t_SQN_NR_DMRS_UplinkConfig_transformPrecodingDisabled_scramblingID1_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_16(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_DMRS_UplinkConfig_transformPrecodingDisabled_dmrs_Uplink_r16_e_dmrs_Uplink_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_DMRS_UplinkConfig_transformPrecodingDisabled_dmrs_Uplink_r16_e_dmrs_Uplink_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_DMRS_UplinkConfig_transformPrecodingDisabled(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_DMRS_UplinkConfig_transformPrecodingDisabled* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncUint16_t_SQN_NR_DMRS_UplinkConfig_transformPrecodingDisabled_scramblingID0_Optional(_buffer, _size, _lidx, &p->scramblingID0);
	_serNrSysEncUint16_t_SQN_NR_DMRS_UplinkConfig_transformPrecodingDisabled_scramblingID1_Optional(_buffer, _size, _lidx, &p->scramblingID1);
	_serNrSysEncSQN_NR_DMRS_UplinkConfig_transformPrecodingDisabled_dmrs_Uplink_r16_e_dmrs_Uplink_r16_Optional(_buffer, _size, _lidx, &p->dmrs_Uplink_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_DMRS_UplinkConfig_transformPrecodingDisabled_transformPrecodingDisabled_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_DMRS_UplinkConfig_transformPrecodingDisabled_transformPrecodingDisabled_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_DMRS_UplinkConfig_transformPrecodingDisabled(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncUint16_t_SQN_NR_DMRS_UplinkConfig_transformPrecodingEnabled_nPUSCH_Identity_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint16_t_SQN_NR_DMRS_UplinkConfig_transformPrecodingEnabled_nPUSCH_Identity_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_16(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_DMRS_UplinkConfig_transformPrecodingEnabled_sequenceGroupHopping_e_sequenceGroupHopping_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_DMRS_UplinkConfig_transformPrecodingEnabled_sequenceGroupHopping_e_sequenceGroupHopping_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_DMRS_UplinkConfig_transformPrecodingEnabled_sequenceHopping_e_sequenceHopping_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_DMRS_UplinkConfig_transformPrecodingEnabled_sequenceHopping_e_sequenceHopping_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncUint16_t_SQN_NR_DMRS_UplinkTransformPrecoding_r16_pi2BPSK_ScramblingID0_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint16_t_SQN_NR_DMRS_UplinkTransformPrecoding_r16_pi2BPSK_ScramblingID0_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_16(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncUint16_t_SQN_NR_DMRS_UplinkTransformPrecoding_r16_pi2BPSK_ScramblingID1_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint16_t_SQN_NR_DMRS_UplinkTransformPrecoding_r16_pi2BPSK_ScramblingID1_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_16(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_DMRS_UplinkTransformPrecoding_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_DMRS_UplinkTransformPrecoding_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncUint16_t_SQN_NR_DMRS_UplinkTransformPrecoding_r16_pi2BPSK_ScramblingID0_Optional(_buffer, _size, _lidx, &p->pi2BPSK_ScramblingID0);
	_serNrSysEncUint16_t_SQN_NR_DMRS_UplinkTransformPrecoding_r16_pi2BPSK_ScramblingID1_Optional(_buffer, _size, _lidx, &p->pi2BPSK_ScramblingID1);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SetupRelease_DMRS_UplinkConfig_transformPrecodingEnabled_dmrs_UplinkTransformPrecoding_r16_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SQN_NR_SetupRelease_DMRS_UplinkConfig_transformPrecodingEnabled_dmrs_UplinkTransformPrecoding_r16_Value* p, enum SQN_NR_SetupRelease_DMRS_UplinkConfig_transformPrecodingEnabled_dmrs_UplinkTransformPrecoding_r16_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SetupRelease_DMRS_UplinkConfig_transformPrecodingEnabled_dmrs_UplinkTransformPrecoding_r16_release) {
		HTON_8(&_buffer[*_lidx], p->release, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SetupRelease_DMRS_UplinkConfig_transformPrecodingEnabled_dmrs_UplinkTransformPrecoding_r16_setup) {
		_serNrSysEncSQN_NR_DMRS_UplinkTransformPrecoding_r16(_buffer, _size, _lidx, &p->setup);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncSQN_NR_SetupRelease_DMRS_UplinkConfig_transformPrecodingEnabled_dmrs_UplinkTransformPrecoding_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SetupRelease_DMRS_UplinkConfig_transformPrecodingEnabled_dmrs_UplinkTransformPrecoding_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_SetupRelease_DMRS_UplinkConfig_transformPrecodingEnabled_dmrs_UplinkTransformPrecoding_r16_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SetupRelease_DMRS_UplinkConfig_transformPrecodingEnabled_dmrs_UplinkTransformPrecoding_r16_SQN_NR_DMRS_UplinkConfig_transformPrecodingEnabled_dmrs_UplinkTransformPrecoding_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SetupRelease_DMRS_UplinkConfig_transformPrecodingEnabled_dmrs_UplinkTransformPrecoding_r16_SQN_NR_DMRS_UplinkConfig_transformPrecodingEnabled_dmrs_UplinkTransformPrecoding_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_SetupRelease_DMRS_UplinkConfig_transformPrecodingEnabled_dmrs_UplinkTransformPrecoding_r16(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_DMRS_UplinkConfig_transformPrecodingEnabled(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_DMRS_UplinkConfig_transformPrecodingEnabled* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncUint16_t_SQN_NR_DMRS_UplinkConfig_transformPrecodingEnabled_nPUSCH_Identity_Optional(_buffer, _size, _lidx, &p->nPUSCH_Identity);
	_serNrSysEncSQN_NR_DMRS_UplinkConfig_transformPrecodingEnabled_sequenceGroupHopping_e_sequenceGroupHopping_Optional(_buffer, _size, _lidx, &p->sequenceGroupHopping);
	_serNrSysEncSQN_NR_DMRS_UplinkConfig_transformPrecodingEnabled_sequenceHopping_e_sequenceHopping_Optional(_buffer, _size, _lidx, &p->sequenceHopping);
	_serNrSysEncSQN_NR_SetupRelease_DMRS_UplinkConfig_transformPrecodingEnabled_dmrs_UplinkTransformPrecoding_r16_SQN_NR_DMRS_UplinkConfig_transformPrecodingEnabled_dmrs_UplinkTransformPrecoding_r16_Optional(_buffer, _size, _lidx, &p->dmrs_UplinkTransformPrecoding_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_DMRS_UplinkConfig_transformPrecodingEnabled_transformPrecodingEnabled_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_DMRS_UplinkConfig_transformPrecodingEnabled_transformPrecodingEnabled_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_DMRS_UplinkConfig_transformPrecodingEnabled(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_DMRS_UplinkConfig(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_DMRS_UplinkConfig* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncSQN_NR_DMRS_UplinkConfig_dmrs_Type_e_dmrs_Type_Optional(_buffer, _size, _lidx, &p->dmrs_Type);
	_serNrSysEncSQN_NR_DMRS_UplinkConfig_dmrs_AdditionalPosition_e_dmrs_AdditionalPosition_Optional(_buffer, _size, _lidx, &p->dmrs_AdditionalPosition);
	_serNrSysEncSQN_NR_SetupRelease_DMRS_UplinkConfig_phaseTrackingRS_SQN_NR_DMRS_UplinkConfig_phaseTrackingRS_Optional(_buffer, _size, _lidx, &p->phaseTrackingRS);
	_serNrSysEncSQN_NR_DMRS_UplinkConfig_maxLength_e_maxLength_Optional(_buffer, _size, _lidx, &p->maxLength);
	_serNrSysEncSQN_NR_DMRS_UplinkConfig_transformPrecodingDisabled_transformPrecodingDisabled_Optional(_buffer, _size, _lidx, &p->transformPrecodingDisabled);
	_serNrSysEncSQN_NR_DMRS_UplinkConfig_transformPrecodingEnabled_transformPrecodingEnabled_Optional(_buffer, _size, _lidx, &p->transformPrecodingEnabled);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SetupRelease_PUSCH_Config_dmrs_UplinkForPUSCH_MappingTypeA_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SQN_NR_SetupRelease_PUSCH_Config_dmrs_UplinkForPUSCH_MappingTypeA_Value* p, enum SQN_NR_SetupRelease_PUSCH_Config_dmrs_UplinkForPUSCH_MappingTypeA_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SetupRelease_PUSCH_Config_dmrs_UplinkForPUSCH_MappingTypeA_release) {
		HTON_8(&_buffer[*_lidx], p->release, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SetupRelease_PUSCH_Config_dmrs_UplinkForPUSCH_MappingTypeA_setup) {
		_serNrSysEncSQN_NR_DMRS_UplinkConfig(_buffer, _size, _lidx, &p->setup);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncSQN_NR_SetupRelease_PUSCH_Config_dmrs_UplinkForPUSCH_MappingTypeA(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SetupRelease_PUSCH_Config_dmrs_UplinkForPUSCH_MappingTypeA* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_SetupRelease_PUSCH_Config_dmrs_UplinkForPUSCH_MappingTypeA_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SetupRelease_PUSCH_Config_dmrs_UplinkForPUSCH_MappingTypeA_SQN_NR_PUSCH_Config_dmrs_UplinkForPUSCH_MappingTypeA_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SetupRelease_PUSCH_Config_dmrs_UplinkForPUSCH_MappingTypeA_SQN_NR_PUSCH_Config_dmrs_UplinkForPUSCH_MappingTypeA_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_SetupRelease_PUSCH_Config_dmrs_UplinkForPUSCH_MappingTypeA(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SetupRelease_PUSCH_Config_dmrs_UplinkForPUSCH_MappingTypeB_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SQN_NR_SetupRelease_PUSCH_Config_dmrs_UplinkForPUSCH_MappingTypeB_Value* p, enum SQN_NR_SetupRelease_PUSCH_Config_dmrs_UplinkForPUSCH_MappingTypeB_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SetupRelease_PUSCH_Config_dmrs_UplinkForPUSCH_MappingTypeB_release) {
		HTON_8(&_buffer[*_lidx], p->release, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SetupRelease_PUSCH_Config_dmrs_UplinkForPUSCH_MappingTypeB_setup) {
		_serNrSysEncSQN_NR_DMRS_UplinkConfig(_buffer, _size, _lidx, &p->setup);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncSQN_NR_SetupRelease_PUSCH_Config_dmrs_UplinkForPUSCH_MappingTypeB(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SetupRelease_PUSCH_Config_dmrs_UplinkForPUSCH_MappingTypeB* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_SetupRelease_PUSCH_Config_dmrs_UplinkForPUSCH_MappingTypeB_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SetupRelease_PUSCH_Config_dmrs_UplinkForPUSCH_MappingTypeB_SQN_NR_PUSCH_Config_dmrs_UplinkForPUSCH_MappingTypeB_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SetupRelease_PUSCH_Config_dmrs_UplinkForPUSCH_MappingTypeB_SQN_NR_PUSCH_Config_dmrs_UplinkForPUSCH_MappingTypeB_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_SetupRelease_PUSCH_Config_dmrs_UplinkForPUSCH_MappingTypeB(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PUSCH_PowerControl_tpc_Accumulation_e_tpc_Accumulation_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PUSCH_PowerControl_tpc_Accumulation_e_tpc_Accumulation_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_Alpha_e_SQN_NR_PUSCH_PowerControl_msg3_Alpha_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_Alpha_e_SQN_NR_PUSCH_PowerControl_msg3_Alpha_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncInt16_t_SQN_NR_PUSCH_PowerControl_p0_NominalWithoutGrant_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct int16_t_SQN_NR_PUSCH_PowerControl_p0_NominalWithoutGrant_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_16(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncInt8_t_SQN_NR_P0_PUSCH_AlphaSet_p0_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct int8_t_SQN_NR_P0_PUSCH_AlphaSet_p0_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_Alpha_e_SQN_NR_P0_PUSCH_AlphaSet_alpha_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_Alpha_e_SQN_NR_P0_PUSCH_AlphaSet_alpha_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_P0_PUSCH_AlphaSet(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_P0_PUSCH_AlphaSet* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->p0_PUSCH_AlphaSetId, _lidx);
	_serNrSysEncInt8_t_SQN_NR_P0_PUSCH_AlphaSet_p0_Optional(_buffer, _size, _lidx, &p->p0);
	_serNrSysEncSQN_NR_Alpha_e_SQN_NR_P0_PUSCH_AlphaSet_alpha_Optional(_buffer, _size, _lidx, &p->alpha);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_P0_PUSCH_AlphaSet_SQN_NR_PUSCH_PowerControl_p0_AlphaSets_DynamicOptional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_P0_PUSCH_AlphaSet_SQN_NR_PUSCH_PowerControl_p0_AlphaSets_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serNrSysEncSQN_NR_P0_PUSCH_AlphaSet(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PUSCH_PathlossReferenceRS_referenceSignal_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SQN_NR_PUSCH_PathlossReferenceRS_referenceSignal_Value* p, enum SQN_NR_PUSCH_PathlossReferenceRS_referenceSignal_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_PUSCH_PathlossReferenceRS_referenceSignal_ssb_Index) {
		HTON_8(&_buffer[*_lidx], p->ssb_Index, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_PUSCH_PathlossReferenceRS_referenceSignal_csi_RS_Index) {
		HTON_8(&_buffer[*_lidx], p->csi_RS_Index, _lidx);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncSQN_NR_PUSCH_PathlossReferenceRS_referenceSignal(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PUSCH_PathlossReferenceRS_referenceSignal* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_PUSCH_PathlossReferenceRS_referenceSignal_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PUSCH_PathlossReferenceRS(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PUSCH_PathlossReferenceRS* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->pusch_PathlossReferenceRS_Id, _lidx);
	_serNrSysEncSQN_NR_PUSCH_PathlossReferenceRS_referenceSignal(_buffer, _size, _lidx, &p->referenceSignal);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PUSCH_PathlossReferenceRS_SQN_NR_PUSCH_PowerControl_pathlossReferenceRSToAddModList_DynamicOptional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PUSCH_PathlossReferenceRS_SQN_NR_PUSCH_PowerControl_pathlossReferenceRSToAddModList_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serNrSysEncSQN_NR_PUSCH_PathlossReferenceRS(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PUSCH_PathlossReferenceRS_Id_SQN_NR_PUSCH_PowerControl_pathlossReferenceRSToReleaseList_DynamicOptional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PUSCH_PathlossReferenceRS_Id_SQN_NR_PUSCH_PowerControl_pathlossReferenceRSToReleaseList_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		HTON_8(&_buffer[*_lidx], p->v.v[i2], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PUSCH_PowerControl_twoPUSCH_PC_AdjustmentStates_e_twoPUSCH_PC_AdjustmentStates_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PUSCH_PowerControl_twoPUSCH_PC_AdjustmentStates_e_twoPUSCH_PC_AdjustmentStates_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PUSCH_PowerControl_deltaMCS_e_deltaMCS_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PUSCH_PowerControl_deltaMCS_e_deltaMCS_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SRI_PUSCH_PowerControl(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SRI_PUSCH_PowerControl* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->sri_PUSCH_PowerControlId, _lidx);
	HTON_8(&_buffer[*_lidx], p->sri_PUSCH_PathlossReferenceRS_Id, _lidx);
	HTON_8(&_buffer[*_lidx], p->sri_P0_PUSCH_AlphaSetId, _lidx);
	{
		size_t _tmp = (size_t)p->sri_PUSCH_ClosedLoopIndex;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SRI_PUSCH_PowerControl_SQN_NR_PUSCH_PowerControl_sri_PUSCH_MappingToAddModList_DynamicOptional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SRI_PUSCH_PowerControl_SQN_NR_PUSCH_PowerControl_sri_PUSCH_MappingToAddModList_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serNrSysEncSQN_NR_SRI_PUSCH_PowerControl(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SRI_PUSCH_PowerControlId_SQN_NR_PUSCH_PowerControl_sri_PUSCH_MappingToReleaseList_DynamicOptional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SRI_PUSCH_PowerControlId_SQN_NR_PUSCH_PowerControl_sri_PUSCH_MappingToReleaseList_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		HTON_8(&_buffer[*_lidx], p->v.v[i2], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PUSCH_PowerControl(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PUSCH_PowerControl* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncSQN_NR_PUSCH_PowerControl_tpc_Accumulation_e_tpc_Accumulation_Optional(_buffer, _size, _lidx, &p->tpc_Accumulation);
	_serNrSysEncSQN_NR_Alpha_e_SQN_NR_PUSCH_PowerControl_msg3_Alpha_Optional(_buffer, _size, _lidx, &p->msg3_Alpha);
	_serNrSysEncInt16_t_SQN_NR_PUSCH_PowerControl_p0_NominalWithoutGrant_Optional(_buffer, _size, _lidx, &p->p0_NominalWithoutGrant);
	_serNrSysEncSQN_NR_P0_PUSCH_AlphaSet_SQN_NR_PUSCH_PowerControl_p0_AlphaSets_DynamicOptional(_buffer, _size, _lidx, &p->p0_AlphaSets);
	_serNrSysEncSQN_NR_PUSCH_PathlossReferenceRS_SQN_NR_PUSCH_PowerControl_pathlossReferenceRSToAddModList_DynamicOptional(_buffer, _size, _lidx, &p->pathlossReferenceRSToAddModList);
	_serNrSysEncSQN_NR_PUSCH_PathlossReferenceRS_Id_SQN_NR_PUSCH_PowerControl_pathlossReferenceRSToReleaseList_DynamicOptional(_buffer, _size, _lidx, &p->pathlossReferenceRSToReleaseList);
	_serNrSysEncSQN_NR_PUSCH_PowerControl_twoPUSCH_PC_AdjustmentStates_e_twoPUSCH_PC_AdjustmentStates_Optional(_buffer, _size, _lidx, &p->twoPUSCH_PC_AdjustmentStates);
	_serNrSysEncSQN_NR_PUSCH_PowerControl_deltaMCS_e_deltaMCS_Optional(_buffer, _size, _lidx, &p->deltaMCS);
	_serNrSysEncSQN_NR_SRI_PUSCH_PowerControl_SQN_NR_PUSCH_PowerControl_sri_PUSCH_MappingToAddModList_DynamicOptional(_buffer, _size, _lidx, &p->sri_PUSCH_MappingToAddModList);
	_serNrSysEncSQN_NR_SRI_PUSCH_PowerControlId_SQN_NR_PUSCH_PowerControl_sri_PUSCH_MappingToReleaseList_DynamicOptional(_buffer, _size, _lidx, &p->sri_PUSCH_MappingToReleaseList);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PUSCH_PowerControl_SQN_NR_PUSCH_Config_pusch_PowerControl_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PUSCH_PowerControl_SQN_NR_PUSCH_Config_pusch_PowerControl_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_PUSCH_PowerControl(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PUSCH_Config_frequencyHopping_e_frequencyHopping_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PUSCH_Config_frequencyHopping_e_frequencyHopping_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncUint16_t_SQN_NR_PUSCH_Config_frequencyHoppingOffsetLists_DynamicOptional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint16_t_SQN_NR_PUSCH_Config_frequencyHoppingOffsetLists_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		HTON_16(&_buffer[*_lidx], p->v.v[i2], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SetupRelease_PUSCH_Config_pusch_TimeDomainAllocationList_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SQN_NR_SetupRelease_PUSCH_Config_pusch_TimeDomainAllocationList_Value* p, enum SQN_NR_SetupRelease_PUSCH_Config_pusch_TimeDomainAllocationList_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SetupRelease_PUSCH_Config_pusch_TimeDomainAllocationList_release) {
		HTON_8(&_buffer[*_lidx], p->release, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SetupRelease_PUSCH_Config_pusch_TimeDomainAllocationList_setup) {
		HTON_32(&_buffer[*_lidx], p->setup.d, _lidx);
		for (size_t i2 = 0; i2 < p->setup.d; i2++) {
			_serNrSysEncSQN_NR_PUSCH_TimeDomainResourceAllocation(_buffer, _size, _lidx, &p->setup.v[i2]);
		}
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncSQN_NR_SetupRelease_PUSCH_Config_pusch_TimeDomainAllocationList(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SetupRelease_PUSCH_Config_pusch_TimeDomainAllocationList* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_SetupRelease_PUSCH_Config_pusch_TimeDomainAllocationList_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SetupRelease_PUSCH_Config_pusch_TimeDomainAllocationList_SQN_NR_PUSCH_Config_pusch_TimeDomainAllocationList_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SetupRelease_PUSCH_Config_pusch_TimeDomainAllocationList_SQN_NR_PUSCH_Config_pusch_TimeDomainAllocationList_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_SetupRelease_PUSCH_Config_pusch_TimeDomainAllocationList(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PUSCH_Config_pusch_AggregationFactor_e_pusch_AggregationFactor_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PUSCH_Config_pusch_AggregationFactor_e_pusch_AggregationFactor_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PUSCH_Config_mcs_Table_e_mcs_Table_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PUSCH_Config_mcs_Table_e_mcs_Table_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PUSCH_Config_mcs_TableTransformPrecoder_e_mcs_TableTransformPrecoder_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PUSCH_Config_mcs_TableTransformPrecoder_e_mcs_TableTransformPrecoder_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PUSCH_Config_transformPrecoder_e_transformPrecoder_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PUSCH_Config_transformPrecoder_e_transformPrecoder_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PUSCH_Config_codebookSubset_e_codebookSubset_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PUSCH_Config_codebookSubset_e_codebookSubset_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncUint8_t_SQN_NR_PUSCH_Config_maxRank_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint8_t_SQN_NR_PUSCH_Config_maxRank_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PUSCH_Config_rbg_Size_e_rbg_Size_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PUSCH_Config_rbg_Size_e_rbg_Size_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncUint8_t_SQN_NR_BetaOffsets_betaOffsetACK_Index1_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint8_t_SQN_NR_BetaOffsets_betaOffsetACK_Index1_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncUint8_t_SQN_NR_BetaOffsets_betaOffsetACK_Index2_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint8_t_SQN_NR_BetaOffsets_betaOffsetACK_Index2_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncUint8_t_SQN_NR_BetaOffsets_betaOffsetACK_Index3_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint8_t_SQN_NR_BetaOffsets_betaOffsetACK_Index3_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncUint8_t_SQN_NR_BetaOffsets_betaOffsetCSI_Part1_Index1_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint8_t_SQN_NR_BetaOffsets_betaOffsetCSI_Part1_Index1_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncUint8_t_SQN_NR_BetaOffsets_betaOffsetCSI_Part1_Index2_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint8_t_SQN_NR_BetaOffsets_betaOffsetCSI_Part1_Index2_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncUint8_t_SQN_NR_BetaOffsets_betaOffsetCSI_Part2_Index1_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint8_t_SQN_NR_BetaOffsets_betaOffsetCSI_Part2_Index1_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncUint8_t_SQN_NR_BetaOffsets_betaOffsetCSI_Part2_Index2_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint8_t_SQN_NR_BetaOffsets_betaOffsetCSI_Part2_Index2_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_BetaOffsets(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_BetaOffsets* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncUint8_t_SQN_NR_BetaOffsets_betaOffsetACK_Index1_Optional(_buffer, _size, _lidx, &p->betaOffsetACK_Index1);
	_serNrSysEncUint8_t_SQN_NR_BetaOffsets_betaOffsetACK_Index2_Optional(_buffer, _size, _lidx, &p->betaOffsetACK_Index2);
	_serNrSysEncUint8_t_SQN_NR_BetaOffsets_betaOffsetACK_Index3_Optional(_buffer, _size, _lidx, &p->betaOffsetACK_Index3);
	_serNrSysEncUint8_t_SQN_NR_BetaOffsets_betaOffsetCSI_Part1_Index1_Optional(_buffer, _size, _lidx, &p->betaOffsetCSI_Part1_Index1);
	_serNrSysEncUint8_t_SQN_NR_BetaOffsets_betaOffsetCSI_Part1_Index2_Optional(_buffer, _size, _lidx, &p->betaOffsetCSI_Part1_Index2);
	_serNrSysEncUint8_t_SQN_NR_BetaOffsets_betaOffsetCSI_Part2_Index1_Optional(_buffer, _size, _lidx, &p->betaOffsetCSI_Part2_Index1);
	_serNrSysEncUint8_t_SQN_NR_BetaOffsets_betaOffsetCSI_Part2_Index2_Optional(_buffer, _size, _lidx, &p->betaOffsetCSI_Part2_Index2);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_UCI_OnPUSCH_betaOffsets_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SQN_NR_UCI_OnPUSCH_betaOffsets_Value* p, enum SQN_NR_UCI_OnPUSCH_betaOffsets_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_UCI_OnPUSCH_betaOffsets_dynamic) {
		for (size_t i2 = 0; i2 < 4; i2++) {
			_serNrSysEncSQN_NR_BetaOffsets(_buffer, _size, _lidx, &p->dynamic[i2]);
		}
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_UCI_OnPUSCH_betaOffsets_semiStatic) {
		_serNrSysEncSQN_NR_BetaOffsets(_buffer, _size, _lidx, &p->semiStatic);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncSQN_NR_UCI_OnPUSCH_betaOffsets(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_UCI_OnPUSCH_betaOffsets* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_UCI_OnPUSCH_betaOffsets_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_UCI_OnPUSCH_betaOffsets_betaOffsets_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_UCI_OnPUSCH_betaOffsets_betaOffsets_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_UCI_OnPUSCH_betaOffsets(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_UCI_OnPUSCH(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_UCI_OnPUSCH* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncSQN_NR_UCI_OnPUSCH_betaOffsets_betaOffsets_Optional(_buffer, _size, _lidx, &p->betaOffsets);
	{
		size_t _tmp = (size_t)p->scaling;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SetupRelease_PUSCH_Config_uci_OnPUSCH_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SQN_NR_SetupRelease_PUSCH_Config_uci_OnPUSCH_Value* p, enum SQN_NR_SetupRelease_PUSCH_Config_uci_OnPUSCH_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SetupRelease_PUSCH_Config_uci_OnPUSCH_release) {
		HTON_8(&_buffer[*_lidx], p->release, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SetupRelease_PUSCH_Config_uci_OnPUSCH_setup) {
		_serNrSysEncSQN_NR_UCI_OnPUSCH(_buffer, _size, _lidx, &p->setup);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncSQN_NR_SetupRelease_PUSCH_Config_uci_OnPUSCH(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SetupRelease_PUSCH_Config_uci_OnPUSCH* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_SetupRelease_PUSCH_Config_uci_OnPUSCH_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SetupRelease_PUSCH_Config_uci_OnPUSCH_SQN_NR_PUSCH_Config_uci_OnPUSCH_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SetupRelease_PUSCH_Config_uci_OnPUSCH_SQN_NR_PUSCH_Config_uci_OnPUSCH_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_SetupRelease_PUSCH_Config_uci_OnPUSCH(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PUSCH_Config_tp_pi2BPSK_e_tp_pi2BPSK_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PUSCH_Config_tp_pi2BPSK_e_tp_pi2BPSK_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SetupRelease_PUSCH_Config_minimumSchedulingOffsetK2_r16_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SQN_NR_SetupRelease_PUSCH_Config_minimumSchedulingOffsetK2_r16_Value* p, enum SQN_NR_SetupRelease_PUSCH_Config_minimumSchedulingOffsetK2_r16_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SetupRelease_PUSCH_Config_minimumSchedulingOffsetK2_r16_release) {
		HTON_8(&_buffer[*_lidx], p->release, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SetupRelease_PUSCH_Config_minimumSchedulingOffsetK2_r16_setup) {
		HTON_32(&_buffer[*_lidx], p->setup.d, _lidx);
		for (size_t i2 = 0; i2 < p->setup.d; i2++) {
			HTON_8(&_buffer[*_lidx], p->setup.v[i2], _lidx);
		}
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncSQN_NR_SetupRelease_PUSCH_Config_minimumSchedulingOffsetK2_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SetupRelease_PUSCH_Config_minimumSchedulingOffsetK2_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_SetupRelease_PUSCH_Config_minimumSchedulingOffsetK2_r16_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SetupRelease_PUSCH_Config_minimumSchedulingOffsetK2_r16_SQN_NR_PUSCH_Config_minimumSchedulingOffsetK2_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SetupRelease_PUSCH_Config_minimumSchedulingOffsetK2_r16_SQN_NR_PUSCH_Config_minimumSchedulingOffsetK2_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_SetupRelease_PUSCH_Config_minimumSchedulingOffsetK2_r16(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SetupRelease_PUSCH_Config_ul_AccessConfigListDCI_0_1_r16_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SQN_NR_SetupRelease_PUSCH_Config_ul_AccessConfigListDCI_0_1_r16_Value* p, enum SQN_NR_SetupRelease_PUSCH_Config_ul_AccessConfigListDCI_0_1_r16_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SetupRelease_PUSCH_Config_ul_AccessConfigListDCI_0_1_r16_release) {
		HTON_8(&_buffer[*_lidx], p->release, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SetupRelease_PUSCH_Config_ul_AccessConfigListDCI_0_1_r16_setup) {
		HTON_32(&_buffer[*_lidx], p->setup.d, _lidx);
		for (size_t i2 = 0; i2 < p->setup.d; i2++) {
			HTON_8(&_buffer[*_lidx], p->setup.v[i2], _lidx);
		}
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncSQN_NR_SetupRelease_PUSCH_Config_ul_AccessConfigListDCI_0_1_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SetupRelease_PUSCH_Config_ul_AccessConfigListDCI_0_1_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_SetupRelease_PUSCH_Config_ul_AccessConfigListDCI_0_1_r16_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SetupRelease_PUSCH_Config_ul_AccessConfigListDCI_0_1_r16_SQN_NR_PUSCH_Config_ul_AccessConfigListDCI_0_1_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SetupRelease_PUSCH_Config_ul_AccessConfigListDCI_0_1_r16_SQN_NR_PUSCH_Config_ul_AccessConfigListDCI_0_1_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_SetupRelease_PUSCH_Config_ul_AccessConfigListDCI_0_1_r16(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncUint8_t_SQN_NR_PUSCH_Config_harq_ProcessNumberSizeDCI_0_2_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint8_t_SQN_NR_PUSCH_Config_harq_ProcessNumberSizeDCI_0_2_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PUSCH_Config_dmrs_SequenceInitializationDCI_0_2_r16_e_dmrs_SequenceInitializationDCI_0_2_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PUSCH_Config_dmrs_SequenceInitializationDCI_0_2_r16_e_dmrs_SequenceInitializationDCI_0_2_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncUint8_t_SQN_NR_PUSCH_Config_numberOfBitsForRV_DCI_0_2_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint8_t_SQN_NR_PUSCH_Config_numberOfBitsForRV_DCI_0_2_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PUSCH_Config_antennaPortsFieldPresenceDCI_0_2_r16_e_antennaPortsFieldPresenceDCI_0_2_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PUSCH_Config_antennaPortsFieldPresenceDCI_0_2_r16_e_antennaPortsFieldPresenceDCI_0_2_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SetupRelease_PUSCH_Config_dmrs_UplinkForPUSCH_MappingTypeA_DCI_0_2_r16_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SQN_NR_SetupRelease_PUSCH_Config_dmrs_UplinkForPUSCH_MappingTypeA_DCI_0_2_r16_Value* p, enum SQN_NR_SetupRelease_PUSCH_Config_dmrs_UplinkForPUSCH_MappingTypeA_DCI_0_2_r16_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SetupRelease_PUSCH_Config_dmrs_UplinkForPUSCH_MappingTypeA_DCI_0_2_r16_release) {
		HTON_8(&_buffer[*_lidx], p->release, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SetupRelease_PUSCH_Config_dmrs_UplinkForPUSCH_MappingTypeA_DCI_0_2_r16_setup) {
		_serNrSysEncSQN_NR_DMRS_UplinkConfig(_buffer, _size, _lidx, &p->setup);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncSQN_NR_SetupRelease_PUSCH_Config_dmrs_UplinkForPUSCH_MappingTypeA_DCI_0_2_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SetupRelease_PUSCH_Config_dmrs_UplinkForPUSCH_MappingTypeA_DCI_0_2_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_SetupRelease_PUSCH_Config_dmrs_UplinkForPUSCH_MappingTypeA_DCI_0_2_r16_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SetupRelease_PUSCH_Config_dmrs_UplinkForPUSCH_MappingTypeA_DCI_0_2_r16_SQN_NR_PUSCH_Config_dmrs_UplinkForPUSCH_MappingTypeA_DCI_0_2_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SetupRelease_PUSCH_Config_dmrs_UplinkForPUSCH_MappingTypeA_DCI_0_2_r16_SQN_NR_PUSCH_Config_dmrs_UplinkForPUSCH_MappingTypeA_DCI_0_2_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_SetupRelease_PUSCH_Config_dmrs_UplinkForPUSCH_MappingTypeA_DCI_0_2_r16(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SetupRelease_PUSCH_Config_dmrs_UplinkForPUSCH_MappingTypeB_DCI_0_2_r16_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SQN_NR_SetupRelease_PUSCH_Config_dmrs_UplinkForPUSCH_MappingTypeB_DCI_0_2_r16_Value* p, enum SQN_NR_SetupRelease_PUSCH_Config_dmrs_UplinkForPUSCH_MappingTypeB_DCI_0_2_r16_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SetupRelease_PUSCH_Config_dmrs_UplinkForPUSCH_MappingTypeB_DCI_0_2_r16_release) {
		HTON_8(&_buffer[*_lidx], p->release, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SetupRelease_PUSCH_Config_dmrs_UplinkForPUSCH_MappingTypeB_DCI_0_2_r16_setup) {
		_serNrSysEncSQN_NR_DMRS_UplinkConfig(_buffer, _size, _lidx, &p->setup);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncSQN_NR_SetupRelease_PUSCH_Config_dmrs_UplinkForPUSCH_MappingTypeB_DCI_0_2_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SetupRelease_PUSCH_Config_dmrs_UplinkForPUSCH_MappingTypeB_DCI_0_2_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_SetupRelease_PUSCH_Config_dmrs_UplinkForPUSCH_MappingTypeB_DCI_0_2_r16_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SetupRelease_PUSCH_Config_dmrs_UplinkForPUSCH_MappingTypeB_DCI_0_2_r16_SQN_NR_PUSCH_Config_dmrs_UplinkForPUSCH_MappingTypeB_DCI_0_2_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SetupRelease_PUSCH_Config_dmrs_UplinkForPUSCH_MappingTypeB_DCI_0_2_r16_SQN_NR_PUSCH_Config_dmrs_UplinkForPUSCH_MappingTypeB_DCI_0_2_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_SetupRelease_PUSCH_Config_dmrs_UplinkForPUSCH_MappingTypeB_DCI_0_2_r16(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PUSCH_Config_frequencyHoppingDCI_0_2_r16_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SQN_NR_PUSCH_Config_frequencyHoppingDCI_0_2_r16_Value* p, enum SQN_NR_PUSCH_Config_frequencyHoppingDCI_0_2_r16_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_PUSCH_Config_frequencyHoppingDCI_0_2_r16_pusch_RepTypeA) {
		{
			size_t _tmp = (size_t)p->pusch_RepTypeA;
			HTON_32(&_buffer[*_lidx], _tmp, _lidx);
		}
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_PUSCH_Config_frequencyHoppingDCI_0_2_r16_pusch_RepTypeB) {
		{
			size_t _tmp = (size_t)p->pusch_RepTypeB;
			HTON_32(&_buffer[*_lidx], _tmp, _lidx);
		}
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncSQN_NR_PUSCH_Config_frequencyHoppingDCI_0_2_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PUSCH_Config_frequencyHoppingDCI_0_2_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_PUSCH_Config_frequencyHoppingDCI_0_2_r16_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PUSCH_Config_frequencyHoppingDCI_0_2_r16_frequencyHoppingDCI_0_2_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PUSCH_Config_frequencyHoppingDCI_0_2_r16_frequencyHoppingDCI_0_2_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_PUSCH_Config_frequencyHoppingDCI_0_2_r16(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SetupRelease_PUSCH_Config_frequencyHoppingOffsetListsDCI_0_2_r16_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SQN_NR_SetupRelease_PUSCH_Config_frequencyHoppingOffsetListsDCI_0_2_r16_Value* p, enum SQN_NR_SetupRelease_PUSCH_Config_frequencyHoppingOffsetListsDCI_0_2_r16_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SetupRelease_PUSCH_Config_frequencyHoppingOffsetListsDCI_0_2_r16_release) {
		HTON_8(&_buffer[*_lidx], p->release, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SetupRelease_PUSCH_Config_frequencyHoppingOffsetListsDCI_0_2_r16_setup) {
		HTON_32(&_buffer[*_lidx], p->setup.d, _lidx);
		for (size_t i2 = 0; i2 < p->setup.d; i2++) {
			HTON_16(&_buffer[*_lidx], p->setup.v[i2], _lidx);
		}
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncSQN_NR_SetupRelease_PUSCH_Config_frequencyHoppingOffsetListsDCI_0_2_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SetupRelease_PUSCH_Config_frequencyHoppingOffsetListsDCI_0_2_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_SetupRelease_PUSCH_Config_frequencyHoppingOffsetListsDCI_0_2_r16_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SetupRelease_PUSCH_Config_frequencyHoppingOffsetListsDCI_0_2_r16_SQN_NR_PUSCH_Config_frequencyHoppingOffsetListsDCI_0_2_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SetupRelease_PUSCH_Config_frequencyHoppingOffsetListsDCI_0_2_r16_SQN_NR_PUSCH_Config_frequencyHoppingOffsetListsDCI_0_2_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_SetupRelease_PUSCH_Config_frequencyHoppingOffsetListsDCI_0_2_r16(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PUSCH_Config_codebookSubsetDCI_0_2_r16_e_codebookSubsetDCI_0_2_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PUSCH_Config_codebookSubsetDCI_0_2_r16_e_codebookSubsetDCI_0_2_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PUSCH_Config_invalidSymbolPatternIndicatorDCI_0_2_r16_e_invalidSymbolPatternIndicatorDCI_0_2_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PUSCH_Config_invalidSymbolPatternIndicatorDCI_0_2_r16_e_invalidSymbolPatternIndicatorDCI_0_2_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncUint8_t_SQN_NR_PUSCH_Config_maxRankDCI_0_2_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint8_t_SQN_NR_PUSCH_Config_maxRankDCI_0_2_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PUSCH_Config_mcs_TableDCI_0_2_r16_e_mcs_TableDCI_0_2_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PUSCH_Config_mcs_TableDCI_0_2_r16_e_mcs_TableDCI_0_2_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PUSCH_Config_mcs_TableTransformPrecoderDCI_0_2_r16_e_mcs_TableTransformPrecoderDCI_0_2_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PUSCH_Config_mcs_TableTransformPrecoderDCI_0_2_r16_e_mcs_TableTransformPrecoderDCI_0_2_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PUSCH_Config_priorityIndicatorDCI_0_2_r16_e_priorityIndicatorDCI_0_2_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PUSCH_Config_priorityIndicatorDCI_0_2_r16_e_priorityIndicatorDCI_0_2_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PUSCH_Config_pusch_RepTypeIndicatorDCI_0_2_r16_e_pusch_RepTypeIndicatorDCI_0_2_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PUSCH_Config_pusch_RepTypeIndicatorDCI_0_2_r16_e_pusch_RepTypeIndicatorDCI_0_2_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PUSCH_Config_resourceAllocationDCI_0_2_r16_e_resourceAllocationDCI_0_2_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PUSCH_Config_resourceAllocationDCI_0_2_r16_e_resourceAllocationDCI_0_2_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PUSCH_Config_resourceAllocationType1GranularityDCI_0_2_r16_e_resourceAllocationType1GranularityDCI_0_2_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PUSCH_Config_resourceAllocationType1GranularityDCI_0_2_r16_e_resourceAllocationType1GranularityDCI_0_2_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_UCI_OnPUSCH_DCI_0_2_r16_betaOffsetsDCI_0_2_r16_dynamicDCI_0_2_r16_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SQN_NR_UCI_OnPUSCH_DCI_0_2_r16_betaOffsetsDCI_0_2_r16_dynamicDCI_0_2_r16_Value* p, enum SQN_NR_UCI_OnPUSCH_DCI_0_2_r16_betaOffsetsDCI_0_2_r16_dynamicDCI_0_2_r16_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_UCI_OnPUSCH_DCI_0_2_r16_betaOffsetsDCI_0_2_r16_dynamicDCI_0_2_r16_oneBit_r16) {
		for (size_t i3 = 0; i3 < 2; i3++) {
			_serNrSysEncSQN_NR_BetaOffsets(_buffer, _size, _lidx, &p->oneBit_r16[i3]);
		}
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_UCI_OnPUSCH_DCI_0_2_r16_betaOffsetsDCI_0_2_r16_dynamicDCI_0_2_r16_twoBits_r16) {
		for (size_t i3 = 0; i3 < 4; i3++) {
			_serNrSysEncSQN_NR_BetaOffsets(_buffer, _size, _lidx, &p->twoBits_r16[i3]);
		}
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncSQN_NR_UCI_OnPUSCH_DCI_0_2_r16_betaOffsetsDCI_0_2_r16_dynamicDCI_0_2_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_UCI_OnPUSCH_DCI_0_2_r16_betaOffsetsDCI_0_2_r16_dynamicDCI_0_2_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_UCI_OnPUSCH_DCI_0_2_r16_betaOffsetsDCI_0_2_r16_dynamicDCI_0_2_r16_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_UCI_OnPUSCH_DCI_0_2_r16_betaOffsetsDCI_0_2_r16_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SQN_NR_UCI_OnPUSCH_DCI_0_2_r16_betaOffsetsDCI_0_2_r16_Value* p, enum SQN_NR_UCI_OnPUSCH_DCI_0_2_r16_betaOffsetsDCI_0_2_r16_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_UCI_OnPUSCH_DCI_0_2_r16_betaOffsetsDCI_0_2_r16_dynamicDCI_0_2_r16) {
		_serNrSysEncSQN_NR_UCI_OnPUSCH_DCI_0_2_r16_betaOffsetsDCI_0_2_r16_dynamicDCI_0_2_r16(_buffer, _size, _lidx, &p->dynamicDCI_0_2_r16);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_UCI_OnPUSCH_DCI_0_2_r16_betaOffsetsDCI_0_2_r16_semiStaticDCI_0_2_r16) {
		_serNrSysEncSQN_NR_BetaOffsets(_buffer, _size, _lidx, &p->semiStaticDCI_0_2_r16);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncSQN_NR_UCI_OnPUSCH_DCI_0_2_r16_betaOffsetsDCI_0_2_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_UCI_OnPUSCH_DCI_0_2_r16_betaOffsetsDCI_0_2_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_UCI_OnPUSCH_DCI_0_2_r16_betaOffsetsDCI_0_2_r16_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_UCI_OnPUSCH_DCI_0_2_r16_betaOffsetsDCI_0_2_r16_betaOffsetsDCI_0_2_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_UCI_OnPUSCH_DCI_0_2_r16_betaOffsetsDCI_0_2_r16_betaOffsetsDCI_0_2_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_UCI_OnPUSCH_DCI_0_2_r16_betaOffsetsDCI_0_2_r16(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_UCI_OnPUSCH_DCI_0_2_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_UCI_OnPUSCH_DCI_0_2_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncSQN_NR_UCI_OnPUSCH_DCI_0_2_r16_betaOffsetsDCI_0_2_r16_betaOffsetsDCI_0_2_r16_Optional(_buffer, _size, _lidx, &p->betaOffsetsDCI_0_2_r16);
	{
		size_t _tmp = (size_t)p->scalingDCI_0_2_r16;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SetupRelease_PUSCH_Config_uci_OnPUSCH_ListDCI_0_2_r16_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SQN_NR_SetupRelease_PUSCH_Config_uci_OnPUSCH_ListDCI_0_2_r16_Value* p, enum SQN_NR_SetupRelease_PUSCH_Config_uci_OnPUSCH_ListDCI_0_2_r16_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SetupRelease_PUSCH_Config_uci_OnPUSCH_ListDCI_0_2_r16_release) {
		HTON_8(&_buffer[*_lidx], p->release, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SetupRelease_PUSCH_Config_uci_OnPUSCH_ListDCI_0_2_r16_setup) {
		HTON_32(&_buffer[*_lidx], p->setup.d, _lidx);
		for (size_t i2 = 0; i2 < p->setup.d; i2++) {
			_serNrSysEncSQN_NR_UCI_OnPUSCH_DCI_0_2_r16(_buffer, _size, _lidx, &p->setup.v[i2]);
		}
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncSQN_NR_SetupRelease_PUSCH_Config_uci_OnPUSCH_ListDCI_0_2_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SetupRelease_PUSCH_Config_uci_OnPUSCH_ListDCI_0_2_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_SetupRelease_PUSCH_Config_uci_OnPUSCH_ListDCI_0_2_r16_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SetupRelease_PUSCH_Config_uci_OnPUSCH_ListDCI_0_2_r16_SQN_NR_PUSCH_Config_uci_OnPUSCH_ListDCI_0_2_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SetupRelease_PUSCH_Config_uci_OnPUSCH_ListDCI_0_2_r16_SQN_NR_PUSCH_Config_uci_OnPUSCH_ListDCI_0_2_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_SetupRelease_PUSCH_Config_uci_OnPUSCH_ListDCI_0_2_r16(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncUint8_t_SQN_NR_PUSCH_TimeDomainResourceAllocation_r16_k2_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint8_t_SQN_NR_PUSCH_TimeDomainResourceAllocation_r16_k2_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PUSCH_Allocation_r16_mappingType_r16_e_mappingType_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PUSCH_Allocation_r16_mappingType_r16_e_mappingType_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncUint8_t_SQN_NR_PUSCH_Allocation_r16_startSymbolAndLength_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint8_t_SQN_NR_PUSCH_Allocation_r16_startSymbolAndLength_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncUint8_t_SQN_NR_PUSCH_Allocation_r16_startSymbol_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint8_t_SQN_NR_PUSCH_Allocation_r16_startSymbol_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncUint8_t_SQN_NR_PUSCH_Allocation_r16_length_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint8_t_SQN_NR_PUSCH_Allocation_r16_length_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PUSCH_Allocation_r16_numberOfRepetitions_r16_e_numberOfRepetitions_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PUSCH_Allocation_r16_numberOfRepetitions_r16_e_numberOfRepetitions_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PUSCH_Allocation_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PUSCH_Allocation_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncSQN_NR_PUSCH_Allocation_r16_mappingType_r16_e_mappingType_r16_Optional(_buffer, _size, _lidx, &p->mappingType_r16);
	_serNrSysEncUint8_t_SQN_NR_PUSCH_Allocation_r16_startSymbolAndLength_r16_Optional(_buffer, _size, _lidx, &p->startSymbolAndLength_r16);
	_serNrSysEncUint8_t_SQN_NR_PUSCH_Allocation_r16_startSymbol_r16_Optional(_buffer, _size, _lidx, &p->startSymbol_r16);
	_serNrSysEncUint8_t_SQN_NR_PUSCH_Allocation_r16_length_r16_Optional(_buffer, _size, _lidx, &p->length_r16);
	_serNrSysEncSQN_NR_PUSCH_Allocation_r16_numberOfRepetitions_r16_e_numberOfRepetitions_r16_Optional(_buffer, _size, _lidx, &p->numberOfRepetitions_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PUSCH_TimeDomainResourceAllocation_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PUSCH_TimeDomainResourceAllocation_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncUint8_t_SQN_NR_PUSCH_TimeDomainResourceAllocation_r16_k2_r16_Optional(_buffer, _size, _lidx, &p->k2_r16);
	HTON_32(&_buffer[*_lidx], p->puschAllocationList_r16.d, _lidx);
	for (size_t i3 = 0; i3 < p->puschAllocationList_r16.d; i3++) {
		_serNrSysEncSQN_NR_PUSCH_Allocation_r16(_buffer, _size, _lidx, &p->puschAllocationList_r16.v[i3]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SetupRelease_PUSCH_Config_pusch_TimeDomainAllocationListDCI_0_2_r16_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SQN_NR_SetupRelease_PUSCH_Config_pusch_TimeDomainAllocationListDCI_0_2_r16_Value* p, enum SQN_NR_SetupRelease_PUSCH_Config_pusch_TimeDomainAllocationListDCI_0_2_r16_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SetupRelease_PUSCH_Config_pusch_TimeDomainAllocationListDCI_0_2_r16_release) {
		HTON_8(&_buffer[*_lidx], p->release, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SetupRelease_PUSCH_Config_pusch_TimeDomainAllocationListDCI_0_2_r16_setup) {
		HTON_32(&_buffer[*_lidx], p->setup.d, _lidx);
		for (size_t i2 = 0; i2 < p->setup.d; i2++) {
			_serNrSysEncSQN_NR_PUSCH_TimeDomainResourceAllocation_r16(_buffer, _size, _lidx, &p->setup.v[i2]);
		}
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncSQN_NR_SetupRelease_PUSCH_Config_pusch_TimeDomainAllocationListDCI_0_2_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SetupRelease_PUSCH_Config_pusch_TimeDomainAllocationListDCI_0_2_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_SetupRelease_PUSCH_Config_pusch_TimeDomainAllocationListDCI_0_2_r16_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SetupRelease_PUSCH_Config_pusch_TimeDomainAllocationListDCI_0_2_r16_SQN_NR_PUSCH_Config_pusch_TimeDomainAllocationListDCI_0_2_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SetupRelease_PUSCH_Config_pusch_TimeDomainAllocationListDCI_0_2_r16_SQN_NR_PUSCH_Config_pusch_TimeDomainAllocationListDCI_0_2_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_SetupRelease_PUSCH_Config_pusch_TimeDomainAllocationListDCI_0_2_r16(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SetupRelease_PUSCH_Config_pusch_TimeDomainAllocationListDCI_0_1_r16_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SQN_NR_SetupRelease_PUSCH_Config_pusch_TimeDomainAllocationListDCI_0_1_r16_Value* p, enum SQN_NR_SetupRelease_PUSCH_Config_pusch_TimeDomainAllocationListDCI_0_1_r16_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SetupRelease_PUSCH_Config_pusch_TimeDomainAllocationListDCI_0_1_r16_release) {
		HTON_8(&_buffer[*_lidx], p->release, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SetupRelease_PUSCH_Config_pusch_TimeDomainAllocationListDCI_0_1_r16_setup) {
		HTON_32(&_buffer[*_lidx], p->setup.d, _lidx);
		for (size_t i2 = 0; i2 < p->setup.d; i2++) {
			_serNrSysEncSQN_NR_PUSCH_TimeDomainResourceAllocation_r16(_buffer, _size, _lidx, &p->setup.v[i2]);
		}
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncSQN_NR_SetupRelease_PUSCH_Config_pusch_TimeDomainAllocationListDCI_0_1_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SetupRelease_PUSCH_Config_pusch_TimeDomainAllocationListDCI_0_1_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_SetupRelease_PUSCH_Config_pusch_TimeDomainAllocationListDCI_0_1_r16_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SetupRelease_PUSCH_Config_pusch_TimeDomainAllocationListDCI_0_1_r16_SQN_NR_PUSCH_Config_pusch_TimeDomainAllocationListDCI_0_1_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SetupRelease_PUSCH_Config_pusch_TimeDomainAllocationListDCI_0_1_r16_SQN_NR_PUSCH_Config_pusch_TimeDomainAllocationListDCI_0_1_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_SetupRelease_PUSCH_Config_pusch_TimeDomainAllocationListDCI_0_1_r16(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PUSCH_Config_invalidSymbolPatternIndicatorDCI_0_1_r16_e_invalidSymbolPatternIndicatorDCI_0_1_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PUSCH_Config_invalidSymbolPatternIndicatorDCI_0_1_r16_e_invalidSymbolPatternIndicatorDCI_0_1_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PUSCH_Config_priorityIndicatorDCI_0_1_r16_e_priorityIndicatorDCI_0_1_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PUSCH_Config_priorityIndicatorDCI_0_1_r16_e_priorityIndicatorDCI_0_1_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PUSCH_Config_pusch_RepTypeIndicatorDCI_0_1_r16_e_pusch_RepTypeIndicatorDCI_0_1_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PUSCH_Config_pusch_RepTypeIndicatorDCI_0_1_r16_e_pusch_RepTypeIndicatorDCI_0_1_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PUSCH_Config_frequencyHoppingDCI_0_1_r16_e_frequencyHoppingDCI_0_1_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PUSCH_Config_frequencyHoppingDCI_0_1_r16_e_frequencyHoppingDCI_0_1_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SetupRelease_PUSCH_Config_uci_OnPUSCH_ListDCI_0_1_r16_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SQN_NR_SetupRelease_PUSCH_Config_uci_OnPUSCH_ListDCI_0_1_r16_Value* p, enum SQN_NR_SetupRelease_PUSCH_Config_uci_OnPUSCH_ListDCI_0_1_r16_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SetupRelease_PUSCH_Config_uci_OnPUSCH_ListDCI_0_1_r16_release) {
		HTON_8(&_buffer[*_lidx], p->release, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SetupRelease_PUSCH_Config_uci_OnPUSCH_ListDCI_0_1_r16_setup) {
		HTON_32(&_buffer[*_lidx], p->setup.d, _lidx);
		for (size_t i2 = 0; i2 < p->setup.d; i2++) {
			_serNrSysEncSQN_NR_UCI_OnPUSCH(_buffer, _size, _lidx, &p->setup.v[i2]);
		}
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncSQN_NR_SetupRelease_PUSCH_Config_uci_OnPUSCH_ListDCI_0_1_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SetupRelease_PUSCH_Config_uci_OnPUSCH_ListDCI_0_1_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_SetupRelease_PUSCH_Config_uci_OnPUSCH_ListDCI_0_1_r16_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SetupRelease_PUSCH_Config_uci_OnPUSCH_ListDCI_0_1_r16_SQN_NR_PUSCH_Config_uci_OnPUSCH_ListDCI_0_1_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SetupRelease_PUSCH_Config_uci_OnPUSCH_ListDCI_0_1_r16_SQN_NR_PUSCH_Config_uci_OnPUSCH_ListDCI_0_1_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_SetupRelease_PUSCH_Config_uci_OnPUSCH_ListDCI_0_1_r16(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_InvalidSymbolPattern_r16_symbols_r16_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SQN_NR_InvalidSymbolPattern_r16_symbols_r16_Value* p, enum SQN_NR_InvalidSymbolPattern_r16_symbols_r16_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_InvalidSymbolPattern_r16_symbols_r16_oneSlot) {
		for (size_t i2 = 0; i2 < 14; i2++) {
			HTON_8(&_buffer[*_lidx], p->oneSlot[i2], _lidx);
		}
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_InvalidSymbolPattern_r16_symbols_r16_twoSlots) {
		for (size_t i2 = 0; i2 < 28; i2++) {
			HTON_8(&_buffer[*_lidx], p->twoSlots[i2], _lidx);
		}
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncSQN_NR_InvalidSymbolPattern_r16_symbols_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_InvalidSymbolPattern_r16_symbols_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_InvalidSymbolPattern_r16_symbols_r16_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_InvalidSymbolPattern_r16_periodicityAndPattern_r16_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SQN_NR_InvalidSymbolPattern_r16_periodicityAndPattern_r16_Value* p, enum SQN_NR_InvalidSymbolPattern_r16_periodicityAndPattern_r16_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_InvalidSymbolPattern_r16_periodicityAndPattern_r16_n2) {
		for (size_t i2 = 0; i2 < 2; i2++) {
			HTON_8(&_buffer[*_lidx], p->n2[i2], _lidx);
		}
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_InvalidSymbolPattern_r16_periodicityAndPattern_r16_n4) {
		for (size_t i2 = 0; i2 < 4; i2++) {
			HTON_8(&_buffer[*_lidx], p->n4[i2], _lidx);
		}
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_InvalidSymbolPattern_r16_periodicityAndPattern_r16_n5) {
		for (size_t i2 = 0; i2 < 5; i2++) {
			HTON_8(&_buffer[*_lidx], p->n5[i2], _lidx);
		}
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_InvalidSymbolPattern_r16_periodicityAndPattern_r16_n8) {
		for (size_t i2 = 0; i2 < 8; i2++) {
			HTON_8(&_buffer[*_lidx], p->n8[i2], _lidx);
		}
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_InvalidSymbolPattern_r16_periodicityAndPattern_r16_n10) {
		for (size_t i2 = 0; i2 < 10; i2++) {
			HTON_8(&_buffer[*_lidx], p->n10[i2], _lidx);
		}
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_InvalidSymbolPattern_r16_periodicityAndPattern_r16_n20) {
		for (size_t i2 = 0; i2 < 20; i2++) {
			HTON_8(&_buffer[*_lidx], p->n20[i2], _lidx);
		}
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_InvalidSymbolPattern_r16_periodicityAndPattern_r16_n40) {
		for (size_t i2 = 0; i2 < 40; i2++) {
			HTON_8(&_buffer[*_lidx], p->n40[i2], _lidx);
		}
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncSQN_NR_InvalidSymbolPattern_r16_periodicityAndPattern_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_InvalidSymbolPattern_r16_periodicityAndPattern_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_InvalidSymbolPattern_r16_periodicityAndPattern_r16_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_InvalidSymbolPattern_r16_periodicityAndPattern_r16_periodicityAndPattern_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_InvalidSymbolPattern_r16_periodicityAndPattern_r16_periodicityAndPattern_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_InvalidSymbolPattern_r16_periodicityAndPattern_r16(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_InvalidSymbolPattern_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_InvalidSymbolPattern_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncSQN_NR_InvalidSymbolPattern_r16_symbols_r16(_buffer, _size, _lidx, &p->symbols_r16);
	_serNrSysEncSQN_NR_InvalidSymbolPattern_r16_periodicityAndPattern_r16_periodicityAndPattern_r16_Optional(_buffer, _size, _lidx, &p->periodicityAndPattern_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_InvalidSymbolPattern_r16_SQN_NR_PUSCH_Config_invalidSymbolPattern_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_InvalidSymbolPattern_r16_SQN_NR_PUSCH_Config_invalidSymbolPattern_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_InvalidSymbolPattern_r16(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PUSCH_PathlossReferenceRS_r16_referenceSignal_r16_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SQN_NR_PUSCH_PathlossReferenceRS_r16_referenceSignal_r16_Value* p, enum SQN_NR_PUSCH_PathlossReferenceRS_r16_referenceSignal_r16_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_PUSCH_PathlossReferenceRS_r16_referenceSignal_r16_ssb_Index_r16) {
		HTON_8(&_buffer[*_lidx], p->ssb_Index_r16, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_PUSCH_PathlossReferenceRS_r16_referenceSignal_r16_csi_RS_Index_r16) {
		HTON_8(&_buffer[*_lidx], p->csi_RS_Index_r16, _lidx);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncSQN_NR_PUSCH_PathlossReferenceRS_r16_referenceSignal_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PUSCH_PathlossReferenceRS_r16_referenceSignal_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_PUSCH_PathlossReferenceRS_r16_referenceSignal_r16_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PUSCH_PathlossReferenceRS_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PUSCH_PathlossReferenceRS_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->pusch_PathlossReferenceRS_Id_r16, _lidx);
	_serNrSysEncSQN_NR_PUSCH_PathlossReferenceRS_r16_referenceSignal_r16(_buffer, _size, _lidx, &p->referenceSignal_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PUSCH_PathlossReferenceRS_r16_SQN_NR_PUSCH_PowerControl_v1610_pathlossReferenceRSToAddModList2_r16_DynamicOptional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PUSCH_PathlossReferenceRS_r16_SQN_NR_PUSCH_PowerControl_v1610_pathlossReferenceRSToAddModList2_r16_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serNrSysEncSQN_NR_PUSCH_PathlossReferenceRS_r16(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PUSCH_PathlossReferenceRS_Id_v1610_SQN_NR_PUSCH_PowerControl_v1610_pathlossReferenceRSToReleaseList2_r16_DynamicOptional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PUSCH_PathlossReferenceRS_Id_v1610_SQN_NR_PUSCH_PowerControl_v1610_pathlossReferenceRSToReleaseList2_r16_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		HTON_8(&_buffer[*_lidx], p->v.v[i2], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_P0_PUSCH_r16_SQN_NR_P0_PUSCH_Set_r16_p0_List_r16_DynamicOptional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_P0_PUSCH_r16_SQN_NR_P0_PUSCH_Set_r16_p0_List_r16_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i3 = 0; i3 < p->v.d; i3++) {
		HTON_8(&_buffer[*_lidx], p->v.v[i3], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_P0_PUSCH_Set_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_P0_PUSCH_Set_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->p0_PUSCH_SetId_r16, _lidx);
	_serNrSysEncSQN_NR_P0_PUSCH_r16_SQN_NR_P0_PUSCH_Set_r16_p0_List_r16_DynamicOptional(_buffer, _size, _lidx, &p->p0_List_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_P0_PUSCH_Set_r16_SQN_NR_PUSCH_PowerControl_v1610_p0_PUSCH_SetList_r16_DynamicOptional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_P0_PUSCH_Set_r16_SQN_NR_PUSCH_PowerControl_v1610_p0_PUSCH_SetList_r16_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serNrSysEncSQN_NR_P0_PUSCH_Set_r16(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncUint8_t_SQN_NR_PUSCH_PowerControl_v1610_olpc_ParameterSet_olpc_ParameterSetDCI_0_1_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint8_t_SQN_NR_PUSCH_PowerControl_v1610_olpc_ParameterSet_olpc_ParameterSetDCI_0_1_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncUint8_t_SQN_NR_PUSCH_PowerControl_v1610_olpc_ParameterSet_olpc_ParameterSetDCI_0_2_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint8_t_SQN_NR_PUSCH_PowerControl_v1610_olpc_ParameterSet_olpc_ParameterSetDCI_0_2_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PUSCH_PowerControl_v1610_olpc_ParameterSet(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PUSCH_PowerControl_v1610_olpc_ParameterSet* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncUint8_t_SQN_NR_PUSCH_PowerControl_v1610_olpc_ParameterSet_olpc_ParameterSetDCI_0_1_r16_Optional(_buffer, _size, _lidx, &p->olpc_ParameterSetDCI_0_1_r16);
	_serNrSysEncUint8_t_SQN_NR_PUSCH_PowerControl_v1610_olpc_ParameterSet_olpc_ParameterSetDCI_0_2_r16_Optional(_buffer, _size, _lidx, &p->olpc_ParameterSetDCI_0_2_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PUSCH_PowerControl_v1610_olpc_ParameterSet_olpc_ParameterSet_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PUSCH_PowerControl_v1610_olpc_ParameterSet_olpc_ParameterSet_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_PUSCH_PowerControl_v1610_olpc_ParameterSet(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PUSCH_PowerControl_v1610(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PUSCH_PowerControl_v1610* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncSQN_NR_PUSCH_PathlossReferenceRS_r16_SQN_NR_PUSCH_PowerControl_v1610_pathlossReferenceRSToAddModList2_r16_DynamicOptional(_buffer, _size, _lidx, &p->pathlossReferenceRSToAddModList2_r16);
	_serNrSysEncSQN_NR_PUSCH_PathlossReferenceRS_Id_v1610_SQN_NR_PUSCH_PowerControl_v1610_pathlossReferenceRSToReleaseList2_r16_DynamicOptional(_buffer, _size, _lidx, &p->pathlossReferenceRSToReleaseList2_r16);
	_serNrSysEncSQN_NR_P0_PUSCH_Set_r16_SQN_NR_PUSCH_PowerControl_v1610_p0_PUSCH_SetList_r16_DynamicOptional(_buffer, _size, _lidx, &p->p0_PUSCH_SetList_r16);
	_serNrSysEncSQN_NR_PUSCH_PowerControl_v1610_olpc_ParameterSet_olpc_ParameterSet_Optional(_buffer, _size, _lidx, &p->olpc_ParameterSet);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SetupRelease_PUSCH_Config_pusch_PowerControl_v1610_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SQN_NR_SetupRelease_PUSCH_Config_pusch_PowerControl_v1610_Value* p, enum SQN_NR_SetupRelease_PUSCH_Config_pusch_PowerControl_v1610_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SetupRelease_PUSCH_Config_pusch_PowerControl_v1610_release) {
		HTON_8(&_buffer[*_lidx], p->release, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SetupRelease_PUSCH_Config_pusch_PowerControl_v1610_setup) {
		_serNrSysEncSQN_NR_PUSCH_PowerControl_v1610(_buffer, _size, _lidx, &p->setup);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncSQN_NR_SetupRelease_PUSCH_Config_pusch_PowerControl_v1610(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SetupRelease_PUSCH_Config_pusch_PowerControl_v1610* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_SetupRelease_PUSCH_Config_pusch_PowerControl_v1610_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SetupRelease_PUSCH_Config_pusch_PowerControl_v1610_SQN_NR_PUSCH_Config_pusch_PowerControl_v1610_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SetupRelease_PUSCH_Config_pusch_PowerControl_v1610_SQN_NR_PUSCH_Config_pusch_PowerControl_v1610_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_SetupRelease_PUSCH_Config_pusch_PowerControl_v1610(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PUSCH_Config_ul_FullPowerTransmission_r16_e_ul_FullPowerTransmission_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PUSCH_Config_ul_FullPowerTransmission_r16_e_ul_FullPowerTransmission_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SetupRelease_PUSCH_Config_pusch_TimeDomainAllocationListForMultiPUSCH_r16_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SQN_NR_SetupRelease_PUSCH_Config_pusch_TimeDomainAllocationListForMultiPUSCH_r16_Value* p, enum SQN_NR_SetupRelease_PUSCH_Config_pusch_TimeDomainAllocationListForMultiPUSCH_r16_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SetupRelease_PUSCH_Config_pusch_TimeDomainAllocationListForMultiPUSCH_r16_release) {
		HTON_8(&_buffer[*_lidx], p->release, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SetupRelease_PUSCH_Config_pusch_TimeDomainAllocationListForMultiPUSCH_r16_setup) {
		HTON_32(&_buffer[*_lidx], p->setup.d, _lidx);
		for (size_t i2 = 0; i2 < p->setup.d; i2++) {
			_serNrSysEncSQN_NR_PUSCH_TimeDomainResourceAllocation_r16(_buffer, _size, _lidx, &p->setup.v[i2]);
		}
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncSQN_NR_SetupRelease_PUSCH_Config_pusch_TimeDomainAllocationListForMultiPUSCH_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SetupRelease_PUSCH_Config_pusch_TimeDomainAllocationListForMultiPUSCH_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_SetupRelease_PUSCH_Config_pusch_TimeDomainAllocationListForMultiPUSCH_r16_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SetupRelease_PUSCH_Config_pusch_TimeDomainAllocationListForMultiPUSCH_r16_SQN_NR_PUSCH_Config_pusch_TimeDomainAllocationListForMultiPUSCH_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SetupRelease_PUSCH_Config_pusch_TimeDomainAllocationListForMultiPUSCH_r16_SQN_NR_PUSCH_Config_pusch_TimeDomainAllocationListForMultiPUSCH_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_SetupRelease_PUSCH_Config_pusch_TimeDomainAllocationListForMultiPUSCH_r16(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncUint8_t_SQN_NR_PUSCH_Config_numberOfInvalidSymbolsForDL_UL_Switching_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint8_t_SQN_NR_PUSCH_Config_numberOfInvalidSymbolsForDL_UL_Switching_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PUSCH_Config(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PUSCH_Config* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncUint16_t_SQN_NR_PUSCH_Config_dataScramblingIdentityPUSCH_Optional(_buffer, _size, _lidx, &p->dataScramblingIdentityPUSCH);
	_serNrSysEncSQN_NR_PUSCH_Config_txConfig_e_txConfig_Optional(_buffer, _size, _lidx, &p->txConfig);
	_serNrSysEncSQN_NR_SetupRelease_PUSCH_Config_dmrs_UplinkForPUSCH_MappingTypeA_SQN_NR_PUSCH_Config_dmrs_UplinkForPUSCH_MappingTypeA_Optional(_buffer, _size, _lidx, &p->dmrs_UplinkForPUSCH_MappingTypeA);
	_serNrSysEncSQN_NR_SetupRelease_PUSCH_Config_dmrs_UplinkForPUSCH_MappingTypeB_SQN_NR_PUSCH_Config_dmrs_UplinkForPUSCH_MappingTypeB_Optional(_buffer, _size, _lidx, &p->dmrs_UplinkForPUSCH_MappingTypeB);
	_serNrSysEncSQN_NR_PUSCH_PowerControl_SQN_NR_PUSCH_Config_pusch_PowerControl_Optional(_buffer, _size, _lidx, &p->pusch_PowerControl);
	_serNrSysEncSQN_NR_PUSCH_Config_frequencyHopping_e_frequencyHopping_Optional(_buffer, _size, _lidx, &p->frequencyHopping);
	_serNrSysEncUint16_t_SQN_NR_PUSCH_Config_frequencyHoppingOffsetLists_DynamicOptional(_buffer, _size, _lidx, &p->frequencyHoppingOffsetLists);
	{
		size_t _tmp = (size_t)p->resourceAllocation;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_SetupRelease_PUSCH_Config_pusch_TimeDomainAllocationList_SQN_NR_PUSCH_Config_pusch_TimeDomainAllocationList_Optional(_buffer, _size, _lidx, &p->pusch_TimeDomainAllocationList);
	_serNrSysEncSQN_NR_PUSCH_Config_pusch_AggregationFactor_e_pusch_AggregationFactor_Optional(_buffer, _size, _lidx, &p->pusch_AggregationFactor);
	_serNrSysEncSQN_NR_PUSCH_Config_mcs_Table_e_mcs_Table_Optional(_buffer, _size, _lidx, &p->mcs_Table);
	_serNrSysEncSQN_NR_PUSCH_Config_mcs_TableTransformPrecoder_e_mcs_TableTransformPrecoder_Optional(_buffer, _size, _lidx, &p->mcs_TableTransformPrecoder);
	_serNrSysEncSQN_NR_PUSCH_Config_transformPrecoder_e_transformPrecoder_Optional(_buffer, _size, _lidx, &p->transformPrecoder);
	_serNrSysEncSQN_NR_PUSCH_Config_codebookSubset_e_codebookSubset_Optional(_buffer, _size, _lidx, &p->codebookSubset);
	_serNrSysEncUint8_t_SQN_NR_PUSCH_Config_maxRank_Optional(_buffer, _size, _lidx, &p->maxRank);
	_serNrSysEncSQN_NR_PUSCH_Config_rbg_Size_e_rbg_Size_Optional(_buffer, _size, _lidx, &p->rbg_Size);
	_serNrSysEncSQN_NR_SetupRelease_PUSCH_Config_uci_OnPUSCH_SQN_NR_PUSCH_Config_uci_OnPUSCH_Optional(_buffer, _size, _lidx, &p->uci_OnPUSCH);
	_serNrSysEncSQN_NR_PUSCH_Config_tp_pi2BPSK_e_tp_pi2BPSK_Optional(_buffer, _size, _lidx, &p->tp_pi2BPSK);
	_serNrSysEncSQN_NR_SetupRelease_PUSCH_Config_minimumSchedulingOffsetK2_r16_SQN_NR_PUSCH_Config_minimumSchedulingOffsetK2_r16_Optional(_buffer, _size, _lidx, &p->minimumSchedulingOffsetK2_r16);
	_serNrSysEncSQN_NR_SetupRelease_PUSCH_Config_ul_AccessConfigListDCI_0_1_r16_SQN_NR_PUSCH_Config_ul_AccessConfigListDCI_0_1_r16_Optional(_buffer, _size, _lidx, &p->ul_AccessConfigListDCI_0_1_r16);
	_serNrSysEncUint8_t_SQN_NR_PUSCH_Config_harq_ProcessNumberSizeDCI_0_2_r16_Optional(_buffer, _size, _lidx, &p->harq_ProcessNumberSizeDCI_0_2_r16);
	_serNrSysEncSQN_NR_PUSCH_Config_dmrs_SequenceInitializationDCI_0_2_r16_e_dmrs_SequenceInitializationDCI_0_2_r16_Optional(_buffer, _size, _lidx, &p->dmrs_SequenceInitializationDCI_0_2_r16);
	_serNrSysEncUint8_t_SQN_NR_PUSCH_Config_numberOfBitsForRV_DCI_0_2_r16_Optional(_buffer, _size, _lidx, &p->numberOfBitsForRV_DCI_0_2_r16);
	_serNrSysEncSQN_NR_PUSCH_Config_antennaPortsFieldPresenceDCI_0_2_r16_e_antennaPortsFieldPresenceDCI_0_2_r16_Optional(_buffer, _size, _lidx, &p->antennaPortsFieldPresenceDCI_0_2_r16);
	_serNrSysEncSQN_NR_SetupRelease_PUSCH_Config_dmrs_UplinkForPUSCH_MappingTypeA_DCI_0_2_r16_SQN_NR_PUSCH_Config_dmrs_UplinkForPUSCH_MappingTypeA_DCI_0_2_r16_Optional(_buffer, _size, _lidx, &p->dmrs_UplinkForPUSCH_MappingTypeA_DCI_0_2_r16);
	_serNrSysEncSQN_NR_SetupRelease_PUSCH_Config_dmrs_UplinkForPUSCH_MappingTypeB_DCI_0_2_r16_SQN_NR_PUSCH_Config_dmrs_UplinkForPUSCH_MappingTypeB_DCI_0_2_r16_Optional(_buffer, _size, _lidx, &p->dmrs_UplinkForPUSCH_MappingTypeB_DCI_0_2_r16);
	_serNrSysEncSQN_NR_PUSCH_Config_frequencyHoppingDCI_0_2_r16_frequencyHoppingDCI_0_2_r16_Optional(_buffer, _size, _lidx, &p->frequencyHoppingDCI_0_2_r16);
	_serNrSysEncSQN_NR_SetupRelease_PUSCH_Config_frequencyHoppingOffsetListsDCI_0_2_r16_SQN_NR_PUSCH_Config_frequencyHoppingOffsetListsDCI_0_2_r16_Optional(_buffer, _size, _lidx, &p->frequencyHoppingOffsetListsDCI_0_2_r16);
	_serNrSysEncSQN_NR_PUSCH_Config_codebookSubsetDCI_0_2_r16_e_codebookSubsetDCI_0_2_r16_Optional(_buffer, _size, _lidx, &p->codebookSubsetDCI_0_2_r16);
	_serNrSysEncSQN_NR_PUSCH_Config_invalidSymbolPatternIndicatorDCI_0_2_r16_e_invalidSymbolPatternIndicatorDCI_0_2_r16_Optional(_buffer, _size, _lidx, &p->invalidSymbolPatternIndicatorDCI_0_2_r16);
	_serNrSysEncUint8_t_SQN_NR_PUSCH_Config_maxRankDCI_0_2_r16_Optional(_buffer, _size, _lidx, &p->maxRankDCI_0_2_r16);
	_serNrSysEncSQN_NR_PUSCH_Config_mcs_TableDCI_0_2_r16_e_mcs_TableDCI_0_2_r16_Optional(_buffer, _size, _lidx, &p->mcs_TableDCI_0_2_r16);
	_serNrSysEncSQN_NR_PUSCH_Config_mcs_TableTransformPrecoderDCI_0_2_r16_e_mcs_TableTransformPrecoderDCI_0_2_r16_Optional(_buffer, _size, _lidx, &p->mcs_TableTransformPrecoderDCI_0_2_r16);
	_serNrSysEncSQN_NR_PUSCH_Config_priorityIndicatorDCI_0_2_r16_e_priorityIndicatorDCI_0_2_r16_Optional(_buffer, _size, _lidx, &p->priorityIndicatorDCI_0_2_r16);
	_serNrSysEncSQN_NR_PUSCH_Config_pusch_RepTypeIndicatorDCI_0_2_r16_e_pusch_RepTypeIndicatorDCI_0_2_r16_Optional(_buffer, _size, _lidx, &p->pusch_RepTypeIndicatorDCI_0_2_r16);
	_serNrSysEncSQN_NR_PUSCH_Config_resourceAllocationDCI_0_2_r16_e_resourceAllocationDCI_0_2_r16_Optional(_buffer, _size, _lidx, &p->resourceAllocationDCI_0_2_r16);
	_serNrSysEncSQN_NR_PUSCH_Config_resourceAllocationType1GranularityDCI_0_2_r16_e_resourceAllocationType1GranularityDCI_0_2_r16_Optional(_buffer, _size, _lidx, &p->resourceAllocationType1GranularityDCI_0_2_r16);
	_serNrSysEncSQN_NR_SetupRelease_PUSCH_Config_uci_OnPUSCH_ListDCI_0_2_r16_SQN_NR_PUSCH_Config_uci_OnPUSCH_ListDCI_0_2_r16_Optional(_buffer, _size, _lidx, &p->uci_OnPUSCH_ListDCI_0_2_r16);
	_serNrSysEncSQN_NR_SetupRelease_PUSCH_Config_pusch_TimeDomainAllocationListDCI_0_2_r16_SQN_NR_PUSCH_Config_pusch_TimeDomainAllocationListDCI_0_2_r16_Optional(_buffer, _size, _lidx, &p->pusch_TimeDomainAllocationListDCI_0_2_r16);
	_serNrSysEncSQN_NR_SetupRelease_PUSCH_Config_pusch_TimeDomainAllocationListDCI_0_1_r16_SQN_NR_PUSCH_Config_pusch_TimeDomainAllocationListDCI_0_1_r16_Optional(_buffer, _size, _lidx, &p->pusch_TimeDomainAllocationListDCI_0_1_r16);
	_serNrSysEncSQN_NR_PUSCH_Config_invalidSymbolPatternIndicatorDCI_0_1_r16_e_invalidSymbolPatternIndicatorDCI_0_1_r16_Optional(_buffer, _size, _lidx, &p->invalidSymbolPatternIndicatorDCI_0_1_r16);
	_serNrSysEncSQN_NR_PUSCH_Config_priorityIndicatorDCI_0_1_r16_e_priorityIndicatorDCI_0_1_r16_Optional(_buffer, _size, _lidx, &p->priorityIndicatorDCI_0_1_r16);
	_serNrSysEncSQN_NR_PUSCH_Config_pusch_RepTypeIndicatorDCI_0_1_r16_e_pusch_RepTypeIndicatorDCI_0_1_r16_Optional(_buffer, _size, _lidx, &p->pusch_RepTypeIndicatorDCI_0_1_r16);
	_serNrSysEncSQN_NR_PUSCH_Config_frequencyHoppingDCI_0_1_r16_e_frequencyHoppingDCI_0_1_r16_Optional(_buffer, _size, _lidx, &p->frequencyHoppingDCI_0_1_r16);
	_serNrSysEncSQN_NR_SetupRelease_PUSCH_Config_uci_OnPUSCH_ListDCI_0_1_r16_SQN_NR_PUSCH_Config_uci_OnPUSCH_ListDCI_0_1_r16_Optional(_buffer, _size, _lidx, &p->uci_OnPUSCH_ListDCI_0_1_r16);
	_serNrSysEncSQN_NR_InvalidSymbolPattern_r16_SQN_NR_PUSCH_Config_invalidSymbolPattern_r16_Optional(_buffer, _size, _lidx, &p->invalidSymbolPattern_r16);
	_serNrSysEncSQN_NR_SetupRelease_PUSCH_Config_pusch_PowerControl_v1610_SQN_NR_PUSCH_Config_pusch_PowerControl_v1610_Optional(_buffer, _size, _lidx, &p->pusch_PowerControl_v1610);
	_serNrSysEncSQN_NR_PUSCH_Config_ul_FullPowerTransmission_r16_e_ul_FullPowerTransmission_r16_Optional(_buffer, _size, _lidx, &p->ul_FullPowerTransmission_r16);
	_serNrSysEncSQN_NR_SetupRelease_PUSCH_Config_pusch_TimeDomainAllocationListForMultiPUSCH_r16_SQN_NR_PUSCH_Config_pusch_TimeDomainAllocationListForMultiPUSCH_r16_Optional(_buffer, _size, _lidx, &p->pusch_TimeDomainAllocationListForMultiPUSCH_r16);
	_serNrSysEncUint8_t_SQN_NR_PUSCH_Config_numberOfInvalidSymbolsForDL_UL_Switching_r16_Optional(_buffer, _size, _lidx, &p->numberOfInvalidSymbolsForDL_UL_Switching_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SetupRelease_BWP_UplinkDedicated_pusch_Config_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SQN_NR_SetupRelease_BWP_UplinkDedicated_pusch_Config_Value* p, enum SQN_NR_SetupRelease_BWP_UplinkDedicated_pusch_Config_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SetupRelease_BWP_UplinkDedicated_pusch_Config_release) {
		HTON_8(&_buffer[*_lidx], p->release, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SetupRelease_BWP_UplinkDedicated_pusch_Config_setup) {
		_serNrSysEncSQN_NR_PUSCH_Config(_buffer, _size, _lidx, &p->setup);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncSQN_NR_SetupRelease_BWP_UplinkDedicated_pusch_Config(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SetupRelease_BWP_UplinkDedicated_pusch_Config* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_SetupRelease_BWP_UplinkDedicated_pusch_Config_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SetupRelease_BWP_UplinkDedicated_pusch_Config_SQN_NR_BWP_UplinkDedicated_pusch_Config_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SetupRelease_BWP_UplinkDedicated_pusch_Config_SQN_NR_BWP_UplinkDedicated_pusch_Config_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_SetupRelease_BWP_UplinkDedicated_pusch_Config(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_ConfiguredGrantConfig_frequencyHopping_e_frequencyHopping_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_ConfiguredGrantConfig_frequencyHopping_e_frequencyHopping_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_ConfiguredGrantConfig_mcs_Table_e_mcs_Table_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_ConfiguredGrantConfig_mcs_Table_e_mcs_Table_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_ConfiguredGrantConfig_mcs_TableTransformPrecoder_e_mcs_TableTransformPrecoder_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_ConfiguredGrantConfig_mcs_TableTransformPrecoder_e_mcs_TableTransformPrecoder_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_CG_UCI_OnPUSCH_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SQN_NR_CG_UCI_OnPUSCH_Value* p, enum SQN_NR_CG_UCI_OnPUSCH_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_CG_UCI_OnPUSCH_dynamic) {
		HTON_32(&_buffer[*_lidx], p->dynamic.d, _lidx);
		for (size_t i2 = 0; i2 < p->dynamic.d; i2++) {
			_serNrSysEncSQN_NR_BetaOffsets(_buffer, _size, _lidx, &p->dynamic.v[i2]);
		}
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_CG_UCI_OnPUSCH_semiStatic) {
		_serNrSysEncSQN_NR_BetaOffsets(_buffer, _size, _lidx, &p->semiStatic);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncSQN_NR_CG_UCI_OnPUSCH(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_CG_UCI_OnPUSCH* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_CG_UCI_OnPUSCH_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SetupRelease_ConfiguredGrantConfig_uci_OnPUSCH_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SQN_NR_SetupRelease_ConfiguredGrantConfig_uci_OnPUSCH_Value* p, enum SQN_NR_SetupRelease_ConfiguredGrantConfig_uci_OnPUSCH_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SetupRelease_ConfiguredGrantConfig_uci_OnPUSCH_release) {
		HTON_8(&_buffer[*_lidx], p->release, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SetupRelease_ConfiguredGrantConfig_uci_OnPUSCH_setup) {
		_serNrSysEncSQN_NR_CG_UCI_OnPUSCH(_buffer, _size, _lidx, &p->setup);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncSQN_NR_SetupRelease_ConfiguredGrantConfig_uci_OnPUSCH(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SetupRelease_ConfiguredGrantConfig_uci_OnPUSCH* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_SetupRelease_ConfiguredGrantConfig_uci_OnPUSCH_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SetupRelease_ConfiguredGrantConfig_uci_OnPUSCH_SQN_NR_ConfiguredGrantConfig_uci_OnPUSCH_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SetupRelease_ConfiguredGrantConfig_uci_OnPUSCH_SQN_NR_ConfiguredGrantConfig_uci_OnPUSCH_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_SetupRelease_ConfiguredGrantConfig_uci_OnPUSCH(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_ConfiguredGrantConfig_rbg_Size_e_rbg_Size_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_ConfiguredGrantConfig_rbg_Size_e_rbg_Size_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_ConfiguredGrantConfig_transformPrecoder_e_transformPrecoder_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_ConfiguredGrantConfig_transformPrecoder_e_transformPrecoder_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_ConfiguredGrantConfig_repK_RV_e_repK_RV_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_ConfiguredGrantConfig_repK_RV_e_repK_RV_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncUint8_t_SQN_NR_ConfiguredGrantConfig_configuredGrantTimer_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint8_t_SQN_NR_ConfiguredGrantConfig_configuredGrantTimer_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncUint8_t_SQN_NR_ConfiguredGrantConfig_rrc_ConfiguredUplinkGrant_dmrs_SeqInitialization_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint8_t_SQN_NR_ConfiguredGrantConfig_rrc_ConfiguredUplinkGrant_dmrs_SeqInitialization_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncUint8_t_SQN_NR_ConfiguredGrantConfig_rrc_ConfiguredUplinkGrant_srs_ResourceIndicator_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint8_t_SQN_NR_ConfiguredGrantConfig_rrc_ConfiguredUplinkGrant_srs_ResourceIndicator_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncUint16_t_SQN_NR_ConfiguredGrantConfig_rrc_ConfiguredUplinkGrant_frequencyHoppingOffset_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint16_t_SQN_NR_ConfiguredGrantConfig_rrc_ConfiguredUplinkGrant_frequencyHoppingOffset_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_16(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_ConfiguredGrantConfig_rrc_ConfiguredUplinkGrant_pusch_RepTypeIndicator_r16_e_pusch_RepTypeIndicator_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_ConfiguredGrantConfig_rrc_ConfiguredUplinkGrant_pusch_RepTypeIndicator_r16_e_pusch_RepTypeIndicator_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_ConfiguredGrantConfig_rrc_ConfiguredUplinkGrant_frequencyHoppingPUSCH_RepTypeB_r16_e_frequencyHoppingPUSCH_RepTypeB_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_ConfiguredGrantConfig_rrc_ConfiguredUplinkGrant_frequencyHoppingPUSCH_RepTypeB_r16_e_frequencyHoppingPUSCH_RepTypeB_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_ConfiguredGrantConfig_rrc_ConfiguredUplinkGrant_timeReferenceSFN_r16_e_timeReferenceSFN_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_ConfiguredGrantConfig_rrc_ConfiguredUplinkGrant_timeReferenceSFN_r16_e_timeReferenceSFN_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_ConfiguredGrantConfig_rrc_ConfiguredUplinkGrant(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_ConfiguredGrantConfig_rrc_ConfiguredUplinkGrant* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_16(&_buffer[*_lidx], p->timeDomainOffset, _lidx);
	HTON_8(&_buffer[*_lidx], p->timeDomainAllocation, _lidx);
	for (size_t i2 = 0; i2 < 18; i2++) {
		HTON_8(&_buffer[*_lidx], p->frequencyDomainAllocation[i2], _lidx);
	}
	HTON_8(&_buffer[*_lidx], p->antennaPort, _lidx);
	_serNrSysEncUint8_t_SQN_NR_ConfiguredGrantConfig_rrc_ConfiguredUplinkGrant_dmrs_SeqInitialization_Optional(_buffer, _size, _lidx, &p->dmrs_SeqInitialization);
	HTON_8(&_buffer[*_lidx], p->precodingAndNumberOfLayers, _lidx);
	_serNrSysEncUint8_t_SQN_NR_ConfiguredGrantConfig_rrc_ConfiguredUplinkGrant_srs_ResourceIndicator_Optional(_buffer, _size, _lidx, &p->srs_ResourceIndicator);
	HTON_8(&_buffer[*_lidx], p->mcsAndTBS, _lidx);
	_serNrSysEncUint16_t_SQN_NR_ConfiguredGrantConfig_rrc_ConfiguredUplinkGrant_frequencyHoppingOffset_Optional(_buffer, _size, _lidx, &p->frequencyHoppingOffset);
	HTON_8(&_buffer[*_lidx], p->pathlossReferenceIndex, _lidx);
	_serNrSysEncSQN_NR_ConfiguredGrantConfig_rrc_ConfiguredUplinkGrant_pusch_RepTypeIndicator_r16_e_pusch_RepTypeIndicator_r16_Optional(_buffer, _size, _lidx, &p->pusch_RepTypeIndicator_r16);
	_serNrSysEncSQN_NR_ConfiguredGrantConfig_rrc_ConfiguredUplinkGrant_frequencyHoppingPUSCH_RepTypeB_r16_e_frequencyHoppingPUSCH_RepTypeB_r16_Optional(_buffer, _size, _lidx, &p->frequencyHoppingPUSCH_RepTypeB_r16);
	_serNrSysEncSQN_NR_ConfiguredGrantConfig_rrc_ConfiguredUplinkGrant_timeReferenceSFN_r16_e_timeReferenceSFN_r16_Optional(_buffer, _size, _lidx, &p->timeReferenceSFN_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_ConfiguredGrantConfig_rrc_ConfiguredUplinkGrant_rrc_ConfiguredUplinkGrant_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_ConfiguredGrantConfig_rrc_ConfiguredUplinkGrant_rrc_ConfiguredUplinkGrant_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_ConfiguredGrantConfig_rrc_ConfiguredUplinkGrant(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncUint8_t_SQN_NR_ConfiguredGrantConfig_cg_RetransmissionTimer_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint8_t_SQN_NR_ConfiguredGrantConfig_cg_RetransmissionTimer_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_ConfiguredGrantConfig_cg_minDFI_Delay_r16_e_cg_minDFI_Delay_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_ConfiguredGrantConfig_cg_minDFI_Delay_r16_e_cg_minDFI_Delay_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncUint8_t_SQN_NR_ConfiguredGrantConfig_cg_nrofPUSCH_InSlot_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint8_t_SQN_NR_ConfiguredGrantConfig_cg_nrofPUSCH_InSlot_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncUint8_t_SQN_NR_ConfiguredGrantConfig_cg_nrofSlots_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint8_t_SQN_NR_ConfiguredGrantConfig_cg_nrofSlots_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncUint8_t_SQN_NR_CG_StartingOffsets_r16_cg_StartingFullBW_InsideCOT_r16_DynamicOptional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint8_t_SQN_NR_CG_StartingOffsets_r16_cg_StartingFullBW_InsideCOT_r16_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		HTON_8(&_buffer[*_lidx], p->v.v[i2], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncUint8_t_SQN_NR_CG_StartingOffsets_r16_cg_StartingFullBW_OutsideCOT_r16_DynamicOptional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint8_t_SQN_NR_CG_StartingOffsets_r16_cg_StartingFullBW_OutsideCOT_r16_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		HTON_8(&_buffer[*_lidx], p->v.v[i2], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncUint8_t_SQN_NR_CG_StartingOffsets_r16_cg_StartingPartialBW_InsideCOT_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint8_t_SQN_NR_CG_StartingOffsets_r16_cg_StartingPartialBW_InsideCOT_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncUint8_t_SQN_NR_CG_StartingOffsets_r16_cg_StartingPartialBW_OutsideCOT_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint8_t_SQN_NR_CG_StartingOffsets_r16_cg_StartingPartialBW_OutsideCOT_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_CG_StartingOffsets_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_CG_StartingOffsets_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncUint8_t_SQN_NR_CG_StartingOffsets_r16_cg_StartingFullBW_InsideCOT_r16_DynamicOptional(_buffer, _size, _lidx, &p->cg_StartingFullBW_InsideCOT_r16);
	_serNrSysEncUint8_t_SQN_NR_CG_StartingOffsets_r16_cg_StartingFullBW_OutsideCOT_r16_DynamicOptional(_buffer, _size, _lidx, &p->cg_StartingFullBW_OutsideCOT_r16);
	_serNrSysEncUint8_t_SQN_NR_CG_StartingOffsets_r16_cg_StartingPartialBW_InsideCOT_r16_Optional(_buffer, _size, _lidx, &p->cg_StartingPartialBW_InsideCOT_r16);
	_serNrSysEncUint8_t_SQN_NR_CG_StartingOffsets_r16_cg_StartingPartialBW_OutsideCOT_r16_Optional(_buffer, _size, _lidx, &p->cg_StartingPartialBW_OutsideCOT_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_CG_StartingOffsets_r16_SQN_NR_ConfiguredGrantConfig_cg_StartingOffsets_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_CG_StartingOffsets_r16_SQN_NR_ConfiguredGrantConfig_cg_StartingOffsets_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_CG_StartingOffsets_r16(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_ConfiguredGrantConfig_cg_UCI_Multiplexing_e_cg_UCI_Multiplexing_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_ConfiguredGrantConfig_cg_UCI_Multiplexing_e_cg_UCI_Multiplexing_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncUint8_t_SQN_NR_ConfiguredGrantConfig_cg_COT_SharingOffset_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint8_t_SQN_NR_ConfiguredGrantConfig_cg_COT_SharingOffset_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncUint8_t_SQN_NR_ConfiguredGrantConfig_betaOffsetCG_UCI_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint8_t_SQN_NR_ConfiguredGrantConfig_betaOffsetCG_UCI_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_CG_COT_Sharing_r16_cot_Sharing_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_CG_COT_Sharing_r16_cot_Sharing_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->duration_r16, _lidx);
	HTON_8(&_buffer[*_lidx], p->offset_r16, _lidx);
	HTON_8(&_buffer[*_lidx], p->channelAccessPriority_r16, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_CG_COT_Sharing_r16_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SQN_NR_CG_COT_Sharing_r16_Value* p, enum SQN_NR_CG_COT_Sharing_r16_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_CG_COT_Sharing_r16_noCOT_Sharing_r16) {
		HTON_8(&_buffer[*_lidx], p->noCOT_Sharing_r16, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_CG_COT_Sharing_r16_cot_Sharing_r16) {
		_serNrSysEncSQN_NR_CG_COT_Sharing_r16_cot_Sharing_r16(_buffer, _size, _lidx, &p->cot_Sharing_r16);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncSQN_NR_CG_COT_Sharing_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_CG_COT_Sharing_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_CG_COT_Sharing_r16_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_CG_COT_Sharing_r16_SQN_NR_ConfiguredGrantConfig_cg_COT_SharingList_r16_DynamicOptional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_CG_COT_Sharing_r16_SQN_NR_ConfiguredGrantConfig_cg_COT_SharingList_r16_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serNrSysEncSQN_NR_CG_COT_Sharing_r16(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncUint8_t_SQN_NR_ConfiguredGrantConfig_harq_ProcID_Offset_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint8_t_SQN_NR_ConfiguredGrantConfig_harq_ProcID_Offset_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncUint8_t_SQN_NR_ConfiguredGrantConfig_harq_ProcID_Offset2_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint8_t_SQN_NR_ConfiguredGrantConfig_harq_ProcID_Offset2_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_ConfiguredGrantConfigIndex_r16_SQN_NR_ConfiguredGrantConfig_configuredGrantConfigIndex_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_ConfiguredGrantConfigIndex_r16_SQN_NR_ConfiguredGrantConfig_configuredGrantConfigIndex_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_ConfiguredGrantConfigIndexMAC_r16_SQN_NR_ConfiguredGrantConfig_configuredGrantConfigIndexMAC_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_ConfiguredGrantConfigIndexMAC_r16_SQN_NR_ConfiguredGrantConfig_configuredGrantConfigIndexMAC_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncUint16_t_SQN_NR_ConfiguredGrantConfig_periodicityExt_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint16_t_SQN_NR_ConfiguredGrantConfig_periodicityExt_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_16(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_ConfiguredGrantConfig_startingFromRV0_r16_e_startingFromRV0_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_ConfiguredGrantConfig_startingFromRV0_r16_e_startingFromRV0_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_ConfiguredGrantConfig_phy_PriorityIndex_r16_e_phy_PriorityIndex_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_ConfiguredGrantConfig_phy_PriorityIndex_r16_e_phy_PriorityIndex_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_ConfiguredGrantConfig_autonomousTx_r16_e_autonomousTx_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_ConfiguredGrantConfig_autonomousTx_r16_e_autonomousTx_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_ConfiguredGrantConfig(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_ConfiguredGrantConfig* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncSQN_NR_ConfiguredGrantConfig_frequencyHopping_e_frequencyHopping_Optional(_buffer, _size, _lidx, &p->frequencyHopping);
	_serNrSysEncSQN_NR_DMRS_UplinkConfig(_buffer, _size, _lidx, &p->cg_DMRS_Configuration);
	_serNrSysEncSQN_NR_ConfiguredGrantConfig_mcs_Table_e_mcs_Table_Optional(_buffer, _size, _lidx, &p->mcs_Table);
	_serNrSysEncSQN_NR_ConfiguredGrantConfig_mcs_TableTransformPrecoder_e_mcs_TableTransformPrecoder_Optional(_buffer, _size, _lidx, &p->mcs_TableTransformPrecoder);
	_serNrSysEncSQN_NR_SetupRelease_ConfiguredGrantConfig_uci_OnPUSCH_SQN_NR_ConfiguredGrantConfig_uci_OnPUSCH_Optional(_buffer, _size, _lidx, &p->uci_OnPUSCH);
	{
		size_t _tmp = (size_t)p->resourceAllocation;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_ConfiguredGrantConfig_rbg_Size_e_rbg_Size_Optional(_buffer, _size, _lidx, &p->rbg_Size);
	{
		size_t _tmp = (size_t)p->powerControlLoopToUse;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	HTON_8(&_buffer[*_lidx], p->p0_PUSCH_Alpha, _lidx);
	_serNrSysEncSQN_NR_ConfiguredGrantConfig_transformPrecoder_e_transformPrecoder_Optional(_buffer, _size, _lidx, &p->transformPrecoder);
	HTON_8(&_buffer[*_lidx], p->nrofHARQ_Processes, _lidx);
	{
		size_t _tmp = (size_t)p->repK;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_ConfiguredGrantConfig_repK_RV_e_repK_RV_Optional(_buffer, _size, _lidx, &p->repK_RV);
	{
		size_t _tmp = (size_t)p->periodicity;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncUint8_t_SQN_NR_ConfiguredGrantConfig_configuredGrantTimer_Optional(_buffer, _size, _lidx, &p->configuredGrantTimer);
	_serNrSysEncSQN_NR_ConfiguredGrantConfig_rrc_ConfiguredUplinkGrant_rrc_ConfiguredUplinkGrant_Optional(_buffer, _size, _lidx, &p->rrc_ConfiguredUplinkGrant);
	_serNrSysEncUint8_t_SQN_NR_ConfiguredGrantConfig_cg_RetransmissionTimer_r16_Optional(_buffer, _size, _lidx, &p->cg_RetransmissionTimer_r16);
	_serNrSysEncSQN_NR_ConfiguredGrantConfig_cg_minDFI_Delay_r16_e_cg_minDFI_Delay_r16_Optional(_buffer, _size, _lidx, &p->cg_minDFI_Delay_r16);
	_serNrSysEncUint8_t_SQN_NR_ConfiguredGrantConfig_cg_nrofPUSCH_InSlot_r16_Optional(_buffer, _size, _lidx, &p->cg_nrofPUSCH_InSlot_r16);
	_serNrSysEncUint8_t_SQN_NR_ConfiguredGrantConfig_cg_nrofSlots_r16_Optional(_buffer, _size, _lidx, &p->cg_nrofSlots_r16);
	_serNrSysEncSQN_NR_CG_StartingOffsets_r16_SQN_NR_ConfiguredGrantConfig_cg_StartingOffsets_r16_Optional(_buffer, _size, _lidx, &p->cg_StartingOffsets_r16);
	_serNrSysEncSQN_NR_ConfiguredGrantConfig_cg_UCI_Multiplexing_e_cg_UCI_Multiplexing_Optional(_buffer, _size, _lidx, &p->cg_UCI_Multiplexing);
	_serNrSysEncUint8_t_SQN_NR_ConfiguredGrantConfig_cg_COT_SharingOffset_r16_Optional(_buffer, _size, _lidx, &p->cg_COT_SharingOffset_r16);
	_serNrSysEncUint8_t_SQN_NR_ConfiguredGrantConfig_betaOffsetCG_UCI_r16_Optional(_buffer, _size, _lidx, &p->betaOffsetCG_UCI_r16);
	_serNrSysEncSQN_NR_CG_COT_Sharing_r16_SQN_NR_ConfiguredGrantConfig_cg_COT_SharingList_r16_DynamicOptional(_buffer, _size, _lidx, &p->cg_COT_SharingList_r16);
	_serNrSysEncUint8_t_SQN_NR_ConfiguredGrantConfig_harq_ProcID_Offset_r16_Optional(_buffer, _size, _lidx, &p->harq_ProcID_Offset_r16);
	_serNrSysEncUint8_t_SQN_NR_ConfiguredGrantConfig_harq_ProcID_Offset2_r16_Optional(_buffer, _size, _lidx, &p->harq_ProcID_Offset2_r16);
	_serNrSysEncSQN_NR_ConfiguredGrantConfigIndex_r16_SQN_NR_ConfiguredGrantConfig_configuredGrantConfigIndex_r16_Optional(_buffer, _size, _lidx, &p->configuredGrantConfigIndex_r16);
	_serNrSysEncSQN_NR_ConfiguredGrantConfigIndexMAC_r16_SQN_NR_ConfiguredGrantConfig_configuredGrantConfigIndexMAC_r16_Optional(_buffer, _size, _lidx, &p->configuredGrantConfigIndexMAC_r16);
	_serNrSysEncUint16_t_SQN_NR_ConfiguredGrantConfig_periodicityExt_r16_Optional(_buffer, _size, _lidx, &p->periodicityExt_r16);
	_serNrSysEncSQN_NR_ConfiguredGrantConfig_startingFromRV0_r16_e_startingFromRV0_r16_Optional(_buffer, _size, _lidx, &p->startingFromRV0_r16);
	_serNrSysEncSQN_NR_ConfiguredGrantConfig_phy_PriorityIndex_r16_e_phy_PriorityIndex_r16_Optional(_buffer, _size, _lidx, &p->phy_PriorityIndex_r16);
	_serNrSysEncSQN_NR_ConfiguredGrantConfig_autonomousTx_r16_e_autonomousTx_r16_Optional(_buffer, _size, _lidx, &p->autonomousTx_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SetupRelease_BWP_UplinkDedicated_configuredGrantConfig_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SQN_NR_SetupRelease_BWP_UplinkDedicated_configuredGrantConfig_Value* p, enum SQN_NR_SetupRelease_BWP_UplinkDedicated_configuredGrantConfig_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SetupRelease_BWP_UplinkDedicated_configuredGrantConfig_release) {
		HTON_8(&_buffer[*_lidx], p->release, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SetupRelease_BWP_UplinkDedicated_configuredGrantConfig_setup) {
		_serNrSysEncSQN_NR_ConfiguredGrantConfig(_buffer, _size, _lidx, &p->setup);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncSQN_NR_SetupRelease_BWP_UplinkDedicated_configuredGrantConfig(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SetupRelease_BWP_UplinkDedicated_configuredGrantConfig* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_SetupRelease_BWP_UplinkDedicated_configuredGrantConfig_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SetupRelease_BWP_UplinkDedicated_configuredGrantConfig_SQN_NR_BWP_UplinkDedicated_configuredGrantConfig_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SetupRelease_BWP_UplinkDedicated_configuredGrantConfig_SQN_NR_BWP_UplinkDedicated_configuredGrantConfig_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_SetupRelease_BWP_UplinkDedicated_configuredGrantConfig(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SRS_ResourceSetId_SQN_NR_SRS_Config_srs_ResourceSetToReleaseList_DynamicOptional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SRS_ResourceSetId_SQN_NR_SRS_Config_srs_ResourceSetToReleaseList_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		HTON_8(&_buffer[*_lidx], p->v.v[i2], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SRS_ResourceId_SQN_NR_SRS_ResourceSet_srs_ResourceIdList_DynamicOptional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SRS_ResourceId_SQN_NR_SRS_ResourceSet_srs_ResourceIdList_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i3 = 0; i3 < p->v.d; i3++) {
		HTON_8(&_buffer[*_lidx], p->v.v[i3], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_NZP_CSI_RS_ResourceId_SQN_NR_SRS_ResourceSet_resourceType_aperiodic_csi_RS_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_NZP_CSI_RS_ResourceId_SQN_NR_SRS_ResourceSet_resourceType_aperiodic_csi_RS_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncUint8_t_SQN_NR_SRS_ResourceSet_resourceType_aperiodic_slotOffset_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint8_t_SQN_NR_SRS_ResourceSet_resourceType_aperiodic_slotOffset_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncUint8_t_SQN_NR_SRS_ResourceSet_resourceType_aperiodic_aperiodicSRS_ResourceTriggerList_DynamicOptional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint8_t_SQN_NR_SRS_ResourceSet_resourceType_aperiodic_aperiodicSRS_ResourceTriggerList_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i3 = 0; i3 < p->v.d; i3++) {
		HTON_8(&_buffer[*_lidx], p->v.v[i3], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SRS_ResourceSet_resourceType_aperiodic(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SRS_ResourceSet_resourceType_aperiodic* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->aperiodicSRS_ResourceTrigger, _lidx);
	_serNrSysEncSQN_NR_NZP_CSI_RS_ResourceId_SQN_NR_SRS_ResourceSet_resourceType_aperiodic_csi_RS_Optional(_buffer, _size, _lidx, &p->csi_RS);
	_serNrSysEncUint8_t_SQN_NR_SRS_ResourceSet_resourceType_aperiodic_slotOffset_Optional(_buffer, _size, _lidx, &p->slotOffset);
	_serNrSysEncUint8_t_SQN_NR_SRS_ResourceSet_resourceType_aperiodic_aperiodicSRS_ResourceTriggerList_DynamicOptional(_buffer, _size, _lidx, &p->aperiodicSRS_ResourceTriggerList);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_NZP_CSI_RS_ResourceId_SQN_NR_SRS_ResourceSet_resourceType_semi_persistent_associatedCSI_RS_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_NZP_CSI_RS_ResourceId_SQN_NR_SRS_ResourceSet_resourceType_semi_persistent_associatedCSI_RS_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SRS_ResourceSet_resourceType_semi_persistent(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SRS_ResourceSet_resourceType_semi_persistent* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncSQN_NR_NZP_CSI_RS_ResourceId_SQN_NR_SRS_ResourceSet_resourceType_semi_persistent_associatedCSI_RS_Optional(_buffer, _size, _lidx, &p->associatedCSI_RS);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_NZP_CSI_RS_ResourceId_SQN_NR_SRS_ResourceSet_resourceType_periodic_associatedCSI_RS_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_NZP_CSI_RS_ResourceId_SQN_NR_SRS_ResourceSet_resourceType_periodic_associatedCSI_RS_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SRS_ResourceSet_resourceType_periodic(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SRS_ResourceSet_resourceType_periodic* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncSQN_NR_NZP_CSI_RS_ResourceId_SQN_NR_SRS_ResourceSet_resourceType_periodic_associatedCSI_RS_Optional(_buffer, _size, _lidx, &p->associatedCSI_RS);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SRS_ResourceSet_resourceType_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SQN_NR_SRS_ResourceSet_resourceType_Value* p, enum SQN_NR_SRS_ResourceSet_resourceType_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SRS_ResourceSet_resourceType_aperiodic) {
		_serNrSysEncSQN_NR_SRS_ResourceSet_resourceType_aperiodic(_buffer, _size, _lidx, &p->aperiodic);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SRS_ResourceSet_resourceType_semi_persistent) {
		_serNrSysEncSQN_NR_SRS_ResourceSet_resourceType_semi_persistent(_buffer, _size, _lidx, &p->semi_persistent);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SRS_ResourceSet_resourceType_periodic) {
		_serNrSysEncSQN_NR_SRS_ResourceSet_resourceType_periodic(_buffer, _size, _lidx, &p->periodic);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncSQN_NR_SRS_ResourceSet_resourceType(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SRS_ResourceSet_resourceType* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_SRS_ResourceSet_resourceType_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_Alpha_e_SQN_NR_SRS_ResourceSet_alpha_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_Alpha_e_SQN_NR_SRS_ResourceSet_alpha_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncInt16_t_SQN_NR_SRS_ResourceSet_p0_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct int16_t_SQN_NR_SRS_ResourceSet_p0_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_16(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PathlossReferenceRS_Config_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SQN_NR_PathlossReferenceRS_Config_Value* p, enum SQN_NR_PathlossReferenceRS_Config_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_PathlossReferenceRS_Config_ssb_Index) {
		HTON_8(&_buffer[*_lidx], p->ssb_Index, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_PathlossReferenceRS_Config_csi_RS_Index) {
		HTON_8(&_buffer[*_lidx], p->csi_RS_Index, _lidx);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncSQN_NR_PathlossReferenceRS_Config(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PathlossReferenceRS_Config* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_PathlossReferenceRS_Config_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PathlossReferenceRS_Config_SQN_NR_SRS_ResourceSet_pathlossReferenceRS_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PathlossReferenceRS_Config_SQN_NR_SRS_ResourceSet_pathlossReferenceRS_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_PathlossReferenceRS_Config(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SRS_ResourceSet_srs_PowerControlAdjustmentStates_e_srs_PowerControlAdjustmentStates_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SRS_ResourceSet_srs_PowerControlAdjustmentStates_e_srs_PowerControlAdjustmentStates_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PathlossReferenceRS_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PathlossReferenceRS_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->srs_PathlossReferenceRS_Id_r16, _lidx);
	_serNrSysEncSQN_NR_PathlossReferenceRS_Config(_buffer, _size, _lidx, &p->pathlossReferenceRS_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SetupRelease_SRS_ResourceSet_pathlossReferenceRSList_r16_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SQN_NR_SetupRelease_SRS_ResourceSet_pathlossReferenceRSList_r16_Value* p, enum SQN_NR_SetupRelease_SRS_ResourceSet_pathlossReferenceRSList_r16_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SetupRelease_SRS_ResourceSet_pathlossReferenceRSList_r16_release) {
		HTON_8(&_buffer[*_lidx], p->release, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SetupRelease_SRS_ResourceSet_pathlossReferenceRSList_r16_setup) {
		HTON_32(&_buffer[*_lidx], p->setup.d, _lidx);
		for (size_t i3 = 0; i3 < p->setup.d; i3++) {
			_serNrSysEncSQN_NR_PathlossReferenceRS_r16(_buffer, _size, _lidx, &p->setup.v[i3]);
		}
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncSQN_NR_SetupRelease_SRS_ResourceSet_pathlossReferenceRSList_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SetupRelease_SRS_ResourceSet_pathlossReferenceRSList_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_SetupRelease_SRS_ResourceSet_pathlossReferenceRSList_r16_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SetupRelease_SRS_ResourceSet_pathlossReferenceRSList_r16_SQN_NR_SRS_ResourceSet_pathlossReferenceRSList_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SetupRelease_SRS_ResourceSet_pathlossReferenceRSList_r16_SQN_NR_SRS_ResourceSet_pathlossReferenceRSList_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_SetupRelease_SRS_ResourceSet_pathlossReferenceRSList_r16(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SRS_ResourceSet(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SRS_ResourceSet* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->srs_ResourceSetId, _lidx);
	_serNrSysEncSQN_NR_SRS_ResourceId_SQN_NR_SRS_ResourceSet_srs_ResourceIdList_DynamicOptional(_buffer, _size, _lidx, &p->srs_ResourceIdList);
	_serNrSysEncSQN_NR_SRS_ResourceSet_resourceType(_buffer, _size, _lidx, &p->resourceType);
	{
		size_t _tmp = (size_t)p->usage;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_Alpha_e_SQN_NR_SRS_ResourceSet_alpha_Optional(_buffer, _size, _lidx, &p->alpha);
	_serNrSysEncInt16_t_SQN_NR_SRS_ResourceSet_p0_Optional(_buffer, _size, _lidx, &p->p0);
	_serNrSysEncSQN_NR_PathlossReferenceRS_Config_SQN_NR_SRS_ResourceSet_pathlossReferenceRS_Optional(_buffer, _size, _lidx, &p->pathlossReferenceRS);
	_serNrSysEncSQN_NR_SRS_ResourceSet_srs_PowerControlAdjustmentStates_e_srs_PowerControlAdjustmentStates_Optional(_buffer, _size, _lidx, &p->srs_PowerControlAdjustmentStates);
	_serNrSysEncSQN_NR_SetupRelease_SRS_ResourceSet_pathlossReferenceRSList_r16_SQN_NR_SRS_ResourceSet_pathlossReferenceRSList_r16_Optional(_buffer, _size, _lidx, &p->pathlossReferenceRSList_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SRS_ResourceSet_SQN_NR_SRS_Config_srs_ResourceSetToAddModList_DynamicOptional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SRS_ResourceSet_SQN_NR_SRS_Config_srs_ResourceSetToAddModList_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serNrSysEncSQN_NR_SRS_ResourceSet(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SRS_ResourceId_SQN_NR_SRS_Config_srs_ResourceToReleaseList_DynamicOptional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SRS_ResourceId_SQN_NR_SRS_Config_srs_ResourceToReleaseList_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		HTON_8(&_buffer[*_lidx], p->v.v[i2], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SRS_Resource_ptrs_PortIndex_e_ptrs_PortIndex_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SRS_Resource_ptrs_PortIndex_e_ptrs_PortIndex_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SRS_Resource_transmissionComb_n2(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SRS_Resource_transmissionComb_n2* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->combOffset_n2, _lidx);
	HTON_8(&_buffer[*_lidx], p->cyclicShift_n2, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SRS_Resource_transmissionComb_n4(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SRS_Resource_transmissionComb_n4* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->combOffset_n4, _lidx);
	HTON_8(&_buffer[*_lidx], p->cyclicShift_n4, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SRS_Resource_transmissionComb_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SQN_NR_SRS_Resource_transmissionComb_Value* p, enum SQN_NR_SRS_Resource_transmissionComb_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SRS_Resource_transmissionComb_n2) {
		_serNrSysEncSQN_NR_SRS_Resource_transmissionComb_n2(_buffer, _size, _lidx, &p->n2);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SRS_Resource_transmissionComb_n4) {
		_serNrSysEncSQN_NR_SRS_Resource_transmissionComb_n4(_buffer, _size, _lidx, &p->n4);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncSQN_NR_SRS_Resource_transmissionComb(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SRS_Resource_transmissionComb* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_SRS_Resource_transmissionComb_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SRS_Resource_resourceMapping(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SRS_Resource_resourceMapping* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->startPosition, _lidx);
	{
		size_t _tmp = (size_t)p->nrofSymbols;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	{
		size_t _tmp = (size_t)p->repetitionFactor;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SRS_Resource_freqHopping(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SRS_Resource_freqHopping* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->c_SRS, _lidx);
	HTON_8(&_buffer[*_lidx], p->b_SRS, _lidx);
	HTON_8(&_buffer[*_lidx], p->b_hop, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SRS_Resource_resourceType_aperiodic(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SRS_Resource_resourceType_aperiodic* p)
{
	(void)_size; // TODO: generate boundaries checking

	(void)_buffer;
	(void)_size;
	(void)_lidx;
	(void)p;

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SRS_PeriodicityAndOffset_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SQN_NR_SRS_PeriodicityAndOffset_Value* p, enum SQN_NR_SRS_PeriodicityAndOffset_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SRS_PeriodicityAndOffset_sl1) {
		HTON_8(&_buffer[*_lidx], p->sl1, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SRS_PeriodicityAndOffset_sl2) {
		HTON_8(&_buffer[*_lidx], p->sl2, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SRS_PeriodicityAndOffset_sl4) {
		HTON_8(&_buffer[*_lidx], p->sl4, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SRS_PeriodicityAndOffset_sl5) {
		HTON_8(&_buffer[*_lidx], p->sl5, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SRS_PeriodicityAndOffset_sl8) {
		HTON_8(&_buffer[*_lidx], p->sl8, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SRS_PeriodicityAndOffset_sl10) {
		HTON_8(&_buffer[*_lidx], p->sl10, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SRS_PeriodicityAndOffset_sl16) {
		HTON_8(&_buffer[*_lidx], p->sl16, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SRS_PeriodicityAndOffset_sl20) {
		HTON_8(&_buffer[*_lidx], p->sl20, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SRS_PeriodicityAndOffset_sl32) {
		HTON_8(&_buffer[*_lidx], p->sl32, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SRS_PeriodicityAndOffset_sl40) {
		HTON_8(&_buffer[*_lidx], p->sl40, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SRS_PeriodicityAndOffset_sl64) {
		HTON_8(&_buffer[*_lidx], p->sl64, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SRS_PeriodicityAndOffset_sl80) {
		HTON_8(&_buffer[*_lidx], p->sl80, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SRS_PeriodicityAndOffset_sl160) {
		HTON_8(&_buffer[*_lidx], p->sl160, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SRS_PeriodicityAndOffset_sl320) {
		HTON_16(&_buffer[*_lidx], p->sl320, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SRS_PeriodicityAndOffset_sl640) {
		HTON_16(&_buffer[*_lidx], p->sl640, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SRS_PeriodicityAndOffset_sl1280) {
		HTON_16(&_buffer[*_lidx], p->sl1280, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SRS_PeriodicityAndOffset_sl2560) {
		HTON_16(&_buffer[*_lidx], p->sl2560, _lidx);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncSQN_NR_SRS_PeriodicityAndOffset(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SRS_PeriodicityAndOffset* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_SRS_PeriodicityAndOffset_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SRS_Resource_resourceType_semi_persistent(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SRS_Resource_resourceType_semi_persistent* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncSQN_NR_SRS_PeriodicityAndOffset(_buffer, _size, _lidx, &p->periodicityAndOffset_sp);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SRS_Resource_resourceType_periodic(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SRS_Resource_resourceType_periodic* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncSQN_NR_SRS_PeriodicityAndOffset(_buffer, _size, _lidx, &p->periodicityAndOffset_p);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SRS_Resource_resourceType_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SQN_NR_SRS_Resource_resourceType_Value* p, enum SQN_NR_SRS_Resource_resourceType_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SRS_Resource_resourceType_aperiodic) {
		_serNrSysEncSQN_NR_SRS_Resource_resourceType_aperiodic(_buffer, _size, _lidx, &p->aperiodic);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SRS_Resource_resourceType_semi_persistent) {
		_serNrSysEncSQN_NR_SRS_Resource_resourceType_semi_persistent(_buffer, _size, _lidx, &p->semi_persistent);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SRS_Resource_resourceType_periodic) {
		_serNrSysEncSQN_NR_SRS_Resource_resourceType_periodic(_buffer, _size, _lidx, &p->periodic);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncSQN_NR_SRS_Resource_resourceType(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SRS_Resource_resourceType* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_SRS_Resource_resourceType_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_ServCellIndex_SQN_NR_SRS_SpatialRelationInfo_servingCellId_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_ServCellIndex_SQN_NR_SRS_SpatialRelationInfo_servingCellId_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SRS_SpatialRelationInfo_referenceSignal_srs(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SRS_SpatialRelationInfo_referenceSignal_srs* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->resourceId, _lidx);
	HTON_8(&_buffer[*_lidx], p->uplinkBWP, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SRS_SpatialRelationInfo_referenceSignal_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SQN_NR_SRS_SpatialRelationInfo_referenceSignal_Value* p, enum SQN_NR_SRS_SpatialRelationInfo_referenceSignal_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SRS_SpatialRelationInfo_referenceSignal_ssb_Index) {
		HTON_8(&_buffer[*_lidx], p->ssb_Index, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SRS_SpatialRelationInfo_referenceSignal_csi_RS_Index) {
		HTON_8(&_buffer[*_lidx], p->csi_RS_Index, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SRS_SpatialRelationInfo_referenceSignal_srs) {
		_serNrSysEncSQN_NR_SRS_SpatialRelationInfo_referenceSignal_srs(_buffer, _size, _lidx, &p->srs);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncSQN_NR_SRS_SpatialRelationInfo_referenceSignal(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SRS_SpatialRelationInfo_referenceSignal* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_SRS_SpatialRelationInfo_referenceSignal_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SRS_SpatialRelationInfo(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SRS_SpatialRelationInfo* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncSQN_NR_ServCellIndex_SQN_NR_SRS_SpatialRelationInfo_servingCellId_Optional(_buffer, _size, _lidx, &p->servingCellId);
	_serNrSysEncSQN_NR_SRS_SpatialRelationInfo_referenceSignal(_buffer, _size, _lidx, &p->referenceSignal);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SRS_SpatialRelationInfo_SQN_NR_SRS_Resource_spatialRelationInfo_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SRS_SpatialRelationInfo_SQN_NR_SRS_Resource_spatialRelationInfo_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_SRS_SpatialRelationInfo(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SRS_Resource_resourceMapping_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SRS_Resource_resourceMapping_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->startPosition_r16, _lidx);
	{
		size_t _tmp = (size_t)p->nrofSymbols_r16;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	{
		size_t _tmp = (size_t)p->repetitionFactor_r16;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SRS_Resource_resourceMapping_r16_resourceMapping_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SRS_Resource_resourceMapping_r16_resourceMapping_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_SRS_Resource_resourceMapping_r16(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SRS_Resource(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SRS_Resource* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->srs_ResourceId, _lidx);
	{
		size_t _tmp = (size_t)p->nrofSRS_Ports;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_SRS_Resource_ptrs_PortIndex_e_ptrs_PortIndex_Optional(_buffer, _size, _lidx, &p->ptrs_PortIndex);
	_serNrSysEncSQN_NR_SRS_Resource_transmissionComb(_buffer, _size, _lidx, &p->transmissionComb);
	_serNrSysEncSQN_NR_SRS_Resource_resourceMapping(_buffer, _size, _lidx, &p->resourceMapping);
	HTON_8(&_buffer[*_lidx], p->freqDomainPosition, _lidx);
	HTON_16(&_buffer[*_lidx], p->freqDomainShift, _lidx);
	_serNrSysEncSQN_NR_SRS_Resource_freqHopping(_buffer, _size, _lidx, &p->freqHopping);
	{
		size_t _tmp = (size_t)p->groupOrSequenceHopping;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_SRS_Resource_resourceType(_buffer, _size, _lidx, &p->resourceType);
	HTON_16(&_buffer[*_lidx], p->sequenceId, _lidx);
	_serNrSysEncSQN_NR_SRS_SpatialRelationInfo_SQN_NR_SRS_Resource_spatialRelationInfo_Optional(_buffer, _size, _lidx, &p->spatialRelationInfo);
	_serNrSysEncSQN_NR_SRS_Resource_resourceMapping_r16_resourceMapping_r16_Optional(_buffer, _size, _lidx, &p->resourceMapping_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SRS_Resource_SQN_NR_SRS_Config_srs_ResourceToAddModList_DynamicOptional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SRS_Resource_SQN_NR_SRS_Config_srs_ResourceToAddModList_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serNrSysEncSQN_NR_SRS_Resource(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SRS_Config_tpc_Accumulation_e_tpc_Accumulation_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SRS_Config_tpc_Accumulation_e_tpc_Accumulation_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncUint8_t_SQN_NR_SRS_Config_srs_RequestDCI_1_2_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint8_t_SQN_NR_SRS_Config_srs_RequestDCI_1_2_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncUint8_t_SQN_NR_SRS_Config_srs_RequestDCI_0_2_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint8_t_SQN_NR_SRS_Config_srs_RequestDCI_0_2_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SRS_ResourceSet_SQN_NR_SRS_Config_srs_ResourceSetToAddModListDCI_0_2_r16_DynamicOptional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SRS_ResourceSet_SQN_NR_SRS_Config_srs_ResourceSetToAddModListDCI_0_2_r16_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serNrSysEncSQN_NR_SRS_ResourceSet(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SRS_ResourceSetId_SQN_NR_SRS_Config_srs_ResourceSetToReleaseListDCI_0_2_r16_DynamicOptional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SRS_ResourceSetId_SQN_NR_SRS_Config_srs_ResourceSetToReleaseListDCI_0_2_r16_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		HTON_8(&_buffer[*_lidx], p->v.v[i2], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SRS_PosResourceSetId_r16_SQN_NR_SRS_Config_srs_PosResourceSetToReleaseList_r16_DynamicOptional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SRS_PosResourceSetId_r16_SQN_NR_SRS_Config_srs_PosResourceSetToReleaseList_r16_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		HTON_8(&_buffer[*_lidx], p->v.v[i2], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SRS_PosResourceId_r16_SQN_NR_SRS_PosResourceSet_r16_srs_PosResourceIdList_r16_DynamicOptional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SRS_PosResourceId_r16_SQN_NR_SRS_PosResourceSet_r16_srs_PosResourceIdList_r16_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i3 = 0; i3 < p->v.d; i3++) {
		HTON_8(&_buffer[*_lidx], p->v.v[i3], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncUint8_t_SQN_NR_SRS_PosResourceSet_r16_resourceType_r16_aperiodic_r16_aperiodicSRS_ResourceTriggerList_r16_DynamicOptional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint8_t_SQN_NR_SRS_PosResourceSet_r16_resourceType_r16_aperiodic_r16_aperiodicSRS_ResourceTriggerList_r16_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i3 = 0; i3 < p->v.d; i3++) {
		HTON_8(&_buffer[*_lidx], p->v.v[i3], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SRS_PosResourceSet_r16_resourceType_r16_aperiodic_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SRS_PosResourceSet_r16_resourceType_r16_aperiodic_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncUint8_t_SQN_NR_SRS_PosResourceSet_r16_resourceType_r16_aperiodic_r16_aperiodicSRS_ResourceTriggerList_r16_DynamicOptional(_buffer, _size, _lidx, &p->aperiodicSRS_ResourceTriggerList_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SRS_PosResourceSet_r16_resourceType_r16_semi_persistent_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SRS_PosResourceSet_r16_resourceType_r16_semi_persistent_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	(void)_buffer;
	(void)_size;
	(void)_lidx;
	(void)p;

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SRS_PosResourceSet_r16_resourceType_r16_periodic_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SRS_PosResourceSet_r16_resourceType_r16_periodic_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	(void)_buffer;
	(void)_size;
	(void)_lidx;
	(void)p;

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SRS_PosResourceSet_r16_resourceType_r16_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SQN_NR_SRS_PosResourceSet_r16_resourceType_r16_Value* p, enum SQN_NR_SRS_PosResourceSet_r16_resourceType_r16_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SRS_PosResourceSet_r16_resourceType_r16_aperiodic_r16) {
		_serNrSysEncSQN_NR_SRS_PosResourceSet_r16_resourceType_r16_aperiodic_r16(_buffer, _size, _lidx, &p->aperiodic_r16);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SRS_PosResourceSet_r16_resourceType_r16_semi_persistent_r16) {
		_serNrSysEncSQN_NR_SRS_PosResourceSet_r16_resourceType_r16_semi_persistent_r16(_buffer, _size, _lidx, &p->semi_persistent_r16);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SRS_PosResourceSet_r16_resourceType_r16_periodic_r16) {
		_serNrSysEncSQN_NR_SRS_PosResourceSet_r16_resourceType_r16_periodic_r16(_buffer, _size, _lidx, &p->periodic_r16);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncSQN_NR_SRS_PosResourceSet_r16_resourceType_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SRS_PosResourceSet_r16_resourceType_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_SRS_PosResourceSet_r16_resourceType_r16_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_Alpha_e_SQN_NR_SRS_PosResourceSet_r16_alpha_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_Alpha_e_SQN_NR_SRS_PosResourceSet_r16_alpha_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncInt16_t_SQN_NR_SRS_PosResourceSet_r16_p0_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct int16_t_SQN_NR_SRS_PosResourceSet_r16_p0_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_16(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SSB_Index_SQN_NR_SSB_InfoNcell_r16_ssb_IndexNcell_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SSB_Index_SQN_NR_SSB_InfoNcell_r16_ssb_IndexNcell_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SSB_Configuration_r16_ssb_Periodicity_r16_e_ssb_Periodicity_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SSB_Configuration_r16_ssb_Periodicity_r16_e_ssb_Periodicity_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncUint8_t_SQN_NR_SSB_Configuration_r16_sfn0_Offset_r16_integerSubframeOffset_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint8_t_SQN_NR_SSB_Configuration_r16_sfn0_Offset_r16_integerSubframeOffset_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SSB_Configuration_r16_sfn0_Offset_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SSB_Configuration_r16_sfn0_Offset_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_16(&_buffer[*_lidx], p->sfn_Offset_r16, _lidx);
	_serNrSysEncUint8_t_SQN_NR_SSB_Configuration_r16_sfn0_Offset_r16_integerSubframeOffset_r16_Optional(_buffer, _size, _lidx, &p->integerSubframeOffset_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SSB_Configuration_r16_sfn0_Offset_r16_sfn0_Offset_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SSB_Configuration_r16_sfn0_Offset_r16_sfn0_Offset_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_SSB_Configuration_r16_sfn0_Offset_r16(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncInt8_t_SQN_NR_SSB_Configuration_r16_ss_PBCH_BlockPower_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct int8_t_SQN_NR_SSB_Configuration_r16_ss_PBCH_BlockPower_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SSB_Configuration_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SSB_Configuration_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_32(&_buffer[*_lidx], p->ssb_Freq_r16, _lidx);
	{
		size_t _tmp = (size_t)p->halfFrameIndex_r16;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	{
		size_t _tmp = (size_t)p->ssbSubcarrierSpacing_r16;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_SSB_Configuration_r16_ssb_Periodicity_r16_e_ssb_Periodicity_r16_Optional(_buffer, _size, _lidx, &p->ssb_Periodicity_r16);
	_serNrSysEncSQN_NR_SSB_Configuration_r16_sfn0_Offset_r16_sfn0_Offset_r16_Optional(_buffer, _size, _lidx, &p->sfn0_Offset_r16);
	HTON_8(&_buffer[*_lidx], p->sfn_SSB_Offset_r16, _lidx);
	_serNrSysEncInt8_t_SQN_NR_SSB_Configuration_r16_ss_PBCH_BlockPower_r16_Optional(_buffer, _size, _lidx, &p->ss_PBCH_BlockPower_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SSB_Configuration_r16_SQN_NR_SSB_InfoNcell_r16_ssb_Configuration_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SSB_Configuration_r16_SQN_NR_SSB_InfoNcell_r16_ssb_Configuration_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_SSB_Configuration_r16(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SSB_InfoNcell_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SSB_InfoNcell_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_16(&_buffer[*_lidx], p->physicalCellId_r16, _lidx);
	_serNrSysEncSQN_NR_SSB_Index_SQN_NR_SSB_InfoNcell_r16_ssb_IndexNcell_r16_Optional(_buffer, _size, _lidx, &p->ssb_IndexNcell_r16);
	_serNrSysEncSQN_NR_SSB_Configuration_r16_SQN_NR_SSB_InfoNcell_r16_ssb_Configuration_r16_Optional(_buffer, _size, _lidx, &p->ssb_Configuration_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncUint8_t_SQN_NR_DL_PRS_Info_r16_dl_PRS_ResourceId_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint8_t_SQN_NR_DL_PRS_Info_r16_dl_PRS_ResourceId_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_DL_PRS_Info_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_DL_PRS_Info_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->dl_PRS_ID_r16, _lidx);
	HTON_8(&_buffer[*_lidx], p->dl_PRS_ResourceSetId_r16, _lidx);
	_serNrSysEncUint8_t_SQN_NR_DL_PRS_Info_r16_dl_PRS_ResourceId_r16_Optional(_buffer, _size, _lidx, &p->dl_PRS_ResourceId_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SRS_PosResourceSet_r16_pathlossReferenceRS_Pos_r16_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SQN_NR_SRS_PosResourceSet_r16_pathlossReferenceRS_Pos_r16_Value* p, enum SQN_NR_SRS_PosResourceSet_r16_pathlossReferenceRS_Pos_r16_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SRS_PosResourceSet_r16_pathlossReferenceRS_Pos_r16_ssb_IndexServing_r16) {
		HTON_8(&_buffer[*_lidx], p->ssb_IndexServing_r16, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SRS_PosResourceSet_r16_pathlossReferenceRS_Pos_r16_ssb_Ncell_r16) {
		_serNrSysEncSQN_NR_SSB_InfoNcell_r16(_buffer, _size, _lidx, &p->ssb_Ncell_r16);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SRS_PosResourceSet_r16_pathlossReferenceRS_Pos_r16_dl_PRS_r16) {
		_serNrSysEncSQN_NR_DL_PRS_Info_r16(_buffer, _size, _lidx, &p->dl_PRS_r16);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncSQN_NR_SRS_PosResourceSet_r16_pathlossReferenceRS_Pos_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SRS_PosResourceSet_r16_pathlossReferenceRS_Pos_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_SRS_PosResourceSet_r16_pathlossReferenceRS_Pos_r16_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SRS_PosResourceSet_r16_pathlossReferenceRS_Pos_r16_pathlossReferenceRS_Pos_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SRS_PosResourceSet_r16_pathlossReferenceRS_Pos_r16_pathlossReferenceRS_Pos_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_SRS_PosResourceSet_r16_pathlossReferenceRS_Pos_r16(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SRS_PosResourceSet_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SRS_PosResourceSet_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->srs_PosResourceSetId_r16, _lidx);
	_serNrSysEncSQN_NR_SRS_PosResourceId_r16_SQN_NR_SRS_PosResourceSet_r16_srs_PosResourceIdList_r16_DynamicOptional(_buffer, _size, _lidx, &p->srs_PosResourceIdList_r16);
	_serNrSysEncSQN_NR_SRS_PosResourceSet_r16_resourceType_r16(_buffer, _size, _lidx, &p->resourceType_r16);
	_serNrSysEncSQN_NR_Alpha_e_SQN_NR_SRS_PosResourceSet_r16_alpha_r16_Optional(_buffer, _size, _lidx, &p->alpha_r16);
	_serNrSysEncInt16_t_SQN_NR_SRS_PosResourceSet_r16_p0_r16_Optional(_buffer, _size, _lidx, &p->p0_r16);
	_serNrSysEncSQN_NR_SRS_PosResourceSet_r16_pathlossReferenceRS_Pos_r16_pathlossReferenceRS_Pos_r16_Optional(_buffer, _size, _lidx, &p->pathlossReferenceRS_Pos_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SRS_PosResourceSet_r16_SQN_NR_SRS_Config_srs_PosResourceSetToAddModList_r16_DynamicOptional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SRS_PosResourceSet_r16_SQN_NR_SRS_Config_srs_PosResourceSetToAddModList_r16_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serNrSysEncSQN_NR_SRS_PosResourceSet_r16(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SRS_PosResourceId_r16_SQN_NR_SRS_Config_srs_PosResourceToReleaseList_r16_DynamicOptional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SRS_PosResourceId_r16_SQN_NR_SRS_Config_srs_PosResourceToReleaseList_r16_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		HTON_8(&_buffer[*_lidx], p->v.v[i2], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SRS_PosResource_r16_transmissionComb_r16_n2_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SRS_PosResource_r16_transmissionComb_r16_n2_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->combOffset_n2_r16, _lidx);
	HTON_8(&_buffer[*_lidx], p->cyclicShift_n2_r16, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SRS_PosResource_r16_transmissionComb_r16_n4_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SRS_PosResource_r16_transmissionComb_r16_n4_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->combOffset_n4_16, _lidx);
	HTON_8(&_buffer[*_lidx], p->cyclicShift_n4_r16, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SRS_PosResource_r16_transmissionComb_r16_n8_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SRS_PosResource_r16_transmissionComb_r16_n8_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->combOffset_n8_r16, _lidx);
	HTON_8(&_buffer[*_lidx], p->cyclicShift_n8_r16, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SRS_PosResource_r16_transmissionComb_r16_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SQN_NR_SRS_PosResource_r16_transmissionComb_r16_Value* p, enum SQN_NR_SRS_PosResource_r16_transmissionComb_r16_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SRS_PosResource_r16_transmissionComb_r16_n2_r16) {
		_serNrSysEncSQN_NR_SRS_PosResource_r16_transmissionComb_r16_n2_r16(_buffer, _size, _lidx, &p->n2_r16);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SRS_PosResource_r16_transmissionComb_r16_n4_r16) {
		_serNrSysEncSQN_NR_SRS_PosResource_r16_transmissionComb_r16_n4_r16(_buffer, _size, _lidx, &p->n4_r16);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SRS_PosResource_r16_transmissionComb_r16_n8_r16) {
		_serNrSysEncSQN_NR_SRS_PosResource_r16_transmissionComb_r16_n8_r16(_buffer, _size, _lidx, &p->n8_r16);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncSQN_NR_SRS_PosResource_r16_transmissionComb_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SRS_PosResource_r16_transmissionComb_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_SRS_PosResource_r16_transmissionComb_r16_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SRS_PosResource_r16_resourceMapping_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SRS_PosResource_r16_resourceMapping_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->startPosition_r16, _lidx);
	{
		size_t _tmp = (size_t)p->nrofSymbols_r16;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SRS_PosResource_r16_freqHopping_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SRS_PosResource_r16_freqHopping_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->c_SRS_r16, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncUint8_t_SQN_NR_SRS_PosResource_r16_resourceType_r16_aperiodic_r16_slotOffset_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint8_t_SQN_NR_SRS_PosResource_r16_resourceType_r16_aperiodic_r16_slotOffset_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SRS_PosResource_r16_resourceType_r16_aperiodic_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SRS_PosResource_r16_resourceType_r16_aperiodic_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncUint8_t_SQN_NR_SRS_PosResource_r16_resourceType_r16_aperiodic_r16_slotOffset_r16_Optional(_buffer, _size, _lidx, &p->slotOffset_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SRS_PeriodicityAndOffset_r16_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SQN_NR_SRS_PeriodicityAndOffset_r16_Value* p, enum SQN_NR_SRS_PeriodicityAndOffset_r16_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SRS_PeriodicityAndOffset_r16_sl1) {
		HTON_8(&_buffer[*_lidx], p->sl1, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SRS_PeriodicityAndOffset_r16_sl2) {
		HTON_8(&_buffer[*_lidx], p->sl2, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SRS_PeriodicityAndOffset_r16_sl4) {
		HTON_8(&_buffer[*_lidx], p->sl4, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SRS_PeriodicityAndOffset_r16_sl5) {
		HTON_8(&_buffer[*_lidx], p->sl5, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SRS_PeriodicityAndOffset_r16_sl8) {
		HTON_8(&_buffer[*_lidx], p->sl8, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SRS_PeriodicityAndOffset_r16_sl10) {
		HTON_8(&_buffer[*_lidx], p->sl10, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SRS_PeriodicityAndOffset_r16_sl16) {
		HTON_8(&_buffer[*_lidx], p->sl16, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SRS_PeriodicityAndOffset_r16_sl20) {
		HTON_8(&_buffer[*_lidx], p->sl20, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SRS_PeriodicityAndOffset_r16_sl32) {
		HTON_8(&_buffer[*_lidx], p->sl32, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SRS_PeriodicityAndOffset_r16_sl40) {
		HTON_8(&_buffer[*_lidx], p->sl40, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SRS_PeriodicityAndOffset_r16_sl64) {
		HTON_8(&_buffer[*_lidx], p->sl64, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SRS_PeriodicityAndOffset_r16_sl80) {
		HTON_8(&_buffer[*_lidx], p->sl80, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SRS_PeriodicityAndOffset_r16_sl160) {
		HTON_8(&_buffer[*_lidx], p->sl160, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SRS_PeriodicityAndOffset_r16_sl320) {
		HTON_16(&_buffer[*_lidx], p->sl320, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SRS_PeriodicityAndOffset_r16_sl640) {
		HTON_16(&_buffer[*_lidx], p->sl640, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SRS_PeriodicityAndOffset_r16_sl1280) {
		HTON_16(&_buffer[*_lidx], p->sl1280, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SRS_PeriodicityAndOffset_r16_sl2560) {
		HTON_16(&_buffer[*_lidx], p->sl2560, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SRS_PeriodicityAndOffset_r16_sl5120) {
		HTON_16(&_buffer[*_lidx], p->sl5120, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SRS_PeriodicityAndOffset_r16_sl10240) {
		HTON_16(&_buffer[*_lidx], p->sl10240, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SRS_PeriodicityAndOffset_r16_sl40960) {
		HTON_16(&_buffer[*_lidx], p->sl40960, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SRS_PeriodicityAndOffset_r16_sl81920) {
		HTON_32(&_buffer[*_lidx], p->sl81920, _lidx);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncSQN_NR_SRS_PeriodicityAndOffset_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SRS_PeriodicityAndOffset_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_SRS_PeriodicityAndOffset_r16_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SRS_PosResource_r16_resourceType_r16_semi_persistent_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SRS_PosResource_r16_resourceType_r16_semi_persistent_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncSQN_NR_SRS_PeriodicityAndOffset_r16(_buffer, _size, _lidx, &p->periodicityAndOffset_sp_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SRS_PosResource_r16_resourceType_r16_periodic_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SRS_PosResource_r16_resourceType_r16_periodic_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncSQN_NR_SRS_PeriodicityAndOffset_r16(_buffer, _size, _lidx, &p->periodicityAndOffset_p_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SRS_PosResource_r16_resourceType_r16_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SQN_NR_SRS_PosResource_r16_resourceType_r16_Value* p, enum SQN_NR_SRS_PosResource_r16_resourceType_r16_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SRS_PosResource_r16_resourceType_r16_aperiodic_r16) {
		_serNrSysEncSQN_NR_SRS_PosResource_r16_resourceType_r16_aperiodic_r16(_buffer, _size, _lidx, &p->aperiodic_r16);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SRS_PosResource_r16_resourceType_r16_semi_persistent_r16) {
		_serNrSysEncSQN_NR_SRS_PosResource_r16_resourceType_r16_semi_persistent_r16(_buffer, _size, _lidx, &p->semi_persistent_r16);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SRS_PosResource_r16_resourceType_r16_periodic_r16) {
		_serNrSysEncSQN_NR_SRS_PosResource_r16_resourceType_r16_periodic_r16(_buffer, _size, _lidx, &p->periodic_r16);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncSQN_NR_SRS_PosResource_r16_resourceType_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SRS_PosResource_r16_resourceType_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_SRS_PosResource_r16_resourceType_r16_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_ServCellIndex_SQN_NR_SRS_SpatialRelationInfoPos_r16_servingRS_r16_servingCellId_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_ServCellIndex_SQN_NR_SRS_SpatialRelationInfoPos_r16_servingRS_r16_servingCellId_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SRS_SpatialRelationInfoPos_r16_servingRS_r16_referenceSignal_r16_srs_SpatialRelation_r16resourceSelection_r16_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SQN_NR_SRS_SpatialRelationInfoPos_r16_servingRS_r16_referenceSignal_r16_srs_SpatialRelation_r16resourceSelection_r16_Value* p, enum SQN_NR_SRS_SpatialRelationInfoPos_r16_servingRS_r16_referenceSignal_r16_srs_SpatialRelation_r16resourceSelection_r16_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SRS_SpatialRelationInfoPos_r16_servingRS_r16_referenceSignal_r16_srs_SpatialRelation_r16resourceSelection_r16_srs_ResourceId_r16) {
		HTON_8(&_buffer[*_lidx], p->srs_ResourceId_r16, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SRS_SpatialRelationInfoPos_r16_servingRS_r16_referenceSignal_r16_srs_SpatialRelation_r16resourceSelection_r16_srs_PosResourceId_r16) {
		HTON_8(&_buffer[*_lidx], p->srs_PosResourceId_r16, _lidx);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncSQN_NR_SRS_SpatialRelationInfoPos_r16_servingRS_r16_referenceSignal_r16_srs_SpatialRelation_r16resourceSelection_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SRS_SpatialRelationInfoPos_r16_servingRS_r16_referenceSignal_r16_srs_SpatialRelation_r16resourceSelection_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_SRS_SpatialRelationInfoPos_r16_servingRS_r16_referenceSignal_r16_srs_SpatialRelation_r16resourceSelection_r16_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SRS_SpatialRelationInfoPos_r16_servingRS_r16_referenceSignal_r16_srs_SpatialRelation_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SRS_SpatialRelationInfoPos_r16_servingRS_r16_referenceSignal_r16_srs_SpatialRelation_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncSQN_NR_SRS_SpatialRelationInfoPos_r16_servingRS_r16_referenceSignal_r16_srs_SpatialRelation_r16resourceSelection_r16(_buffer, _size, _lidx, &p->resourceSelection_r16);
	HTON_8(&_buffer[*_lidx], p->uplinkBWP_r16, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SRS_SpatialRelationInfoPos_r16_servingRS_r16_referenceSignal_r16_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SQN_NR_SRS_SpatialRelationInfoPos_r16_servingRS_r16_referenceSignal_r16_Value* p, enum SQN_NR_SRS_SpatialRelationInfoPos_r16_servingRS_r16_referenceSignal_r16_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SRS_SpatialRelationInfoPos_r16_servingRS_r16_referenceSignal_r16_ssb_IndexServing_r16) {
		HTON_8(&_buffer[*_lidx], p->ssb_IndexServing_r16, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SRS_SpatialRelationInfoPos_r16_servingRS_r16_referenceSignal_r16_csi_RS_IndexServing_r16) {
		HTON_8(&_buffer[*_lidx], p->csi_RS_IndexServing_r16, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SRS_SpatialRelationInfoPos_r16_servingRS_r16_referenceSignal_r16_srs_SpatialRelation_r16) {
		_serNrSysEncSQN_NR_SRS_SpatialRelationInfoPos_r16_servingRS_r16_referenceSignal_r16_srs_SpatialRelation_r16(_buffer, _size, _lidx, &p->srs_SpatialRelation_r16);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncSQN_NR_SRS_SpatialRelationInfoPos_r16_servingRS_r16_referenceSignal_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SRS_SpatialRelationInfoPos_r16_servingRS_r16_referenceSignal_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_SRS_SpatialRelationInfoPos_r16_servingRS_r16_referenceSignal_r16_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SRS_SpatialRelationInfoPos_r16_servingRS_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SRS_SpatialRelationInfoPos_r16_servingRS_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncSQN_NR_ServCellIndex_SQN_NR_SRS_SpatialRelationInfoPos_r16_servingRS_r16_servingCellId_Optional(_buffer, _size, _lidx, &p->servingCellId);
	_serNrSysEncSQN_NR_SRS_SpatialRelationInfoPos_r16_servingRS_r16_referenceSignal_r16(_buffer, _size, _lidx, &p->referenceSignal_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SRS_SpatialRelationInfoPos_r16_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SQN_NR_SRS_SpatialRelationInfoPos_r16_Value* p, enum SQN_NR_SRS_SpatialRelationInfoPos_r16_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SRS_SpatialRelationInfoPos_r16_servingRS_r16) {
		_serNrSysEncSQN_NR_SRS_SpatialRelationInfoPos_r16_servingRS_r16(_buffer, _size, _lidx, &p->servingRS_r16);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SRS_SpatialRelationInfoPos_r16_ssb_Ncell_r16) {
		_serNrSysEncSQN_NR_SSB_InfoNcell_r16(_buffer, _size, _lidx, &p->ssb_Ncell_r16);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SRS_SpatialRelationInfoPos_r16_dl_PRS_r16) {
		_serNrSysEncSQN_NR_DL_PRS_Info_r16(_buffer, _size, _lidx, &p->dl_PRS_r16);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncSQN_NR_SRS_SpatialRelationInfoPos_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SRS_SpatialRelationInfoPos_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_SRS_SpatialRelationInfoPos_r16_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SRS_SpatialRelationInfoPos_r16_SQN_NR_SRS_PosResource_r16_spatialRelationInfoPos_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SRS_SpatialRelationInfoPos_r16_SQN_NR_SRS_PosResource_r16_spatialRelationInfoPos_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_SRS_SpatialRelationInfoPos_r16(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SRS_PosResource_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SRS_PosResource_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->srs_PosResourceId_r16, _lidx);
	_serNrSysEncSQN_NR_SRS_PosResource_r16_transmissionComb_r16(_buffer, _size, _lidx, &p->transmissionComb_r16);
	_serNrSysEncSQN_NR_SRS_PosResource_r16_resourceMapping_r16(_buffer, _size, _lidx, &p->resourceMapping_r16);
	HTON_16(&_buffer[*_lidx], p->freqDomainShift_r16, _lidx);
	_serNrSysEncSQN_NR_SRS_PosResource_r16_freqHopping_r16(_buffer, _size, _lidx, &p->freqHopping_r16);
	{
		size_t _tmp = (size_t)p->groupOrSequenceHopping_r16;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_SRS_PosResource_r16_resourceType_r16(_buffer, _size, _lidx, &p->resourceType_r16);
	HTON_16(&_buffer[*_lidx], p->sequenceId_r16, _lidx);
	_serNrSysEncSQN_NR_SRS_SpatialRelationInfoPos_r16_SQN_NR_SRS_PosResource_r16_spatialRelationInfoPos_r16_Optional(_buffer, _size, _lidx, &p->spatialRelationInfoPos_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SRS_PosResource_r16_SQN_NR_SRS_Config_srs_PosResourceToAddModList_r16_DynamicOptional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SRS_PosResource_r16_SQN_NR_SRS_Config_srs_PosResourceToAddModList_r16_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serNrSysEncSQN_NR_SRS_PosResource_r16(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SRS_Config(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SRS_Config* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncSQN_NR_SRS_ResourceSetId_SQN_NR_SRS_Config_srs_ResourceSetToReleaseList_DynamicOptional(_buffer, _size, _lidx, &p->srs_ResourceSetToReleaseList);
	_serNrSysEncSQN_NR_SRS_ResourceSet_SQN_NR_SRS_Config_srs_ResourceSetToAddModList_DynamicOptional(_buffer, _size, _lidx, &p->srs_ResourceSetToAddModList);
	_serNrSysEncSQN_NR_SRS_ResourceId_SQN_NR_SRS_Config_srs_ResourceToReleaseList_DynamicOptional(_buffer, _size, _lidx, &p->srs_ResourceToReleaseList);
	_serNrSysEncSQN_NR_SRS_Resource_SQN_NR_SRS_Config_srs_ResourceToAddModList_DynamicOptional(_buffer, _size, _lidx, &p->srs_ResourceToAddModList);
	_serNrSysEncSQN_NR_SRS_Config_tpc_Accumulation_e_tpc_Accumulation_Optional(_buffer, _size, _lidx, &p->tpc_Accumulation);
	_serNrSysEncUint8_t_SQN_NR_SRS_Config_srs_RequestDCI_1_2_r16_Optional(_buffer, _size, _lidx, &p->srs_RequestDCI_1_2_r16);
	_serNrSysEncUint8_t_SQN_NR_SRS_Config_srs_RequestDCI_0_2_r16_Optional(_buffer, _size, _lidx, &p->srs_RequestDCI_0_2_r16);
	_serNrSysEncSQN_NR_SRS_ResourceSet_SQN_NR_SRS_Config_srs_ResourceSetToAddModListDCI_0_2_r16_DynamicOptional(_buffer, _size, _lidx, &p->srs_ResourceSetToAddModListDCI_0_2_r16);
	_serNrSysEncSQN_NR_SRS_ResourceSetId_SQN_NR_SRS_Config_srs_ResourceSetToReleaseListDCI_0_2_r16_DynamicOptional(_buffer, _size, _lidx, &p->srs_ResourceSetToReleaseListDCI_0_2_r16);
	_serNrSysEncSQN_NR_SRS_PosResourceSetId_r16_SQN_NR_SRS_Config_srs_PosResourceSetToReleaseList_r16_DynamicOptional(_buffer, _size, _lidx, &p->srs_PosResourceSetToReleaseList_r16);
	_serNrSysEncSQN_NR_SRS_PosResourceSet_r16_SQN_NR_SRS_Config_srs_PosResourceSetToAddModList_r16_DynamicOptional(_buffer, _size, _lidx, &p->srs_PosResourceSetToAddModList_r16);
	_serNrSysEncSQN_NR_SRS_PosResourceId_r16_SQN_NR_SRS_Config_srs_PosResourceToReleaseList_r16_DynamicOptional(_buffer, _size, _lidx, &p->srs_PosResourceToReleaseList_r16);
	_serNrSysEncSQN_NR_SRS_PosResource_r16_SQN_NR_SRS_Config_srs_PosResourceToAddModList_r16_DynamicOptional(_buffer, _size, _lidx, &p->srs_PosResourceToAddModList_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SetupRelease_BWP_UplinkDedicated_srs_Config_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SQN_NR_SetupRelease_BWP_UplinkDedicated_srs_Config_Value* p, enum SQN_NR_SetupRelease_BWP_UplinkDedicated_srs_Config_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SetupRelease_BWP_UplinkDedicated_srs_Config_release) {
		HTON_8(&_buffer[*_lidx], p->release, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SetupRelease_BWP_UplinkDedicated_srs_Config_setup) {
		_serNrSysEncSQN_NR_SRS_Config(_buffer, _size, _lidx, &p->setup);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncSQN_NR_SetupRelease_BWP_UplinkDedicated_srs_Config(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SetupRelease_BWP_UplinkDedicated_srs_Config* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_SetupRelease_BWP_UplinkDedicated_srs_Config_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SetupRelease_BWP_UplinkDedicated_srs_Config_SQN_NR_BWP_UplinkDedicated_srs_Config_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SetupRelease_BWP_UplinkDedicated_srs_Config_SQN_NR_BWP_UplinkDedicated_srs_Config_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_SetupRelease_BWP_UplinkDedicated_srs_Config(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncUint8_t_SQN_NR_BeamFailureRecoveryConfig_rootSequenceIndex_BFR_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint8_t_SQN_NR_BeamFailureRecoveryConfig_rootSequenceIndex_BFR_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_RACH_ConfigGeneric_SQN_NR_BeamFailureRecoveryConfig_rach_ConfigBFR_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_RACH_ConfigGeneric_SQN_NR_BeamFailureRecoveryConfig_rach_ConfigBFR_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_RACH_ConfigGeneric(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_RSRP_Range_SQN_NR_BeamFailureRecoveryConfig_rsrp_ThresholdSSB_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_RSRP_Range_SQN_NR_BeamFailureRecoveryConfig_rsrp_ThresholdSSB_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_BFR_SSB_Resource(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_BFR_SSB_Resource* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->ssb, _lidx);
	HTON_8(&_buffer[*_lidx], p->ra_PreambleIndex, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncUint16_t_SQN_NR_BFR_CSIRS_Resource_ra_OccasionList_DynamicOptional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint16_t_SQN_NR_BFR_CSIRS_Resource_ra_OccasionList_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i3 = 0; i3 < p->v.d; i3++) {
		HTON_16(&_buffer[*_lidx], p->v.v[i3], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncUint8_t_SQN_NR_BFR_CSIRS_Resource_ra_PreambleIndex_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint8_t_SQN_NR_BFR_CSIRS_Resource_ra_PreambleIndex_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_BFR_CSIRS_Resource(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_BFR_CSIRS_Resource* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->csi_RS, _lidx);
	_serNrSysEncUint16_t_SQN_NR_BFR_CSIRS_Resource_ra_OccasionList_DynamicOptional(_buffer, _size, _lidx, &p->ra_OccasionList);
	_serNrSysEncUint8_t_SQN_NR_BFR_CSIRS_Resource_ra_PreambleIndex_Optional(_buffer, _size, _lidx, &p->ra_PreambleIndex);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PRACH_ResourceDedicatedBFR_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SQN_NR_PRACH_ResourceDedicatedBFR_Value* p, enum SQN_NR_PRACH_ResourceDedicatedBFR_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_PRACH_ResourceDedicatedBFR_ssb) {
		_serNrSysEncSQN_NR_BFR_SSB_Resource(_buffer, _size, _lidx, &p->ssb);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_PRACH_ResourceDedicatedBFR_csi_RS) {
		_serNrSysEncSQN_NR_BFR_CSIRS_Resource(_buffer, _size, _lidx, &p->csi_RS);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncSQN_NR_PRACH_ResourceDedicatedBFR(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PRACH_ResourceDedicatedBFR* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_PRACH_ResourceDedicatedBFR_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PRACH_ResourceDedicatedBFR_SQN_NR_BeamFailureRecoveryConfig_candidateBeamRSList_DynamicOptional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PRACH_ResourceDedicatedBFR_SQN_NR_BeamFailureRecoveryConfig_candidateBeamRSList_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serNrSysEncSQN_NR_PRACH_ResourceDedicatedBFR(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_BeamFailureRecoveryConfig_ssb_perRACH_Occasion_e_ssb_perRACH_Occasion_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_BeamFailureRecoveryConfig_ssb_perRACH_Occasion_e_ssb_perRACH_Occasion_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncUint8_t_SQN_NR_BeamFailureRecoveryConfig_ra_ssb_OccasionMaskIndex_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint8_t_SQN_NR_BeamFailureRecoveryConfig_ra_ssb_OccasionMaskIndex_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SearchSpaceId_SQN_NR_BeamFailureRecoveryConfig_recoverySearchSpaceId_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SearchSpaceId_SQN_NR_BeamFailureRecoveryConfig_recoverySearchSpaceId_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_RA_Prioritization_SQN_NR_BeamFailureRecoveryConfig_ra_Prioritization_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_RA_Prioritization_SQN_NR_BeamFailureRecoveryConfig_ra_Prioritization_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_RA_Prioritization(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_BeamFailureRecoveryConfig_beamFailureRecoveryTimer_e_beamFailureRecoveryTimer_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_BeamFailureRecoveryConfig_beamFailureRecoveryTimer_e_beamFailureRecoveryTimer_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SubcarrierSpacing_e_SQN_NR_BeamFailureRecoveryConfig_msg1_SubcarrierSpacing_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SubcarrierSpacing_e_SQN_NR_BeamFailureRecoveryConfig_msg1_SubcarrierSpacing_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_RA_Prioritization_SQN_NR_BeamFailureRecoveryConfig_ra_PrioritizationTwoStep_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_RA_Prioritization_SQN_NR_BeamFailureRecoveryConfig_ra_PrioritizationTwoStep_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_RA_Prioritization(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SetupRelease_BeamFailureRecoveryConfig_candidateBeamRSListExt_v1610_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SQN_NR_SetupRelease_BeamFailureRecoveryConfig_candidateBeamRSListExt_v1610_Value* p, enum SQN_NR_SetupRelease_BeamFailureRecoveryConfig_candidateBeamRSListExt_v1610_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SetupRelease_BeamFailureRecoveryConfig_candidateBeamRSListExt_v1610_release) {
		HTON_8(&_buffer[*_lidx], p->release, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SetupRelease_BeamFailureRecoveryConfig_candidateBeamRSListExt_v1610_setup) {
		HTON_32(&_buffer[*_lidx], p->setup.d, _lidx);
		for (size_t i2 = 0; i2 < p->setup.d; i2++) {
			_serNrSysEncSQN_NR_PRACH_ResourceDedicatedBFR(_buffer, _size, _lidx, &p->setup.v[i2]);
		}
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncSQN_NR_SetupRelease_BeamFailureRecoveryConfig_candidateBeamRSListExt_v1610(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SetupRelease_BeamFailureRecoveryConfig_candidateBeamRSListExt_v1610* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_SetupRelease_BeamFailureRecoveryConfig_candidateBeamRSListExt_v1610_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SetupRelease_BeamFailureRecoveryConfig_candidateBeamRSListExt_v1610_SQN_NR_BeamFailureRecoveryConfig_candidateBeamRSListExt_v1610_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SetupRelease_BeamFailureRecoveryConfig_candidateBeamRSListExt_v1610_SQN_NR_BeamFailureRecoveryConfig_candidateBeamRSListExt_v1610_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_SetupRelease_BeamFailureRecoveryConfig_candidateBeamRSListExt_v1610(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_BeamFailureRecoveryConfig(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_BeamFailureRecoveryConfig* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncUint8_t_SQN_NR_BeamFailureRecoveryConfig_rootSequenceIndex_BFR_Optional(_buffer, _size, _lidx, &p->rootSequenceIndex_BFR);
	_serNrSysEncSQN_NR_RACH_ConfigGeneric_SQN_NR_BeamFailureRecoveryConfig_rach_ConfigBFR_Optional(_buffer, _size, _lidx, &p->rach_ConfigBFR);
	_serNrSysEncSQN_NR_RSRP_Range_SQN_NR_BeamFailureRecoveryConfig_rsrp_ThresholdSSB_Optional(_buffer, _size, _lidx, &p->rsrp_ThresholdSSB);
	_serNrSysEncSQN_NR_PRACH_ResourceDedicatedBFR_SQN_NR_BeamFailureRecoveryConfig_candidateBeamRSList_DynamicOptional(_buffer, _size, _lidx, &p->candidateBeamRSList);
	_serNrSysEncSQN_NR_BeamFailureRecoveryConfig_ssb_perRACH_Occasion_e_ssb_perRACH_Occasion_Optional(_buffer, _size, _lidx, &p->ssb_perRACH_Occasion);
	_serNrSysEncUint8_t_SQN_NR_BeamFailureRecoveryConfig_ra_ssb_OccasionMaskIndex_Optional(_buffer, _size, _lidx, &p->ra_ssb_OccasionMaskIndex);
	_serNrSysEncSQN_NR_SearchSpaceId_SQN_NR_BeamFailureRecoveryConfig_recoverySearchSpaceId_Optional(_buffer, _size, _lidx, &p->recoverySearchSpaceId);
	_serNrSysEncSQN_NR_RA_Prioritization_SQN_NR_BeamFailureRecoveryConfig_ra_Prioritization_Optional(_buffer, _size, _lidx, &p->ra_Prioritization);
	_serNrSysEncSQN_NR_BeamFailureRecoveryConfig_beamFailureRecoveryTimer_e_beamFailureRecoveryTimer_Optional(_buffer, _size, _lidx, &p->beamFailureRecoveryTimer);
	_serNrSysEncSQN_NR_SubcarrierSpacing_e_SQN_NR_BeamFailureRecoveryConfig_msg1_SubcarrierSpacing_Optional(_buffer, _size, _lidx, &p->msg1_SubcarrierSpacing);
	_serNrSysEncSQN_NR_RA_Prioritization_SQN_NR_BeamFailureRecoveryConfig_ra_PrioritizationTwoStep_r16_Optional(_buffer, _size, _lidx, &p->ra_PrioritizationTwoStep_r16);
	_serNrSysEncSQN_NR_SetupRelease_BeamFailureRecoveryConfig_candidateBeamRSListExt_v1610_SQN_NR_BeamFailureRecoveryConfig_candidateBeamRSListExt_v1610_Optional(_buffer, _size, _lidx, &p->candidateBeamRSListExt_v1610);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SetupRelease_BWP_UplinkDedicated_beamFailureRecoveryConfig_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SQN_NR_SetupRelease_BWP_UplinkDedicated_beamFailureRecoveryConfig_Value* p, enum SQN_NR_SetupRelease_BWP_UplinkDedicated_beamFailureRecoveryConfig_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SetupRelease_BWP_UplinkDedicated_beamFailureRecoveryConfig_release) {
		HTON_8(&_buffer[*_lidx], p->release, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SetupRelease_BWP_UplinkDedicated_beamFailureRecoveryConfig_setup) {
		_serNrSysEncSQN_NR_BeamFailureRecoveryConfig(_buffer, _size, _lidx, &p->setup);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncSQN_NR_SetupRelease_BWP_UplinkDedicated_beamFailureRecoveryConfig(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SetupRelease_BWP_UplinkDedicated_beamFailureRecoveryConfig* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_SetupRelease_BWP_UplinkDedicated_beamFailureRecoveryConfig_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SetupRelease_BWP_UplinkDedicated_beamFailureRecoveryConfig_SQN_NR_BWP_UplinkDedicated_beamFailureRecoveryConfig_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SetupRelease_BWP_UplinkDedicated_beamFailureRecoveryConfig_SQN_NR_BWP_UplinkDedicated_beamFailureRecoveryConfig_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_SetupRelease_BWP_UplinkDedicated_beamFailureRecoveryConfig(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SetupRelease_BWP_UplinkDedicated_sl_PUCCH_Config_r16_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SQN_NR_SetupRelease_BWP_UplinkDedicated_sl_PUCCH_Config_r16_Value* p, enum SQN_NR_SetupRelease_BWP_UplinkDedicated_sl_PUCCH_Config_r16_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SetupRelease_BWP_UplinkDedicated_sl_PUCCH_Config_r16_release) {
		HTON_8(&_buffer[*_lidx], p->release, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SetupRelease_BWP_UplinkDedicated_sl_PUCCH_Config_r16_setup) {
		_serNrSysEncSQN_NR_PUCCH_Config(_buffer, _size, _lidx, &p->setup);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncSQN_NR_SetupRelease_BWP_UplinkDedicated_sl_PUCCH_Config_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SetupRelease_BWP_UplinkDedicated_sl_PUCCH_Config_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_SetupRelease_BWP_UplinkDedicated_sl_PUCCH_Config_r16_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SetupRelease_BWP_UplinkDedicated_sl_PUCCH_Config_r16_SQN_NR_BWP_UplinkDedicated_sl_PUCCH_Config_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SetupRelease_BWP_UplinkDedicated_sl_PUCCH_Config_r16_SQN_NR_BWP_UplinkDedicated_sl_PUCCH_Config_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_SetupRelease_BWP_UplinkDedicated_sl_PUCCH_Config_r16(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncUint8_t_SQN_NR_BWP_UplinkDedicated_cp_ExtensionC2_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint8_t_SQN_NR_BWP_UplinkDedicated_cp_ExtensionC2_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncUint8_t_SQN_NR_BWP_UplinkDedicated_cp_ExtensionC3_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint8_t_SQN_NR_BWP_UplinkDedicated_cp_ExtensionC3_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_BWP_UplinkDedicated_useInterlacePUCCH_PUSCH_r16_e_useInterlacePUCCH_PUSCH_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_BWP_UplinkDedicated_useInterlacePUCCH_PUSCH_r16_e_useInterlacePUCCH_PUSCH_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SetupRelease_BWP_UplinkDedicated_pucch_ConfigurationList_r16_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SQN_NR_SetupRelease_BWP_UplinkDedicated_pucch_ConfigurationList_r16_Value* p, enum SQN_NR_SetupRelease_BWP_UplinkDedicated_pucch_ConfigurationList_r16_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SetupRelease_BWP_UplinkDedicated_pucch_ConfigurationList_r16_release) {
		HTON_8(&_buffer[*_lidx], p->release, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SetupRelease_BWP_UplinkDedicated_pucch_ConfigurationList_r16_setup) {
		HTON_32(&_buffer[*_lidx], p->setup.d, _lidx);
		for (size_t i2 = 0; i2 < p->setup.d; i2++) {
			_serNrSysEncSQN_NR_PUCCH_Config(_buffer, _size, _lidx, &p->setup.v[i2]);
		}
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncSQN_NR_SetupRelease_BWP_UplinkDedicated_pucch_ConfigurationList_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SetupRelease_BWP_UplinkDedicated_pucch_ConfigurationList_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_SetupRelease_BWP_UplinkDedicated_pucch_ConfigurationList_r16_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SetupRelease_BWP_UplinkDedicated_pucch_ConfigurationList_r16_SQN_NR_BWP_UplinkDedicated_pucch_ConfigurationList_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SetupRelease_BWP_UplinkDedicated_pucch_ConfigurationList_r16_SQN_NR_BWP_UplinkDedicated_pucch_ConfigurationList_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_SetupRelease_BWP_UplinkDedicated_pucch_ConfigurationList_r16(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_LBT_FailureRecoveryConfig_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_LBT_FailureRecoveryConfig_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->lbt_FailureInstanceMaxCount_r16;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	{
		size_t _tmp = (size_t)p->lbt_FailureDetectionTimer_r16;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SetupRelease_BWP_UplinkDedicated_lbt_FailureRecoveryConfig_r16_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SQN_NR_SetupRelease_BWP_UplinkDedicated_lbt_FailureRecoveryConfig_r16_Value* p, enum SQN_NR_SetupRelease_BWP_UplinkDedicated_lbt_FailureRecoveryConfig_r16_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SetupRelease_BWP_UplinkDedicated_lbt_FailureRecoveryConfig_r16_release) {
		HTON_8(&_buffer[*_lidx], p->release, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SetupRelease_BWP_UplinkDedicated_lbt_FailureRecoveryConfig_r16_setup) {
		_serNrSysEncSQN_NR_LBT_FailureRecoveryConfig_r16(_buffer, _size, _lidx, &p->setup);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncSQN_NR_SetupRelease_BWP_UplinkDedicated_lbt_FailureRecoveryConfig_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SetupRelease_BWP_UplinkDedicated_lbt_FailureRecoveryConfig_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_SetupRelease_BWP_UplinkDedicated_lbt_FailureRecoveryConfig_r16_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SetupRelease_BWP_UplinkDedicated_lbt_FailureRecoveryConfig_r16_SQN_NR_BWP_UplinkDedicated_lbt_FailureRecoveryConfig_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SetupRelease_BWP_UplinkDedicated_lbt_FailureRecoveryConfig_r16_SQN_NR_BWP_UplinkDedicated_lbt_FailureRecoveryConfig_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_SetupRelease_BWP_UplinkDedicated_lbt_FailureRecoveryConfig_r16(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_ConfiguredGrantConfigToAddModList_r16_SQN_NR_BWP_UplinkDedicated_configuredGrantConfigToAddModList_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_ConfiguredGrantConfigToAddModList_r16_SQN_NR_BWP_UplinkDedicated_configuredGrantConfigToAddModList_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serNrSysEncSQN_NR_ConfiguredGrantConfig(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_ConfiguredGrantConfigToReleaseList_r16_SQN_NR_BWP_UplinkDedicated_configuredGrantConfigToReleaseList_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_ConfiguredGrantConfigToReleaseList_r16_SQN_NR_BWP_UplinkDedicated_configuredGrantConfigToReleaseList_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		HTON_8(&_buffer[*_lidx], p->v.v[i2], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_ConfiguredGrantConfigType2DeactivationStateList_r16_SQN_NR_BWP_UplinkDedicated_configuredGrantConfigType2DeactivationStateList_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_ConfiguredGrantConfigType2DeactivationStateList_r16_SQN_NR_BWP_UplinkDedicated_configuredGrantConfigType2DeactivationStateList_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		HTON_32(&_buffer[*_lidx], p->v.v[i2].d, _lidx);
		for (size_t i3 = 0; i3 < p->v.v[i2].d; i3++) {
			HTON_8(&_buffer[*_lidx], p->v.v[i2].v[i3], _lidx);
		}
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_BWP_UplinkDedicated(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_BWP_UplinkDedicated* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncSQN_NR_SetupRelease_BWP_UplinkDedicated_pucch_Config_SQN_NR_BWP_UplinkDedicated_pucch_Config_Optional(_buffer, _size, _lidx, &p->pucch_Config);
	_serNrSysEncSQN_NR_SetupRelease_BWP_UplinkDedicated_pusch_Config_SQN_NR_BWP_UplinkDedicated_pusch_Config_Optional(_buffer, _size, _lidx, &p->pusch_Config);
	_serNrSysEncSQN_NR_SetupRelease_BWP_UplinkDedicated_configuredGrantConfig_SQN_NR_BWP_UplinkDedicated_configuredGrantConfig_Optional(_buffer, _size, _lidx, &p->configuredGrantConfig);
	_serNrSysEncSQN_NR_SetupRelease_BWP_UplinkDedicated_srs_Config_SQN_NR_BWP_UplinkDedicated_srs_Config_Optional(_buffer, _size, _lidx, &p->srs_Config);
	_serNrSysEncSQN_NR_SetupRelease_BWP_UplinkDedicated_beamFailureRecoveryConfig_SQN_NR_BWP_UplinkDedicated_beamFailureRecoveryConfig_Optional(_buffer, _size, _lidx, &p->beamFailureRecoveryConfig);
	_serNrSysEncSQN_NR_SetupRelease_BWP_UplinkDedicated_sl_PUCCH_Config_r16_SQN_NR_BWP_UplinkDedicated_sl_PUCCH_Config_r16_Optional(_buffer, _size, _lidx, &p->sl_PUCCH_Config_r16);
	_serNrSysEncUint8_t_SQN_NR_BWP_UplinkDedicated_cp_ExtensionC2_r16_Optional(_buffer, _size, _lidx, &p->cp_ExtensionC2_r16);
	_serNrSysEncUint8_t_SQN_NR_BWP_UplinkDedicated_cp_ExtensionC3_r16_Optional(_buffer, _size, _lidx, &p->cp_ExtensionC3_r16);
	_serNrSysEncSQN_NR_BWP_UplinkDedicated_useInterlacePUCCH_PUSCH_r16_e_useInterlacePUCCH_PUSCH_r16_Optional(_buffer, _size, _lidx, &p->useInterlacePUCCH_PUSCH_r16);
	_serNrSysEncSQN_NR_SetupRelease_BWP_UplinkDedicated_pucch_ConfigurationList_r16_SQN_NR_BWP_UplinkDedicated_pucch_ConfigurationList_r16_Optional(_buffer, _size, _lidx, &p->pucch_ConfigurationList_r16);
	_serNrSysEncSQN_NR_SetupRelease_BWP_UplinkDedicated_lbt_FailureRecoveryConfig_r16_SQN_NR_BWP_UplinkDedicated_lbt_FailureRecoveryConfig_r16_Optional(_buffer, _size, _lidx, &p->lbt_FailureRecoveryConfig_r16);
	_serNrSysEncSQN_NR_ConfiguredGrantConfigToAddModList_r16_SQN_NR_BWP_UplinkDedicated_configuredGrantConfigToAddModList_r16_Optional(_buffer, _size, _lidx, &p->configuredGrantConfigToAddModList_r16);
	_serNrSysEncSQN_NR_ConfiguredGrantConfigToReleaseList_r16_SQN_NR_BWP_UplinkDedicated_configuredGrantConfigToReleaseList_r16_Optional(_buffer, _size, _lidx, &p->configuredGrantConfigToReleaseList_r16);
	_serNrSysEncSQN_NR_ConfiguredGrantConfigType2DeactivationStateList_r16_SQN_NR_BWP_UplinkDedicated_configuredGrantConfigType2DeactivationStateList_r16_Optional(_buffer, _size, _lidx, &p->configuredGrantConfigType2DeactivationStateList_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_ASN1_BWP_UplinkDedicated_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union NR_ASN1_BWP_UplinkDedicated_Type_Value* p, enum NR_ASN1_BWP_UplinkDedicated_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_ASN1_BWP_UplinkDedicated_Type_R15) {
		_serNrSysEncSQN_NR_BWP_UplinkDedicated(_buffer, _size, _lidx, &p->R15);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncNR_ASN1_BWP_UplinkDedicated_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_ASN1_BWP_UplinkDedicated_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncNR_ASN1_BWP_UplinkDedicated_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_ASN1_BWP_UplinkDedicated_Type_Dedicated_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_ASN1_BWP_UplinkDedicated_Type_Dedicated_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncNR_ASN1_BWP_UplinkDedicated_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_UplinkBWP_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_UplinkBWP_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncSQN_NR_BWP_Id_NR_UplinkBWP_Type_Id_Optional(_buffer, _size, _lidx, &p->Id);
	_serNrSysEncNR_ASN1_BWP_UplinkCommon_Type_Common_Optional(_buffer, _size, _lidx, &p->Common);
	_serNrSysEncNR_ASN1_BWP_UplinkDedicated_Type_Dedicated_Optional(_buffer, _size, _lidx, &p->Dedicated);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_UplinkBWP_List_Type_BwpArray_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_UplinkBWP_List_Type_BwpArray_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i1 = 0; i1 < p->v.d; i1++) {
		_serNrSysEncNR_UplinkBWP_Type(_buffer, _size, _lidx, &p->v.v[i1]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_UplinkBWPs_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_UplinkBWPs_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncNR_ActiveUplinkBWP_Id_Type_ActiveBWP_Optional(_buffer, _size, _lidx, &p->ActiveBWP);
	_serNrSysEncNR_UplinkBWP_List_Type_BwpArray_Optional(_buffer, _size, _lidx, &p->BwpArray);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_UplinkBWPs_Type_BWPs_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_UplinkBWPs_Type_BWPs_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncNR_UplinkBWPs_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_CFRA_occasions_ssb_perRACH_Occasion_e_ssb_perRACH_Occasion_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_CFRA_occasions_ssb_perRACH_Occasion_e_ssb_perRACH_Occasion_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_CFRA_occasions(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_CFRA_occasions* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncSQN_NR_RACH_ConfigGeneric(_buffer, _size, _lidx, &p->rach_ConfigGeneric);
	_serNrSysEncSQN_NR_CFRA_occasions_ssb_perRACH_Occasion_e_ssb_perRACH_Occasion_Optional(_buffer, _size, _lidx, &p->ssb_perRACH_Occasion);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_CFRA_occasions_occasions_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_CFRA_occasions_occasions_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_CFRA_occasions(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncUint16_t_SQN_NR_CFRA_SSB_Resource_msgA_PUSCH_resource_Index_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint16_t_SQN_NR_CFRA_SSB_Resource_msgA_PUSCH_resource_Index_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_16(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_CFRA_SSB_Resource(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_CFRA_SSB_Resource* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->ssb, _lidx);
	HTON_8(&_buffer[*_lidx], p->ra_PreambleIndex, _lidx);
	_serNrSysEncUint16_t_SQN_NR_CFRA_SSB_Resource_msgA_PUSCH_resource_Index_r16_Optional(_buffer, _size, _lidx, &p->msgA_PUSCH_resource_Index_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_CFRA_resources_ssb(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_CFRA_resources_ssb* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_32(&_buffer[*_lidx], p->ssb_ResourceList.d, _lidx);
	for (size_t i1 = 0; i1 < p->ssb_ResourceList.d; i1++) {
		_serNrSysEncSQN_NR_CFRA_SSB_Resource(_buffer, _size, _lidx, &p->ssb_ResourceList.v[i1]);
	}
	HTON_8(&_buffer[*_lidx], p->ra_ssb_OccasionMaskIndex, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_CFRA_CSIRS_Resource(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_CFRA_CSIRS_Resource* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->csi_RS, _lidx);
	HTON_32(&_buffer[*_lidx], p->ra_OccasionList.d, _lidx);
	for (size_t i2 = 0; i2 < p->ra_OccasionList.d; i2++) {
		HTON_16(&_buffer[*_lidx], p->ra_OccasionList.v[i2], _lidx);
	}
	HTON_8(&_buffer[*_lidx], p->ra_PreambleIndex, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_CFRA_resources_csirs(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_CFRA_resources_csirs* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_32(&_buffer[*_lidx], p->csirs_ResourceList.d, _lidx);
	for (size_t i1 = 0; i1 < p->csirs_ResourceList.d; i1++) {
		_serNrSysEncSQN_NR_CFRA_CSIRS_Resource(_buffer, _size, _lidx, &p->csirs_ResourceList.v[i1]);
	}
	HTON_8(&_buffer[*_lidx], p->rsrp_ThresholdCSI_RS, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_CFRA_resources_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SQN_NR_CFRA_resources_Value* p, enum SQN_NR_CFRA_resources_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_CFRA_resources_ssb) {
		_serNrSysEncSQN_NR_CFRA_resources_ssb(_buffer, _size, _lidx, &p->ssb);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_CFRA_resources_csirs) {
		_serNrSysEncSQN_NR_CFRA_resources_csirs(_buffer, _size, _lidx, &p->csirs);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncSQN_NR_CFRA_resources(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_CFRA_resources* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_CFRA_resources_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncUint8_t_SQN_NR_CFRA_totalNumberOfRA_Preambles_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint8_t_SQN_NR_CFRA_totalNumberOfRA_Preambles_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_CFRA(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_CFRA* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncSQN_NR_CFRA_occasions_occasions_Optional(_buffer, _size, _lidx, &p->occasions);
	_serNrSysEncSQN_NR_CFRA_resources(_buffer, _size, _lidx, &p->resources);
	_serNrSysEncUint8_t_SQN_NR_CFRA_totalNumberOfRA_Preambles_Optional(_buffer, _size, _lidx, &p->totalNumberOfRA_Preambles);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_CFRA_SQN_NR_RACH_ConfigDedicated_cfra_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_CFRA_SQN_NR_RACH_ConfigDedicated_cfra_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_CFRA(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_RA_Prioritization_SQN_NR_RACH_ConfigDedicated_ra_Prioritization_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_RA_Prioritization_SQN_NR_RACH_ConfigDedicated_ra_Prioritization_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_RA_Prioritization(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_RA_Prioritization_SQN_NR_RACH_ConfigDedicated_ra_PrioritizationTwoStep_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_RA_Prioritization_SQN_NR_RACH_ConfigDedicated_ra_PrioritizationTwoStep_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_RA_Prioritization(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_CFRA_TwoStep_r16_occasionsTwoStepRA_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_CFRA_TwoStep_r16_occasionsTwoStepRA_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncSQN_NR_RACH_ConfigGenericTwoStepRA_r16(_buffer, _size, _lidx, &p->rach_ConfigGenericTwoStepRA_r16);
	{
		size_t _tmp = (size_t)p->ssb_PerRACH_OccasionTwoStepRA_r16;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_CFRA_TwoStep_r16_occasionsTwoStepRA_r16_occasionsTwoStepRA_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_CFRA_TwoStep_r16_occasionsTwoStepRA_r16_occasionsTwoStepRA_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_CFRA_TwoStep_r16_occasionsTwoStepRA_r16(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_CFRA_TwoStep_r16_msgA_TransMax_r16_e_msgA_TransMax_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_CFRA_TwoStep_r16_msgA_TransMax_r16_e_msgA_TransMax_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_CFRA_TwoStep_r16_resourcesTwoStep_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_CFRA_TwoStep_r16_resourcesTwoStep_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_32(&_buffer[*_lidx], p->ssb_ResourceList.d, _lidx);
	for (size_t i1 = 0; i1 < p->ssb_ResourceList.d; i1++) {
		_serNrSysEncSQN_NR_CFRA_SSB_Resource(_buffer, _size, _lidx, &p->ssb_ResourceList.v[i1]);
	}
	HTON_8(&_buffer[*_lidx], p->ra_ssb_OccasionMaskIndex, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_CFRA_TwoStep_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_CFRA_TwoStep_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncSQN_NR_CFRA_TwoStep_r16_occasionsTwoStepRA_r16_occasionsTwoStepRA_r16_Optional(_buffer, _size, _lidx, &p->occasionsTwoStepRA_r16);
	_serNrSysEncSQN_NR_MsgA_PUSCH_Resource_r16(_buffer, _size, _lidx, &p->msgA_CFRA_PUSCH_r16);
	_serNrSysEncSQN_NR_CFRA_TwoStep_r16_msgA_TransMax_r16_e_msgA_TransMax_r16_Optional(_buffer, _size, _lidx, &p->msgA_TransMax_r16);
	_serNrSysEncSQN_NR_CFRA_TwoStep_r16_resourcesTwoStep_r16(_buffer, _size, _lidx, &p->resourcesTwoStep_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_CFRA_TwoStep_r16_SQN_NR_RACH_ConfigDedicated_cfra_TwoStep_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_CFRA_TwoStep_r16_SQN_NR_RACH_ConfigDedicated_cfra_TwoStep_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_CFRA_TwoStep_r16(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_RACH_ConfigDedicated(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_RACH_ConfigDedicated* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncSQN_NR_CFRA_SQN_NR_RACH_ConfigDedicated_cfra_Optional(_buffer, _size, _lidx, &p->cfra);
	_serNrSysEncSQN_NR_RA_Prioritization_SQN_NR_RACH_ConfigDedicated_ra_Prioritization_Optional(_buffer, _size, _lidx, &p->ra_Prioritization);
	_serNrSysEncSQN_NR_RA_Prioritization_SQN_NR_RACH_ConfigDedicated_ra_PrioritizationTwoStep_r16_Optional(_buffer, _size, _lidx, &p->ra_PrioritizationTwoStep_r16);
	_serNrSysEncSQN_NR_CFRA_TwoStep_r16_SQN_NR_RACH_ConfigDedicated_cfra_TwoStep_r16_Optional(_buffer, _size, _lidx, &p->cfra_TwoStep_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_ASN1_RACH_ConfigDedicated_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union NR_ASN1_RACH_ConfigDedicated_Type_Value* p, enum NR_ASN1_RACH_ConfigDedicated_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_ASN1_RACH_ConfigDedicated_Type_R15) {
		_serNrSysEncSQN_NR_RACH_ConfigDedicated(_buffer, _size, _lidx, &p->R15);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncNR_ASN1_RACH_ConfigDedicated_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_ASN1_RACH_ConfigDedicated_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncNR_ASN1_RACH_ConfigDedicated_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_ASN1_RACH_ConfigDedicated_Type_RACH_ConfigDedicated_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_ASN1_RACH_ConfigDedicated_Type_RACH_ConfigDedicated_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncNR_ASN1_RACH_ConfigDedicated_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SI_RequestConfig_rach_OccasionsSI(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SI_RequestConfig_rach_OccasionsSI* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncSQN_NR_RACH_ConfigGeneric(_buffer, _size, _lidx, &p->rach_ConfigSI);
	{
		size_t _tmp = (size_t)p->ssb_perRACH_Occasion;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SI_RequestConfig_rach_OccasionsSI_rach_OccasionsSI_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SI_RequestConfig_rach_OccasionsSI_rach_OccasionsSI_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_SI_RequestConfig_rach_OccasionsSI(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SI_RequestConfig_si_RequestPeriod_e_si_RequestPeriod_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SI_RequestConfig_si_RequestPeriod_e_si_RequestPeriod_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncUint8_t_SQN_NR_SI_RequestResources_ra_AssociationPeriodIndex_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint8_t_SQN_NR_SI_RequestResources_ra_AssociationPeriodIndex_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncUint8_t_SQN_NR_SI_RequestResources_ra_ssb_OccasionMaskIndex_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint8_t_SQN_NR_SI_RequestResources_ra_ssb_OccasionMaskIndex_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SI_RequestResources(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SI_RequestResources* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->ra_PreambleStartIndex, _lidx);
	_serNrSysEncUint8_t_SQN_NR_SI_RequestResources_ra_AssociationPeriodIndex_Optional(_buffer, _size, _lidx, &p->ra_AssociationPeriodIndex);
	_serNrSysEncUint8_t_SQN_NR_SI_RequestResources_ra_ssb_OccasionMaskIndex_Optional(_buffer, _size, _lidx, &p->ra_ssb_OccasionMaskIndex);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SI_RequestConfig(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SI_RequestConfig* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncSQN_NR_SI_RequestConfig_rach_OccasionsSI_rach_OccasionsSI_Optional(_buffer, _size, _lidx, &p->rach_OccasionsSI);
	_serNrSysEncSQN_NR_SI_RequestConfig_si_RequestPeriod_e_si_RequestPeriod_Optional(_buffer, _size, _lidx, &p->si_RequestPeriod);
	HTON_32(&_buffer[*_lidx], p->si_RequestResources.d, _lidx);
	for (size_t i1 = 0; i1 < p->si_RequestResources.d; i1++) {
		_serNrSysEncSQN_NR_SI_RequestResources(_buffer, _size, _lidx, &p->si_RequestResources.v[i1]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_ASN1_SI_RequestConfig_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union NR_ASN1_SI_RequestConfig_Type_Value* p, enum NR_ASN1_SI_RequestConfig_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_ASN1_SI_RequestConfig_Type_R15) {
		_serNrSysEncSQN_NR_SI_RequestConfig(_buffer, _size, _lidx, &p->R15);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncNR_ASN1_SI_RequestConfig_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_ASN1_SI_RequestConfig_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncNR_ASN1_SI_RequestConfig_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_ASN1_SI_RequestConfig_Type_SI_RequestConfig_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_ASN1_SI_RequestConfig_Type_SI_RequestConfig_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncNR_ASN1_SI_RequestConfig_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_UplinkConfig_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_UplinkConfig_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncNR_ASN1_FrequencyInfoUL_Type_FrequencyInfoUL_Optional(_buffer, _size, _lidx, &p->FrequencyInfoUL);
	_serNrSysEncNR_UplinkBWPs_Type_BWPs_Optional(_buffer, _size, _lidx, &p->BWPs);
	_serNrSysEncNR_ASN1_RACH_ConfigDedicated_Type_RACH_ConfigDedicated_Optional(_buffer, _size, _lidx, &p->RACH_ConfigDedicated);
	_serNrSysEncNR_ASN1_SI_RequestConfig_Type_SI_RequestConfig_Optional(_buffer, _size, _lidx, &p->SI_RequestConfig);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_Uplink_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union NR_Uplink_Type_Value* p, enum NR_Uplink_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_Uplink_Type_Config) {
		_serNrSysEncNR_UplinkConfig_Type(_buffer, _size, _lidx, &p->Config);
		return SIDL_STATUS_OK;
	}
	if (d == NR_Uplink_Type_None) {
		HTON_8(&_buffer[*_lidx], p->None, _lidx);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncNR_Uplink_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_Uplink_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncNR_Uplink_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_Uplink_Type_Uplink_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_Uplink_Type_Uplink_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncNR_Uplink_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_Uplink_Type_SupplementaryUplink_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_Uplink_Type_SupplementaryUplink_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncNR_Uplink_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_SS_TimingAdvanceConfig_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union NR_SS_TimingAdvanceConfig_Type_Value* p, enum NR_SS_TimingAdvanceConfig_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_SS_TimingAdvanceConfig_Type_InitialValue) {
		HTON_16(&_buffer[*_lidx], p->InitialValue, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == NR_SS_TimingAdvanceConfig_Type_Relative) {
		HTON_8(&_buffer[*_lidx], p->Relative, _lidx);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncNR_SS_TimingAdvanceConfig_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_SS_TimingAdvanceConfig_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncNR_SS_TimingAdvanceConfig_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_SS_TimingAdvanceConfig_Type_TimingAdvance_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_SS_TimingAdvanceConfig_Type_TimingAdvance_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncNR_SS_TimingAdvanceConfig_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PUSCH_CodeBlockGroupTransmission(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PUSCH_CodeBlockGroupTransmission* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->maxCodeBlockGroupsPerTransportBlock;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SetupRelease_PUSCH_ServingCellConfig_codeBlockGroupTransmission_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SQN_NR_SetupRelease_PUSCH_ServingCellConfig_codeBlockGroupTransmission_Value* p, enum SQN_NR_SetupRelease_PUSCH_ServingCellConfig_codeBlockGroupTransmission_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SetupRelease_PUSCH_ServingCellConfig_codeBlockGroupTransmission_release) {
		HTON_8(&_buffer[*_lidx], p->release, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SetupRelease_PUSCH_ServingCellConfig_codeBlockGroupTransmission_setup) {
		_serNrSysEncSQN_NR_PUSCH_CodeBlockGroupTransmission(_buffer, _size, _lidx, &p->setup);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncSQN_NR_SetupRelease_PUSCH_ServingCellConfig_codeBlockGroupTransmission(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SetupRelease_PUSCH_ServingCellConfig_codeBlockGroupTransmission* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_SetupRelease_PUSCH_ServingCellConfig_codeBlockGroupTransmission_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SetupRelease_PUSCH_ServingCellConfig_codeBlockGroupTransmission_SQN_NR_PUSCH_ServingCellConfig_codeBlockGroupTransmission_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SetupRelease_PUSCH_ServingCellConfig_codeBlockGroupTransmission_SQN_NR_PUSCH_ServingCellConfig_codeBlockGroupTransmission_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_SetupRelease_PUSCH_ServingCellConfig_codeBlockGroupTransmission(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PUSCH_ServingCellConfig_rateMatching_e_rateMatching_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PUSCH_ServingCellConfig_rateMatching_e_rateMatching_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PUSCH_ServingCellConfig_xOverhead_e_xOverhead_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PUSCH_ServingCellConfig_xOverhead_e_xOverhead_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncUint8_t_SQN_NR_PUSCH_ServingCellConfig_maxMIMO_Layers_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint8_t_SQN_NR_PUSCH_ServingCellConfig_maxMIMO_Layers_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncBool_SQN_NR_PUSCH_ServingCellConfig_processingType2Enabled_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct bool_SQN_NR_PUSCH_ServingCellConfig_processingType2Enabled_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SetupRelease_PUSCH_ServingCellConfig_maxMIMO_LayersDCI_0_2_r16_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SQN_NR_SetupRelease_PUSCH_ServingCellConfig_maxMIMO_LayersDCI_0_2_r16_Value* p, enum SQN_NR_SetupRelease_PUSCH_ServingCellConfig_maxMIMO_LayersDCI_0_2_r16_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SetupRelease_PUSCH_ServingCellConfig_maxMIMO_LayersDCI_0_2_r16_release) {
		HTON_8(&_buffer[*_lidx], p->release, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SetupRelease_PUSCH_ServingCellConfig_maxMIMO_LayersDCI_0_2_r16_setup) {
		HTON_8(&_buffer[*_lidx], p->setup, _lidx);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncSQN_NR_SetupRelease_PUSCH_ServingCellConfig_maxMIMO_LayersDCI_0_2_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SetupRelease_PUSCH_ServingCellConfig_maxMIMO_LayersDCI_0_2_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_SetupRelease_PUSCH_ServingCellConfig_maxMIMO_LayersDCI_0_2_r16_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SetupRelease_PUSCH_ServingCellConfig_maxMIMO_LayersDCI_0_2_r16_SQN_NR_PUSCH_ServingCellConfig_maxMIMO_LayersDCI_0_2_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SetupRelease_PUSCH_ServingCellConfig_maxMIMO_LayersDCI_0_2_r16_SQN_NR_PUSCH_ServingCellConfig_maxMIMO_LayersDCI_0_2_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_SetupRelease_PUSCH_ServingCellConfig_maxMIMO_LayersDCI_0_2_r16(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PUSCH_ServingCellConfig(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PUSCH_ServingCellConfig* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncSQN_NR_SetupRelease_PUSCH_ServingCellConfig_codeBlockGroupTransmission_SQN_NR_PUSCH_ServingCellConfig_codeBlockGroupTransmission_Optional(_buffer, _size, _lidx, &p->codeBlockGroupTransmission);
	_serNrSysEncSQN_NR_PUSCH_ServingCellConfig_rateMatching_e_rateMatching_Optional(_buffer, _size, _lidx, &p->rateMatching);
	_serNrSysEncSQN_NR_PUSCH_ServingCellConfig_xOverhead_e_xOverhead_Optional(_buffer, _size, _lidx, &p->xOverhead);
	_serNrSysEncUint8_t_SQN_NR_PUSCH_ServingCellConfig_maxMIMO_Layers_Optional(_buffer, _size, _lidx, &p->maxMIMO_Layers);
	_serNrSysEncBool_SQN_NR_PUSCH_ServingCellConfig_processingType2Enabled_Optional(_buffer, _size, _lidx, &p->processingType2Enabled);
	_serNrSysEncSQN_NR_SetupRelease_PUSCH_ServingCellConfig_maxMIMO_LayersDCI_0_2_r16_SQN_NR_PUSCH_ServingCellConfig_maxMIMO_LayersDCI_0_2_r16_Optional(_buffer, _size, _lidx, &p->maxMIMO_LayersDCI_0_2_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_ASN1_PUSCH_ServingCellConfig_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union NR_ASN1_PUSCH_ServingCellConfig_Type_Value* p, enum NR_ASN1_PUSCH_ServingCellConfig_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_ASN1_PUSCH_ServingCellConfig_Type_R15) {
		_serNrSysEncSQN_NR_PUSCH_ServingCellConfig(_buffer, _size, _lidx, &p->R15);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncNR_ASN1_PUSCH_ServingCellConfig_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_ASN1_PUSCH_ServingCellConfig_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncNR_ASN1_PUSCH_ServingCellConfig_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_ASN1_PUSCH_ServingCellConfig_Type_PUSCH_ServingCellConfig_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_ASN1_PUSCH_ServingCellConfig_Type_PUSCH_ServingCellConfig_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncNR_ASN1_PUSCH_ServingCellConfig_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_ASN1_PUSCH_ServingCellConfig_Type_PUSCH_ServingCellConfigSUL_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_ASN1_PUSCH_ServingCellConfig_Type_PUSCH_ServingCellConfigSUL_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncNR_ASN1_PUSCH_ServingCellConfig_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_CellConfigPhysicalLayerUplink_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_CellConfigPhysicalLayerUplink_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncNR_Uplink_Type_Uplink_Optional(_buffer, _size, _lidx, &p->Uplink);
	_serNrSysEncNR_Uplink_Type_SupplementaryUplink_Optional(_buffer, _size, _lidx, &p->SupplementaryUplink);
	_serNrSysEncNR_SS_TimingAdvanceConfig_Type_TimingAdvance_Optional(_buffer, _size, _lidx, &p->TimingAdvance);
	_serNrSysEncNR_ASN1_PUSCH_ServingCellConfig_Type_PUSCH_ServingCellConfig_Optional(_buffer, _size, _lidx, &p->PUSCH_ServingCellConfig);
	_serNrSysEncNR_ASN1_PUSCH_ServingCellConfig_Type_PUSCH_ServingCellConfigSUL_Optional(_buffer, _size, _lidx, &p->PUSCH_ServingCellConfigSUL);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_CellConfigPhysicalLayerUplink_Type_Uplink_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_CellConfigPhysicalLayerUplink_Type_Uplink_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncNR_CellConfigPhysicalLayerUplink_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_CellConfigPhysicalLayer_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_CellConfigPhysicalLayer_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncNR_CellConfigPhysicalLayerCommon_Type_Common_Optional(_buffer, _size, _lidx, &p->Common);
	_serNrSysEncNR_CellConfigPhysicalLayerDownlink_Type_Downlink_Optional(_buffer, _size, _lidx, &p->Downlink);
	_serNrSysEncNR_CellConfigPhysicalLayerUplink_Type_Uplink_Optional(_buffer, _size, _lidx, &p->Uplink);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_CellConfigPhysicalLayer_Type_PhysicalLayer_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_CellConfigPhysicalLayer_Type_PhysicalLayer_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncNR_CellConfigPhysicalLayer_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_BcchToPbchConfig_Type_Pbch_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_BcchToPbchConfig_Type_Pbch_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNull_Type_ActiveBWP_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct Null_Type_ActiveBWP_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNull_Type_InitialBWP_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct Null_Type_InitialBWP_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_AssignedBWPs_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_AssignedBWPs_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncNull_Type_ActiveBWP_Optional(_buffer, _size, _lidx, &p->ActiveBWP);
	_serNrSysEncNull_Type_InitialBWP_Optional(_buffer, _size, _lidx, &p->InitialBWP);
	HTON_32(&_buffer[*_lidx], p->DedicatedBWPs.d, _lidx);
	for (size_t i1 = 0; i1 < p->DedicatedBWPs.d; i1++) {
		HTON_8(&_buffer[*_lidx], p->DedicatedBWPs.v[i1], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_AssignedBWPs_Type_NR_SearchSpaceDlDciAssignment_Type_AssignedBWPs_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_AssignedBWPs_Type_NR_SearchSpaceDlDciAssignment_Type_AssignedBWPs_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncNR_AssignedBWPs_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_SearchSpaceType_Type_NR_SearchSpaceDlDciAssignment_Type_SearchSpaceType_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_SearchSpaceType_Type_NR_SearchSpaceDlDciAssignment_Type_SearchSpaceType_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_ResourceAllocationType_Type_NR_DciFormat_1_X_ResourceAssignment_Type_ResourceAllocationType_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_ResourceAllocationType_Type_NR_DciFormat_1_X_ResourceAssignment_Type_ResourceAllocationType_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_FreqDomainSchedulCommonDL_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_FreqDomainSchedulCommonDL_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_32(&_buffer[*_lidx], p->FirstRbIndex, _lidx);
	HTON_32(&_buffer[*_lidx], p->MaxRbCnt, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_FreqDomainSchedulExplicit_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_FreqDomainSchedulExplicit_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_32(&_buffer[*_lidx], p->FirstRbIndex, _lidx);
	HTON_32(&_buffer[*_lidx], p->Nprb, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_FreqDomainResourceAssignmentDL_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union NR_FreqDomainResourceAssignmentDL_Type_Value* p, enum NR_FreqDomainResourceAssignmentDL_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_FreqDomainResourceAssignmentDL_Type_Automatic) {
		_serNrSysEncNR_FreqDomainSchedulCommonDL_Type(_buffer, _size, _lidx, &p->Automatic);
		return SIDL_STATUS_OK;
	}
	if (d == NR_FreqDomainResourceAssignmentDL_Type_Explicit) {
		_serNrSysEncNR_FreqDomainSchedulExplicit_Type(_buffer, _size, _lidx, &p->Explicit);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncNR_FreqDomainResourceAssignmentDL_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_FreqDomainResourceAssignmentDL_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncNR_FreqDomainResourceAssignmentDL_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_FreqDomainResourceAssignmentDL_Type_FreqDomain_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_FreqDomainResourceAssignmentDL_Type_FreqDomain_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncNR_FreqDomainResourceAssignmentDL_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_DciCommon_TimeDomainResourceAssignment_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union NR_DciCommon_TimeDomainResourceAssignment_Type_Value* p, enum NR_DciCommon_TimeDomainResourceAssignment_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_DciCommon_TimeDomainResourceAssignment_Type_Index) {
		HTON_32(&_buffer[*_lidx], p->Index.d, _lidx);
		for (size_t i1 = 0; i1 < p->Index.d; i1++) {
			HTON_8(&_buffer[*_lidx], p->Index.v[i1], _lidx);
		}
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncNR_DciCommon_TimeDomainResourceAssignment_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_DciCommon_TimeDomainResourceAssignment_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncNR_DciCommon_TimeDomainResourceAssignment_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_DciCommon_TimeDomainResourceAssignment_Type_NR_DciFormat_1_X_ResourceAssignment_Type_TimeDomain_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_DciCommon_TimeDomainResourceAssignment_Type_NR_DciFormat_1_X_ResourceAssignment_Type_TimeDomain_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncNR_DciCommon_TimeDomainResourceAssignment_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_ModulationSchemePDSCH_Type_TransportBlock2_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_ModulationSchemePDSCH_Type_TransportBlock2_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_RedundancyVersionList_Type_RedundancyVersionList_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_RedundancyVersionList_Type_RedundancyVersionList_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i1 = 0; i1 < p->v.d; i1++) {
		HTON_8(&_buffer[*_lidx], p->v.v[i1], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_TransportBlockSchedulingDL_Automatic_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_TransportBlockSchedulingDL_Automatic_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->TransportBlock1;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncNR_ModulationSchemePDSCH_Type_TransportBlock2_Optional(_buffer, _size, _lidx, &p->TransportBlock2);
	_serNrSysEncNR_RedundancyVersionList_Type_RedundancyVersionList_Optional(_buffer, _size, _lidx, &p->RedundancyVersionList);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncRetransmissionTiming_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union RetransmissionTiming_Type_Value* p, enum RetransmissionTiming_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == RetransmissionTiming_Type_SlotOffset) {
		HTON_32(&_buffer[*_lidx], p->SlotOffset, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == RetransmissionTiming_Type_SubframeOffset) {
		HTON_32(&_buffer[*_lidx], p->SubframeOffset, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == RetransmissionTiming_Type_AnyTime) {
		HTON_8(&_buffer[*_lidx], p->AnyTime, _lidx);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncRetransmissionTiming_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct RetransmissionTiming_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncRetransmissionTiming_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncTransmissionTimingOffset_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union TransmissionTimingOffset_Type_Value* p, enum TransmissionTimingOffset_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == TransmissionTimingOffset_Type_None) {
		HTON_8(&_buffer[*_lidx], p->None, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == TransmissionTimingOffset_Type_Retransmission) {
		_serNrSysEncRetransmissionTiming_Type(_buffer, _size, _lidx, &p->Retransmission);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncTransmissionTimingOffset_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct TransmissionTimingOffset_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncTransmissionTimingOffset_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_TransportBlockSingleTransmission_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_TransportBlockSingleTransmission_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncTransmissionTimingOffset_Type(_buffer, _size, _lidx, &p->TimingOffset);
	HTON_8(&_buffer[*_lidx], p->ImcsValue, _lidx);
	HTON_8(&_buffer[*_lidx], p->RedundancyVersion, _lidx);
	HTON_8(&_buffer[*_lidx], p->ToggleNDI, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_TransportBlockRetransmissionList_Type_TransportBlock2_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_TransportBlockRetransmissionList_Type_TransportBlock2_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i1 = 0; i1 < p->v.d; i1++) {
		_serNrSysEncNR_TransportBlockSingleTransmission_Type(_buffer, _size, _lidx, &p->v.v[i1]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_TransportBlockSchedulingDL_Explicit_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_TransportBlockSchedulingDL_Explicit_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_32(&_buffer[*_lidx], p->TransportBlock1.d, _lidx);
	for (size_t i1 = 0; i1 < p->TransportBlock1.d; i1++) {
		_serNrSysEncNR_TransportBlockSingleTransmission_Type(_buffer, _size, _lidx, &p->TransportBlock1.v[i1]);
	}
	_serNrSysEncNR_TransportBlockRetransmissionList_Type_TransportBlock2_Optional(_buffer, _size, _lidx, &p->TransportBlock2);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_TransportBlockSchedulingDL_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union NR_TransportBlockSchedulingDL_Type_Value* p, enum NR_TransportBlockSchedulingDL_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_TransportBlockSchedulingDL_Type_Automatic) {
		_serNrSysEncNR_TransportBlockSchedulingDL_Automatic_Type(_buffer, _size, _lidx, &p->Automatic);
		return SIDL_STATUS_OK;
	}
	if (d == NR_TransportBlockSchedulingDL_Type_Explicit) {
		_serNrSysEncNR_TransportBlockSchedulingDL_Explicit_Type(_buffer, _size, _lidx, &p->Explicit);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncNR_TransportBlockSchedulingDL_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_TransportBlockSchedulingDL_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncNR_TransportBlockSchedulingDL_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_TransportBlockSchedulingDL_Type_TransportBlockScheduling_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_TransportBlockSchedulingDL_Type_TransportBlockScheduling_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncNR_TransportBlockSchedulingDL_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_HarqProcessConfig_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union NR_HarqProcessConfig_Type_Value* p, enum NR_HarqProcessConfig_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_HarqProcessConfig_Type_None) {
		HTON_8(&_buffer[*_lidx], p->None, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == NR_HarqProcessConfig_Type_Broadcast) {
		HTON_8(&_buffer[*_lidx], p->Broadcast, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == NR_HarqProcessConfig_Type_AnyProcess) {
		HTON_8(&_buffer[*_lidx], p->AnyProcess, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == NR_HarqProcessConfig_Type_SpecificSubset) {
		HTON_32(&_buffer[*_lidx], p->SpecificSubset.d, _lidx);
		for (size_t i1 = 0; i1 < p->SpecificSubset.d; i1++) {
			HTON_32(&_buffer[*_lidx], p->SpecificSubset.v[i1], _lidx);
		}
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncNR_HarqProcessConfig_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_HarqProcessConfig_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncNR_HarqProcessConfig_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_HarqProcessConfig_Type_NR_DciFormat_1_X_ResourceAssignment_Type_HarqProcessConfig_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_HarqProcessConfig_Type_NR_DciFormat_1_X_ResourceAssignment_Type_HarqProcessConfig_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncNR_HarqProcessConfig_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_DciFormat_1_X_ResourceAssignment_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_DciFormat_1_X_ResourceAssignment_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncNR_ResourceAllocationType_Type_NR_DciFormat_1_X_ResourceAssignment_Type_ResourceAllocationType_Optional(_buffer, _size, _lidx, &p->ResourceAllocationType);
	_serNrSysEncNR_FreqDomainResourceAssignmentDL_Type_FreqDomain_Optional(_buffer, _size, _lidx, &p->FreqDomain);
	_serNrSysEncNR_DciCommon_TimeDomainResourceAssignment_Type_NR_DciFormat_1_X_ResourceAssignment_Type_TimeDomain_Optional(_buffer, _size, _lidx, &p->TimeDomain);
	_serNrSysEncNR_TransportBlockSchedulingDL_Type_TransportBlockScheduling_Optional(_buffer, _size, _lidx, &p->TransportBlockScheduling);
	_serNrSysEncNR_HarqProcessConfig_Type_NR_DciFormat_1_X_ResourceAssignment_Type_HarqProcessConfig_Optional(_buffer, _size, _lidx, &p->HarqProcessConfig);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_DciFormat_1_X_ResourceAssignment_Type_ResoureAssignment_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_DciFormat_1_X_ResourceAssignment_Type_ResoureAssignment_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncNR_DciFormat_1_X_ResourceAssignment_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_DciCommon_VrbPrbMapping_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union NR_DciCommon_VrbPrbMapping_Type_Value* p, enum NR_DciCommon_VrbPrbMapping_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_DciCommon_VrbPrbMapping_Type_None) {
		HTON_8(&_buffer[*_lidx], p->None, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == NR_DciCommon_VrbPrbMapping_Type_Index) {
		for (size_t i1 = 0; i1 < 1; i1++) {
			HTON_8(&_buffer[*_lidx], p->Index[i1], _lidx);
		}
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncNR_DciCommon_VrbPrbMapping_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_DciCommon_VrbPrbMapping_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncNR_DciCommon_VrbPrbMapping_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_DciCommon_VrbPrbMapping_Type_VrbPrbMapping_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_DciCommon_VrbPrbMapping_Type_VrbPrbMapping_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncNR_DciCommon_VrbPrbMapping_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncDAI_B2_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union DAI_B2_Type_Value* p, enum DAI_B2_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == DAI_B2_Type_Index) {
		for (size_t i1 = 0; i1 < 2; i1++) {
			HTON_8(&_buffer[*_lidx], p->Index[i1], _lidx);
		}
		return SIDL_STATUS_OK;
	}
	if (d == DAI_B2_Type_Automatic) {
		HTON_8(&_buffer[*_lidx], p->Automatic, _lidx);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncDAI_B2_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct DAI_B2_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncDAI_B2_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_DciFormat_1_0_DAI_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union NR_DciFormat_1_0_DAI_Type_Value* p, enum NR_DciFormat_1_0_DAI_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_DciFormat_1_0_DAI_Type_Index) {
		_serNrSysEncDAI_B2_Type(_buffer, _size, _lidx, &p->Index);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncNR_DciFormat_1_0_DAI_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_DciFormat_1_0_DAI_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncNR_DciFormat_1_0_DAI_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_DciFormat_1_0_DAI_Type_DAI_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_DciFormat_1_0_DAI_Type_DAI_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncNR_DciFormat_1_0_DAI_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_DciCommon_TpcCommand_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union NR_DciCommon_TpcCommand_Type_Value* p, enum NR_DciCommon_TpcCommand_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_DciCommon_TpcCommand_Type_Value) {
		for (size_t i1 = 0; i1 < 2; i1++) {
			HTON_8(&_buffer[*_lidx], p->Value[i1], _lidx);
		}
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncNR_DciCommon_TpcCommand_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_DciCommon_TpcCommand_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncNR_DciCommon_TpcCommand_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_DciCommon_TpcCommand_Type_NR_DciFormat_1_0_SpecificInfo_Type_TpcCommandPucch_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_DciCommon_TpcCommand_Type_NR_DciFormat_1_0_SpecificInfo_Type_TpcCommandPucch_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncNR_DciCommon_TpcCommand_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_DciFormat_1_X_PucchResourceIndicator_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union NR_DciFormat_1_X_PucchResourceIndicator_Type_Value* p, enum NR_DciFormat_1_X_PucchResourceIndicator_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_DciFormat_1_X_PucchResourceIndicator_Type_Value) {
		for (size_t i1 = 0; i1 < 3; i1++) {
			HTON_8(&_buffer[*_lidx], p->Value[i1], _lidx);
		}
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncNR_DciFormat_1_X_PucchResourceIndicator_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_DciFormat_1_X_PucchResourceIndicator_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncNR_DciFormat_1_X_PucchResourceIndicator_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_DciFormat_1_X_PucchResourceIndicator_Type_NR_DciFormat_1_0_SpecificInfo_Type_PucchResourceIndicator_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_DciFormat_1_X_PucchResourceIndicator_Type_NR_DciFormat_1_0_SpecificInfo_Type_PucchResourceIndicator_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncNR_DciFormat_1_X_PucchResourceIndicator_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_DciFormat_1_X_PdschHarqTimingIndicator_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union NR_DciFormat_1_X_PdschHarqTimingIndicator_Type_Value* p, enum NR_DciFormat_1_X_PdschHarqTimingIndicator_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_DciFormat_1_X_PdschHarqTimingIndicator_Type_Value) {
		HTON_32(&_buffer[*_lidx], p->Value.d, _lidx);
		for (size_t i1 = 0; i1 < p->Value.d; i1++) {
			HTON_8(&_buffer[*_lidx], p->Value.v[i1], _lidx);
		}
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncNR_DciFormat_1_X_PdschHarqTimingIndicator_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_DciFormat_1_X_PdschHarqTimingIndicator_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncNR_DciFormat_1_X_PdschHarqTimingIndicator_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_DciFormat_1_X_PdschHarqTimingIndicator_Type_NR_DciFormat_1_0_SpecificInfo_Type_PdschHarqTimingIndicator_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_DciFormat_1_X_PdschHarqTimingIndicator_Type_NR_DciFormat_1_0_SpecificInfo_Type_PdschHarqTimingIndicator_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncNR_DciFormat_1_X_PdschHarqTimingIndicator_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_DciFormat_X_0_ChannelAccessCPext_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union NR_DciFormat_X_0_ChannelAccessCPext_Type_Value* p, enum NR_DciFormat_X_0_ChannelAccessCPext_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_DciFormat_X_0_ChannelAccessCPext_Type_None) {
		HTON_8(&_buffer[*_lidx], p->None, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == NR_DciFormat_X_0_ChannelAccessCPext_Type_Value) {
		for (size_t i1 = 0; i1 < 2; i1++) {
			HTON_8(&_buffer[*_lidx], p->Value[i1], _lidx);
		}
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncNR_DciFormat_X_0_ChannelAccessCPext_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_DciFormat_X_0_ChannelAccessCPext_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncNR_DciFormat_X_0_ChannelAccessCPext_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_DciFormat_X_0_ChannelAccessCPext_Type_NR_DciFormat_1_0_SpecificInfo_Type_ChannelAccessCPext_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_DciFormat_X_0_ChannelAccessCPext_Type_NR_DciFormat_1_0_SpecificInfo_Type_ChannelAccessCPext_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncNR_DciFormat_X_0_ChannelAccessCPext_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_DciFormat_1_0_SpecificInfo_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_DciFormat_1_0_SpecificInfo_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncNR_DciFormat_1_0_DAI_Type_DAI_Optional(_buffer, _size, _lidx, &p->DAI);
	_serNrSysEncNR_DciCommon_TpcCommand_Type_NR_DciFormat_1_0_SpecificInfo_Type_TpcCommandPucch_Optional(_buffer, _size, _lidx, &p->TpcCommandPucch);
	_serNrSysEncNR_DciFormat_1_X_PucchResourceIndicator_Type_NR_DciFormat_1_0_SpecificInfo_Type_PucchResourceIndicator_Optional(_buffer, _size, _lidx, &p->PucchResourceIndicator);
	_serNrSysEncNR_DciFormat_1_X_PdschHarqTimingIndicator_Type_NR_DciFormat_1_0_SpecificInfo_Type_PdschHarqTimingIndicator_Optional(_buffer, _size, _lidx, &p->PdschHarqTimingIndicator);
	_serNrSysEncNR_DciFormat_X_0_ChannelAccessCPext_Type_NR_DciFormat_1_0_SpecificInfo_Type_ChannelAccessCPext_Optional(_buffer, _size, _lidx, &p->ChannelAccessCPext);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncB2_Type_NR_DciFormat_1_0_P_RNTI_SpecificInfo_Type_ShortMessageIndicator_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct B2_Type_NR_DciFormat_1_0_P_RNTI_SpecificInfo_Type_ShortMessageIndicator_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	for (size_t i1 = 0; i1 < 2; i1++) {
		HTON_8(&_buffer[*_lidx], p->v[i1], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncB8_Type_NR_DciFormat_1_0_P_RNTI_SpecificInfo_Type_ShortMessages_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct B8_Type_NR_DciFormat_1_0_P_RNTI_SpecificInfo_Type_ShortMessages_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	for (size_t i1 = 0; i1 < 8; i1++) {
		HTON_8(&_buffer[*_lidx], p->v[i1], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncB2_Type_NR_DciFormat_1_0_P_RNTI_SpecificInfo_Type_TbScaling_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct B2_Type_NR_DciFormat_1_0_P_RNTI_SpecificInfo_Type_TbScaling_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	for (size_t i1 = 0; i1 < 2; i1++) {
		HTON_8(&_buffer[*_lidx], p->v[i1], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_DciFormat_1_0_P_RNTI_SpecificInfo_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_DciFormat_1_0_P_RNTI_SpecificInfo_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncB2_Type_NR_DciFormat_1_0_P_RNTI_SpecificInfo_Type_ShortMessageIndicator_Optional(_buffer, _size, _lidx, &p->ShortMessageIndicator);
	_serNrSysEncB8_Type_NR_DciFormat_1_0_P_RNTI_SpecificInfo_Type_ShortMessages_Optional(_buffer, _size, _lidx, &p->ShortMessages);
	_serNrSysEncB2_Type_NR_DciFormat_1_0_P_RNTI_SpecificInfo_Type_TbScaling_Optional(_buffer, _size, _lidx, &p->TbScaling);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncB1_Type_NR_DciFormat_1_0_SI_RNTI_SpecificInfo_Type_SystemInfoIndicator_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct B1_Type_NR_DciFormat_1_0_SI_RNTI_SpecificInfo_Type_SystemInfoIndicator_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	for (size_t i1 = 0; i1 < 1; i1++) {
		HTON_8(&_buffer[*_lidx], p->v[i1], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_DciFormat_1_0_SI_RNTI_SpecificInfo_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_DciFormat_1_0_SI_RNTI_SpecificInfo_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncB1_Type_NR_DciFormat_1_0_SI_RNTI_SpecificInfo_Type_SystemInfoIndicator_Optional(_buffer, _size, _lidx, &p->SystemInfoIndicator);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncB2_Type_NR_DciFormat_1_0_RA_RNTI_SpecificInfo_Type_TbScaling_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct B2_Type_NR_DciFormat_1_0_RA_RNTI_SpecificInfo_Type_TbScaling_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	for (size_t i1 = 0; i1 < 2; i1++) {
		HTON_8(&_buffer[*_lidx], p->v[i1], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_DciFormat_1_0_LSBsOfSFN_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union NR_DciFormat_1_0_LSBsOfSFN_Type_Value* p, enum NR_DciFormat_1_0_LSBsOfSFN_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_DciFormat_1_0_LSBsOfSFN_Type_None) {
		HTON_8(&_buffer[*_lidx], p->None, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == NR_DciFormat_1_0_LSBsOfSFN_Type_Automatic) {
		HTON_8(&_buffer[*_lidx], p->Automatic, _lidx);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncNR_DciFormat_1_0_LSBsOfSFN_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_DciFormat_1_0_LSBsOfSFN_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncNR_DciFormat_1_0_LSBsOfSFN_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_DciFormat_1_0_LSBsOfSFN_Type_LSBsOfSFN_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_DciFormat_1_0_LSBsOfSFN_Type_LSBsOfSFN_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncNR_DciFormat_1_0_LSBsOfSFN_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_DciFormat_1_0_RA_RNTI_SpecificInfo_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_DciFormat_1_0_RA_RNTI_SpecificInfo_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncB2_Type_NR_DciFormat_1_0_RA_RNTI_SpecificInfo_Type_TbScaling_Optional(_buffer, _size, _lidx, &p->TbScaling);
	_serNrSysEncNR_DciFormat_1_0_LSBsOfSFN_Type_LSBsOfSFN_Optional(_buffer, _size, _lidx, &p->LSBsOfSFN);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_DciCommon_CarrierIndicator_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union NR_DciCommon_CarrierIndicator_Type_Value* p, enum NR_DciCommon_CarrierIndicator_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_DciCommon_CarrierIndicator_Type_None) {
		HTON_8(&_buffer[*_lidx], p->None, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == NR_DciCommon_CarrierIndicator_Type_CellIndex) {
		for (size_t i1 = 0; i1 < 3; i1++) {
			HTON_8(&_buffer[*_lidx], p->CellIndex[i1], _lidx);
		}
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncNR_DciCommon_CarrierIndicator_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_DciCommon_CarrierIndicator_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncNR_DciCommon_CarrierIndicator_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_DciCommon_CarrierIndicator_Type_NR_DciFormat_1_1_SpecificInfo_Type_CarrierIndicator_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_DciCommon_CarrierIndicator_Type_NR_DciFormat_1_1_SpecificInfo_Type_CarrierIndicator_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncNR_DciCommon_CarrierIndicator_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_DciCommon_BWPIndicator_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union NR_DciCommon_BWPIndicator_Type_Value* p, enum NR_DciCommon_BWPIndicator_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_DciCommon_BWPIndicator_Type_Index) {
		HTON_32(&_buffer[*_lidx], p->Index.d, _lidx);
		for (size_t i1 = 0; i1 < p->Index.d; i1++) {
			HTON_8(&_buffer[*_lidx], p->Index.v[i1], _lidx);
		}
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncNR_DciCommon_BWPIndicator_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_DciCommon_BWPIndicator_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncNR_DciCommon_BWPIndicator_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_DciCommon_BWPIndicator_Type_NR_DciFormat_1_1_SpecificInfo_Type_BWPIndicator_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_DciCommon_BWPIndicator_Type_NR_DciFormat_1_1_SpecificInfo_Type_BWPIndicator_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncNR_DciCommon_BWPIndicator_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_DciFormat_1_1_PrbBundlingSizeIndicator_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union NR_DciFormat_1_1_PrbBundlingSizeIndicator_Type_Value* p, enum NR_DciFormat_1_1_PrbBundlingSizeIndicator_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_DciFormat_1_1_PrbBundlingSizeIndicator_Type_None) {
		HTON_8(&_buffer[*_lidx], p->None, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == NR_DciFormat_1_1_PrbBundlingSizeIndicator_Type_Dynamic) {
		for (size_t i1 = 0; i1 < 1; i1++) {
			HTON_8(&_buffer[*_lidx], p->Dynamic[i1], _lidx);
		}
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncNR_DciFormat_1_1_PrbBundlingSizeIndicator_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_DciFormat_1_1_PrbBundlingSizeIndicator_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncNR_DciFormat_1_1_PrbBundlingSizeIndicator_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_DciFormat_1_1_PrbBundlingSizeIndicator_Type_PrbBundlingSizeIndicator_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_DciFormat_1_1_PrbBundlingSizeIndicator_Type_PrbBundlingSizeIndicator_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncNR_DciFormat_1_1_PrbBundlingSizeIndicator_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_DciFormat_1_1_RateMatchingIndicator_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union NR_DciFormat_1_1_RateMatchingIndicator_Type_Value* p, enum NR_DciFormat_1_1_RateMatchingIndicator_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_DciFormat_1_1_RateMatchingIndicator_Type_Bitmap) {
		HTON_32(&_buffer[*_lidx], p->Bitmap.d, _lidx);
		for (size_t i1 = 0; i1 < p->Bitmap.d; i1++) {
			HTON_8(&_buffer[*_lidx], p->Bitmap.v[i1], _lidx);
		}
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncNR_DciFormat_1_1_RateMatchingIndicator_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_DciFormat_1_1_RateMatchingIndicator_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncNR_DciFormat_1_1_RateMatchingIndicator_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_DciFormat_1_1_RateMatchingIndicator_Type_RateMatchingIndicator_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_DciFormat_1_1_RateMatchingIndicator_Type_RateMatchingIndicator_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncNR_DciFormat_1_1_RateMatchingIndicator_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_DciFormat_1_1_ZP_CSI_RS_Trigger_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union NR_DciFormat_1_1_ZP_CSI_RS_Trigger_Type_Value* p, enum NR_DciFormat_1_1_ZP_CSI_RS_Trigger_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_DciFormat_1_1_ZP_CSI_RS_Trigger_Type_Index) {
		HTON_32(&_buffer[*_lidx], p->Index.d, _lidx);
		for (size_t i1 = 0; i1 < p->Index.d; i1++) {
			HTON_8(&_buffer[*_lidx], p->Index.v[i1], _lidx);
		}
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncNR_DciFormat_1_1_ZP_CSI_RS_Trigger_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_DciFormat_1_1_ZP_CSI_RS_Trigger_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncNR_DciFormat_1_1_ZP_CSI_RS_Trigger_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_DciFormat_1_1_ZP_CSI_RS_Trigger_Type_ZP_CSI_RS_Trigger_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_DciFormat_1_1_ZP_CSI_RS_Trigger_Type_ZP_CSI_RS_Trigger_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncNR_DciFormat_1_1_ZP_CSI_RS_Trigger_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncDAI_B4_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union DAI_B4_Type_Value* p, enum DAI_B4_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == DAI_B4_Type_Index) {
		for (size_t i1 = 0; i1 < 4; i1++) {
			HTON_8(&_buffer[*_lidx], p->Index[i1], _lidx);
		}
		return SIDL_STATUS_OK;
	}
	if (d == DAI_B4_Type_Automatic) {
		HTON_8(&_buffer[*_lidx], p->Automatic, _lidx);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncDAI_B4_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct DAI_B4_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncDAI_B4_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncDAI_B6_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union DAI_B6_Type_Value* p, enum DAI_B6_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == DAI_B6_Type_Index) {
		for (size_t i1 = 0; i1 < 6; i1++) {
			HTON_8(&_buffer[*_lidx], p->Index[i1], _lidx);
		}
		return SIDL_STATUS_OK;
	}
	if (d == DAI_B6_Type_Automatic) {
		HTON_8(&_buffer[*_lidx], p->Automatic, _lidx);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncDAI_B6_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct DAI_B6_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncDAI_B6_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_DciFormat_1_1_DAI_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union NR_DciFormat_1_1_DAI_Type_Value* p, enum NR_DciFormat_1_1_DAI_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_DciFormat_1_1_DAI_Type_None) {
		HTON_8(&_buffer[*_lidx], p->None, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == NR_DciFormat_1_1_DAI_Type_TwoBits) {
		_serNrSysEncDAI_B2_Type(_buffer, _size, _lidx, &p->TwoBits);
		return SIDL_STATUS_OK;
	}
	if (d == NR_DciFormat_1_1_DAI_Type_FourBits) {
		_serNrSysEncDAI_B4_Type(_buffer, _size, _lidx, &p->FourBits);
		return SIDL_STATUS_OK;
	}
	if (d == NR_DciFormat_1_1_DAI_Type_SixBits) {
		_serNrSysEncDAI_B6_Type(_buffer, _size, _lidx, &p->SixBits);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncNR_DciFormat_1_1_DAI_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_DciFormat_1_1_DAI_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncNR_DciFormat_1_1_DAI_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_DciFormat_1_1_DAI_Type_DAI_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_DciFormat_1_1_DAI_Type_DAI_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncNR_DciFormat_1_1_DAI_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_DciCommon_TpcCommand_Type_NR_DciFormat_1_1_SpecificInfo_Type_TpcCommandPucch_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_DciCommon_TpcCommand_Type_NR_DciFormat_1_1_SpecificInfo_Type_TpcCommandPucch_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncNR_DciCommon_TpcCommand_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_DciFormat_1_X_PucchResourceIndicator_Type_NR_DciFormat_1_1_SpecificInfo_Type_PucchResourceIndicator_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_DciFormat_1_X_PucchResourceIndicator_Type_NR_DciFormat_1_1_SpecificInfo_Type_PucchResourceIndicator_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncNR_DciFormat_1_X_PucchResourceIndicator_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_DciFormat_1_X_PdschHarqTimingIndicator_Type_NR_DciFormat_1_1_SpecificInfo_Type_PdschHarqTimingIndicator_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_DciFormat_1_X_PdschHarqTimingIndicator_Type_NR_DciFormat_1_1_SpecificInfo_Type_PdschHarqTimingIndicator_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncNR_DciFormat_1_X_PdschHarqTimingIndicator_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_DciFormat_1_1_OneShotHarqAckRequest_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union NR_DciFormat_1_1_OneShotHarqAckRequest_Type_Value* p, enum NR_DciFormat_1_1_OneShotHarqAckRequest_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_DciFormat_1_1_OneShotHarqAckRequest_Type_None) {
		HTON_8(&_buffer[*_lidx], p->None, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == NR_DciFormat_1_1_OneShotHarqAckRequest_Type_Value) {
		for (size_t i1 = 0; i1 < 1; i1++) {
			HTON_8(&_buffer[*_lidx], p->Value[i1], _lidx);
		}
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncNR_DciFormat_1_1_OneShotHarqAckRequest_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_DciFormat_1_1_OneShotHarqAckRequest_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncNR_DciFormat_1_1_OneShotHarqAckRequest_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_DciFormat_1_1_OneShotHarqAckRequest_Type_OneShotHarqAckRequest_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_DciFormat_1_1_OneShotHarqAckRequest_Type_OneShotHarqAckRequest_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncNR_DciFormat_1_1_OneShotHarqAckRequest_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_DciFormat_1_1_PdschGroupIndex_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union NR_DciFormat_1_1_PdschGroupIndex_Type_Value* p, enum NR_DciFormat_1_1_PdschGroupIndex_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_DciFormat_1_1_PdschGroupIndex_Type_None) {
		HTON_8(&_buffer[*_lidx], p->None, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == NR_DciFormat_1_1_PdschGroupIndex_Type_Value) {
		for (size_t i1 = 0; i1 < 1; i1++) {
			HTON_8(&_buffer[*_lidx], p->Value[i1], _lidx);
		}
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncNR_DciFormat_1_1_PdschGroupIndex_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_DciFormat_1_1_PdschGroupIndex_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncNR_DciFormat_1_1_PdschGroupIndex_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_DciFormat_1_1_PdschGroupIndex_Type_PdschGroupIndex_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_DciFormat_1_1_PdschGroupIndex_Type_PdschGroupIndex_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncNR_DciFormat_1_1_PdschGroupIndex_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_DciFormat_1_1_NewFeedbackIndicator_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union NR_DciFormat_1_1_NewFeedbackIndicator_Type_Value* p, enum NR_DciFormat_1_1_NewFeedbackIndicator_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_DciFormat_1_1_NewFeedbackIndicator_Type_None) {
		HTON_8(&_buffer[*_lidx], p->None, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == NR_DciFormat_1_1_NewFeedbackIndicator_Type_Value) {
		HTON_32(&_buffer[*_lidx], p->Value.d, _lidx);
		for (size_t i1 = 0; i1 < p->Value.d; i1++) {
			HTON_8(&_buffer[*_lidx], p->Value.v[i1], _lidx);
		}
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncNR_DciFormat_1_1_NewFeedbackIndicator_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_DciFormat_1_1_NewFeedbackIndicator_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncNR_DciFormat_1_1_NewFeedbackIndicator_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_DciFormat_1_1_NewFeedbackIndicator_Type_NewFeedbackIndicator_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_DciFormat_1_1_NewFeedbackIndicator_Type_NewFeedbackIndicator_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncNR_DciFormat_1_1_NewFeedbackIndicator_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_DciFormat_1_1_NumberRequestedPdschGroup_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union NR_DciFormat_1_1_NumberRequestedPdschGroup_Type_Value* p, enum NR_DciFormat_1_1_NumberRequestedPdschGroup_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_DciFormat_1_1_NumberRequestedPdschGroup_Type_None) {
		HTON_8(&_buffer[*_lidx], p->None, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == NR_DciFormat_1_1_NumberRequestedPdschGroup_Type_Value) {
		for (size_t i1 = 0; i1 < 1; i1++) {
			HTON_8(&_buffer[*_lidx], p->Value[i1], _lidx);
		}
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncNR_DciFormat_1_1_NumberRequestedPdschGroup_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_DciFormat_1_1_NumberRequestedPdschGroup_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncNR_DciFormat_1_1_NumberRequestedPdschGroup_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_DciFormat_1_1_NumberRequestedPdschGroup_Type_NumberRequestedPdschGroup_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_DciFormat_1_1_NumberRequestedPdschGroup_Type_NumberRequestedPdschGroup_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncNR_DciFormat_1_1_NumberRequestedPdschGroup_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_DciFormat_1_1_AntennaPorts_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union NR_DciFormat_1_1_AntennaPorts_Type_Value* p, enum NR_DciFormat_1_1_AntennaPorts_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_DciFormat_1_1_AntennaPorts_Type_Index) {
		HTON_32(&_buffer[*_lidx], p->Index.d, _lidx);
		for (size_t i1 = 0; i1 < p->Index.d; i1++) {
			HTON_8(&_buffer[*_lidx], p->Index.v[i1], _lidx);
		}
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncNR_DciFormat_1_1_AntennaPorts_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_DciFormat_1_1_AntennaPorts_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncNR_DciFormat_1_1_AntennaPorts_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_DciFormat_1_1_AntennaPorts_Type_AntennaPorts_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_DciFormat_1_1_AntennaPorts_Type_AntennaPorts_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncNR_DciFormat_1_1_AntennaPorts_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_DciFormat_1_1_TCI_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union NR_DciFormat_1_1_TCI_Type_Value* p, enum NR_DciFormat_1_1_TCI_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_DciFormat_1_1_TCI_Type_None) {
		HTON_8(&_buffer[*_lidx], p->None, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == NR_DciFormat_1_1_TCI_Type_Value) {
		for (size_t i1 = 0; i1 < 3; i1++) {
			HTON_8(&_buffer[*_lidx], p->Value[i1], _lidx);
		}
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncNR_DciFormat_1_1_TCI_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_DciFormat_1_1_TCI_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncNR_DciFormat_1_1_TCI_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_DciFormat_1_1_TCI_Type_TCI_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_DciFormat_1_1_TCI_Type_TCI_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncNR_DciFormat_1_1_TCI_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_DciFormat_X_1_SrsRequest_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union NR_DciFormat_X_1_SrsRequest_Type_Value* p, enum NR_DciFormat_X_1_SrsRequest_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_DciFormat_X_1_SrsRequest_Type_SingleUL) {
		for (size_t i1 = 0; i1 < 2; i1++) {
			HTON_8(&_buffer[*_lidx], p->SingleUL[i1], _lidx);
		}
		return SIDL_STATUS_OK;
	}
	if (d == NR_DciFormat_X_1_SrsRequest_Type_UL_SUL) {
		for (size_t i1 = 0; i1 < 3; i1++) {
			HTON_8(&_buffer[*_lidx], p->UL_SUL[i1], _lidx);
		}
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncNR_DciFormat_X_1_SrsRequest_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_DciFormat_X_1_SrsRequest_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncNR_DciFormat_X_1_SrsRequest_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_DciFormat_X_1_SrsRequest_Type_NR_DciFormat_1_1_SpecificInfo_Type_SrsRequest_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_DciFormat_X_1_SrsRequest_Type_NR_DciFormat_1_1_SpecificInfo_Type_SrsRequest_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncNR_DciFormat_X_1_SrsRequest_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_DciFormat_1_1_CBGTI_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union NR_DciFormat_1_1_CBGTI_Type_Value* p, enum NR_DciFormat_1_1_CBGTI_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_DciFormat_1_1_CBGTI_Type_Bitmap) {
		HTON_32(&_buffer[*_lidx], p->Bitmap.d, _lidx);
		for (size_t i1 = 0; i1 < p->Bitmap.d; i1++) {
			HTON_8(&_buffer[*_lidx], p->Bitmap.v[i1], _lidx);
		}
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncNR_DciFormat_1_1_CBGTI_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_DciFormat_1_1_CBGTI_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncNR_DciFormat_1_1_CBGTI_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_DciFormat_1_1_CBGTI_Type_CBGTI_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_DciFormat_1_1_CBGTI_Type_CBGTI_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncNR_DciFormat_1_1_CBGTI_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_DciFormat_1_1_CBGFI_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union NR_DciFormat_1_1_CBGFI_Type_Value* p, enum NR_DciFormat_1_1_CBGFI_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_DciFormat_1_1_CBGFI_Type_None) {
		HTON_8(&_buffer[*_lidx], p->None, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == NR_DciFormat_1_1_CBGFI_Type_Flag) {
		for (size_t i1 = 0; i1 < 1; i1++) {
			HTON_8(&_buffer[*_lidx], p->Flag[i1], _lidx);
		}
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncNR_DciFormat_1_1_CBGFI_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_DciFormat_1_1_CBGFI_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncNR_DciFormat_1_1_CBGFI_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_DciFormat_1_1_CBGFI_Type_CBGFI_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_DciFormat_1_1_CBGFI_Type_CBGFI_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncNR_DciFormat_1_1_CBGFI_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_DciFormat_X_1_DmrsSequenceInit_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union NR_DciFormat_X_1_DmrsSequenceInit_Type_Value* p, enum NR_DciFormat_X_1_DmrsSequenceInit_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_DciFormat_X_1_DmrsSequenceInit_Type_None) {
		HTON_8(&_buffer[*_lidx], p->None, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == NR_DciFormat_X_1_DmrsSequenceInit_Type_Value) {
		for (size_t i1 = 0; i1 < 1; i1++) {
			HTON_8(&_buffer[*_lidx], p->Value[i1], _lidx);
		}
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncNR_DciFormat_X_1_DmrsSequenceInit_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_DciFormat_X_1_DmrsSequenceInit_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncNR_DciFormat_X_1_DmrsSequenceInit_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_DciFormat_X_1_DmrsSequenceInit_Type_NR_DciFormat_1_1_SpecificInfo_Type_DmrsSequenceInit_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_DciFormat_X_1_DmrsSequenceInit_Type_NR_DciFormat_1_1_SpecificInfo_Type_DmrsSequenceInit_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncNR_DciFormat_X_1_DmrsSequenceInit_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_DciFormat_X_1_PriorityIndicator_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union NR_DciFormat_X_1_PriorityIndicator_Type_Value* p, enum NR_DciFormat_X_1_PriorityIndicator_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_DciFormat_X_1_PriorityIndicator_Type_None) {
		HTON_8(&_buffer[*_lidx], p->None, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == NR_DciFormat_X_1_PriorityIndicator_Type_Value) {
		for (size_t i1 = 0; i1 < 1; i1++) {
			HTON_8(&_buffer[*_lidx], p->Value[i1], _lidx);
		}
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncNR_DciFormat_X_1_PriorityIndicator_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_DciFormat_X_1_PriorityIndicator_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncNR_DciFormat_X_1_PriorityIndicator_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_DciFormat_X_1_PriorityIndicator_Type_NR_DciFormat_1_1_SpecificInfo_Type_PriorityIndicator_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_DciFormat_X_1_PriorityIndicator_Type_NR_DciFormat_1_1_SpecificInfo_Type_PriorityIndicator_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncNR_DciFormat_X_1_PriorityIndicator_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_DciFormat_1_1_ChannelAccessCPext_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union NR_DciFormat_1_1_ChannelAccessCPext_Type_Value* p, enum NR_DciFormat_1_1_ChannelAccessCPext_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_DciFormat_1_1_ChannelAccessCPext_Type_None) {
		HTON_8(&_buffer[*_lidx], p->None, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == NR_DciFormat_1_1_ChannelAccessCPext_Type_Value) {
		HTON_32(&_buffer[*_lidx], p->Value.d, _lidx);
		for (size_t i1 = 0; i1 < p->Value.d; i1++) {
			HTON_8(&_buffer[*_lidx], p->Value.v[i1], _lidx);
		}
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncNR_DciFormat_1_1_ChannelAccessCPext_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_DciFormat_1_1_ChannelAccessCPext_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncNR_DciFormat_1_1_ChannelAccessCPext_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_DciFormat_1_1_ChannelAccessCPext_Type_ChannelAccessCPext_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_DciFormat_1_1_ChannelAccessCPext_Type_ChannelAccessCPext_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncNR_DciFormat_1_1_ChannelAccessCPext_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_DciFormat_X_1_MinimumApplicableSchedulingOffset_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union NR_DciFormat_X_1_MinimumApplicableSchedulingOffset_Type_Value* p, enum NR_DciFormat_X_1_MinimumApplicableSchedulingOffset_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_DciFormat_X_1_MinimumApplicableSchedulingOffset_Type_None) {
		HTON_8(&_buffer[*_lidx], p->None, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == NR_DciFormat_X_1_MinimumApplicableSchedulingOffset_Type_Value) {
		for (size_t i1 = 0; i1 < 1; i1++) {
			HTON_8(&_buffer[*_lidx], p->Value[i1], _lidx);
		}
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncNR_DciFormat_X_1_MinimumApplicableSchedulingOffset_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_DciFormat_X_1_MinimumApplicableSchedulingOffset_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncNR_DciFormat_X_1_MinimumApplicableSchedulingOffset_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_DciFormat_X_1_MinimumApplicableSchedulingOffset_Type_NR_DciFormat_1_1_SpecificInfo_Type_MinimumApplicableSchedulingOffset_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_DciFormat_X_1_MinimumApplicableSchedulingOffset_Type_NR_DciFormat_1_1_SpecificInfo_Type_MinimumApplicableSchedulingOffset_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncNR_DciFormat_X_1_MinimumApplicableSchedulingOffset_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_DciFormat_X_1_SCellDormancyIndication_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union NR_DciFormat_X_1_SCellDormancyIndication_Type_Value* p, enum NR_DciFormat_X_1_SCellDormancyIndication_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_DciFormat_X_1_SCellDormancyIndication_Type_None) {
		HTON_8(&_buffer[*_lidx], p->None, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == NR_DciFormat_X_1_SCellDormancyIndication_Type_Value) {
		HTON_32(&_buffer[*_lidx], p->Value.d, _lidx);
		for (size_t i1 = 0; i1 < p->Value.d; i1++) {
			HTON_8(&_buffer[*_lidx], p->Value.v[i1], _lidx);
		}
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncNR_DciFormat_X_1_SCellDormancyIndication_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_DciFormat_X_1_SCellDormancyIndication_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncNR_DciFormat_X_1_SCellDormancyIndication_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_DciFormat_X_1_SCellDormancyIndication_Type_NR_DciFormat_1_1_SpecificInfo_Type_SCellDormancyIndication_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_DciFormat_X_1_SCellDormancyIndication_Type_NR_DciFormat_1_1_SpecificInfo_Type_SCellDormancyIndication_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncNR_DciFormat_X_1_SCellDormancyIndication_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_DciFormat_1_1_SpecificInfo_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_DciFormat_1_1_SpecificInfo_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncNR_DciCommon_CarrierIndicator_Type_NR_DciFormat_1_1_SpecificInfo_Type_CarrierIndicator_Optional(_buffer, _size, _lidx, &p->CarrierIndicator);
	_serNrSysEncNR_DciCommon_BWPIndicator_Type_NR_DciFormat_1_1_SpecificInfo_Type_BWPIndicator_Optional(_buffer, _size, _lidx, &p->BWPIndicator);
	_serNrSysEncNR_DciFormat_1_1_PrbBundlingSizeIndicator_Type_PrbBundlingSizeIndicator_Optional(_buffer, _size, _lidx, &p->PrbBundlingSizeIndicator);
	_serNrSysEncNR_DciFormat_1_1_RateMatchingIndicator_Type_RateMatchingIndicator_Optional(_buffer, _size, _lidx, &p->RateMatchingIndicator);
	_serNrSysEncNR_DciFormat_1_1_ZP_CSI_RS_Trigger_Type_ZP_CSI_RS_Trigger_Optional(_buffer, _size, _lidx, &p->ZP_CSI_RS_Trigger);
	_serNrSysEncNR_DciFormat_1_1_DAI_Type_DAI_Optional(_buffer, _size, _lidx, &p->DAI);
	_serNrSysEncNR_DciCommon_TpcCommand_Type_NR_DciFormat_1_1_SpecificInfo_Type_TpcCommandPucch_Optional(_buffer, _size, _lidx, &p->TpcCommandPucch);
	_serNrSysEncNR_DciFormat_1_X_PucchResourceIndicator_Type_NR_DciFormat_1_1_SpecificInfo_Type_PucchResourceIndicator_Optional(_buffer, _size, _lidx, &p->PucchResourceIndicator);
	_serNrSysEncNR_DciFormat_1_X_PdschHarqTimingIndicator_Type_NR_DciFormat_1_1_SpecificInfo_Type_PdschHarqTimingIndicator_Optional(_buffer, _size, _lidx, &p->PdschHarqTimingIndicator);
	_serNrSysEncNR_DciFormat_1_1_OneShotHarqAckRequest_Type_OneShotHarqAckRequest_Optional(_buffer, _size, _lidx, &p->OneShotHarqAckRequest);
	_serNrSysEncNR_DciFormat_1_1_PdschGroupIndex_Type_PdschGroupIndex_Optional(_buffer, _size, _lidx, &p->PdschGroupIndex);
	_serNrSysEncNR_DciFormat_1_1_NewFeedbackIndicator_Type_NewFeedbackIndicator_Optional(_buffer, _size, _lidx, &p->NewFeedbackIndicator);
	_serNrSysEncNR_DciFormat_1_1_NumberRequestedPdschGroup_Type_NumberRequestedPdschGroup_Optional(_buffer, _size, _lidx, &p->NumberRequestedPdschGroup);
	_serNrSysEncNR_DciFormat_1_1_AntennaPorts_Type_AntennaPorts_Optional(_buffer, _size, _lidx, &p->AntennaPorts);
	_serNrSysEncNR_DciFormat_1_1_TCI_Type_TCI_Optional(_buffer, _size, _lidx, &p->TCI);
	_serNrSysEncNR_DciFormat_X_1_SrsRequest_Type_NR_DciFormat_1_1_SpecificInfo_Type_SrsRequest_Optional(_buffer, _size, _lidx, &p->SrsRequest);
	_serNrSysEncNR_DciFormat_1_1_CBGTI_Type_CBGTI_Optional(_buffer, _size, _lidx, &p->CBGTI);
	_serNrSysEncNR_DciFormat_1_1_CBGFI_Type_CBGFI_Optional(_buffer, _size, _lidx, &p->CBGFI);
	_serNrSysEncNR_DciFormat_X_1_DmrsSequenceInit_Type_NR_DciFormat_1_1_SpecificInfo_Type_DmrsSequenceInit_Optional(_buffer, _size, _lidx, &p->DmrsSequenceInit);
	_serNrSysEncNR_DciFormat_X_1_PriorityIndicator_Type_NR_DciFormat_1_1_SpecificInfo_Type_PriorityIndicator_Optional(_buffer, _size, _lidx, &p->PriorityIndicator);
	_serNrSysEncNR_DciFormat_1_1_ChannelAccessCPext_Type_ChannelAccessCPext_Optional(_buffer, _size, _lidx, &p->ChannelAccessCPext);
	_serNrSysEncNR_DciFormat_X_1_MinimumApplicableSchedulingOffset_Type_NR_DciFormat_1_1_SpecificInfo_Type_MinimumApplicableSchedulingOffset_Optional(_buffer, _size, _lidx, &p->MinimumApplicableSchedulingOffset);
	_serNrSysEncNR_DciFormat_X_1_SCellDormancyIndication_Type_NR_DciFormat_1_1_SpecificInfo_Type_SCellDormancyIndication_Optional(_buffer, _size, _lidx, &p->SCellDormancyIndication);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_DciFormat_1_X_SpecificInfo_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union NR_DciFormat_1_X_SpecificInfo_Type_Value* p, enum NR_DciFormat_1_X_SpecificInfo_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_DciFormat_1_X_SpecificInfo_Type_Format_1_0) {
		_serNrSysEncNR_DciFormat_1_0_SpecificInfo_Type(_buffer, _size, _lidx, &p->Format_1_0);
		return SIDL_STATUS_OK;
	}
	if (d == NR_DciFormat_1_X_SpecificInfo_Type_Format_1_0_P_RNTI) {
		_serNrSysEncNR_DciFormat_1_0_P_RNTI_SpecificInfo_Type(_buffer, _size, _lidx, &p->Format_1_0_P_RNTI);
		return SIDL_STATUS_OK;
	}
	if (d == NR_DciFormat_1_X_SpecificInfo_Type_Format_1_0_SI_RNTI) {
		_serNrSysEncNR_DciFormat_1_0_SI_RNTI_SpecificInfo_Type(_buffer, _size, _lidx, &p->Format_1_0_SI_RNTI);
		return SIDL_STATUS_OK;
	}
	if (d == NR_DciFormat_1_X_SpecificInfo_Type_Format_1_0_RA_RNTI) {
		_serNrSysEncNR_DciFormat_1_0_RA_RNTI_SpecificInfo_Type(_buffer, _size, _lidx, &p->Format_1_0_RA_RNTI);
		return SIDL_STATUS_OK;
	}
	if (d == NR_DciFormat_1_X_SpecificInfo_Type_Format_1_1) {
		_serNrSysEncNR_DciFormat_1_1_SpecificInfo_Type(_buffer, _size, _lidx, &p->Format_1_1);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncNR_DciFormat_1_X_SpecificInfo_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_DciFormat_1_X_SpecificInfo_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncNR_DciFormat_1_X_SpecificInfo_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_DciFormat_1_X_SpecificInfo_Type_Format_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_DciFormat_1_X_SpecificInfo_Type_Format_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncNR_DciFormat_1_X_SpecificInfo_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_DciDlInfo_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_DciDlInfo_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncNR_DciFormat_1_X_ResourceAssignment_Type_ResoureAssignment_Optional(_buffer, _size, _lidx, &p->ResoureAssignment);
	_serNrSysEncNR_DciCommon_VrbPrbMapping_Type_VrbPrbMapping_Optional(_buffer, _size, _lidx, &p->VrbPrbMapping);
	_serNrSysEncNR_DciFormat_1_X_SpecificInfo_Type_Format_Optional(_buffer, _size, _lidx, &p->Format);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_DciDlInfo_Type_DciInfo_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_DciDlInfo_Type_DciInfo_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncNR_DciDlInfo_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_SearchSpaceDlDciAssignment_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_SearchSpaceDlDciAssignment_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncNR_AssignedBWPs_Type_NR_SearchSpaceDlDciAssignment_Type_AssignedBWPs_Optional(_buffer, _size, _lidx, &p->AssignedBWPs);
	_serNrSysEncNR_SearchSpaceType_Type_NR_SearchSpaceDlDciAssignment_Type_SearchSpaceType_Optional(_buffer, _size, _lidx, &p->SearchSpaceType);
	_serNrSysEncNR_DciDlInfo_Type_DciInfo_Optional(_buffer, _size, _lidx, &p->DciInfo);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_SearchSpaceDlDciAssignment_Type_NR_Sib1Schedul_Type_SearchSpaceAndDci_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_SearchSpaceDlDciAssignment_Type_NR_Sib1Schedul_Type_SearchSpaceAndDci_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncNR_SearchSpaceDlDciAssignment_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncInt32_t_NR_Sib1Schedul_Type_Periodicity_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct int32_t_NR_Sib1Schedul_Type_Periodicity_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncIntegerList_Type_SlotOffsetList_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct IntegerList_Type_SlotOffsetList_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i1 = 0; i1 < p->v.d; i1++) {
		HTON_32(&_buffer[*_lidx], p->v.v[i1], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_Sib1Schedul_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_Sib1Schedul_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncNR_SearchSpaceDlDciAssignment_Type_NR_Sib1Schedul_Type_SearchSpaceAndDci_Optional(_buffer, _size, _lidx, &p->SearchSpaceAndDci);
	_serNrSysEncInt32_t_NR_Sib1Schedul_Type_Periodicity_Optional(_buffer, _size, _lidx, &p->Periodicity);
	_serNrSysEncIntegerList_Type_SlotOffsetList_Optional(_buffer, _size, _lidx, &p->SlotOffsetList);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_Sib1Schedul_Type_Sib1Schedul_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_Sib1Schedul_Type_Sib1Schedul_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncNR_Sib1Schedul_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_SiWindowLength_Type_WindowLength_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_SiWindowLength_Type_WindowLength_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_SiPeriodicity_Type_Periodicity_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_SiPeriodicity_Type_Periodicity_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_SearchSpaceDlDciAssignment_Type_NR_SingleSiSchedul_Type_SearchSpaceAndDci_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_SearchSpaceDlDciAssignment_Type_NR_SingleSiSchedul_Type_SearchSpaceAndDci_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncNR_SearchSpaceDlDciAssignment_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncInt32_t_NR_SingleSiSchedul_Type_SlotOffset_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct int32_t_NR_SingleSiSchedul_Type_SlotOffset_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_SingleSiSchedul_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_SingleSiSchedul_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncNR_SearchSpaceDlDciAssignment_Type_NR_SingleSiSchedul_Type_SearchSpaceAndDci_Optional(_buffer, _size, _lidx, &p->SearchSpaceAndDci);
	_serNrSysEncInt32_t_NR_SingleSiSchedul_Type_SlotOffset_Optional(_buffer, _size, _lidx, &p->SlotOffset);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_SingleSiSchedul_Type_Window_DynamicOptional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_SingleSiSchedul_Type_Window_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serNrSysEncNR_SingleSiSchedul_Type(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_OtherSiSchedul_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_OtherSiSchedul_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncNR_SiPeriodicity_Type_Periodicity_Optional(_buffer, _size, _lidx, &p->Periodicity);
	_serNrSysEncNR_SingleSiSchedul_Type_Window_DynamicOptional(_buffer, _size, _lidx, &p->Window);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_OtherSiSchedulList_Type_SiList_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_OtherSiSchedulList_Type_SiList_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i1 = 0; i1 < p->v.d; i1++) {
		_serNrSysEncNR_OtherSiSchedul_Type(_buffer, _size, _lidx, &p->v.v[i1]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_OtherSiSchedulList_Type_SegmentedSiList_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_OtherSiSchedulList_Type_SegmentedSiList_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i1 = 0; i1 < p->v.d; i1++) {
		_serNrSysEncNR_OtherSiSchedul_Type(_buffer, _size, _lidx, &p->v.v[i1]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_AllOtherSiSchedul_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_AllOtherSiSchedul_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncNR_SiWindowLength_Type_WindowLength_Optional(_buffer, _size, _lidx, &p->WindowLength);
	_serNrSysEncNR_OtherSiSchedulList_Type_SiList_Optional(_buffer, _size, _lidx, &p->SiList);
	_serNrSysEncNR_OtherSiSchedulList_Type_SegmentedSiList_Optional(_buffer, _size, _lidx, &p->SegmentedSiList);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_AllOtherSiSchedul_Type_SiSchedul_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_AllOtherSiSchedul_Type_SiSchedul_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncNR_AllOtherSiSchedul_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_BcchToPdschConfig_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_BcchToPdschConfig_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncNR_Sib1Schedul_Type_Sib1Schedul_Optional(_buffer, _size, _lidx, &p->Sib1Schedul);
	_serNrSysEncNR_AllOtherSiSchedul_Type_SiSchedul_Optional(_buffer, _size, _lidx, &p->SiSchedul);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_BcchToPdschConfig_Type_Pdsch_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_BcchToPdschConfig_Type_Pdsch_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncNR_BcchToPdschConfig_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PDCCH_ConfigSIB1(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PDCCH_ConfigSIB1* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->controlResourceSetZero, _lidx);
	HTON_8(&_buffer[*_lidx], p->searchSpaceZero, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_MIB(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_MIB* p)
{
	(void)_size; // TODO: generate boundaries checking

	for (size_t i1 = 0; i1 < 6; i1++) {
		HTON_8(&_buffer[*_lidx], p->systemFrameNumber[i1], _lidx);
	}
	{
		size_t _tmp = (size_t)p->subCarrierSpacingCommon;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	HTON_8(&_buffer[*_lidx], p->ssb_SubcarrierOffset, _lidx);
	{
		size_t _tmp = (size_t)p->dmrs_TypeA_Position;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_PDCCH_ConfigSIB1(_buffer, _size, _lidx, &p->pdcch_ConfigSIB1);
	{
		size_t _tmp = (size_t)p->cellBarred;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	{
		size_t _tmp = (size_t)p->intraFreqReselection;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	for (size_t i1 = 0; i1 < 1; i1++) {
		HTON_8(&_buffer[*_lidx], p->spare[i1], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_BCCH_BCH_MessageType_messageClassExtension(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_BCCH_BCH_MessageType_messageClassExtension* p)
{
	(void)_size; // TODO: generate boundaries checking

	(void)_buffer;
	(void)_size;
	(void)_lidx;
	(void)p;

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_BCCH_BCH_MessageType_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SQN_NR_BCCH_BCH_MessageType_Value* p, enum SQN_NR_BCCH_BCH_MessageType_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_BCCH_BCH_MessageType_mib) {
		_serNrSysEncSQN_NR_MIB(_buffer, _size, _lidx, &p->mib);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_BCCH_BCH_MessageType_messageClassExtension) {
		_serNrSysEncSQN_NR_BCCH_BCH_MessageType_messageClassExtension(_buffer, _size, _lidx, &p->messageClassExtension);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncSQN_NR_BCCH_BCH_MessageType(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_BCCH_BCH_MessageType* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_BCCH_BCH_MessageType_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_BCCH_BCH_Message(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_BCCH_BCH_Message* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncSQN_NR_BCCH_BCH_MessageType(_buffer, _size, _lidx, &p->message);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_BCCH_BCH_Message_MIB_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_BCCH_BCH_Message_MIB_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_BCCH_BCH_Message(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncUint8_t_SQN_NR_SIB2_cellReselectionInfoCommon_nrofSS_BlocksToAverage_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint8_t_SQN_NR_SIB2_cellReselectionInfoCommon_nrofSS_BlocksToAverage_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_RSRP_Range_SQN_NR_ThresholdNR_thresholdRSRP_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_RSRP_Range_SQN_NR_ThresholdNR_thresholdRSRP_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_RSRQ_Range_SQN_NR_ThresholdNR_thresholdRSRQ_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_RSRQ_Range_SQN_NR_ThresholdNR_thresholdRSRQ_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SINR_Range_SQN_NR_ThresholdNR_thresholdSINR_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SINR_Range_SQN_NR_ThresholdNR_thresholdSINR_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_ThresholdNR(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_ThresholdNR* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncSQN_NR_RSRP_Range_SQN_NR_ThresholdNR_thresholdRSRP_Optional(_buffer, _size, _lidx, &p->thresholdRSRP);
	_serNrSysEncSQN_NR_RSRQ_Range_SQN_NR_ThresholdNR_thresholdRSRQ_Optional(_buffer, _size, _lidx, &p->thresholdRSRQ);
	_serNrSysEncSQN_NR_SINR_Range_SQN_NR_ThresholdNR_thresholdSINR_Optional(_buffer, _size, _lidx, &p->thresholdSINR);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_ThresholdNR_SQN_NR_SIB2_cellReselectionInfoCommon_absThreshSS_BlocksConsolidation_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_ThresholdNR_SQN_NR_SIB2_cellReselectionInfoCommon_absThreshSS_BlocksConsolidation_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_ThresholdNR(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_Q_OffsetRange_e_SQN_NR_SIB2_cellReselectionInfoCommon_rangeToBestCell_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_Q_OffsetRange_e_SQN_NR_SIB2_cellReselectionInfoCommon_rangeToBestCell_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_MobilityStateParameters(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_MobilityStateParameters* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->t_Evaluation;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	{
		size_t _tmp = (size_t)p->t_HystNormal;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	HTON_8(&_buffer[*_lidx], p->n_CellChangeMedium, _lidx);
	HTON_8(&_buffer[*_lidx], p->n_CellChangeHigh, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SIB2_cellReselectionInfoCommon_speedStateReselectionPars_q_HystSF(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SIB2_cellReselectionInfoCommon_speedStateReselectionPars_q_HystSF* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->sf_Medium;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	{
		size_t _tmp = (size_t)p->sf_High;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SIB2_cellReselectionInfoCommon_speedStateReselectionPars(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SIB2_cellReselectionInfoCommon_speedStateReselectionPars* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncSQN_NR_MobilityStateParameters(_buffer, _size, _lidx, &p->mobilityStateParameters);
	_serNrSysEncSQN_NR_SIB2_cellReselectionInfoCommon_speedStateReselectionPars_q_HystSF(_buffer, _size, _lidx, &p->q_HystSF);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SIB2_cellReselectionInfoCommon_speedStateReselectionPars_speedStateReselectionPars_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SIB2_cellReselectionInfoCommon_speedStateReselectionPars_speedStateReselectionPars_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_SIB2_cellReselectionInfoCommon_speedStateReselectionPars(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SIB2_cellReselectionInfoCommon(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SIB2_cellReselectionInfoCommon* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncUint8_t_SQN_NR_SIB2_cellReselectionInfoCommon_nrofSS_BlocksToAverage_Optional(_buffer, _size, _lidx, &p->nrofSS_BlocksToAverage);
	_serNrSysEncSQN_NR_ThresholdNR_SQN_NR_SIB2_cellReselectionInfoCommon_absThreshSS_BlocksConsolidation_Optional(_buffer, _size, _lidx, &p->absThreshSS_BlocksConsolidation);
	_serNrSysEncSQN_NR_Q_OffsetRange_e_SQN_NR_SIB2_cellReselectionInfoCommon_rangeToBestCell_Optional(_buffer, _size, _lidx, &p->rangeToBestCell);
	{
		size_t _tmp = (size_t)p->q_Hyst;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_SIB2_cellReselectionInfoCommon_speedStateReselectionPars_speedStateReselectionPars_Optional(_buffer, _size, _lidx, &p->speedStateReselectionPars);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_ReselectionThreshold_SQN_NR_SIB2_cellReselectionServingFreqInfo_s_NonIntraSearchP_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_ReselectionThreshold_SQN_NR_SIB2_cellReselectionServingFreqInfo_s_NonIntraSearchP_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_ReselectionThresholdQ_SQN_NR_SIB2_cellReselectionServingFreqInfo_s_NonIntraSearchQ_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_ReselectionThresholdQ_SQN_NR_SIB2_cellReselectionServingFreqInfo_s_NonIntraSearchQ_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_ReselectionThresholdQ_SQN_NR_SIB2_cellReselectionServingFreqInfo_threshServingLowQ_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_ReselectionThresholdQ_SQN_NR_SIB2_cellReselectionServingFreqInfo_threshServingLowQ_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_CellReselectionSubPriority_e_SQN_NR_SIB2_cellReselectionServingFreqInfo_cellReselectionSubPriority_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_CellReselectionSubPriority_e_SQN_NR_SIB2_cellReselectionServingFreqInfo_cellReselectionSubPriority_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SIB2_cellReselectionServingFreqInfo(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SIB2_cellReselectionServingFreqInfo* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncSQN_NR_ReselectionThreshold_SQN_NR_SIB2_cellReselectionServingFreqInfo_s_NonIntraSearchP_Optional(_buffer, _size, _lidx, &p->s_NonIntraSearchP);
	_serNrSysEncSQN_NR_ReselectionThresholdQ_SQN_NR_SIB2_cellReselectionServingFreqInfo_s_NonIntraSearchQ_Optional(_buffer, _size, _lidx, &p->s_NonIntraSearchQ);
	HTON_8(&_buffer[*_lidx], p->threshServingLowP, _lidx);
	_serNrSysEncSQN_NR_ReselectionThresholdQ_SQN_NR_SIB2_cellReselectionServingFreqInfo_threshServingLowQ_Optional(_buffer, _size, _lidx, &p->threshServingLowQ);
	HTON_8(&_buffer[*_lidx], p->cellReselectionPriority, _lidx);
	_serNrSysEncSQN_NR_CellReselectionSubPriority_e_SQN_NR_SIB2_cellReselectionServingFreqInfo_cellReselectionSubPriority_Optional(_buffer, _size, _lidx, &p->cellReselectionSubPriority);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_Q_RxLevMin_SQN_NR_SIB2_intraFreqCellReselectionInfo_q_RxLevMinSUL_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_Q_RxLevMin_SQN_NR_SIB2_intraFreqCellReselectionInfo_q_RxLevMinSUL_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_Q_QualMin_SQN_NR_SIB2_intraFreqCellReselectionInfo_q_QualMin_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_Q_QualMin_SQN_NR_SIB2_intraFreqCellReselectionInfo_q_QualMin_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_ReselectionThresholdQ_SQN_NR_SIB2_intraFreqCellReselectionInfo_s_IntraSearchQ_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_ReselectionThresholdQ_SQN_NR_SIB2_intraFreqCellReselectionInfo_s_IntraSearchQ_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_FreqBandIndicatorNR_SQN_NR_NR_MultiBandInfo_freqBandIndicatorNR_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_FreqBandIndicatorNR_SQN_NR_NR_MultiBandInfo_freqBandIndicatorNR_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_16(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_P_Max_SQN_NR_NR_NS_PmaxValue_additionalPmax_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_P_Max_SQN_NR_NR_NS_PmaxValue_additionalPmax_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_NR_NS_PmaxValue(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_NR_NS_PmaxValue* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncSQN_NR_P_Max_SQN_NR_NR_NS_PmaxValue_additionalPmax_Optional(_buffer, _size, _lidx, &p->additionalPmax);
	HTON_8(&_buffer[*_lidx], p->additionalSpectrumEmission, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_NR_NS_PmaxList_SQN_NR_NR_MultiBandInfo_nr_NS_PmaxList_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_NR_NS_PmaxList_SQN_NR_NR_MultiBandInfo_nr_NS_PmaxList_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i3 = 0; i3 < p->v.d; i3++) {
		_serNrSysEncSQN_NR_NR_NS_PmaxValue(_buffer, _size, _lidx, &p->v.v[i3]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_NR_MultiBandInfo(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_NR_MultiBandInfo* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncSQN_NR_FreqBandIndicatorNR_SQN_NR_NR_MultiBandInfo_freqBandIndicatorNR_Optional(_buffer, _size, _lidx, &p->freqBandIndicatorNR);
	_serNrSysEncSQN_NR_NR_NS_PmaxList_SQN_NR_NR_MultiBandInfo_nr_NS_PmaxList_Optional(_buffer, _size, _lidx, &p->nr_NS_PmaxList);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_MultiFrequencyBandListNR_SIB_SQN_NR_SIB2_intraFreqCellReselectionInfo_frequencyBandList_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_MultiFrequencyBandListNR_SIB_SQN_NR_SIB2_intraFreqCellReselectionInfo_frequencyBandList_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serNrSysEncSQN_NR_NR_MultiBandInfo(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_MultiFrequencyBandListNR_SIB_SQN_NR_SIB2_intraFreqCellReselectionInfo_frequencyBandListSUL_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_MultiFrequencyBandListNR_SIB_SQN_NR_SIB2_intraFreqCellReselectionInfo_frequencyBandListSUL_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serNrSysEncSQN_NR_NR_MultiBandInfo(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_P_Max_SQN_NR_SIB2_intraFreqCellReselectionInfo_p_Max_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_P_Max_SQN_NR_SIB2_intraFreqCellReselectionInfo_p_Max_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SSB_MTC_periodicityAndOffset_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SQN_NR_SSB_MTC_periodicityAndOffset_Value* p, enum SQN_NR_SSB_MTC_periodicityAndOffset_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SSB_MTC_periodicityAndOffset_sf5) {
		HTON_8(&_buffer[*_lidx], p->sf5, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SSB_MTC_periodicityAndOffset_sf10) {
		HTON_8(&_buffer[*_lidx], p->sf10, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SSB_MTC_periodicityAndOffset_sf20) {
		HTON_8(&_buffer[*_lidx], p->sf20, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SSB_MTC_periodicityAndOffset_sf40) {
		HTON_8(&_buffer[*_lidx], p->sf40, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SSB_MTC_periodicityAndOffset_sf80) {
		HTON_8(&_buffer[*_lidx], p->sf80, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SSB_MTC_periodicityAndOffset_sf160) {
		HTON_8(&_buffer[*_lidx], p->sf160, _lidx);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncSQN_NR_SSB_MTC_periodicityAndOffset(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SSB_MTC_periodicityAndOffset* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_SSB_MTC_periodicityAndOffset_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SSB_MTC(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SSB_MTC* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncSQN_NR_SSB_MTC_periodicityAndOffset(_buffer, _size, _lidx, &p->periodicityAndOffset);
	{
		size_t _tmp = (size_t)p->duration;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SSB_MTC_SQN_NR_SIB2_intraFreqCellReselectionInfo_smtc_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SSB_MTC_SQN_NR_SIB2_intraFreqCellReselectionInfo_smtc_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_SSB_MTC(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SS_RSSI_Measurement(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SS_RSSI_Measurement* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_32(&_buffer[*_lidx], p->measurementSlots.d, _lidx);
	for (size_t i2 = 0; i2 < p->measurementSlots.d; i2++) {
		HTON_8(&_buffer[*_lidx], p->measurementSlots.v[i2], _lidx);
	}
	HTON_8(&_buffer[*_lidx], p->endSymbol, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SS_RSSI_Measurement_SQN_NR_SIB2_intraFreqCellReselectionInfo_ss_RSSI_Measurement_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SS_RSSI_Measurement_SQN_NR_SIB2_intraFreqCellReselectionInfo_ss_RSSI_Measurement_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_SS_RSSI_Measurement(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SSB_ToMeasure_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SQN_NR_SSB_ToMeasure_Value* p, enum SQN_NR_SSB_ToMeasure_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SSB_ToMeasure_shortBitmap) {
		for (size_t i2 = 0; i2 < 4; i2++) {
			HTON_8(&_buffer[*_lidx], p->shortBitmap[i2], _lidx);
		}
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SSB_ToMeasure_mediumBitmap) {
		for (size_t i2 = 0; i2 < 8; i2++) {
			HTON_8(&_buffer[*_lidx], p->mediumBitmap[i2], _lidx);
		}
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SSB_ToMeasure_longBitmap) {
		for (size_t i2 = 0; i2 < 64; i2++) {
			HTON_8(&_buffer[*_lidx], p->longBitmap[i2], _lidx);
		}
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncSQN_NR_SSB_ToMeasure(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SSB_ToMeasure* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_SSB_ToMeasure_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SSB_ToMeasure_SQN_NR_SIB2_intraFreqCellReselectionInfo_ssb_ToMeasure_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SSB_ToMeasure_SQN_NR_SIB2_intraFreqCellReselectionInfo_ssb_ToMeasure_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_SSB_ToMeasure(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SpeedStateScaleFactors(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SpeedStateScaleFactors* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->sf_Medium;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	{
		size_t _tmp = (size_t)p->sf_High;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SpeedStateScaleFactors_SQN_NR_SIB2_intraFreqCellReselectionInfo_t_ReselectionNR_SF_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SpeedStateScaleFactors_SQN_NR_SIB2_intraFreqCellReselectionInfo_t_ReselectionNR_SF_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_SpeedStateScaleFactors(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PhysCellId_SQN_NR_SSB_MTC2_LP_r16_pci_List_DynamicOptional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PhysCellId_SQN_NR_SSB_MTC2_LP_r16_pci_List_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		HTON_16(&_buffer[*_lidx], p->v.v[i2], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SSB_MTC2_LP_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SSB_MTC2_LP_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncSQN_NR_PhysCellId_SQN_NR_SSB_MTC2_LP_r16_pci_List_DynamicOptional(_buffer, _size, _lidx, &p->pci_List);
	{
		size_t _tmp = (size_t)p->periodicity;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SSB_MTC2_LP_r16_SQN_NR_SIB2_intraFreqCellReselectionInfo_smtc2_LP_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SSB_MTC2_LP_r16_SQN_NR_SIB2_intraFreqCellReselectionInfo_smtc2_LP_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_SSB_MTC2_LP_r16(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SSB_PositionQCL_Relation_r16_e_SQN_NR_SIB2_intraFreqCellReselectionInfo_ssb_PositionQCL_Common_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SSB_PositionQCL_Relation_r16_e_SQN_NR_SIB2_intraFreqCellReselectionInfo_ssb_PositionQCL_Common_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SIB2_intraFreqCellReselectionInfo(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SIB2_intraFreqCellReselectionInfo* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->q_RxLevMin, _lidx);
	_serNrSysEncSQN_NR_Q_RxLevMin_SQN_NR_SIB2_intraFreqCellReselectionInfo_q_RxLevMinSUL_Optional(_buffer, _size, _lidx, &p->q_RxLevMinSUL);
	_serNrSysEncSQN_NR_Q_QualMin_SQN_NR_SIB2_intraFreqCellReselectionInfo_q_QualMin_Optional(_buffer, _size, _lidx, &p->q_QualMin);
	HTON_8(&_buffer[*_lidx], p->s_IntraSearchP, _lidx);
	_serNrSysEncSQN_NR_ReselectionThresholdQ_SQN_NR_SIB2_intraFreqCellReselectionInfo_s_IntraSearchQ_Optional(_buffer, _size, _lidx, &p->s_IntraSearchQ);
	HTON_8(&_buffer[*_lidx], p->t_ReselectionNR, _lidx);
	_serNrSysEncSQN_NR_MultiFrequencyBandListNR_SIB_SQN_NR_SIB2_intraFreqCellReselectionInfo_frequencyBandList_Optional(_buffer, _size, _lidx, &p->frequencyBandList);
	_serNrSysEncSQN_NR_MultiFrequencyBandListNR_SIB_SQN_NR_SIB2_intraFreqCellReselectionInfo_frequencyBandListSUL_Optional(_buffer, _size, _lidx, &p->frequencyBandListSUL);
	_serNrSysEncSQN_NR_P_Max_SQN_NR_SIB2_intraFreqCellReselectionInfo_p_Max_Optional(_buffer, _size, _lidx, &p->p_Max);
	_serNrSysEncSQN_NR_SSB_MTC_SQN_NR_SIB2_intraFreqCellReselectionInfo_smtc_Optional(_buffer, _size, _lidx, &p->smtc);
	_serNrSysEncSQN_NR_SS_RSSI_Measurement_SQN_NR_SIB2_intraFreqCellReselectionInfo_ss_RSSI_Measurement_Optional(_buffer, _size, _lidx, &p->ss_RSSI_Measurement);
	_serNrSysEncSQN_NR_SSB_ToMeasure_SQN_NR_SIB2_intraFreqCellReselectionInfo_ssb_ToMeasure_Optional(_buffer, _size, _lidx, &p->ssb_ToMeasure);
	HTON_8(&_buffer[*_lidx], p->deriveSSB_IndexFromCell, _lidx);
	_serNrSysEncSQN_NR_SpeedStateScaleFactors_SQN_NR_SIB2_intraFreqCellReselectionInfo_t_ReselectionNR_SF_Optional(_buffer, _size, _lidx, &p->t_ReselectionNR_SF);
	_serNrSysEncSQN_NR_SSB_MTC2_LP_r16_SQN_NR_SIB2_intraFreqCellReselectionInfo_smtc2_LP_r16_Optional(_buffer, _size, _lidx, &p->smtc2_LP_r16);
	_serNrSysEncSQN_NR_SSB_PositionQCL_Relation_r16_e_SQN_NR_SIB2_intraFreqCellReselectionInfo_ssb_PositionQCL_Common_r16_Optional(_buffer, _size, _lidx, &p->ssb_PositionQCL_Common_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SIB2_relaxedMeasurement_r16_lowMobilityEvaluation_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SIB2_relaxedMeasurement_r16_lowMobilityEvaluation_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->s_SearchDeltaP_r16;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	{
		size_t _tmp = (size_t)p->t_SearchDeltaP_r16;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SIB2_relaxedMeasurement_r16_lowMobilityEvaluation_r16_lowMobilityEvaluation_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SIB2_relaxedMeasurement_r16_lowMobilityEvaluation_r16_lowMobilityEvaluation_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_SIB2_relaxedMeasurement_r16_lowMobilityEvaluation_r16(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_ReselectionThresholdQ_SQN_NR_SIB2_relaxedMeasurement_r16_cellEdgeEvaluation_r16_s_SearchThresholdQ_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_ReselectionThresholdQ_SQN_NR_SIB2_relaxedMeasurement_r16_cellEdgeEvaluation_r16_s_SearchThresholdQ_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SIB2_relaxedMeasurement_r16_cellEdgeEvaluation_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SIB2_relaxedMeasurement_r16_cellEdgeEvaluation_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->s_SearchThresholdP_r16, _lidx);
	_serNrSysEncSQN_NR_ReselectionThresholdQ_SQN_NR_SIB2_relaxedMeasurement_r16_cellEdgeEvaluation_r16_s_SearchThresholdQ_r16_Optional(_buffer, _size, _lidx, &p->s_SearchThresholdQ_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SIB2_relaxedMeasurement_r16_cellEdgeEvaluation_r16_cellEdgeEvaluation_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SIB2_relaxedMeasurement_r16_cellEdgeEvaluation_r16_cellEdgeEvaluation_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_SIB2_relaxedMeasurement_r16_cellEdgeEvaluation_r16(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SIB2_relaxedMeasurement_r16_combineRelaxedMeasCondition_r16_e_combineRelaxedMeasCondition_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SIB2_relaxedMeasurement_r16_combineRelaxedMeasCondition_r16_e_combineRelaxedMeasCondition_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SIB2_relaxedMeasurement_r16_highPriorityMeasRelax_r16_e_highPriorityMeasRelax_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SIB2_relaxedMeasurement_r16_highPriorityMeasRelax_r16_e_highPriorityMeasRelax_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SIB2_relaxedMeasurement_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SIB2_relaxedMeasurement_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncSQN_NR_SIB2_relaxedMeasurement_r16_lowMobilityEvaluation_r16_lowMobilityEvaluation_r16_Optional(_buffer, _size, _lidx, &p->lowMobilityEvaluation_r16);
	_serNrSysEncSQN_NR_SIB2_relaxedMeasurement_r16_cellEdgeEvaluation_r16_cellEdgeEvaluation_r16_Optional(_buffer, _size, _lidx, &p->cellEdgeEvaluation_r16);
	_serNrSysEncSQN_NR_SIB2_relaxedMeasurement_r16_combineRelaxedMeasCondition_r16_e_combineRelaxedMeasCondition_r16_Optional(_buffer, _size, _lidx, &p->combineRelaxedMeasCondition_r16);
	_serNrSysEncSQN_NR_SIB2_relaxedMeasurement_r16_highPriorityMeasRelax_r16_e_highPriorityMeasRelax_r16_Optional(_buffer, _size, _lidx, &p->highPriorityMeasRelax_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SIB2_relaxedMeasurement_r16_relaxedMeasurement_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SIB2_relaxedMeasurement_r16_relaxedMeasurement_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_SIB2_relaxedMeasurement_r16(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SIB2(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SIB2* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncSQN_NR_SIB2_cellReselectionInfoCommon(_buffer, _size, _lidx, &p->cellReselectionInfoCommon);
	_serNrSysEncSQN_NR_SIB2_cellReselectionServingFreqInfo(_buffer, _size, _lidx, &p->cellReselectionServingFreqInfo);
	_serNrSysEncSQN_NR_SIB2_intraFreqCellReselectionInfo(_buffer, _size, _lidx, &p->intraFreqCellReselectionInfo);
	_serNrSysEncSQN_NR_SIB2_relaxedMeasurement_r16_relaxedMeasurement_r16_Optional(_buffer, _size, _lidx, &p->relaxedMeasurement_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncUint8_t_SQN_NR_IntraFreqNeighCellInfo_q_RxLevMinOffsetCell_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint8_t_SQN_NR_IntraFreqNeighCellInfo_q_RxLevMinOffsetCell_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncUint8_t_SQN_NR_IntraFreqNeighCellInfo_q_RxLevMinOffsetCellSUL_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint8_t_SQN_NR_IntraFreqNeighCellInfo_q_RxLevMinOffsetCellSUL_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncUint8_t_SQN_NR_IntraFreqNeighCellInfo_q_QualMinOffsetCell_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint8_t_SQN_NR_IntraFreqNeighCellInfo_q_QualMinOffsetCell_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_IntraFreqNeighCellInfo(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_IntraFreqNeighCellInfo* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_16(&_buffer[*_lidx], p->physCellId, _lidx);
	{
		size_t _tmp = (size_t)p->q_OffsetCell;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncUint8_t_SQN_NR_IntraFreqNeighCellInfo_q_RxLevMinOffsetCell_Optional(_buffer, _size, _lidx, &p->q_RxLevMinOffsetCell);
	_serNrSysEncUint8_t_SQN_NR_IntraFreqNeighCellInfo_q_RxLevMinOffsetCellSUL_Optional(_buffer, _size, _lidx, &p->q_RxLevMinOffsetCellSUL);
	_serNrSysEncUint8_t_SQN_NR_IntraFreqNeighCellInfo_q_QualMinOffsetCell_Optional(_buffer, _size, _lidx, &p->q_QualMinOffsetCell);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_IntraFreqNeighCellList_SQN_NR_SIB3_intraFreqNeighCellList_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_IntraFreqNeighCellList_SQN_NR_SIB3_intraFreqNeighCellList_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serNrSysEncSQN_NR_IntraFreqNeighCellInfo(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PCI_Range_range_e_range_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PCI_Range_range_e_range_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PCI_Range(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PCI_Range* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_16(&_buffer[*_lidx], p->start, _lidx);
	_serNrSysEncSQN_NR_PCI_Range_range_e_range_Optional(_buffer, _size, _lidx, &p->range);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_IntraFreqBlackCellList_SQN_NR_SIB3_intraFreqBlackCellList_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_IntraFreqBlackCellList_SQN_NR_SIB3_intraFreqBlackCellList_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serNrSysEncSQN_NR_PCI_Range(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncOCTET_STRING_SQN_NR_SIB3_lateNonCriticalExtension_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct OCTET_STRING_SQN_NR_SIB3_lateNonCriticalExtension_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		HTON_8(&_buffer[*_lidx], p->v.v[i2], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SSB_PositionQCL_Relation_r16_e_SQN_NR_IntraFreqNeighCellInfo_v1610_ssb_PositionQCL_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SSB_PositionQCL_Relation_r16_e_SQN_NR_IntraFreqNeighCellInfo_v1610_ssb_PositionQCL_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_IntraFreqNeighCellInfo_v1610(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_IntraFreqNeighCellInfo_v1610* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncSQN_NR_SSB_PositionQCL_Relation_r16_e_SQN_NR_IntraFreqNeighCellInfo_v1610_ssb_PositionQCL_r16_Optional(_buffer, _size, _lidx, &p->ssb_PositionQCL_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_IntraFreqNeighCellList_v1610_SQN_NR_SIB3_intraFreqNeighCellList_v1610_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_IntraFreqNeighCellList_v1610_SQN_NR_SIB3_intraFreqNeighCellList_v1610_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serNrSysEncSQN_NR_IntraFreqNeighCellInfo_v1610(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_IntraFreqWhiteCellList_r16_SQN_NR_SIB3_intraFreqWhiteCellList_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_IntraFreqWhiteCellList_r16_SQN_NR_SIB3_intraFreqWhiteCellList_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serNrSysEncSQN_NR_PCI_Range(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_IntraFreqCAG_CellListPerPLMN_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_IntraFreqCAG_CellListPerPLMN_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->plmn_IdentityIndex_r16, _lidx);
	HTON_32(&_buffer[*_lidx], p->cag_CellList_r16.d, _lidx);
	for (size_t i3 = 0; i3 < p->cag_CellList_r16.d; i3++) {
		_serNrSysEncSQN_NR_PCI_Range(_buffer, _size, _lidx, &p->cag_CellList_r16.v[i3]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_IntraFreqCAG_CellListPerPLMN_r16_SQN_NR_SIB3_intraFreqCAG_CellList_r16_DynamicOptional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_IntraFreqCAG_CellListPerPLMN_r16_SQN_NR_SIB3_intraFreqCAG_CellList_r16_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serNrSysEncSQN_NR_IntraFreqCAG_CellListPerPLMN_r16(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SIB3(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SIB3* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncSQN_NR_IntraFreqNeighCellList_SQN_NR_SIB3_intraFreqNeighCellList_Optional(_buffer, _size, _lidx, &p->intraFreqNeighCellList);
	_serNrSysEncSQN_NR_IntraFreqBlackCellList_SQN_NR_SIB3_intraFreqBlackCellList_Optional(_buffer, _size, _lidx, &p->intraFreqBlackCellList);
	_serNrSysEncOCTET_STRING_SQN_NR_SIB3_lateNonCriticalExtension_Optional(_buffer, _size, _lidx, &p->lateNonCriticalExtension);
	_serNrSysEncSQN_NR_IntraFreqNeighCellList_v1610_SQN_NR_SIB3_intraFreqNeighCellList_v1610_Optional(_buffer, _size, _lidx, &p->intraFreqNeighCellList_v1610);
	_serNrSysEncSQN_NR_IntraFreqWhiteCellList_r16_SQN_NR_SIB3_intraFreqWhiteCellList_r16_Optional(_buffer, _size, _lidx, &p->intraFreqWhiteCellList_r16);
	_serNrSysEncSQN_NR_IntraFreqCAG_CellListPerPLMN_r16_SQN_NR_SIB3_intraFreqCAG_CellList_r16_DynamicOptional(_buffer, _size, _lidx, &p->intraFreqCAG_CellList_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_MultiFrequencyBandListNR_SIB_SQN_NR_InterFreqCarrierFreqInfo_frequencyBandList_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_MultiFrequencyBandListNR_SIB_SQN_NR_InterFreqCarrierFreqInfo_frequencyBandList_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i3 = 0; i3 < p->v.d; i3++) {
		_serNrSysEncSQN_NR_NR_MultiBandInfo(_buffer, _size, _lidx, &p->v.v[i3]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_MultiFrequencyBandListNR_SIB_SQN_NR_InterFreqCarrierFreqInfo_frequencyBandListSUL_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_MultiFrequencyBandListNR_SIB_SQN_NR_InterFreqCarrierFreqInfo_frequencyBandListSUL_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i3 = 0; i3 < p->v.d; i3++) {
		_serNrSysEncSQN_NR_NR_MultiBandInfo(_buffer, _size, _lidx, &p->v.v[i3]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncUint8_t_SQN_NR_InterFreqCarrierFreqInfo_nrofSS_BlocksToAverage_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint8_t_SQN_NR_InterFreqCarrierFreqInfo_nrofSS_BlocksToAverage_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_ThresholdNR_SQN_NR_InterFreqCarrierFreqInfo_absThreshSS_BlocksConsolidation_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_ThresholdNR_SQN_NR_InterFreqCarrierFreqInfo_absThreshSS_BlocksConsolidation_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_ThresholdNR(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SSB_MTC_SQN_NR_InterFreqCarrierFreqInfo_smtc_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SSB_MTC_SQN_NR_InterFreqCarrierFreqInfo_smtc_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_SSB_MTC(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SSB_ToMeasure_SQN_NR_InterFreqCarrierFreqInfo_ssb_ToMeasure_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SSB_ToMeasure_SQN_NR_InterFreqCarrierFreqInfo_ssb_ToMeasure_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_SSB_ToMeasure(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SS_RSSI_Measurement_SQN_NR_InterFreqCarrierFreqInfo_ss_RSSI_Measurement_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SS_RSSI_Measurement_SQN_NR_InterFreqCarrierFreqInfo_ss_RSSI_Measurement_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_SS_RSSI_Measurement(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_Q_RxLevMin_SQN_NR_InterFreqCarrierFreqInfo_q_RxLevMinSUL_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_Q_RxLevMin_SQN_NR_InterFreqCarrierFreqInfo_q_RxLevMinSUL_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_Q_QualMin_SQN_NR_InterFreqCarrierFreqInfo_q_QualMin_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_Q_QualMin_SQN_NR_InterFreqCarrierFreqInfo_q_QualMin_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_P_Max_SQN_NR_InterFreqCarrierFreqInfo_p_Max_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_P_Max_SQN_NR_InterFreqCarrierFreqInfo_p_Max_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SpeedStateScaleFactors_SQN_NR_InterFreqCarrierFreqInfo_t_ReselectionNR_SF_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SpeedStateScaleFactors_SQN_NR_InterFreqCarrierFreqInfo_t_ReselectionNR_SF_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_SpeedStateScaleFactors(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_InterFreqCarrierFreqInfo_threshX_Q(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_InterFreqCarrierFreqInfo_threshX_Q* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->threshX_HighQ, _lidx);
	HTON_8(&_buffer[*_lidx], p->threshX_LowQ, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_InterFreqCarrierFreqInfo_threshX_Q_threshX_Q_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_InterFreqCarrierFreqInfo_threshX_Q_threshX_Q_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_InterFreqCarrierFreqInfo_threshX_Q(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_CellReselectionPriority_SQN_NR_InterFreqCarrierFreqInfo_cellReselectionPriority_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_CellReselectionPriority_SQN_NR_InterFreqCarrierFreqInfo_cellReselectionPriority_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_CellReselectionSubPriority_e_SQN_NR_InterFreqCarrierFreqInfo_cellReselectionSubPriority_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_CellReselectionSubPriority_e_SQN_NR_InterFreqCarrierFreqInfo_cellReselectionSubPriority_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_Q_OffsetRange_e_SQN_NR_InterFreqCarrierFreqInfo_q_OffsetFreq_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_Q_OffsetRange_e_SQN_NR_InterFreqCarrierFreqInfo_q_OffsetFreq_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncUint8_t_SQN_NR_InterFreqNeighCellInfo_q_RxLevMinOffsetCell_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint8_t_SQN_NR_InterFreqNeighCellInfo_q_RxLevMinOffsetCell_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncUint8_t_SQN_NR_InterFreqNeighCellInfo_q_RxLevMinOffsetCellSUL_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint8_t_SQN_NR_InterFreqNeighCellInfo_q_RxLevMinOffsetCellSUL_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncUint8_t_SQN_NR_InterFreqNeighCellInfo_q_QualMinOffsetCell_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint8_t_SQN_NR_InterFreqNeighCellInfo_q_QualMinOffsetCell_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_InterFreqNeighCellInfo(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_InterFreqNeighCellInfo* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_16(&_buffer[*_lidx], p->physCellId, _lidx);
	{
		size_t _tmp = (size_t)p->q_OffsetCell;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncUint8_t_SQN_NR_InterFreqNeighCellInfo_q_RxLevMinOffsetCell_Optional(_buffer, _size, _lidx, &p->q_RxLevMinOffsetCell);
	_serNrSysEncUint8_t_SQN_NR_InterFreqNeighCellInfo_q_RxLevMinOffsetCellSUL_Optional(_buffer, _size, _lidx, &p->q_RxLevMinOffsetCellSUL);
	_serNrSysEncUint8_t_SQN_NR_InterFreqNeighCellInfo_q_QualMinOffsetCell_Optional(_buffer, _size, _lidx, &p->q_QualMinOffsetCell);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_InterFreqNeighCellList_SQN_NR_InterFreqCarrierFreqInfo_interFreqNeighCellList_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_InterFreqNeighCellList_SQN_NR_InterFreqCarrierFreqInfo_interFreqNeighCellList_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i3 = 0; i3 < p->v.d; i3++) {
		_serNrSysEncSQN_NR_InterFreqNeighCellInfo(_buffer, _size, _lidx, &p->v.v[i3]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_InterFreqBlackCellList_SQN_NR_InterFreqCarrierFreqInfo_interFreqBlackCellList_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_InterFreqBlackCellList_SQN_NR_InterFreqCarrierFreqInfo_interFreqBlackCellList_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i3 = 0; i3 < p->v.d; i3++) {
		_serNrSysEncSQN_NR_PCI_Range(_buffer, _size, _lidx, &p->v.v[i3]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_InterFreqCarrierFreqInfo(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_InterFreqCarrierFreqInfo* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_32(&_buffer[*_lidx], p->dl_CarrierFreq, _lidx);
	_serNrSysEncSQN_NR_MultiFrequencyBandListNR_SIB_SQN_NR_InterFreqCarrierFreqInfo_frequencyBandList_Optional(_buffer, _size, _lidx, &p->frequencyBandList);
	_serNrSysEncSQN_NR_MultiFrequencyBandListNR_SIB_SQN_NR_InterFreqCarrierFreqInfo_frequencyBandListSUL_Optional(_buffer, _size, _lidx, &p->frequencyBandListSUL);
	_serNrSysEncUint8_t_SQN_NR_InterFreqCarrierFreqInfo_nrofSS_BlocksToAverage_Optional(_buffer, _size, _lidx, &p->nrofSS_BlocksToAverage);
	_serNrSysEncSQN_NR_ThresholdNR_SQN_NR_InterFreqCarrierFreqInfo_absThreshSS_BlocksConsolidation_Optional(_buffer, _size, _lidx, &p->absThreshSS_BlocksConsolidation);
	_serNrSysEncSQN_NR_SSB_MTC_SQN_NR_InterFreqCarrierFreqInfo_smtc_Optional(_buffer, _size, _lidx, &p->smtc);
	{
		size_t _tmp = (size_t)p->ssbSubcarrierSpacing;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_SSB_ToMeasure_SQN_NR_InterFreqCarrierFreqInfo_ssb_ToMeasure_Optional(_buffer, _size, _lidx, &p->ssb_ToMeasure);
	HTON_8(&_buffer[*_lidx], p->deriveSSB_IndexFromCell, _lidx);
	_serNrSysEncSQN_NR_SS_RSSI_Measurement_SQN_NR_InterFreqCarrierFreqInfo_ss_RSSI_Measurement_Optional(_buffer, _size, _lidx, &p->ss_RSSI_Measurement);
	HTON_8(&_buffer[*_lidx], p->q_RxLevMin, _lidx);
	_serNrSysEncSQN_NR_Q_RxLevMin_SQN_NR_InterFreqCarrierFreqInfo_q_RxLevMinSUL_Optional(_buffer, _size, _lidx, &p->q_RxLevMinSUL);
	_serNrSysEncSQN_NR_Q_QualMin_SQN_NR_InterFreqCarrierFreqInfo_q_QualMin_Optional(_buffer, _size, _lidx, &p->q_QualMin);
	_serNrSysEncSQN_NR_P_Max_SQN_NR_InterFreqCarrierFreqInfo_p_Max_Optional(_buffer, _size, _lidx, &p->p_Max);
	HTON_8(&_buffer[*_lidx], p->t_ReselectionNR, _lidx);
	_serNrSysEncSQN_NR_SpeedStateScaleFactors_SQN_NR_InterFreqCarrierFreqInfo_t_ReselectionNR_SF_Optional(_buffer, _size, _lidx, &p->t_ReselectionNR_SF);
	HTON_8(&_buffer[*_lidx], p->threshX_HighP, _lidx);
	HTON_8(&_buffer[*_lidx], p->threshX_LowP, _lidx);
	_serNrSysEncSQN_NR_InterFreqCarrierFreqInfo_threshX_Q_threshX_Q_Optional(_buffer, _size, _lidx, &p->threshX_Q);
	_serNrSysEncSQN_NR_CellReselectionPriority_SQN_NR_InterFreqCarrierFreqInfo_cellReselectionPriority_Optional(_buffer, _size, _lidx, &p->cellReselectionPriority);
	_serNrSysEncSQN_NR_CellReselectionSubPriority_e_SQN_NR_InterFreqCarrierFreqInfo_cellReselectionSubPriority_Optional(_buffer, _size, _lidx, &p->cellReselectionSubPriority);
	_serNrSysEncSQN_NR_Q_OffsetRange_e_SQN_NR_InterFreqCarrierFreqInfo_q_OffsetFreq_Optional(_buffer, _size, _lidx, &p->q_OffsetFreq);
	_serNrSysEncSQN_NR_InterFreqNeighCellList_SQN_NR_InterFreqCarrierFreqInfo_interFreqNeighCellList_Optional(_buffer, _size, _lidx, &p->interFreqNeighCellList);
	_serNrSysEncSQN_NR_InterFreqBlackCellList_SQN_NR_InterFreqCarrierFreqInfo_interFreqBlackCellList_Optional(_buffer, _size, _lidx, &p->interFreqBlackCellList);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncOCTET_STRING_SQN_NR_SIB4_lateNonCriticalExtension_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct OCTET_STRING_SQN_NR_SIB4_lateNonCriticalExtension_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		HTON_8(&_buffer[*_lidx], p->v.v[i2], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SSB_PositionQCL_Relation_r16_e_SQN_NR_InterFreqNeighCellInfo_v1610_ssb_PositionQCL_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SSB_PositionQCL_Relation_r16_e_SQN_NR_InterFreqNeighCellInfo_v1610_ssb_PositionQCL_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_InterFreqNeighCellInfo_v1610(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_InterFreqNeighCellInfo_v1610* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncSQN_NR_SSB_PositionQCL_Relation_r16_e_SQN_NR_InterFreqNeighCellInfo_v1610_ssb_PositionQCL_r16_Optional(_buffer, _size, _lidx, &p->ssb_PositionQCL_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_InterFreqNeighCellList_v1610_SQN_NR_InterFreqCarrierFreqInfo_v1610_interFreqNeighCellList_v1610_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_InterFreqNeighCellList_v1610_SQN_NR_InterFreqCarrierFreqInfo_v1610_interFreqNeighCellList_v1610_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i3 = 0; i3 < p->v.d; i3++) {
		_serNrSysEncSQN_NR_InterFreqNeighCellInfo_v1610(_buffer, _size, _lidx, &p->v.v[i3]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SSB_MTC2_LP_r16_SQN_NR_InterFreqCarrierFreqInfo_v1610_smtc2_LP_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SSB_MTC2_LP_r16_SQN_NR_InterFreqCarrierFreqInfo_v1610_smtc2_LP_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_SSB_MTC2_LP_r16(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_InterFreqWhiteCellList_r16_SQN_NR_InterFreqCarrierFreqInfo_v1610_interFreqWhiteCellList_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_InterFreqWhiteCellList_r16_SQN_NR_InterFreqCarrierFreqInfo_v1610_interFreqWhiteCellList_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i3 = 0; i3 < p->v.d; i3++) {
		_serNrSysEncSQN_NR_PCI_Range(_buffer, _size, _lidx, &p->v.v[i3]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SSB_PositionQCL_Relation_r16_e_SQN_NR_InterFreqCarrierFreqInfo_v1610_ssb_PositionQCL_Common_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SSB_PositionQCL_Relation_r16_e_SQN_NR_InterFreqCarrierFreqInfo_v1610_ssb_PositionQCL_Common_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_InterFreqCAG_CellListPerPLMN_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_InterFreqCAG_CellListPerPLMN_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->plmn_IdentityIndex_r16, _lidx);
	HTON_32(&_buffer[*_lidx], p->cag_CellList_r16.d, _lidx);
	for (size_t i4 = 0; i4 < p->cag_CellList_r16.d; i4++) {
		_serNrSysEncSQN_NR_PCI_Range(_buffer, _size, _lidx, &p->cag_CellList_r16.v[i4]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_InterFreqCAG_CellListPerPLMN_r16_SQN_NR_InterFreqCarrierFreqInfo_v1610_interFreqCAG_CellList_r16_DynamicOptional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_InterFreqCAG_CellListPerPLMN_r16_SQN_NR_InterFreqCarrierFreqInfo_v1610_interFreqCAG_CellList_r16_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i3 = 0; i3 < p->v.d; i3++) {
		_serNrSysEncSQN_NR_InterFreqCAG_CellListPerPLMN_r16(_buffer, _size, _lidx, &p->v.v[i3]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_InterFreqCarrierFreqInfo_v1610(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_InterFreqCarrierFreqInfo_v1610* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncSQN_NR_InterFreqNeighCellList_v1610_SQN_NR_InterFreqCarrierFreqInfo_v1610_interFreqNeighCellList_v1610_Optional(_buffer, _size, _lidx, &p->interFreqNeighCellList_v1610);
	_serNrSysEncSQN_NR_SSB_MTC2_LP_r16_SQN_NR_InterFreqCarrierFreqInfo_v1610_smtc2_LP_r16_Optional(_buffer, _size, _lidx, &p->smtc2_LP_r16);
	_serNrSysEncSQN_NR_InterFreqWhiteCellList_r16_SQN_NR_InterFreqCarrierFreqInfo_v1610_interFreqWhiteCellList_r16_Optional(_buffer, _size, _lidx, &p->interFreqWhiteCellList_r16);
	_serNrSysEncSQN_NR_SSB_PositionQCL_Relation_r16_e_SQN_NR_InterFreqCarrierFreqInfo_v1610_ssb_PositionQCL_Common_r16_Optional(_buffer, _size, _lidx, &p->ssb_PositionQCL_Common_r16);
	_serNrSysEncSQN_NR_InterFreqCAG_CellListPerPLMN_r16_SQN_NR_InterFreqCarrierFreqInfo_v1610_interFreqCAG_CellList_r16_DynamicOptional(_buffer, _size, _lidx, &p->interFreqCAG_CellList_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_InterFreqCarrierFreqList_v1610_SQN_NR_SIB4_interFreqCarrierFreqList_v1610_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_InterFreqCarrierFreqList_v1610_SQN_NR_SIB4_interFreqCarrierFreqList_v1610_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serNrSysEncSQN_NR_InterFreqCarrierFreqInfo_v1610(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SIB4(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SIB4* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_32(&_buffer[*_lidx], p->interFreqCarrierFreqList.d, _lidx);
	for (size_t i2 = 0; i2 < p->interFreqCarrierFreqList.d; i2++) {
		_serNrSysEncSQN_NR_InterFreqCarrierFreqInfo(_buffer, _size, _lidx, &p->interFreqCarrierFreqList.v[i2]);
	}
	_serNrSysEncOCTET_STRING_SQN_NR_SIB4_lateNonCriticalExtension_Optional(_buffer, _size, _lidx, &p->lateNonCriticalExtension);
	_serNrSysEncSQN_NR_InterFreqCarrierFreqList_v1610_SQN_NR_SIB4_interFreqCarrierFreqList_v1610_Optional(_buffer, _size, _lidx, &p->interFreqCarrierFreqList_v1610);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncInt8_t_SQN_NR_EUTRA_NS_PmaxValue_additionalPmax_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct int8_t_SQN_NR_EUTRA_NS_PmaxValue_additionalPmax_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncUint16_t_SQN_NR_EUTRA_NS_PmaxValue_additionalSpectrumEmission_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint16_t_SQN_NR_EUTRA_NS_PmaxValue_additionalSpectrumEmission_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_16(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_EUTRA_NS_PmaxValue(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_EUTRA_NS_PmaxValue* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncInt8_t_SQN_NR_EUTRA_NS_PmaxValue_additionalPmax_Optional(_buffer, _size, _lidx, &p->additionalPmax);
	_serNrSysEncUint16_t_SQN_NR_EUTRA_NS_PmaxValue_additionalSpectrumEmission_Optional(_buffer, _size, _lidx, &p->additionalSpectrumEmission);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_EUTRA_NS_PmaxList_SQN_NR_EUTRA_MultiBandInfo_eutra_NS_PmaxList_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_EUTRA_NS_PmaxList_SQN_NR_EUTRA_MultiBandInfo_eutra_NS_PmaxList_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i4 = 0; i4 < p->v.d; i4++) {
		_serNrSysEncSQN_NR_EUTRA_NS_PmaxValue(_buffer, _size, _lidx, &p->v.v[i4]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_EUTRA_MultiBandInfo(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_EUTRA_MultiBandInfo* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_16(&_buffer[*_lidx], p->eutra_FreqBandIndicator, _lidx);
	_serNrSysEncSQN_NR_EUTRA_NS_PmaxList_SQN_NR_EUTRA_MultiBandInfo_eutra_NS_PmaxList_Optional(_buffer, _size, _lidx, &p->eutra_NS_PmaxList);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_EUTRA_MultiBandInfoList_SQN_NR_CarrierFreqEUTRA_eutra_multiBandInfoList_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_EUTRA_MultiBandInfoList_SQN_NR_CarrierFreqEUTRA_eutra_multiBandInfoList_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i3 = 0; i3 < p->v.d; i3++) {
		_serNrSysEncSQN_NR_EUTRA_MultiBandInfo(_buffer, _size, _lidx, &p->v.v[i3]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncUint8_t_SQN_NR_EUTRA_FreqNeighCellInfo_q_RxLevMinOffsetCell_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint8_t_SQN_NR_EUTRA_FreqNeighCellInfo_q_RxLevMinOffsetCell_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncUint8_t_SQN_NR_EUTRA_FreqNeighCellInfo_q_QualMinOffsetCell_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint8_t_SQN_NR_EUTRA_FreqNeighCellInfo_q_QualMinOffsetCell_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_EUTRA_FreqNeighCellInfo(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_EUTRA_FreqNeighCellInfo* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_16(&_buffer[*_lidx], p->physCellId, _lidx);
	{
		size_t _tmp = (size_t)p->dummy;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncUint8_t_SQN_NR_EUTRA_FreqNeighCellInfo_q_RxLevMinOffsetCell_Optional(_buffer, _size, _lidx, &p->q_RxLevMinOffsetCell);
	_serNrSysEncUint8_t_SQN_NR_EUTRA_FreqNeighCellInfo_q_QualMinOffsetCell_Optional(_buffer, _size, _lidx, &p->q_QualMinOffsetCell);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_EUTRA_FreqNeighCellList_SQN_NR_CarrierFreqEUTRA_eutra_FreqNeighCellList_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_EUTRA_FreqNeighCellList_SQN_NR_CarrierFreqEUTRA_eutra_FreqNeighCellList_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i3 = 0; i3 < p->v.d; i3++) {
		_serNrSysEncSQN_NR_EUTRA_FreqNeighCellInfo(_buffer, _size, _lidx, &p->v.v[i3]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_EUTRA_PhysCellIdRange_range_e_range_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_EUTRA_PhysCellIdRange_range_e_range_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_EUTRA_PhysCellIdRange(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_EUTRA_PhysCellIdRange* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_16(&_buffer[*_lidx], p->start, _lidx);
	_serNrSysEncSQN_NR_EUTRA_PhysCellIdRange_range_e_range_Optional(_buffer, _size, _lidx, &p->range);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_EUTRA_FreqBlackCellList_SQN_NR_CarrierFreqEUTRA_eutra_BlackCellList_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_EUTRA_FreqBlackCellList_SQN_NR_CarrierFreqEUTRA_eutra_BlackCellList_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i3 = 0; i3 < p->v.d; i3++) {
		_serNrSysEncSQN_NR_EUTRA_PhysCellIdRange(_buffer, _size, _lidx, &p->v.v[i3]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_CellReselectionPriority_SQN_NR_CarrierFreqEUTRA_cellReselectionPriority_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_CellReselectionPriority_SQN_NR_CarrierFreqEUTRA_cellReselectionPriority_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_CellReselectionSubPriority_e_SQN_NR_CarrierFreqEUTRA_cellReselectionSubPriority_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_CellReselectionSubPriority_e_SQN_NR_CarrierFreqEUTRA_cellReselectionSubPriority_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_CarrierFreqEUTRA_threshX_Q(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_CarrierFreqEUTRA_threshX_Q* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->threshX_HighQ, _lidx);
	HTON_8(&_buffer[*_lidx], p->threshX_LowQ, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_CarrierFreqEUTRA_threshX_Q_threshX_Q_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_CarrierFreqEUTRA_threshX_Q_threshX_Q_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_CarrierFreqEUTRA_threshX_Q(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_CarrierFreqEUTRA(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_CarrierFreqEUTRA* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_32(&_buffer[*_lidx], p->carrierFreq, _lidx);
	_serNrSysEncSQN_NR_EUTRA_MultiBandInfoList_SQN_NR_CarrierFreqEUTRA_eutra_multiBandInfoList_Optional(_buffer, _size, _lidx, &p->eutra_multiBandInfoList);
	_serNrSysEncSQN_NR_EUTRA_FreqNeighCellList_SQN_NR_CarrierFreqEUTRA_eutra_FreqNeighCellList_Optional(_buffer, _size, _lidx, &p->eutra_FreqNeighCellList);
	_serNrSysEncSQN_NR_EUTRA_FreqBlackCellList_SQN_NR_CarrierFreqEUTRA_eutra_BlackCellList_Optional(_buffer, _size, _lidx, &p->eutra_BlackCellList);
	{
		size_t _tmp = (size_t)p->allowedMeasBandwidth;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	HTON_8(&_buffer[*_lidx], p->presenceAntennaPort1, _lidx);
	_serNrSysEncSQN_NR_CellReselectionPriority_SQN_NR_CarrierFreqEUTRA_cellReselectionPriority_Optional(_buffer, _size, _lidx, &p->cellReselectionPriority);
	_serNrSysEncSQN_NR_CellReselectionSubPriority_e_SQN_NR_CarrierFreqEUTRA_cellReselectionSubPriority_Optional(_buffer, _size, _lidx, &p->cellReselectionSubPriority);
	HTON_8(&_buffer[*_lidx], p->threshX_High, _lidx);
	HTON_8(&_buffer[*_lidx], p->threshX_Low, _lidx);
	HTON_8(&_buffer[*_lidx], p->q_RxLevMin, _lidx);
	HTON_8(&_buffer[*_lidx], p->q_QualMin, _lidx);
	HTON_8(&_buffer[*_lidx], p->p_MaxEUTRA, _lidx);
	_serNrSysEncSQN_NR_CarrierFreqEUTRA_threshX_Q_threshX_Q_Optional(_buffer, _size, _lidx, &p->threshX_Q);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_CarrierFreqListEUTRA_SQN_NR_SIB5_carrierFreqListEUTRA_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_CarrierFreqListEUTRA_SQN_NR_SIB5_carrierFreqListEUTRA_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serNrSysEncSQN_NR_CarrierFreqEUTRA(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SpeedStateScaleFactors_SQN_NR_SIB5_t_ReselectionEUTRA_SF_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SpeedStateScaleFactors_SQN_NR_SIB5_t_ReselectionEUTRA_SF_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_SpeedStateScaleFactors(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncOCTET_STRING_SQN_NR_SIB5_lateNonCriticalExtension_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct OCTET_STRING_SQN_NR_SIB5_lateNonCriticalExtension_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		HTON_8(&_buffer[*_lidx], p->v.v[i2], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_CarrierFreqEUTRA_v1610_highSpeedEUTRACarrier_r16_e_highSpeedEUTRACarrier_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_CarrierFreqEUTRA_v1610_highSpeedEUTRACarrier_r16_e_highSpeedEUTRACarrier_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_CarrierFreqEUTRA_v1610(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_CarrierFreqEUTRA_v1610* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncSQN_NR_CarrierFreqEUTRA_v1610_highSpeedEUTRACarrier_r16_e_highSpeedEUTRACarrier_r16_Optional(_buffer, _size, _lidx, &p->highSpeedEUTRACarrier_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_CarrierFreqListEUTRA_v1610_SQN_NR_SIB5_carrierFreqListEUTRA_v1610_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_CarrierFreqListEUTRA_v1610_SQN_NR_SIB5_carrierFreqListEUTRA_v1610_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serNrSysEncSQN_NR_CarrierFreqEUTRA_v1610(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SIB5(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SIB5* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncSQN_NR_CarrierFreqListEUTRA_SQN_NR_SIB5_carrierFreqListEUTRA_Optional(_buffer, _size, _lidx, &p->carrierFreqListEUTRA);
	HTON_8(&_buffer[*_lidx], p->t_ReselectionEUTRA, _lidx);
	_serNrSysEncSQN_NR_SpeedStateScaleFactors_SQN_NR_SIB5_t_ReselectionEUTRA_SF_Optional(_buffer, _size, _lidx, &p->t_ReselectionEUTRA_SF);
	_serNrSysEncOCTET_STRING_SQN_NR_SIB5_lateNonCriticalExtension_Optional(_buffer, _size, _lidx, &p->lateNonCriticalExtension);
	_serNrSysEncSQN_NR_CarrierFreqListEUTRA_v1610_SQN_NR_SIB5_carrierFreqListEUTRA_v1610_Optional(_buffer, _size, _lidx, &p->carrierFreqListEUTRA_v1610);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncOCTET_STRING_SQN_NR_SIB6_lateNonCriticalExtension_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct OCTET_STRING_SQN_NR_SIB6_lateNonCriticalExtension_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		HTON_8(&_buffer[*_lidx], p->v.v[i2], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SIB6(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SIB6* p)
{
	(void)_size; // TODO: generate boundaries checking

	for (size_t i2 = 0; i2 < 16; i2++) {
		HTON_8(&_buffer[*_lidx], p->messageIdentifier[i2], _lidx);
	}
	for (size_t i2 = 0; i2 < 16; i2++) {
		HTON_8(&_buffer[*_lidx], p->serialNumber[i2], _lidx);
	}
	for (size_t i2 = 0; i2 < 2; i2++) {
		HTON_8(&_buffer[*_lidx], p->warningType[i2], _lidx);
	}
	_serNrSysEncOCTET_STRING_SQN_NR_SIB6_lateNonCriticalExtension_Optional(_buffer, _size, _lidx, &p->lateNonCriticalExtension);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncO1_SQN_NR_SIB7_dataCodingScheme_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct O1_SQN_NR_SIB7_dataCodingScheme_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	for (size_t i2 = 0; i2 < 1; i2++) {
		HTON_8(&_buffer[*_lidx], p->v[i2], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncOCTET_STRING_SQN_NR_SIB7_lateNonCriticalExtension_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct OCTET_STRING_SQN_NR_SIB7_lateNonCriticalExtension_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		HTON_8(&_buffer[*_lidx], p->v.v[i2], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SIB7(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SIB7* p)
{
	(void)_size; // TODO: generate boundaries checking

	for (size_t i2 = 0; i2 < 16; i2++) {
		HTON_8(&_buffer[*_lidx], p->messageIdentifier[i2], _lidx);
	}
	for (size_t i2 = 0; i2 < 16; i2++) {
		HTON_8(&_buffer[*_lidx], p->serialNumber[i2], _lidx);
	}
	{
		size_t _tmp = (size_t)p->warningMessageSegmentType;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	HTON_8(&_buffer[*_lidx], p->warningMessageSegmentNumber, _lidx);
	HTON_32(&_buffer[*_lidx], p->warningMessageSegment.d, _lidx);
	for (size_t i2 = 0; i2 < p->warningMessageSegment.d; i2++) {
		HTON_8(&_buffer[*_lidx], p->warningMessageSegment.v[i2], _lidx);
	}
	_serNrSysEncO1_SQN_NR_SIB7_dataCodingScheme_Optional(_buffer, _size, _lidx, &p->dataCodingScheme);
	_serNrSysEncOCTET_STRING_SQN_NR_SIB7_lateNonCriticalExtension_Optional(_buffer, _size, _lidx, &p->lateNonCriticalExtension);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncO1_SQN_NR_SIB8_dataCodingScheme_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct O1_SQN_NR_SIB8_dataCodingScheme_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	for (size_t i2 = 0; i2 < 1; i2++) {
		HTON_8(&_buffer[*_lidx], p->v[i2], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncOCTET_STRING_SQN_NR_SIB8_warningAreaCoordinatesSegment_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct OCTET_STRING_SQN_NR_SIB8_warningAreaCoordinatesSegment_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		HTON_8(&_buffer[*_lidx], p->v.v[i2], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncOCTET_STRING_SQN_NR_SIB8_lateNonCriticalExtension_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct OCTET_STRING_SQN_NR_SIB8_lateNonCriticalExtension_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		HTON_8(&_buffer[*_lidx], p->v.v[i2], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SIB8(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SIB8* p)
{
	(void)_size; // TODO: generate boundaries checking

	for (size_t i2 = 0; i2 < 16; i2++) {
		HTON_8(&_buffer[*_lidx], p->messageIdentifier[i2], _lidx);
	}
	for (size_t i2 = 0; i2 < 16; i2++) {
		HTON_8(&_buffer[*_lidx], p->serialNumber[i2], _lidx);
	}
	{
		size_t _tmp = (size_t)p->warningMessageSegmentType;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	HTON_8(&_buffer[*_lidx], p->warningMessageSegmentNumber, _lidx);
	HTON_32(&_buffer[*_lidx], p->warningMessageSegment.d, _lidx);
	for (size_t i2 = 0; i2 < p->warningMessageSegment.d; i2++) {
		HTON_8(&_buffer[*_lidx], p->warningMessageSegment.v[i2], _lidx);
	}
	_serNrSysEncO1_SQN_NR_SIB8_dataCodingScheme_Optional(_buffer, _size, _lidx, &p->dataCodingScheme);
	_serNrSysEncOCTET_STRING_SQN_NR_SIB8_warningAreaCoordinatesSegment_Optional(_buffer, _size, _lidx, &p->warningAreaCoordinatesSegment);
	_serNrSysEncOCTET_STRING_SQN_NR_SIB8_lateNonCriticalExtension_Optional(_buffer, _size, _lidx, &p->lateNonCriticalExtension);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncB2_SQN_NR_SIB9_timeInfo_dayLightSavingTime_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct B2_SQN_NR_SIB9_timeInfo_dayLightSavingTime_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	for (size_t i2 = 0; i2 < 2; i2++) {
		HTON_8(&_buffer[*_lidx], p->v[i2], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncInt16_t_SQN_NR_SIB9_timeInfo_leapSeconds_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct int16_t_SQN_NR_SIB9_timeInfo_leapSeconds_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_16(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncInt8_t_SQN_NR_SIB9_timeInfo_localTimeOffset_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct int8_t_SQN_NR_SIB9_timeInfo_localTimeOffset_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SIB9_timeInfo(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SIB9_timeInfo* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_32(&_buffer[*_lidx], p->timeInfoUTC, _lidx);
	_serNrSysEncB2_SQN_NR_SIB9_timeInfo_dayLightSavingTime_Optional(_buffer, _size, _lidx, &p->dayLightSavingTime);
	_serNrSysEncInt16_t_SQN_NR_SIB9_timeInfo_leapSeconds_Optional(_buffer, _size, _lidx, &p->leapSeconds);
	_serNrSysEncInt8_t_SQN_NR_SIB9_timeInfo_localTimeOffset_Optional(_buffer, _size, _lidx, &p->localTimeOffset);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SIB9_timeInfo_timeInfo_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SIB9_timeInfo_timeInfo_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_SIB9_timeInfo(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncOCTET_STRING_SQN_NR_SIB9_lateNonCriticalExtension_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct OCTET_STRING_SQN_NR_SIB9_lateNonCriticalExtension_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		HTON_8(&_buffer[*_lidx], p->v.v[i2], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_ReferenceTime_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_ReferenceTime_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_32(&_buffer[*_lidx], p->refDays_r16, _lidx);
	HTON_32(&_buffer[*_lidx], p->refSeconds_r16, _lidx);
	HTON_16(&_buffer[*_lidx], p->refMilliSeconds_r16, _lidx);
	HTON_32(&_buffer[*_lidx], p->refTenNanoSeconds_r16, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncUint16_t_SQN_NR_ReferenceTimeInfo_r16_uncertainty_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint16_t_SQN_NR_ReferenceTimeInfo_r16_uncertainty_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_16(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_ReferenceTimeInfo_r16_timeInfoType_r16_e_timeInfoType_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_ReferenceTimeInfo_r16_timeInfoType_r16_e_timeInfoType_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncUint16_t_SQN_NR_ReferenceTimeInfo_r16_referenceSFN_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint16_t_SQN_NR_ReferenceTimeInfo_r16_referenceSFN_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_16(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_ReferenceTimeInfo_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_ReferenceTimeInfo_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncSQN_NR_ReferenceTime_r16(_buffer, _size, _lidx, &p->time_r16);
	_serNrSysEncUint16_t_SQN_NR_ReferenceTimeInfo_r16_uncertainty_r16_Optional(_buffer, _size, _lidx, &p->uncertainty_r16);
	_serNrSysEncSQN_NR_ReferenceTimeInfo_r16_timeInfoType_r16_e_timeInfoType_r16_Optional(_buffer, _size, _lidx, &p->timeInfoType_r16);
	_serNrSysEncUint16_t_SQN_NR_ReferenceTimeInfo_r16_referenceSFN_r16_Optional(_buffer, _size, _lidx, &p->referenceSFN_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_ReferenceTimeInfo_r16_SQN_NR_SIB9_referenceTimeInfo_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_ReferenceTimeInfo_r16_SQN_NR_SIB9_referenceTimeInfo_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_ReferenceTimeInfo_r16(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SIB9(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SIB9* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncSQN_NR_SIB9_timeInfo_timeInfo_Optional(_buffer, _size, _lidx, &p->timeInfo);
	_serNrSysEncOCTET_STRING_SQN_NR_SIB9_lateNonCriticalExtension_Optional(_buffer, _size, _lidx, &p->lateNonCriticalExtension);
	_serNrSysEncSQN_NR_ReferenceTimeInfo_r16_SQN_NR_SIB9_referenceTimeInfo_r16_Optional(_buffer, _size, _lidx, &p->referenceTimeInfo_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncOCTET_STRING_SQN_NR_HRNN_r16_hrnn_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct OCTET_STRING_SQN_NR_HRNN_r16_hrnn_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i3 = 0; i3 < p->v.d; i3++) {
		HTON_8(&_buffer[*_lidx], p->v.v[i3], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_HRNN_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_HRNN_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncOCTET_STRING_SQN_NR_HRNN_r16_hrnn_r16_Optional(_buffer, _size, _lidx, &p->hrnn_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_HRNN_List_r16_SQN_NR_SIB10_r16_hrnn_List_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_HRNN_List_r16_SQN_NR_SIB10_r16_hrnn_List_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serNrSysEncSQN_NR_HRNN_r16(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncOCTET_STRING_SQN_NR_SIB10_r16_lateNonCriticalExtension_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct OCTET_STRING_SQN_NR_SIB10_r16_lateNonCriticalExtension_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		HTON_8(&_buffer[*_lidx], p->v.v[i2], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SIB10_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SIB10_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncSQN_NR_HRNN_List_r16_SQN_NR_SIB10_r16_hrnn_List_r16_Optional(_buffer, _size, _lidx, &p->hrnn_List_r16);
	_serNrSysEncOCTET_STRING_SQN_NR_SIB10_r16_lateNonCriticalExtension_Optional(_buffer, _size, _lidx, &p->lateNonCriticalExtension);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_MultiFrequencyBandListNR_SQN_NR_MeasIdleCarrierNR_r16_frequencyBandList_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_MultiFrequencyBandListNR_SQN_NR_MeasIdleCarrierNR_r16_frequencyBandList_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i3 = 0; i3 < p->v.d; i3++) {
		HTON_16(&_buffer[*_lidx], p->v.v[i3], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_CellListNR_r16_SQN_NR_MeasIdleCarrierNR_r16_measCellListNR_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_CellListNR_r16_SQN_NR_MeasIdleCarrierNR_r16_measCellListNR_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i3 = 0; i3 < p->v.d; i3++) {
		_serNrSysEncSQN_NR_PCI_Range(_buffer, _size, _lidx, &p->v.v[i3]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_RSRP_Range_SQN_NR_MeasIdleCarrierNR_r16_qualityThreshold_r16_idleRSRP_Threshold_NR_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_RSRP_Range_SQN_NR_MeasIdleCarrierNR_r16_qualityThreshold_r16_idleRSRP_Threshold_NR_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_RSRQ_Range_SQN_NR_MeasIdleCarrierNR_r16_qualityThreshold_r16_idleRSRQ_Threshold_NR_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_RSRQ_Range_SQN_NR_MeasIdleCarrierNR_r16_qualityThreshold_r16_idleRSRQ_Threshold_NR_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_MeasIdleCarrierNR_r16_qualityThreshold_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_MeasIdleCarrierNR_r16_qualityThreshold_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncSQN_NR_RSRP_Range_SQN_NR_MeasIdleCarrierNR_r16_qualityThreshold_r16_idleRSRP_Threshold_NR_r16_Optional(_buffer, _size, _lidx, &p->idleRSRP_Threshold_NR_r16);
	_serNrSysEncSQN_NR_RSRQ_Range_SQN_NR_MeasIdleCarrierNR_r16_qualityThreshold_r16_idleRSRQ_Threshold_NR_r16_Optional(_buffer, _size, _lidx, &p->idleRSRQ_Threshold_NR_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_MeasIdleCarrierNR_r16_qualityThreshold_r16_qualityThreshold_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_MeasIdleCarrierNR_r16_qualityThreshold_r16_qualityThreshold_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_MeasIdleCarrierNR_r16_qualityThreshold_r16(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncUint8_t_SQN_NR_MeasIdleCarrierNR_r16_ssb_MeasConfig_r16_nrofSS_BlocksToAverage_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint8_t_SQN_NR_MeasIdleCarrierNR_r16_ssb_MeasConfig_r16_nrofSS_BlocksToAverage_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_ThresholdNR_SQN_NR_MeasIdleCarrierNR_r16_ssb_MeasConfig_r16_absThreshSS_BlocksConsolidation_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_ThresholdNR_SQN_NR_MeasIdleCarrierNR_r16_ssb_MeasConfig_r16_absThreshSS_BlocksConsolidation_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_ThresholdNR(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SSB_MTC_SQN_NR_MeasIdleCarrierNR_r16_ssb_MeasConfig_r16_smtc_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SSB_MTC_SQN_NR_MeasIdleCarrierNR_r16_ssb_MeasConfig_r16_smtc_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_SSB_MTC(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SSB_ToMeasure_SQN_NR_MeasIdleCarrierNR_r16_ssb_MeasConfig_r16_ssb_ToMeasure_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SSB_ToMeasure_SQN_NR_MeasIdleCarrierNR_r16_ssb_MeasConfig_r16_ssb_ToMeasure_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_SSB_ToMeasure(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SS_RSSI_Measurement_SQN_NR_MeasIdleCarrierNR_r16_ssb_MeasConfig_r16_ss_RSSI_Measurement_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SS_RSSI_Measurement_SQN_NR_MeasIdleCarrierNR_r16_ssb_MeasConfig_r16_ss_RSSI_Measurement_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_SS_RSSI_Measurement(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_MeasIdleCarrierNR_r16_ssb_MeasConfig_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_MeasIdleCarrierNR_r16_ssb_MeasConfig_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncUint8_t_SQN_NR_MeasIdleCarrierNR_r16_ssb_MeasConfig_r16_nrofSS_BlocksToAverage_r16_Optional(_buffer, _size, _lidx, &p->nrofSS_BlocksToAverage_r16);
	_serNrSysEncSQN_NR_ThresholdNR_SQN_NR_MeasIdleCarrierNR_r16_ssb_MeasConfig_r16_absThreshSS_BlocksConsolidation_r16_Optional(_buffer, _size, _lidx, &p->absThreshSS_BlocksConsolidation_r16);
	_serNrSysEncSQN_NR_SSB_MTC_SQN_NR_MeasIdleCarrierNR_r16_ssb_MeasConfig_r16_smtc_r16_Optional(_buffer, _size, _lidx, &p->smtc_r16);
	_serNrSysEncSQN_NR_SSB_ToMeasure_SQN_NR_MeasIdleCarrierNR_r16_ssb_MeasConfig_r16_ssb_ToMeasure_r16_Optional(_buffer, _size, _lidx, &p->ssb_ToMeasure_r16);
	HTON_8(&_buffer[*_lidx], p->deriveSSB_IndexFromCell_r16, _lidx);
	_serNrSysEncSQN_NR_SS_RSSI_Measurement_SQN_NR_MeasIdleCarrierNR_r16_ssb_MeasConfig_r16_ss_RSSI_Measurement_r16_Optional(_buffer, _size, _lidx, &p->ss_RSSI_Measurement_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_MeasIdleCarrierNR_r16_ssb_MeasConfig_r16_ssb_MeasConfig_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_MeasIdleCarrierNR_r16_ssb_MeasConfig_r16_ssb_MeasConfig_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_MeasIdleCarrierNR_r16_ssb_MeasConfig_r16(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_BeamMeasConfigIdle_NR_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_BeamMeasConfigIdle_NR_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->reportQuantityRS_Indexes_r16;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	HTON_8(&_buffer[*_lidx], p->maxNrofRS_IndexesToReport_r16, _lidx);
	HTON_8(&_buffer[*_lidx], p->includeBeamMeasurements_r16, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_BeamMeasConfigIdle_NR_r16_SQN_NR_MeasIdleCarrierNR_r16_beamMeasConfigIdle_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_BeamMeasConfigIdle_NR_r16_SQN_NR_MeasIdleCarrierNR_r16_beamMeasConfigIdle_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_BeamMeasConfigIdle_NR_r16(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_MeasIdleCarrierNR_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_MeasIdleCarrierNR_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_32(&_buffer[*_lidx], p->carrierFreq_r16, _lidx);
	{
		size_t _tmp = (size_t)p->ssbSubcarrierSpacing_r16;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_MultiFrequencyBandListNR_SQN_NR_MeasIdleCarrierNR_r16_frequencyBandList_Optional(_buffer, _size, _lidx, &p->frequencyBandList);
	_serNrSysEncSQN_NR_CellListNR_r16_SQN_NR_MeasIdleCarrierNR_r16_measCellListNR_r16_Optional(_buffer, _size, _lidx, &p->measCellListNR_r16);
	{
		size_t _tmp = (size_t)p->reportQuantities_r16;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_MeasIdleCarrierNR_r16_qualityThreshold_r16_qualityThreshold_r16_Optional(_buffer, _size, _lidx, &p->qualityThreshold_r16);
	_serNrSysEncSQN_NR_MeasIdleCarrierNR_r16_ssb_MeasConfig_r16_ssb_MeasConfig_r16_Optional(_buffer, _size, _lidx, &p->ssb_MeasConfig_r16);
	_serNrSysEncSQN_NR_BeamMeasConfigIdle_NR_r16_SQN_NR_MeasIdleCarrierNR_r16_beamMeasConfigIdle_r16_Optional(_buffer, _size, _lidx, &p->beamMeasConfigIdle_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_MeasIdleCarrierNR_r16_SQN_NR_MeasIdleConfigSIB_r16_measIdleCarrierListNR_r16_DynamicOptional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_MeasIdleCarrierNR_r16_SQN_NR_MeasIdleConfigSIB_r16_measIdleCarrierListNR_r16_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serNrSysEncSQN_NR_MeasIdleCarrierNR_r16(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_CellListEUTRA_r16_SQN_NR_MeasIdleCarrierEUTRA_r16_measCellListEUTRA_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_CellListEUTRA_r16_SQN_NR_MeasIdleCarrierEUTRA_r16_measCellListEUTRA_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i3 = 0; i3 < p->v.d; i3++) {
		_serNrSysEncSQN_NR_EUTRA_PhysCellIdRange(_buffer, _size, _lidx, &p->v.v[i3]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_RSRP_RangeEUTRA_SQN_NR_MeasIdleCarrierEUTRA_r16_qualityThresholdEUTRA_r16_idleRSRP_Threshold_EUTRA_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_RSRP_RangeEUTRA_SQN_NR_MeasIdleCarrierEUTRA_r16_qualityThresholdEUTRA_r16_idleRSRP_Threshold_EUTRA_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_RSRQ_RangeEUTRA_r16_SQN_NR_MeasIdleCarrierEUTRA_r16_qualityThresholdEUTRA_r16_idleRSRQ_Threshold_EUTRA_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_RSRQ_RangeEUTRA_r16_SQN_NR_MeasIdleCarrierEUTRA_r16_qualityThresholdEUTRA_r16_idleRSRQ_Threshold_EUTRA_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_MeasIdleCarrierEUTRA_r16_qualityThresholdEUTRA_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_MeasIdleCarrierEUTRA_r16_qualityThresholdEUTRA_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncSQN_NR_RSRP_RangeEUTRA_SQN_NR_MeasIdleCarrierEUTRA_r16_qualityThresholdEUTRA_r16_idleRSRP_Threshold_EUTRA_r16_Optional(_buffer, _size, _lidx, &p->idleRSRP_Threshold_EUTRA_r16);
	_serNrSysEncSQN_NR_RSRQ_RangeEUTRA_r16_SQN_NR_MeasIdleCarrierEUTRA_r16_qualityThresholdEUTRA_r16_idleRSRQ_Threshold_EUTRA_r16_Optional(_buffer, _size, _lidx, &p->idleRSRQ_Threshold_EUTRA_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_MeasIdleCarrierEUTRA_r16_qualityThresholdEUTRA_r16_qualityThresholdEUTRA_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_MeasIdleCarrierEUTRA_r16_qualityThresholdEUTRA_r16_qualityThresholdEUTRA_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_MeasIdleCarrierEUTRA_r16_qualityThresholdEUTRA_r16(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_MeasIdleCarrierEUTRA_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_MeasIdleCarrierEUTRA_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_32(&_buffer[*_lidx], p->carrierFreqEUTRA_r16, _lidx);
	{
		size_t _tmp = (size_t)p->allowedMeasBandwidth_r16;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_CellListEUTRA_r16_SQN_NR_MeasIdleCarrierEUTRA_r16_measCellListEUTRA_r16_Optional(_buffer, _size, _lidx, &p->measCellListEUTRA_r16);
	{
		size_t _tmp = (size_t)p->reportQuantitiesEUTRA_r16;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_MeasIdleCarrierEUTRA_r16_qualityThresholdEUTRA_r16_qualityThresholdEUTRA_r16_Optional(_buffer, _size, _lidx, &p->qualityThresholdEUTRA_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_MeasIdleCarrierEUTRA_r16_SQN_NR_MeasIdleConfigSIB_r16_measIdleCarrierListEUTRA_r16_DynamicOptional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_MeasIdleCarrierEUTRA_r16_SQN_NR_MeasIdleConfigSIB_r16_measIdleCarrierListEUTRA_r16_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serNrSysEncSQN_NR_MeasIdleCarrierEUTRA_r16(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_MeasIdleConfigSIB_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_MeasIdleConfigSIB_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncSQN_NR_MeasIdleCarrierNR_r16_SQN_NR_MeasIdleConfigSIB_r16_measIdleCarrierListNR_r16_DynamicOptional(_buffer, _size, _lidx, &p->measIdleCarrierListNR_r16);
	_serNrSysEncSQN_NR_MeasIdleCarrierEUTRA_r16_SQN_NR_MeasIdleConfigSIB_r16_measIdleCarrierListEUTRA_r16_DynamicOptional(_buffer, _size, _lidx, &p->measIdleCarrierListEUTRA_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_MeasIdleConfigSIB_r16_SQN_NR_SIB11_r16_measIdleConfigSIB_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_MeasIdleConfigSIB_r16_SQN_NR_SIB11_r16_measIdleConfigSIB_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_MeasIdleConfigSIB_r16(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncOCTET_STRING_SQN_NR_SIB11_r16_lateNonCriticalExtension_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct OCTET_STRING_SQN_NR_SIB11_r16_lateNonCriticalExtension_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		HTON_8(&_buffer[*_lidx], p->v.v[i2], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SIB11_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SIB11_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncSQN_NR_MeasIdleConfigSIB_r16_SQN_NR_SIB11_r16_measIdleConfigSIB_r16_Optional(_buffer, _size, _lidx, &p->measIdleConfigSIB_r16);
	_serNrSysEncOCTET_STRING_SQN_NR_SIB11_r16_lateNonCriticalExtension_Optional(_buffer, _size, _lidx, &p->lateNonCriticalExtension);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SIB12_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SIB12_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->segmentNumber_r16, _lidx);
	{
		size_t _tmp = (size_t)p->segmentType_r16;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	HTON_32(&_buffer[*_lidx], p->segmentContainer_r16.d, _lidx);
	for (size_t i2 = 0; i2 < p->segmentContainer_r16.d; i2++) {
		HTON_8(&_buffer[*_lidx], p->segmentContainer_r16.v[i2], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncOCTET_STRING_SQN_NR_SIB13_r16_lateNonCriticalExtension_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct OCTET_STRING_SQN_NR_SIB13_r16_lateNonCriticalExtension_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		HTON_8(&_buffer[*_lidx], p->v.v[i2], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SIB13_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SIB13_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_32(&_buffer[*_lidx], p->sl_V2X_ConfigCommon_r16.d, _lidx);
	for (size_t i2 = 0; i2 < p->sl_V2X_ConfigCommon_r16.d; i2++) {
		HTON_8(&_buffer[*_lidx], p->sl_V2X_ConfigCommon_r16.v[i2], _lidx);
	}
	HTON_32(&_buffer[*_lidx], p->sl_Bandwidth_r16.d, _lidx);
	for (size_t i2 = 0; i2 < p->sl_Bandwidth_r16.d; i2++) {
		HTON_8(&_buffer[*_lidx], p->sl_Bandwidth_r16.v[i2], _lidx);
	}
	HTON_32(&_buffer[*_lidx], p->tdd_Config_r16.d, _lidx);
	for (size_t i2 = 0; i2 < p->tdd_Config_r16.d; i2++) {
		HTON_8(&_buffer[*_lidx], p->tdd_Config_r16.v[i2], _lidx);
	}
	_serNrSysEncOCTET_STRING_SQN_NR_SIB13_r16_lateNonCriticalExtension_Optional(_buffer, _size, _lidx, &p->lateNonCriticalExtension);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncOCTET_STRING_SQN_NR_SIB14_r16_lateNonCriticalExtension_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct OCTET_STRING_SQN_NR_SIB14_r16_lateNonCriticalExtension_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		HTON_8(&_buffer[*_lidx], p->v.v[i2], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SIB14_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SIB14_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_32(&_buffer[*_lidx], p->sl_V2X_ConfigCommonExt_r16.d, _lidx);
	for (size_t i2 = 0; i2 < p->sl_V2X_ConfigCommonExt_r16.d; i2++) {
		HTON_8(&_buffer[*_lidx], p->sl_V2X_ConfigCommonExt_r16.v[i2], _lidx);
	}
	_serNrSysEncOCTET_STRING_SQN_NR_SIB14_r16_lateNonCriticalExtension_Optional(_buffer, _size, _lidx, &p->lateNonCriticalExtension);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SystemInformation_IEs_sib_TypeAndInfo_s_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SQN_NR_SystemInformation_IEs_sib_TypeAndInfo_s_Value* p, enum SQN_NR_SystemInformation_IEs_sib_TypeAndInfo_s_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SystemInformation_IEs_sib_TypeAndInfo_s_sib2) {
		_serNrSysEncSQN_NR_SIB2(_buffer, _size, _lidx, &p->sib2);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SystemInformation_IEs_sib_TypeAndInfo_s_sib3) {
		_serNrSysEncSQN_NR_SIB3(_buffer, _size, _lidx, &p->sib3);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SystemInformation_IEs_sib_TypeAndInfo_s_sib4) {
		_serNrSysEncSQN_NR_SIB4(_buffer, _size, _lidx, &p->sib4);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SystemInformation_IEs_sib_TypeAndInfo_s_sib5) {
		_serNrSysEncSQN_NR_SIB5(_buffer, _size, _lidx, &p->sib5);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SystemInformation_IEs_sib_TypeAndInfo_s_sib6) {
		_serNrSysEncSQN_NR_SIB6(_buffer, _size, _lidx, &p->sib6);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SystemInformation_IEs_sib_TypeAndInfo_s_sib7) {
		_serNrSysEncSQN_NR_SIB7(_buffer, _size, _lidx, &p->sib7);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SystemInformation_IEs_sib_TypeAndInfo_s_sib8) {
		_serNrSysEncSQN_NR_SIB8(_buffer, _size, _lidx, &p->sib8);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SystemInformation_IEs_sib_TypeAndInfo_s_sib9) {
		_serNrSysEncSQN_NR_SIB9(_buffer, _size, _lidx, &p->sib9);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SystemInformation_IEs_sib_TypeAndInfo_s_sib10_v1610) {
		_serNrSysEncSQN_NR_SIB10_r16(_buffer, _size, _lidx, &p->sib10_v1610);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SystemInformation_IEs_sib_TypeAndInfo_s_sib11_v1610) {
		_serNrSysEncSQN_NR_SIB11_r16(_buffer, _size, _lidx, &p->sib11_v1610);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SystemInformation_IEs_sib_TypeAndInfo_s_sib12_v1610) {
		_serNrSysEncSQN_NR_SIB12_r16(_buffer, _size, _lidx, &p->sib12_v1610);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SystemInformation_IEs_sib_TypeAndInfo_s_sib13_v1610) {
		_serNrSysEncSQN_NR_SIB13_r16(_buffer, _size, _lidx, &p->sib13_v1610);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SystemInformation_IEs_sib_TypeAndInfo_s_sib14_v1610) {
		_serNrSysEncSQN_NR_SIB14_r16(_buffer, _size, _lidx, &p->sib14_v1610);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncSQN_NR_SystemInformation_IEs_sib_TypeAndInfo_s(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SystemInformation_IEs_sib_TypeAndInfo_s* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_SystemInformation_IEs_sib_TypeAndInfo_s_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncOCTET_STRING_SQN_NR_SystemInformation_IEs_lateNonCriticalExtension_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct OCTET_STRING_SQN_NR_SystemInformation_IEs_lateNonCriticalExtension_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i1 = 0; i1 < p->v.d; i1++) {
		HTON_8(&_buffer[*_lidx], p->v.v[i1], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SystemInformation_IEs_nonCriticalExtension(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SystemInformation_IEs_nonCriticalExtension* p)
{
	(void)_size; // TODO: generate boundaries checking

	(void)_buffer;
	(void)_size;
	(void)_lidx;
	(void)p;

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SystemInformation_IEs_nonCriticalExtension_nonCriticalExtension_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SystemInformation_IEs_nonCriticalExtension_nonCriticalExtension_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_SystemInformation_IEs_nonCriticalExtension(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SystemInformation_IEs(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SystemInformation_IEs* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_32(&_buffer[*_lidx], p->sib_TypeAndInfo.d, _lidx);
	for (size_t i1 = 0; i1 < p->sib_TypeAndInfo.d; i1++) {
		_serNrSysEncSQN_NR_SystemInformation_IEs_sib_TypeAndInfo_s(_buffer, _size, _lidx, &p->sib_TypeAndInfo.v[i1]);
	}
	_serNrSysEncOCTET_STRING_SQN_NR_SystemInformation_IEs_lateNonCriticalExtension_Optional(_buffer, _size, _lidx, &p->lateNonCriticalExtension);
	_serNrSysEncSQN_NR_SystemInformation_IEs_nonCriticalExtension_nonCriticalExtension_Optional(_buffer, _size, _lidx, &p->nonCriticalExtension);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncOCTET_STRING_SQN_NR_SIBpos_r16_lateNonCriticalExtension_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct OCTET_STRING_SQN_NR_SIBpos_r16_lateNonCriticalExtension_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		HTON_8(&_buffer[*_lidx], p->v.v[i2], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SIBpos_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SIBpos_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_32(&_buffer[*_lidx], p->assistanceDataSIB_Element_r16.d, _lidx);
	for (size_t i2 = 0; i2 < p->assistanceDataSIB_Element_r16.d; i2++) {
		HTON_8(&_buffer[*_lidx], p->assistanceDataSIB_Element_r16.v[i2], _lidx);
	}
	_serNrSysEncOCTET_STRING_SQN_NR_SIBpos_r16_lateNonCriticalExtension_Optional(_buffer, _size, _lidx, &p->lateNonCriticalExtension);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PosSystemInformation_r16_IEs_posSIB_TypeAndInfo_r16_s_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SQN_NR_PosSystemInformation_r16_IEs_posSIB_TypeAndInfo_r16_s_Value* p, enum SQN_NR_PosSystemInformation_r16_IEs_posSIB_TypeAndInfo_r16_s_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_PosSystemInformation_r16_IEs_posSIB_TypeAndInfo_r16_s_posSib1_1_r16) {
		_serNrSysEncSQN_NR_SIBpos_r16(_buffer, _size, _lidx, &p->posSib1_1_r16);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_PosSystemInformation_r16_IEs_posSIB_TypeAndInfo_r16_s_posSib1_2_r16) {
		_serNrSysEncSQN_NR_SIBpos_r16(_buffer, _size, _lidx, &p->posSib1_2_r16);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_PosSystemInformation_r16_IEs_posSIB_TypeAndInfo_r16_s_posSib1_3_r16) {
		_serNrSysEncSQN_NR_SIBpos_r16(_buffer, _size, _lidx, &p->posSib1_3_r16);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_PosSystemInformation_r16_IEs_posSIB_TypeAndInfo_r16_s_posSib1_4_r16) {
		_serNrSysEncSQN_NR_SIBpos_r16(_buffer, _size, _lidx, &p->posSib1_4_r16);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_PosSystemInformation_r16_IEs_posSIB_TypeAndInfo_r16_s_posSib1_5_r16) {
		_serNrSysEncSQN_NR_SIBpos_r16(_buffer, _size, _lidx, &p->posSib1_5_r16);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_PosSystemInformation_r16_IEs_posSIB_TypeAndInfo_r16_s_posSib1_6_r16) {
		_serNrSysEncSQN_NR_SIBpos_r16(_buffer, _size, _lidx, &p->posSib1_6_r16);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_PosSystemInformation_r16_IEs_posSIB_TypeAndInfo_r16_s_posSib1_7_r16) {
		_serNrSysEncSQN_NR_SIBpos_r16(_buffer, _size, _lidx, &p->posSib1_7_r16);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_PosSystemInformation_r16_IEs_posSIB_TypeAndInfo_r16_s_posSib1_8_r16) {
		_serNrSysEncSQN_NR_SIBpos_r16(_buffer, _size, _lidx, &p->posSib1_8_r16);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_PosSystemInformation_r16_IEs_posSIB_TypeAndInfo_r16_s_posSib2_1_r16) {
		_serNrSysEncSQN_NR_SIBpos_r16(_buffer, _size, _lidx, &p->posSib2_1_r16);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_PosSystemInformation_r16_IEs_posSIB_TypeAndInfo_r16_s_posSib2_2_r16) {
		_serNrSysEncSQN_NR_SIBpos_r16(_buffer, _size, _lidx, &p->posSib2_2_r16);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_PosSystemInformation_r16_IEs_posSIB_TypeAndInfo_r16_s_posSib2_3_r16) {
		_serNrSysEncSQN_NR_SIBpos_r16(_buffer, _size, _lidx, &p->posSib2_3_r16);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_PosSystemInformation_r16_IEs_posSIB_TypeAndInfo_r16_s_posSib2_4_r16) {
		_serNrSysEncSQN_NR_SIBpos_r16(_buffer, _size, _lidx, &p->posSib2_4_r16);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_PosSystemInformation_r16_IEs_posSIB_TypeAndInfo_r16_s_posSib2_5_r16) {
		_serNrSysEncSQN_NR_SIBpos_r16(_buffer, _size, _lidx, &p->posSib2_5_r16);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_PosSystemInformation_r16_IEs_posSIB_TypeAndInfo_r16_s_posSib2_6_r16) {
		_serNrSysEncSQN_NR_SIBpos_r16(_buffer, _size, _lidx, &p->posSib2_6_r16);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_PosSystemInformation_r16_IEs_posSIB_TypeAndInfo_r16_s_posSib2_7_r16) {
		_serNrSysEncSQN_NR_SIBpos_r16(_buffer, _size, _lidx, &p->posSib2_7_r16);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_PosSystemInformation_r16_IEs_posSIB_TypeAndInfo_r16_s_posSib2_8_r16) {
		_serNrSysEncSQN_NR_SIBpos_r16(_buffer, _size, _lidx, &p->posSib2_8_r16);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_PosSystemInformation_r16_IEs_posSIB_TypeAndInfo_r16_s_posSib2_9_r16) {
		_serNrSysEncSQN_NR_SIBpos_r16(_buffer, _size, _lidx, &p->posSib2_9_r16);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_PosSystemInformation_r16_IEs_posSIB_TypeAndInfo_r16_s_posSib2_10_r16) {
		_serNrSysEncSQN_NR_SIBpos_r16(_buffer, _size, _lidx, &p->posSib2_10_r16);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_PosSystemInformation_r16_IEs_posSIB_TypeAndInfo_r16_s_posSib2_11_r16) {
		_serNrSysEncSQN_NR_SIBpos_r16(_buffer, _size, _lidx, &p->posSib2_11_r16);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_PosSystemInformation_r16_IEs_posSIB_TypeAndInfo_r16_s_posSib2_12_r16) {
		_serNrSysEncSQN_NR_SIBpos_r16(_buffer, _size, _lidx, &p->posSib2_12_r16);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_PosSystemInformation_r16_IEs_posSIB_TypeAndInfo_r16_s_posSib2_13_r16) {
		_serNrSysEncSQN_NR_SIBpos_r16(_buffer, _size, _lidx, &p->posSib2_13_r16);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_PosSystemInformation_r16_IEs_posSIB_TypeAndInfo_r16_s_posSib2_14_r16) {
		_serNrSysEncSQN_NR_SIBpos_r16(_buffer, _size, _lidx, &p->posSib2_14_r16);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_PosSystemInformation_r16_IEs_posSIB_TypeAndInfo_r16_s_posSib2_15_r16) {
		_serNrSysEncSQN_NR_SIBpos_r16(_buffer, _size, _lidx, &p->posSib2_15_r16);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_PosSystemInformation_r16_IEs_posSIB_TypeAndInfo_r16_s_posSib2_16_r16) {
		_serNrSysEncSQN_NR_SIBpos_r16(_buffer, _size, _lidx, &p->posSib2_16_r16);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_PosSystemInformation_r16_IEs_posSIB_TypeAndInfo_r16_s_posSib2_17_r16) {
		_serNrSysEncSQN_NR_SIBpos_r16(_buffer, _size, _lidx, &p->posSib2_17_r16);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_PosSystemInformation_r16_IEs_posSIB_TypeAndInfo_r16_s_posSib2_18_r16) {
		_serNrSysEncSQN_NR_SIBpos_r16(_buffer, _size, _lidx, &p->posSib2_18_r16);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_PosSystemInformation_r16_IEs_posSIB_TypeAndInfo_r16_s_posSib2_19_r16) {
		_serNrSysEncSQN_NR_SIBpos_r16(_buffer, _size, _lidx, &p->posSib2_19_r16);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_PosSystemInformation_r16_IEs_posSIB_TypeAndInfo_r16_s_posSib2_20_r16) {
		_serNrSysEncSQN_NR_SIBpos_r16(_buffer, _size, _lidx, &p->posSib2_20_r16);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_PosSystemInformation_r16_IEs_posSIB_TypeAndInfo_r16_s_posSib2_21_r16) {
		_serNrSysEncSQN_NR_SIBpos_r16(_buffer, _size, _lidx, &p->posSib2_21_r16);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_PosSystemInformation_r16_IEs_posSIB_TypeAndInfo_r16_s_posSib2_22_r16) {
		_serNrSysEncSQN_NR_SIBpos_r16(_buffer, _size, _lidx, &p->posSib2_22_r16);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_PosSystemInformation_r16_IEs_posSIB_TypeAndInfo_r16_s_posSib2_23_r16) {
		_serNrSysEncSQN_NR_SIBpos_r16(_buffer, _size, _lidx, &p->posSib2_23_r16);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_PosSystemInformation_r16_IEs_posSIB_TypeAndInfo_r16_s_posSib3_1_r16) {
		_serNrSysEncSQN_NR_SIBpos_r16(_buffer, _size, _lidx, &p->posSib3_1_r16);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_PosSystemInformation_r16_IEs_posSIB_TypeAndInfo_r16_s_posSib4_1_r16) {
		_serNrSysEncSQN_NR_SIBpos_r16(_buffer, _size, _lidx, &p->posSib4_1_r16);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_PosSystemInformation_r16_IEs_posSIB_TypeAndInfo_r16_s_posSib5_1_r16) {
		_serNrSysEncSQN_NR_SIBpos_r16(_buffer, _size, _lidx, &p->posSib5_1_r16);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_PosSystemInformation_r16_IEs_posSIB_TypeAndInfo_r16_s_posSib6_1_r16) {
		_serNrSysEncSQN_NR_SIBpos_r16(_buffer, _size, _lidx, &p->posSib6_1_r16);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_PosSystemInformation_r16_IEs_posSIB_TypeAndInfo_r16_s_posSib6_2_r16) {
		_serNrSysEncSQN_NR_SIBpos_r16(_buffer, _size, _lidx, &p->posSib6_2_r16);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_PosSystemInformation_r16_IEs_posSIB_TypeAndInfo_r16_s_posSib6_3_r16) {
		_serNrSysEncSQN_NR_SIBpos_r16(_buffer, _size, _lidx, &p->posSib6_3_r16);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncSQN_NR_PosSystemInformation_r16_IEs_posSIB_TypeAndInfo_r16_s(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PosSystemInformation_r16_IEs_posSIB_TypeAndInfo_r16_s* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_PosSystemInformation_r16_IEs_posSIB_TypeAndInfo_r16_s_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncOCTET_STRING_SQN_NR_PosSystemInformation_r16_IEs_lateNonCriticalExtension_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct OCTET_STRING_SQN_NR_PosSystemInformation_r16_IEs_lateNonCriticalExtension_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i1 = 0; i1 < p->v.d; i1++) {
		HTON_8(&_buffer[*_lidx], p->v.v[i1], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PosSystemInformation_r16_IEs_nonCriticalExtension(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PosSystemInformation_r16_IEs_nonCriticalExtension* p)
{
	(void)_size; // TODO: generate boundaries checking

	(void)_buffer;
	(void)_size;
	(void)_lidx;
	(void)p;

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PosSystemInformation_r16_IEs_nonCriticalExtension_nonCriticalExtension_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PosSystemInformation_r16_IEs_nonCriticalExtension_nonCriticalExtension_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_PosSystemInformation_r16_IEs_nonCriticalExtension(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PosSystemInformation_r16_IEs(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PosSystemInformation_r16_IEs* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_32(&_buffer[*_lidx], p->posSIB_TypeAndInfo_r16.d, _lidx);
	for (size_t i1 = 0; i1 < p->posSIB_TypeAndInfo_r16.d; i1++) {
		_serNrSysEncSQN_NR_PosSystemInformation_r16_IEs_posSIB_TypeAndInfo_r16_s(_buffer, _size, _lidx, &p->posSIB_TypeAndInfo_r16.v[i1]);
	}
	_serNrSysEncOCTET_STRING_SQN_NR_PosSystemInformation_r16_IEs_lateNonCriticalExtension_Optional(_buffer, _size, _lidx, &p->lateNonCriticalExtension);
	_serNrSysEncSQN_NR_PosSystemInformation_r16_IEs_nonCriticalExtension_nonCriticalExtension_Optional(_buffer, _size, _lidx, &p->nonCriticalExtension);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SystemInformation_criticalExtensions_criticalExtensionsFuture_r16_criticalExtensionsFuture(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SystemInformation_criticalExtensions_criticalExtensionsFuture_r16_criticalExtensionsFuture* p)
{
	(void)_size; // TODO: generate boundaries checking

	(void)_buffer;
	(void)_size;
	(void)_lidx;
	(void)p;

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SystemInformation_criticalExtensions_criticalExtensionsFuture_r16_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SQN_NR_SystemInformation_criticalExtensions_criticalExtensionsFuture_r16_Value* p, enum SQN_NR_SystemInformation_criticalExtensions_criticalExtensionsFuture_r16_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SystemInformation_criticalExtensions_criticalExtensionsFuture_r16_posSystemInformation_r16) {
		_serNrSysEncSQN_NR_PosSystemInformation_r16_IEs(_buffer, _size, _lidx, &p->posSystemInformation_r16);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SystemInformation_criticalExtensions_criticalExtensionsFuture_r16_criticalExtensionsFuture) {
		_serNrSysEncSQN_NR_SystemInformation_criticalExtensions_criticalExtensionsFuture_r16_criticalExtensionsFuture(_buffer, _size, _lidx, &p->criticalExtensionsFuture);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncSQN_NR_SystemInformation_criticalExtensions_criticalExtensionsFuture_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SystemInformation_criticalExtensions_criticalExtensionsFuture_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_SystemInformation_criticalExtensions_criticalExtensionsFuture_r16_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SystemInformation_criticalExtensions_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SQN_NR_SystemInformation_criticalExtensions_Value* p, enum SQN_NR_SystemInformation_criticalExtensions_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SystemInformation_criticalExtensions_systemInformation) {
		_serNrSysEncSQN_NR_SystemInformation_IEs(_buffer, _size, _lidx, &p->systemInformation);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SystemInformation_criticalExtensions_criticalExtensionsFuture_r16) {
		_serNrSysEncSQN_NR_SystemInformation_criticalExtensions_criticalExtensionsFuture_r16(_buffer, _size, _lidx, &p->criticalExtensionsFuture_r16);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncSQN_NR_SystemInformation_criticalExtensions(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SystemInformation_criticalExtensions* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_SystemInformation_criticalExtensions_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SystemInformation(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SystemInformation* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncSQN_NR_SystemInformation_criticalExtensions(_buffer, _size, _lidx, &p->criticalExtensions);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncUint8_t_SQN_NR_SIB1_cellSelectionInfo_q_RxLevMinOffset_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint8_t_SQN_NR_SIB1_cellSelectionInfo_q_RxLevMinOffset_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_Q_RxLevMin_SQN_NR_SIB1_cellSelectionInfo_q_RxLevMinSUL_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_Q_RxLevMin_SQN_NR_SIB1_cellSelectionInfo_q_RxLevMinSUL_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_Q_QualMin_SQN_NR_SIB1_cellSelectionInfo_q_QualMin_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_Q_QualMin_SQN_NR_SIB1_cellSelectionInfo_q_QualMin_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncUint8_t_SQN_NR_SIB1_cellSelectionInfo_q_QualMinOffset_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint8_t_SQN_NR_SIB1_cellSelectionInfo_q_QualMinOffset_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SIB1_cellSelectionInfo(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SIB1_cellSelectionInfo* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->q_RxLevMin, _lidx);
	_serNrSysEncUint8_t_SQN_NR_SIB1_cellSelectionInfo_q_RxLevMinOffset_Optional(_buffer, _size, _lidx, &p->q_RxLevMinOffset);
	_serNrSysEncSQN_NR_Q_RxLevMin_SQN_NR_SIB1_cellSelectionInfo_q_RxLevMinSUL_Optional(_buffer, _size, _lidx, &p->q_RxLevMinSUL);
	_serNrSysEncSQN_NR_Q_QualMin_SQN_NR_SIB1_cellSelectionInfo_q_QualMin_Optional(_buffer, _size, _lidx, &p->q_QualMin);
	_serNrSysEncUint8_t_SQN_NR_SIB1_cellSelectionInfo_q_QualMinOffset_Optional(_buffer, _size, _lidx, &p->q_QualMinOffset);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SIB1_cellSelectionInfo_cellSelectionInfo_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SIB1_cellSelectionInfo_cellSelectionInfo_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_SIB1_cellSelectionInfo(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_MCC_SQN_NR_PLMN_Identity_mcc_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_MCC_SQN_NR_PLMN_Identity_mcc_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	for (size_t i3 = 0; i3 < 3; i3++) {
		HTON_8(&_buffer[*_lidx], p->v[i3], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PLMN_Identity(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PLMN_Identity* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncSQN_NR_MCC_SQN_NR_PLMN_Identity_mcc_Optional(_buffer, _size, _lidx, &p->mcc);
	HTON_32(&_buffer[*_lidx], p->mnc.d, _lidx);
	for (size_t i3 = 0; i3 < p->mnc.d; i3++) {
		HTON_8(&_buffer[*_lidx], p->mnc.v[i3], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_TrackingAreaCode_SQN_NR_PLMN_IdentityInfo_trackingAreaCode_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_TrackingAreaCode_SQN_NR_PLMN_IdentityInfo_trackingAreaCode_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	for (size_t i2 = 0; i2 < 24; i2++) {
		HTON_8(&_buffer[*_lidx], p->v[i2], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_RAN_AreaCode_SQN_NR_PLMN_IdentityInfo_ranac_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_RAN_AreaCode_SQN_NR_PLMN_IdentityInfo_ranac_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PLMN_IdentityInfo_iab_Support_r16_e_iab_Support_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PLMN_IdentityInfo_iab_Support_r16_e_iab_Support_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PLMN_IdentityInfo(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PLMN_IdentityInfo* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_32(&_buffer[*_lidx], p->plmn_IdentityList.d, _lidx);
	for (size_t i2 = 0; i2 < p->plmn_IdentityList.d; i2++) {
		_serNrSysEncSQN_NR_PLMN_Identity(_buffer, _size, _lidx, &p->plmn_IdentityList.v[i2]);
	}
	_serNrSysEncSQN_NR_TrackingAreaCode_SQN_NR_PLMN_IdentityInfo_trackingAreaCode_Optional(_buffer, _size, _lidx, &p->trackingAreaCode);
	_serNrSysEncSQN_NR_RAN_AreaCode_SQN_NR_PLMN_IdentityInfo_ranac_Optional(_buffer, _size, _lidx, &p->ranac);
	for (size_t i2 = 0; i2 < 36; i2++) {
		HTON_8(&_buffer[*_lidx], p->cellIdentity[i2], _lidx);
	}
	{
		size_t _tmp = (size_t)p->cellReservedForOperatorUse;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_PLMN_IdentityInfo_iab_Support_r16_e_iab_Support_r16_Optional(_buffer, _size, _lidx, &p->iab_Support_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_CellAccessRelatedInfo_cellReservedForOtherUse_e_cellReservedForOtherUse_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_CellAccessRelatedInfo_cellReservedForOtherUse_e_cellReservedForOtherUse_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_CellAccessRelatedInfo_cellReservedForFutureUse_r16_e_cellReservedForFutureUse_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_CellAccessRelatedInfo_cellReservedForFutureUse_r16_e_cellReservedForFutureUse_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_CAG_IdentityInfo_r16_manualCAGselectionAllowed_r16_e_manualCAGselectionAllowed_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_CAG_IdentityInfo_r16_manualCAGselectionAllowed_r16_e_manualCAGselectionAllowed_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_CAG_IdentityInfo_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_CAG_IdentityInfo_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	for (size_t i4 = 0; i4 < 32; i4++) {
		HTON_8(&_buffer[*_lidx], p->cag_Identity_r16[i4], _lidx);
	}
	_serNrSysEncSQN_NR_CAG_IdentityInfo_r16_manualCAGselectionAllowed_r16_e_manualCAGselectionAllowed_r16_Optional(_buffer, _size, _lidx, &p->manualCAGselectionAllowed_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_NPN_Identity_r16_pni_npn_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_NPN_Identity_r16_pni_npn_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncSQN_NR_PLMN_Identity(_buffer, _size, _lidx, &p->plmn_Identity_r16);
	HTON_32(&_buffer[*_lidx], p->cag_IdentityList_r16.d, _lidx);
	for (size_t i3 = 0; i3 < p->cag_IdentityList_r16.d; i3++) {
		_serNrSysEncSQN_NR_CAG_IdentityInfo_r16(_buffer, _size, _lidx, &p->cag_IdentityList_r16.v[i3]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_NPN_Identity_r16_snpn_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_NPN_Identity_r16_snpn_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncSQN_NR_PLMN_Identity(_buffer, _size, _lidx, &p->plmn_Identity);
	HTON_32(&_buffer[*_lidx], p->nid_List_r16.d, _lidx);
	for (size_t i3 = 0; i3 < p->nid_List_r16.d; i3++) {
		for (size_t i4 = 0; i4 < 44; i4++) {
			HTON_8(&_buffer[*_lidx], p->nid_List_r16.v[i3][i4], _lidx);
		}
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_NPN_Identity_r16_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SQN_NR_NPN_Identity_r16_Value* p, enum SQN_NR_NPN_Identity_r16_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_NPN_Identity_r16_pni_npn_r16) {
		_serNrSysEncSQN_NR_NPN_Identity_r16_pni_npn_r16(_buffer, _size, _lidx, &p->pni_npn_r16);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_NPN_Identity_r16_snpn_r16) {
		_serNrSysEncSQN_NR_NPN_Identity_r16_snpn_r16(_buffer, _size, _lidx, &p->snpn_r16);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncSQN_NR_NPN_Identity_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_NPN_Identity_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_NPN_Identity_r16_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_RAN_AreaCode_SQN_NR_NPN_IdentityInfo_r16_ranac_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_RAN_AreaCode_SQN_NR_NPN_IdentityInfo_r16_ranac_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_NPN_IdentityInfo_r16_iab_Support_r16_e_iab_Support_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_NPN_IdentityInfo_r16_iab_Support_r16_e_iab_Support_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_NPN_IdentityInfo_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_NPN_IdentityInfo_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_32(&_buffer[*_lidx], p->npn_IdentityList_r16.d, _lidx);
	for (size_t i2 = 0; i2 < p->npn_IdentityList_r16.d; i2++) {
		_serNrSysEncSQN_NR_NPN_Identity_r16(_buffer, _size, _lidx, &p->npn_IdentityList_r16.v[i2]);
	}
	for (size_t i2 = 0; i2 < 24; i2++) {
		HTON_8(&_buffer[*_lidx], p->trackingAreaCode_r16[i2], _lidx);
	}
	_serNrSysEncSQN_NR_RAN_AreaCode_SQN_NR_NPN_IdentityInfo_r16_ranac_r16_Optional(_buffer, _size, _lidx, &p->ranac_r16);
	for (size_t i2 = 0; i2 < 36; i2++) {
		HTON_8(&_buffer[*_lidx], p->cellIdentity_r16[i2], _lidx);
	}
	{
		size_t _tmp = (size_t)p->cellReservedForOperatorUse_r16;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_NPN_IdentityInfo_r16_iab_Support_r16_e_iab_Support_r16_Optional(_buffer, _size, _lidx, &p->iab_Support_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_NPN_IdentityInfoList_r16_SQN_NR_CellAccessRelatedInfo_npn_IdentityInfoList_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_NPN_IdentityInfoList_r16_SQN_NR_CellAccessRelatedInfo_npn_IdentityInfoList_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i1 = 0; i1 < p->v.d; i1++) {
		_serNrSysEncSQN_NR_NPN_IdentityInfo_r16(_buffer, _size, _lidx, &p->v.v[i1]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_CellAccessRelatedInfo(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_CellAccessRelatedInfo* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_32(&_buffer[*_lidx], p->plmn_IdentityList.d, _lidx);
	for (size_t i1 = 0; i1 < p->plmn_IdentityList.d; i1++) {
		_serNrSysEncSQN_NR_PLMN_IdentityInfo(_buffer, _size, _lidx, &p->plmn_IdentityList.v[i1]);
	}
	_serNrSysEncSQN_NR_CellAccessRelatedInfo_cellReservedForOtherUse_e_cellReservedForOtherUse_Optional(_buffer, _size, _lidx, &p->cellReservedForOtherUse);
	_serNrSysEncSQN_NR_CellAccessRelatedInfo_cellReservedForFutureUse_r16_e_cellReservedForFutureUse_r16_Optional(_buffer, _size, _lidx, &p->cellReservedForFutureUse_r16);
	_serNrSysEncSQN_NR_NPN_IdentityInfoList_r16_SQN_NR_CellAccessRelatedInfo_npn_IdentityInfoList_r16_Optional(_buffer, _size, _lidx, &p->npn_IdentityInfoList_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncUint8_t_SQN_NR_ConnEstFailureControl_connEstFailOffset_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint8_t_SQN_NR_ConnEstFailureControl_connEstFailOffset_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_ConnEstFailureControl(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_ConnEstFailureControl* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->connEstFailCount;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	{
		size_t _tmp = (size_t)p->connEstFailOffsetValidity;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncUint8_t_SQN_NR_ConnEstFailureControl_connEstFailOffset_Optional(_buffer, _size, _lidx, &p->connEstFailOffset);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_ConnEstFailureControl_SQN_NR_SIB1_connEstFailureControl_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_ConnEstFailureControl_SQN_NR_SIB1_connEstFailureControl_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_ConnEstFailureControl(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncUint8_t_SQN_NR_SIB_TypeInfo_valueTag_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint8_t_SQN_NR_SIB_TypeInfo_valueTag_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SIB_TypeInfo_areaScope_e_areaScope_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SIB_TypeInfo_areaScope_e_areaScope_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SIB_TypeInfo(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SIB_TypeInfo* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->type;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncUint8_t_SQN_NR_SIB_TypeInfo_valueTag_Optional(_buffer, _size, _lidx, &p->valueTag);
	_serNrSysEncSQN_NR_SIB_TypeInfo_areaScope_e_areaScope_Optional(_buffer, _size, _lidx, &p->areaScope);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SchedulingInfo(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SchedulingInfo* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->si_BroadcastStatus;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	{
		size_t _tmp = (size_t)p->si_Periodicity;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	HTON_32(&_buffer[*_lidx], p->sib_MappingInfo.d, _lidx);
	for (size_t i2 = 0; i2 < p->sib_MappingInfo.d; i2++) {
		_serNrSysEncSQN_NR_SIB_TypeInfo(_buffer, _size, _lidx, &p->sib_MappingInfo.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SI_RequestConfig_SQN_NR_SI_SchedulingInfo_si_RequestConfig_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SI_RequestConfig_SQN_NR_SI_SchedulingInfo_si_RequestConfig_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_SI_RequestConfig(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SI_RequestConfig_SQN_NR_SI_SchedulingInfo_si_RequestConfigSUL_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SI_RequestConfig_SQN_NR_SI_SchedulingInfo_si_RequestConfigSUL_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_SI_RequestConfig(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncB24_SQN_NR_SI_SchedulingInfo_systemInformationAreaID_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct B24_SQN_NR_SI_SchedulingInfo_systemInformationAreaID_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	for (size_t i1 = 0; i1 < 24; i1++) {
		HTON_8(&_buffer[*_lidx], p->v[i1], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SI_SchedulingInfo(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SI_SchedulingInfo* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_32(&_buffer[*_lidx], p->schedulingInfoList.d, _lidx);
	for (size_t i1 = 0; i1 < p->schedulingInfoList.d; i1++) {
		_serNrSysEncSQN_NR_SchedulingInfo(_buffer, _size, _lidx, &p->schedulingInfoList.v[i1]);
	}
	{
		size_t _tmp = (size_t)p->si_WindowLength;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_SI_RequestConfig_SQN_NR_SI_SchedulingInfo_si_RequestConfig_Optional(_buffer, _size, _lidx, &p->si_RequestConfig);
	_serNrSysEncSQN_NR_SI_RequestConfig_SQN_NR_SI_SchedulingInfo_si_RequestConfigSUL_Optional(_buffer, _size, _lidx, &p->si_RequestConfigSUL);
	_serNrSysEncB24_SQN_NR_SI_SchedulingInfo_systemInformationAreaID_Optional(_buffer, _size, _lidx, &p->systemInformationAreaID);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SI_SchedulingInfo_SQN_NR_SIB1_si_SchedulingInfo_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SI_SchedulingInfo_SQN_NR_SIB1_si_SchedulingInfo_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_SI_SchedulingInfo(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_FrequencyInfoDL_SIB(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_FrequencyInfoDL_SIB* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_32(&_buffer[*_lidx], p->frequencyBandList.d, _lidx);
	for (size_t i1 = 0; i1 < p->frequencyBandList.d; i1++) {
		_serNrSysEncSQN_NR_NR_MultiBandInfo(_buffer, _size, _lidx, &p->frequencyBandList.v[i1]);
	}
	HTON_16(&_buffer[*_lidx], p->offsetToPointA, _lidx);
	HTON_32(&_buffer[*_lidx], p->scs_SpecificCarrierList.d, _lidx);
	for (size_t i1 = 0; i1 < p->scs_SpecificCarrierList.d; i1++) {
		_serNrSysEncSQN_NR_SCS_SpecificCarrier(_buffer, _size, _lidx, &p->scs_SpecificCarrierList.v[i1]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_ControlResourceSetZero_SQN_NR_PDCCH_ConfigCommon_controlResourceSetZero_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_ControlResourceSetZero_SQN_NR_PDCCH_ConfigCommon_controlResourceSetZero_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_ControlResourceSet_SQN_NR_PDCCH_ConfigCommon_commonControlResourceSet_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_ControlResourceSet_SQN_NR_PDCCH_ConfigCommon_commonControlResourceSet_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_ControlResourceSet(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SearchSpaceZero_SQN_NR_PDCCH_ConfigCommon_searchSpaceZero_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SearchSpaceZero_SQN_NR_PDCCH_ConfigCommon_searchSpaceZero_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SearchSpace_SQN_NR_PDCCH_ConfigCommon_commonSearchSpaceList_DynamicOptional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SearchSpace_SQN_NR_PDCCH_ConfigCommon_commonSearchSpaceList_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i1 = 0; i1 < p->v.d; i1++) {
		_serNrSysEncSQN_NR_SearchSpace(_buffer, _size, _lidx, &p->v.v[i1]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SearchSpaceId_SQN_NR_PDCCH_ConfigCommon_searchSpaceSIB1_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SearchSpaceId_SQN_NR_PDCCH_ConfigCommon_searchSpaceSIB1_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SearchSpaceId_SQN_NR_PDCCH_ConfigCommon_searchSpaceOtherSystemInformation_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SearchSpaceId_SQN_NR_PDCCH_ConfigCommon_searchSpaceOtherSystemInformation_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SearchSpaceId_SQN_NR_PDCCH_ConfigCommon_pagingSearchSpace_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SearchSpaceId_SQN_NR_PDCCH_ConfigCommon_pagingSearchSpace_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SearchSpaceId_SQN_NR_PDCCH_ConfigCommon_ra_SearchSpace_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SearchSpaceId_SQN_NR_PDCCH_ConfigCommon_ra_SearchSpace_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PDCCH_ConfigCommon_firstPDCCH_MonitoringOccasionOfPO_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SQN_NR_PDCCH_ConfigCommon_firstPDCCH_MonitoringOccasionOfPO_Value* p, enum SQN_NR_PDCCH_ConfigCommon_firstPDCCH_MonitoringOccasionOfPO_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_PDCCH_ConfigCommon_firstPDCCH_MonitoringOccasionOfPO_sCS15KHZoneT) {
		HTON_32(&_buffer[*_lidx], p->sCS15KHZoneT.d, _lidx);
		for (size_t i1 = 0; i1 < p->sCS15KHZoneT.d; i1++) {
			HTON_8(&_buffer[*_lidx], p->sCS15KHZoneT.v[i1], _lidx);
		}
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_PDCCH_ConfigCommon_firstPDCCH_MonitoringOccasionOfPO_sCS30KHZoneT_SCS15KHZhalfT) {
		HTON_32(&_buffer[*_lidx], p->sCS30KHZoneT_SCS15KHZhalfT.d, _lidx);
		for (size_t i1 = 0; i1 < p->sCS30KHZoneT_SCS15KHZhalfT.d; i1++) {
			HTON_16(&_buffer[*_lidx], p->sCS30KHZoneT_SCS15KHZhalfT.v[i1], _lidx);
		}
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_PDCCH_ConfigCommon_firstPDCCH_MonitoringOccasionOfPO_sCS60KHZoneT_SCS30KHZhalfT_SCS15KHZquarterT) {
		HTON_32(&_buffer[*_lidx], p->sCS60KHZoneT_SCS30KHZhalfT_SCS15KHZquarterT.d, _lidx);
		for (size_t i1 = 0; i1 < p->sCS60KHZoneT_SCS30KHZhalfT_SCS15KHZquarterT.d; i1++) {
			HTON_16(&_buffer[*_lidx], p->sCS60KHZoneT_SCS30KHZhalfT_SCS15KHZquarterT.v[i1], _lidx);
		}
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_PDCCH_ConfigCommon_firstPDCCH_MonitoringOccasionOfPO_sCS120KHZoneT_SCS60KHZhalfT_SCS30KHZquarterT_SCS15KHZoneEighthT) {
		HTON_32(&_buffer[*_lidx], p->sCS120KHZoneT_SCS60KHZhalfT_SCS30KHZquarterT_SCS15KHZoneEighthT.d, _lidx);
		for (size_t i1 = 0; i1 < p->sCS120KHZoneT_SCS60KHZhalfT_SCS30KHZquarterT_SCS15KHZoneEighthT.d; i1++) {
			HTON_16(&_buffer[*_lidx], p->sCS120KHZoneT_SCS60KHZhalfT_SCS30KHZquarterT_SCS15KHZoneEighthT.v[i1], _lidx);
		}
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_PDCCH_ConfigCommon_firstPDCCH_MonitoringOccasionOfPO_sCS120KHZhalfT_SCS60KHZquarterT_SCS30KHZoneEighthT_SCS15KHZoneSixteenthT) {
		HTON_32(&_buffer[*_lidx], p->sCS120KHZhalfT_SCS60KHZquarterT_SCS30KHZoneEighthT_SCS15KHZoneSixteenthT.d, _lidx);
		for (size_t i1 = 0; i1 < p->sCS120KHZhalfT_SCS60KHZquarterT_SCS30KHZoneEighthT_SCS15KHZoneSixteenthT.d; i1++) {
			HTON_16(&_buffer[*_lidx], p->sCS120KHZhalfT_SCS60KHZquarterT_SCS30KHZoneEighthT_SCS15KHZoneSixteenthT.v[i1], _lidx);
		}
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_PDCCH_ConfigCommon_firstPDCCH_MonitoringOccasionOfPO_sCS120KHZquarterT_SCS60KHZoneEighthT_SCS30KHZoneSixteenthT) {
		HTON_32(&_buffer[*_lidx], p->sCS120KHZquarterT_SCS60KHZoneEighthT_SCS30KHZoneSixteenthT.d, _lidx);
		for (size_t i1 = 0; i1 < p->sCS120KHZquarterT_SCS60KHZoneEighthT_SCS30KHZoneSixteenthT.d; i1++) {
			HTON_16(&_buffer[*_lidx], p->sCS120KHZquarterT_SCS60KHZoneEighthT_SCS30KHZoneSixteenthT.v[i1], _lidx);
		}
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_PDCCH_ConfigCommon_firstPDCCH_MonitoringOccasionOfPO_sCS120KHZoneEighthT_SCS60KHZoneSixteenthT) {
		HTON_32(&_buffer[*_lidx], p->sCS120KHZoneEighthT_SCS60KHZoneSixteenthT.d, _lidx);
		for (size_t i1 = 0; i1 < p->sCS120KHZoneEighthT_SCS60KHZoneSixteenthT.d; i1++) {
			HTON_16(&_buffer[*_lidx], p->sCS120KHZoneEighthT_SCS60KHZoneSixteenthT.v[i1], _lidx);
		}
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_PDCCH_ConfigCommon_firstPDCCH_MonitoringOccasionOfPO_sCS120KHZoneSixteenthT) {
		HTON_32(&_buffer[*_lidx], p->sCS120KHZoneSixteenthT.d, _lidx);
		for (size_t i1 = 0; i1 < p->sCS120KHZoneSixteenthT.d; i1++) {
			HTON_16(&_buffer[*_lidx], p->sCS120KHZoneSixteenthT.v[i1], _lidx);
		}
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncSQN_NR_PDCCH_ConfigCommon_firstPDCCH_MonitoringOccasionOfPO(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PDCCH_ConfigCommon_firstPDCCH_MonitoringOccasionOfPO* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_PDCCH_ConfigCommon_firstPDCCH_MonitoringOccasionOfPO_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PDCCH_ConfigCommon_firstPDCCH_MonitoringOccasionOfPO_firstPDCCH_MonitoringOccasionOfPO_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PDCCH_ConfigCommon_firstPDCCH_MonitoringOccasionOfPO_firstPDCCH_MonitoringOccasionOfPO_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_PDCCH_ConfigCommon_firstPDCCH_MonitoringOccasionOfPO(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_ControlResourceSetId_r16_SQN_NR_SearchSpaceExt_r16_controlResourceSetId_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_ControlResourceSetId_r16_SQN_NR_SearchSpaceExt_r16_controlResourceSetId_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SearchSpaceExt_r16_searchSpaceType_r16_common_r16_dci_Format2_4_r16nrofCandidates_CI_r16aggregationLevel1_r16_e_aggregationLevel1_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SearchSpaceExt_r16_searchSpaceType_r16_common_r16_dci_Format2_4_r16nrofCandidates_CI_r16aggregationLevel1_r16_e_aggregationLevel1_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SearchSpaceExt_r16_searchSpaceType_r16_common_r16_dci_Format2_4_r16nrofCandidates_CI_r16aggregationLevel2_r16_e_aggregationLevel2_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SearchSpaceExt_r16_searchSpaceType_r16_common_r16_dci_Format2_4_r16nrofCandidates_CI_r16aggregationLevel2_r16_e_aggregationLevel2_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SearchSpaceExt_r16_searchSpaceType_r16_common_r16_dci_Format2_4_r16nrofCandidates_CI_r16aggregationLevel4_r16_e_aggregationLevel4_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SearchSpaceExt_r16_searchSpaceType_r16_common_r16_dci_Format2_4_r16nrofCandidates_CI_r16aggregationLevel4_r16_e_aggregationLevel4_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SearchSpaceExt_r16_searchSpaceType_r16_common_r16_dci_Format2_4_r16nrofCandidates_CI_r16aggregationLevel8_r16_e_aggregationLevel8_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SearchSpaceExt_r16_searchSpaceType_r16_common_r16_dci_Format2_4_r16nrofCandidates_CI_r16aggregationLevel8_r16_e_aggregationLevel8_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SearchSpaceExt_r16_searchSpaceType_r16_common_r16_dci_Format2_4_r16nrofCandidates_CI_r16aggregationLevel16_r16_e_aggregationLevel16_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SearchSpaceExt_r16_searchSpaceType_r16_common_r16_dci_Format2_4_r16nrofCandidates_CI_r16aggregationLevel16_r16_e_aggregationLevel16_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SearchSpaceExt_r16_searchSpaceType_r16_common_r16_dci_Format2_4_r16nrofCandidates_CI_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SearchSpaceExt_r16_searchSpaceType_r16_common_r16_dci_Format2_4_r16nrofCandidates_CI_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncSQN_NR_SearchSpaceExt_r16_searchSpaceType_r16_common_r16_dci_Format2_4_r16nrofCandidates_CI_r16aggregationLevel1_r16_e_aggregationLevel1_r16_Optional(_buffer, _size, _lidx, &p->aggregationLevel1_r16);
	_serNrSysEncSQN_NR_SearchSpaceExt_r16_searchSpaceType_r16_common_r16_dci_Format2_4_r16nrofCandidates_CI_r16aggregationLevel2_r16_e_aggregationLevel2_r16_Optional(_buffer, _size, _lidx, &p->aggregationLevel2_r16);
	_serNrSysEncSQN_NR_SearchSpaceExt_r16_searchSpaceType_r16_common_r16_dci_Format2_4_r16nrofCandidates_CI_r16aggregationLevel4_r16_e_aggregationLevel4_r16_Optional(_buffer, _size, _lidx, &p->aggregationLevel4_r16);
	_serNrSysEncSQN_NR_SearchSpaceExt_r16_searchSpaceType_r16_common_r16_dci_Format2_4_r16nrofCandidates_CI_r16aggregationLevel8_r16_e_aggregationLevel8_r16_Optional(_buffer, _size, _lidx, &p->aggregationLevel8_r16);
	_serNrSysEncSQN_NR_SearchSpaceExt_r16_searchSpaceType_r16_common_r16_dci_Format2_4_r16nrofCandidates_CI_r16aggregationLevel16_r16_e_aggregationLevel16_r16_Optional(_buffer, _size, _lidx, &p->aggregationLevel16_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SearchSpaceExt_r16_searchSpaceType_r16_common_r16_dci_Format2_4_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SearchSpaceExt_r16_searchSpaceType_r16_common_r16_dci_Format2_4_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncSQN_NR_SearchSpaceExt_r16_searchSpaceType_r16_common_r16_dci_Format2_4_r16nrofCandidates_CI_r16(_buffer, _size, _lidx, &p->nrofCandidates_CI_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SearchSpaceExt_r16_searchSpaceType_r16_common_r16_dci_Format2_4_r16_dci_Format2_4_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SearchSpaceExt_r16_searchSpaceType_r16_common_r16_dci_Format2_4_r16_dci_Format2_4_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_SearchSpaceExt_r16_searchSpaceType_r16_common_r16_dci_Format2_4_r16(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SearchSpaceExt_r16_searchSpaceType_r16_common_r16_dci_Format2_5_r16nrofCandidates_IAB_r16aggregationLevel1_r16_e_aggregationLevel1_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SearchSpaceExt_r16_searchSpaceType_r16_common_r16_dci_Format2_5_r16nrofCandidates_IAB_r16aggregationLevel1_r16_e_aggregationLevel1_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SearchSpaceExt_r16_searchSpaceType_r16_common_r16_dci_Format2_5_r16nrofCandidates_IAB_r16aggregationLevel2_r16_e_aggregationLevel2_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SearchSpaceExt_r16_searchSpaceType_r16_common_r16_dci_Format2_5_r16nrofCandidates_IAB_r16aggregationLevel2_r16_e_aggregationLevel2_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SearchSpaceExt_r16_searchSpaceType_r16_common_r16_dci_Format2_5_r16nrofCandidates_IAB_r16aggregationLevel4_r16_e_aggregationLevel4_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SearchSpaceExt_r16_searchSpaceType_r16_common_r16_dci_Format2_5_r16nrofCandidates_IAB_r16aggregationLevel4_r16_e_aggregationLevel4_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SearchSpaceExt_r16_searchSpaceType_r16_common_r16_dci_Format2_5_r16nrofCandidates_IAB_r16aggregationLevel8_r16_e_aggregationLevel8_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SearchSpaceExt_r16_searchSpaceType_r16_common_r16_dci_Format2_5_r16nrofCandidates_IAB_r16aggregationLevel8_r16_e_aggregationLevel8_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SearchSpaceExt_r16_searchSpaceType_r16_common_r16_dci_Format2_5_r16nrofCandidates_IAB_r16aggregationLevel16_r16_e_aggregationLevel16_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SearchSpaceExt_r16_searchSpaceType_r16_common_r16_dci_Format2_5_r16nrofCandidates_IAB_r16aggregationLevel16_r16_e_aggregationLevel16_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SearchSpaceExt_r16_searchSpaceType_r16_common_r16_dci_Format2_5_r16nrofCandidates_IAB_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SearchSpaceExt_r16_searchSpaceType_r16_common_r16_dci_Format2_5_r16nrofCandidates_IAB_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncSQN_NR_SearchSpaceExt_r16_searchSpaceType_r16_common_r16_dci_Format2_5_r16nrofCandidates_IAB_r16aggregationLevel1_r16_e_aggregationLevel1_r16_Optional(_buffer, _size, _lidx, &p->aggregationLevel1_r16);
	_serNrSysEncSQN_NR_SearchSpaceExt_r16_searchSpaceType_r16_common_r16_dci_Format2_5_r16nrofCandidates_IAB_r16aggregationLevel2_r16_e_aggregationLevel2_r16_Optional(_buffer, _size, _lidx, &p->aggregationLevel2_r16);
	_serNrSysEncSQN_NR_SearchSpaceExt_r16_searchSpaceType_r16_common_r16_dci_Format2_5_r16nrofCandidates_IAB_r16aggregationLevel4_r16_e_aggregationLevel4_r16_Optional(_buffer, _size, _lidx, &p->aggregationLevel4_r16);
	_serNrSysEncSQN_NR_SearchSpaceExt_r16_searchSpaceType_r16_common_r16_dci_Format2_5_r16nrofCandidates_IAB_r16aggregationLevel8_r16_e_aggregationLevel8_r16_Optional(_buffer, _size, _lidx, &p->aggregationLevel8_r16);
	_serNrSysEncSQN_NR_SearchSpaceExt_r16_searchSpaceType_r16_common_r16_dci_Format2_5_r16nrofCandidates_IAB_r16aggregationLevel16_r16_e_aggregationLevel16_r16_Optional(_buffer, _size, _lidx, &p->aggregationLevel16_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SearchSpaceExt_r16_searchSpaceType_r16_common_r16_dci_Format2_5_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SearchSpaceExt_r16_searchSpaceType_r16_common_r16_dci_Format2_5_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncSQN_NR_SearchSpaceExt_r16_searchSpaceType_r16_common_r16_dci_Format2_5_r16nrofCandidates_IAB_r16(_buffer, _size, _lidx, &p->nrofCandidates_IAB_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SearchSpaceExt_r16_searchSpaceType_r16_common_r16_dci_Format2_5_r16_dci_Format2_5_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SearchSpaceExt_r16_searchSpaceType_r16_common_r16_dci_Format2_5_r16_dci_Format2_5_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_SearchSpaceExt_r16_searchSpaceType_r16_common_r16_dci_Format2_5_r16(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SearchSpaceExt_r16_searchSpaceType_r16_common_r16_dci_Format2_6_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SearchSpaceExt_r16_searchSpaceType_r16_common_r16_dci_Format2_6_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	(void)_buffer;
	(void)_size;
	(void)_lidx;
	(void)p;

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SearchSpaceExt_r16_searchSpaceType_r16_common_r16_dci_Format2_6_r16_dci_Format2_6_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SearchSpaceExt_r16_searchSpaceType_r16_common_r16_dci_Format2_6_r16_dci_Format2_6_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_SearchSpaceExt_r16_searchSpaceType_r16_common_r16_dci_Format2_6_r16(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SearchSpaceExt_r16_searchSpaceType_r16_common_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SearchSpaceExt_r16_searchSpaceType_r16_common_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncSQN_NR_SearchSpaceExt_r16_searchSpaceType_r16_common_r16_dci_Format2_4_r16_dci_Format2_4_r16_Optional(_buffer, _size, _lidx, &p->dci_Format2_4_r16);
	_serNrSysEncSQN_NR_SearchSpaceExt_r16_searchSpaceType_r16_common_r16_dci_Format2_5_r16_dci_Format2_5_r16_Optional(_buffer, _size, _lidx, &p->dci_Format2_5_r16);
	_serNrSysEncSQN_NR_SearchSpaceExt_r16_searchSpaceType_r16_common_r16_dci_Format2_6_r16_dci_Format2_6_r16_Optional(_buffer, _size, _lidx, &p->dci_Format2_6_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SearchSpaceExt_r16_searchSpaceType_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SearchSpaceExt_r16_searchSpaceType_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncSQN_NR_SearchSpaceExt_r16_searchSpaceType_r16_common_r16(_buffer, _size, _lidx, &p->common_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SearchSpaceExt_r16_searchSpaceType_r16_searchSpaceType_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SearchSpaceExt_r16_searchSpaceType_r16_searchSpaceType_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_SearchSpaceExt_r16_searchSpaceType_r16(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncUint8_t_SQN_NR_SearchSpaceExt_r16_searchSpaceGroupIdList_r16_DynamicOptional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint8_t_SQN_NR_SearchSpaceExt_r16_searchSpaceGroupIdList_r16_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		HTON_8(&_buffer[*_lidx], p->v.v[i2], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncB5_SQN_NR_SearchSpaceExt_r16_freqMonitorLocations_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct B5_SQN_NR_SearchSpaceExt_r16_freqMonitorLocations_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	for (size_t i2 = 0; i2 < 5; i2++) {
		HTON_8(&_buffer[*_lidx], p->v[i2], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SearchSpaceExt_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SearchSpaceExt_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncSQN_NR_ControlResourceSetId_r16_SQN_NR_SearchSpaceExt_r16_controlResourceSetId_r16_Optional(_buffer, _size, _lidx, &p->controlResourceSetId_r16);
	_serNrSysEncSQN_NR_SearchSpaceExt_r16_searchSpaceType_r16_searchSpaceType_r16_Optional(_buffer, _size, _lidx, &p->searchSpaceType_r16);
	_serNrSysEncUint8_t_SQN_NR_SearchSpaceExt_r16_searchSpaceGroupIdList_r16_DynamicOptional(_buffer, _size, _lidx, &p->searchSpaceGroupIdList_r16);
	_serNrSysEncB5_SQN_NR_SearchSpaceExt_r16_freqMonitorLocations_r16_Optional(_buffer, _size, _lidx, &p->freqMonitorLocations_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SearchSpaceExt_r16_SQN_NR_PDCCH_ConfigCommon_commonSearchSpaceListExt_r16_DynamicOptional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SearchSpaceExt_r16_SQN_NR_PDCCH_ConfigCommon_commonSearchSpaceListExt_r16_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i1 = 0; i1 < p->v.d; i1++) {
		_serNrSysEncSQN_NR_SearchSpaceExt_r16(_buffer, _size, _lidx, &p->v.v[i1]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PDCCH_ConfigCommon(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PDCCH_ConfigCommon* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncSQN_NR_ControlResourceSetZero_SQN_NR_PDCCH_ConfigCommon_controlResourceSetZero_Optional(_buffer, _size, _lidx, &p->controlResourceSetZero);
	_serNrSysEncSQN_NR_ControlResourceSet_SQN_NR_PDCCH_ConfigCommon_commonControlResourceSet_Optional(_buffer, _size, _lidx, &p->commonControlResourceSet);
	_serNrSysEncSQN_NR_SearchSpaceZero_SQN_NR_PDCCH_ConfigCommon_searchSpaceZero_Optional(_buffer, _size, _lidx, &p->searchSpaceZero);
	_serNrSysEncSQN_NR_SearchSpace_SQN_NR_PDCCH_ConfigCommon_commonSearchSpaceList_DynamicOptional(_buffer, _size, _lidx, &p->commonSearchSpaceList);
	_serNrSysEncSQN_NR_SearchSpaceId_SQN_NR_PDCCH_ConfigCommon_searchSpaceSIB1_Optional(_buffer, _size, _lidx, &p->searchSpaceSIB1);
	_serNrSysEncSQN_NR_SearchSpaceId_SQN_NR_PDCCH_ConfigCommon_searchSpaceOtherSystemInformation_Optional(_buffer, _size, _lidx, &p->searchSpaceOtherSystemInformation);
	_serNrSysEncSQN_NR_SearchSpaceId_SQN_NR_PDCCH_ConfigCommon_pagingSearchSpace_Optional(_buffer, _size, _lidx, &p->pagingSearchSpace);
	_serNrSysEncSQN_NR_SearchSpaceId_SQN_NR_PDCCH_ConfigCommon_ra_SearchSpace_Optional(_buffer, _size, _lidx, &p->ra_SearchSpace);
	_serNrSysEncSQN_NR_PDCCH_ConfigCommon_firstPDCCH_MonitoringOccasionOfPO_firstPDCCH_MonitoringOccasionOfPO_Optional(_buffer, _size, _lidx, &p->firstPDCCH_MonitoringOccasionOfPO);
	_serNrSysEncSQN_NR_SearchSpaceExt_r16_SQN_NR_PDCCH_ConfigCommon_commonSearchSpaceListExt_r16_DynamicOptional(_buffer, _size, _lidx, &p->commonSearchSpaceListExt_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SetupRelease_BWP_DownlinkCommon_pdcch_ConfigCommon_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SQN_NR_SetupRelease_BWP_DownlinkCommon_pdcch_ConfigCommon_Value* p, enum SQN_NR_SetupRelease_BWP_DownlinkCommon_pdcch_ConfigCommon_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SetupRelease_BWP_DownlinkCommon_pdcch_ConfigCommon_release) {
		HTON_8(&_buffer[*_lidx], p->release, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SetupRelease_BWP_DownlinkCommon_pdcch_ConfigCommon_setup) {
		_serNrSysEncSQN_NR_PDCCH_ConfigCommon(_buffer, _size, _lidx, &p->setup);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncSQN_NR_SetupRelease_BWP_DownlinkCommon_pdcch_ConfigCommon(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SetupRelease_BWP_DownlinkCommon_pdcch_ConfigCommon* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_SetupRelease_BWP_DownlinkCommon_pdcch_ConfigCommon_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SetupRelease_BWP_DownlinkCommon_pdcch_ConfigCommon_SQN_NR_BWP_DownlinkCommon_pdcch_ConfigCommon_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SetupRelease_BWP_DownlinkCommon_pdcch_ConfigCommon_SQN_NR_BWP_DownlinkCommon_pdcch_ConfigCommon_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_SetupRelease_BWP_DownlinkCommon_pdcch_ConfigCommon(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SetupRelease_BWP_DownlinkCommon_pdsch_ConfigCommon_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SQN_NR_SetupRelease_BWP_DownlinkCommon_pdsch_ConfigCommon_Value* p, enum SQN_NR_SetupRelease_BWP_DownlinkCommon_pdsch_ConfigCommon_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SetupRelease_BWP_DownlinkCommon_pdsch_ConfigCommon_release) {
		HTON_8(&_buffer[*_lidx], p->release, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SetupRelease_BWP_DownlinkCommon_pdsch_ConfigCommon_setup) {
		_serNrSysEncSQN_NR_PDSCH_ConfigCommon(_buffer, _size, _lidx, &p->setup);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncSQN_NR_SetupRelease_BWP_DownlinkCommon_pdsch_ConfigCommon(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SetupRelease_BWP_DownlinkCommon_pdsch_ConfigCommon* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_SetupRelease_BWP_DownlinkCommon_pdsch_ConfigCommon_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SetupRelease_BWP_DownlinkCommon_pdsch_ConfigCommon_SQN_NR_BWP_DownlinkCommon_pdsch_ConfigCommon_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SetupRelease_BWP_DownlinkCommon_pdsch_ConfigCommon_SQN_NR_BWP_DownlinkCommon_pdsch_ConfigCommon_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_SetupRelease_BWP_DownlinkCommon_pdsch_ConfigCommon(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_BWP_DownlinkCommon(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_BWP_DownlinkCommon* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncSQN_NR_BWP(_buffer, _size, _lidx, &p->genericParameters);
	_serNrSysEncSQN_NR_SetupRelease_BWP_DownlinkCommon_pdcch_ConfigCommon_SQN_NR_BWP_DownlinkCommon_pdcch_ConfigCommon_Optional(_buffer, _size, _lidx, &p->pdcch_ConfigCommon);
	_serNrSysEncSQN_NR_SetupRelease_BWP_DownlinkCommon_pdsch_ConfigCommon_SQN_NR_BWP_DownlinkCommon_pdsch_ConfigCommon_Optional(_buffer, _size, _lidx, &p->pdsch_ConfigCommon);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_BCCH_Config(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_BCCH_Config* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->modificationPeriodCoeff;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PCCH_Config_nAndPagingFrameOffset_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SQN_NR_PCCH_Config_nAndPagingFrameOffset_Value* p, enum SQN_NR_PCCH_Config_nAndPagingFrameOffset_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_PCCH_Config_nAndPagingFrameOffset_oneT) {
		HTON_8(&_buffer[*_lidx], p->oneT, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_PCCH_Config_nAndPagingFrameOffset_halfT) {
		HTON_8(&_buffer[*_lidx], p->halfT, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_PCCH_Config_nAndPagingFrameOffset_quarterT) {
		HTON_8(&_buffer[*_lidx], p->quarterT, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_PCCH_Config_nAndPagingFrameOffset_oneEighthT) {
		HTON_8(&_buffer[*_lidx], p->oneEighthT, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_PCCH_Config_nAndPagingFrameOffset_oneSixteenthT) {
		HTON_8(&_buffer[*_lidx], p->oneSixteenthT, _lidx);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncSQN_NR_PCCH_Config_nAndPagingFrameOffset(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PCCH_Config_nAndPagingFrameOffset* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_PCCH_Config_nAndPagingFrameOffset_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PCCH_Config_firstPDCCH_MonitoringOccasionOfPO_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SQN_NR_PCCH_Config_firstPDCCH_MonitoringOccasionOfPO_Value* p, enum SQN_NR_PCCH_Config_firstPDCCH_MonitoringOccasionOfPO_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_PCCH_Config_firstPDCCH_MonitoringOccasionOfPO_sCS15KHZoneT) {
		HTON_32(&_buffer[*_lidx], p->sCS15KHZoneT.d, _lidx);
		for (size_t i1 = 0; i1 < p->sCS15KHZoneT.d; i1++) {
			HTON_8(&_buffer[*_lidx], p->sCS15KHZoneT.v[i1], _lidx);
		}
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_PCCH_Config_firstPDCCH_MonitoringOccasionOfPO_sCS30KHZoneT_SCS15KHZhalfT) {
		HTON_32(&_buffer[*_lidx], p->sCS30KHZoneT_SCS15KHZhalfT.d, _lidx);
		for (size_t i1 = 0; i1 < p->sCS30KHZoneT_SCS15KHZhalfT.d; i1++) {
			HTON_16(&_buffer[*_lidx], p->sCS30KHZoneT_SCS15KHZhalfT.v[i1], _lidx);
		}
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_PCCH_Config_firstPDCCH_MonitoringOccasionOfPO_sCS60KHZoneT_SCS30KHZhalfT_SCS15KHZquarterT) {
		HTON_32(&_buffer[*_lidx], p->sCS60KHZoneT_SCS30KHZhalfT_SCS15KHZquarterT.d, _lidx);
		for (size_t i1 = 0; i1 < p->sCS60KHZoneT_SCS30KHZhalfT_SCS15KHZquarterT.d; i1++) {
			HTON_16(&_buffer[*_lidx], p->sCS60KHZoneT_SCS30KHZhalfT_SCS15KHZquarterT.v[i1], _lidx);
		}
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_PCCH_Config_firstPDCCH_MonitoringOccasionOfPO_sCS120KHZoneT_SCS60KHZhalfT_SCS30KHZquarterT_SCS15KHZoneEighthT) {
		HTON_32(&_buffer[*_lidx], p->sCS120KHZoneT_SCS60KHZhalfT_SCS30KHZquarterT_SCS15KHZoneEighthT.d, _lidx);
		for (size_t i1 = 0; i1 < p->sCS120KHZoneT_SCS60KHZhalfT_SCS30KHZquarterT_SCS15KHZoneEighthT.d; i1++) {
			HTON_16(&_buffer[*_lidx], p->sCS120KHZoneT_SCS60KHZhalfT_SCS30KHZquarterT_SCS15KHZoneEighthT.v[i1], _lidx);
		}
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_PCCH_Config_firstPDCCH_MonitoringOccasionOfPO_sCS120KHZhalfT_SCS60KHZquarterT_SCS30KHZoneEighthT_SCS15KHZoneSixteenthT) {
		HTON_32(&_buffer[*_lidx], p->sCS120KHZhalfT_SCS60KHZquarterT_SCS30KHZoneEighthT_SCS15KHZoneSixteenthT.d, _lidx);
		for (size_t i1 = 0; i1 < p->sCS120KHZhalfT_SCS60KHZquarterT_SCS30KHZoneEighthT_SCS15KHZoneSixteenthT.d; i1++) {
			HTON_16(&_buffer[*_lidx], p->sCS120KHZhalfT_SCS60KHZquarterT_SCS30KHZoneEighthT_SCS15KHZoneSixteenthT.v[i1], _lidx);
		}
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_PCCH_Config_firstPDCCH_MonitoringOccasionOfPO_sCS120KHZquarterT_SCS60KHZoneEighthT_SCS30KHZoneSixteenthT) {
		HTON_32(&_buffer[*_lidx], p->sCS120KHZquarterT_SCS60KHZoneEighthT_SCS30KHZoneSixteenthT.d, _lidx);
		for (size_t i1 = 0; i1 < p->sCS120KHZquarterT_SCS60KHZoneEighthT_SCS30KHZoneSixteenthT.d; i1++) {
			HTON_16(&_buffer[*_lidx], p->sCS120KHZquarterT_SCS60KHZoneEighthT_SCS30KHZoneSixteenthT.v[i1], _lidx);
		}
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_PCCH_Config_firstPDCCH_MonitoringOccasionOfPO_sCS120KHZoneEighthT_SCS60KHZoneSixteenthT) {
		HTON_32(&_buffer[*_lidx], p->sCS120KHZoneEighthT_SCS60KHZoneSixteenthT.d, _lidx);
		for (size_t i1 = 0; i1 < p->sCS120KHZoneEighthT_SCS60KHZoneSixteenthT.d; i1++) {
			HTON_16(&_buffer[*_lidx], p->sCS120KHZoneEighthT_SCS60KHZoneSixteenthT.v[i1], _lidx);
		}
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_PCCH_Config_firstPDCCH_MonitoringOccasionOfPO_sCS120KHZoneSixteenthT) {
		HTON_32(&_buffer[*_lidx], p->sCS120KHZoneSixteenthT.d, _lidx);
		for (size_t i1 = 0; i1 < p->sCS120KHZoneSixteenthT.d; i1++) {
			HTON_16(&_buffer[*_lidx], p->sCS120KHZoneSixteenthT.v[i1], _lidx);
		}
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncSQN_NR_PCCH_Config_firstPDCCH_MonitoringOccasionOfPO(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PCCH_Config_firstPDCCH_MonitoringOccasionOfPO* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_PCCH_Config_firstPDCCH_MonitoringOccasionOfPO_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PCCH_Config_firstPDCCH_MonitoringOccasionOfPO_firstPDCCH_MonitoringOccasionOfPO_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PCCH_Config_firstPDCCH_MonitoringOccasionOfPO_firstPDCCH_MonitoringOccasionOfPO_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_PCCH_Config_firstPDCCH_MonitoringOccasionOfPO(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncUint8_t_SQN_NR_PCCH_Config_nrofPDCCH_MonitoringOccasionPerSSB_InPO_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct uint8_t_SQN_NR_PCCH_Config_nrofPDCCH_MonitoringOccasionPerSSB_InPO_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PCCH_Config(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PCCH_Config* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->defaultPagingCycle;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_PCCH_Config_nAndPagingFrameOffset(_buffer, _size, _lidx, &p->nAndPagingFrameOffset);
	{
		size_t _tmp = (size_t)p->ns;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_PCCH_Config_firstPDCCH_MonitoringOccasionOfPO_firstPDCCH_MonitoringOccasionOfPO_Optional(_buffer, _size, _lidx, &p->firstPDCCH_MonitoringOccasionOfPO);
	_serNrSysEncUint8_t_SQN_NR_PCCH_Config_nrofPDCCH_MonitoringOccasionPerSSB_InPO_r16_Optional(_buffer, _size, _lidx, &p->nrofPDCCH_MonitoringOccasionPerSSB_InPO_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_DownlinkConfigCommonSIB(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_DownlinkConfigCommonSIB* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncSQN_NR_FrequencyInfoDL_SIB(_buffer, _size, _lidx, &p->frequencyInfoDL);
	_serNrSysEncSQN_NR_BWP_DownlinkCommon(_buffer, _size, _lidx, &p->initialDownlinkBWP);
	_serNrSysEncSQN_NR_BCCH_Config(_buffer, _size, _lidx, &p->bcch_Config);
	_serNrSysEncSQN_NR_PCCH_Config(_buffer, _size, _lidx, &p->pcch_Config);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_MultiFrequencyBandListNR_SIB_SQN_NR_FrequencyInfoUL_SIB_frequencyBandList_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_MultiFrequencyBandListNR_SIB_SQN_NR_FrequencyInfoUL_SIB_frequencyBandList_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i1 = 0; i1 < p->v.d; i1++) {
		_serNrSysEncSQN_NR_NR_MultiBandInfo(_buffer, _size, _lidx, &p->v.v[i1]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_ARFCN_ValueNR_SQN_NR_FrequencyInfoUL_SIB_absoluteFrequencyPointA_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_ARFCN_ValueNR_SQN_NR_FrequencyInfoUL_SIB_absoluteFrequencyPointA_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_P_Max_SQN_NR_FrequencyInfoUL_SIB_p_Max_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_P_Max_SQN_NR_FrequencyInfoUL_SIB_p_Max_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_FrequencyInfoUL_SIB_frequencyShift7p5khz_e_frequencyShift7p5khz_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_FrequencyInfoUL_SIB_frequencyShift7p5khz_e_frequencyShift7p5khz_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_FrequencyInfoUL_SIB(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_FrequencyInfoUL_SIB* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncSQN_NR_MultiFrequencyBandListNR_SIB_SQN_NR_FrequencyInfoUL_SIB_frequencyBandList_Optional(_buffer, _size, _lidx, &p->frequencyBandList);
	_serNrSysEncSQN_NR_ARFCN_ValueNR_SQN_NR_FrequencyInfoUL_SIB_absoluteFrequencyPointA_Optional(_buffer, _size, _lidx, &p->absoluteFrequencyPointA);
	HTON_32(&_buffer[*_lidx], p->scs_SpecificCarrierList.d, _lidx);
	for (size_t i1 = 0; i1 < p->scs_SpecificCarrierList.d; i1++) {
		_serNrSysEncSQN_NR_SCS_SpecificCarrier(_buffer, _size, _lidx, &p->scs_SpecificCarrierList.v[i1]);
	}
	_serNrSysEncSQN_NR_P_Max_SQN_NR_FrequencyInfoUL_SIB_p_Max_Optional(_buffer, _size, _lidx, &p->p_Max);
	_serNrSysEncSQN_NR_FrequencyInfoUL_SIB_frequencyShift7p5khz_e_frequencyShift7p5khz_Optional(_buffer, _size, _lidx, &p->frequencyShift7p5khz);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_UplinkConfigCommonSIB(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_UplinkConfigCommonSIB* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncSQN_NR_FrequencyInfoUL_SIB(_buffer, _size, _lidx, &p->frequencyInfoUL);
	_serNrSysEncSQN_NR_BWP_UplinkCommon(_buffer, _size, _lidx, &p->initialUplinkBWP);
	{
		size_t _tmp = (size_t)p->timeAlignmentTimerCommon;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_UplinkConfigCommonSIB_SQN_NR_ServingCellConfigCommonSIB_uplinkConfigCommon_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_UplinkConfigCommonSIB_SQN_NR_ServingCellConfigCommonSIB_uplinkConfigCommon_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_UplinkConfigCommonSIB(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_UplinkConfigCommonSIB_SQN_NR_ServingCellConfigCommonSIB_supplementaryUplink_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_UplinkConfigCommonSIB_SQN_NR_ServingCellConfigCommonSIB_supplementaryUplink_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_UplinkConfigCommonSIB(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_ServingCellConfigCommonSIB_n_TimingAdvanceOffset_e_n_TimingAdvanceOffset_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_ServingCellConfigCommonSIB_n_TimingAdvanceOffset_e_n_TimingAdvanceOffset_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncB8_SQN_NR_ServingCellConfigCommonSIB_ssb_PositionsInBurst_groupPresence_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct B8_SQN_NR_ServingCellConfigCommonSIB_ssb_PositionsInBurst_groupPresence_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	for (size_t i1 = 0; i1 < 8; i1++) {
		HTON_8(&_buffer[*_lidx], p->v[i1], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_ServingCellConfigCommonSIB_ssb_PositionsInBurst(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_ServingCellConfigCommonSIB_ssb_PositionsInBurst* p)
{
	(void)_size; // TODO: generate boundaries checking

	for (size_t i1 = 0; i1 < 8; i1++) {
		HTON_8(&_buffer[*_lidx], p->inOneGroup[i1], _lidx);
	}
	_serNrSysEncB8_SQN_NR_ServingCellConfigCommonSIB_ssb_PositionsInBurst_groupPresence_Optional(_buffer, _size, _lidx, &p->groupPresence);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_TDD_UL_DL_ConfigCommon_SQN_NR_ServingCellConfigCommonSIB_tdd_UL_DL_ConfigurationCommon_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_TDD_UL_DL_ConfigCommon_SQN_NR_ServingCellConfigCommonSIB_tdd_UL_DL_ConfigurationCommon_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_TDD_UL_DL_ConfigCommon(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SemiStaticChannelAccessConfig(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SemiStaticChannelAccessConfig* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->period;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_ServingCellConfigCommonSIB_channelAccessMode_r16_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SQN_NR_ServingCellConfigCommonSIB_channelAccessMode_r16_Value* p, enum SQN_NR_ServingCellConfigCommonSIB_channelAccessMode_r16_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_ServingCellConfigCommonSIB_channelAccessMode_r16_dynamic) {
		HTON_8(&_buffer[*_lidx], p->dynamic, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_ServingCellConfigCommonSIB_channelAccessMode_r16_semiStatic) {
		_serNrSysEncSQN_NR_SemiStaticChannelAccessConfig(_buffer, _size, _lidx, &p->semiStatic);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncSQN_NR_ServingCellConfigCommonSIB_channelAccessMode_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_ServingCellConfigCommonSIB_channelAccessMode_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_ServingCellConfigCommonSIB_channelAccessMode_r16_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_ServingCellConfigCommonSIB_channelAccessMode_r16_channelAccessMode_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_ServingCellConfigCommonSIB_channelAccessMode_r16_channelAccessMode_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_ServingCellConfigCommonSIB_channelAccessMode_r16(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_ServingCellConfigCommonSIB_discoveryBurstWindowLength_r16_e_discoveryBurstWindowLength_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_ServingCellConfigCommonSIB_discoveryBurstWindowLength_r16_e_discoveryBurstWindowLength_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_HighSpeedConfig_r16_highSpeedMeasFlag_r16_e_highSpeedMeasFlag_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_HighSpeedConfig_r16_highSpeedMeasFlag_r16_e_highSpeedMeasFlag_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_HighSpeedConfig_r16_highSpeedDemodFlag_r16_e_highSpeedDemodFlag_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_HighSpeedConfig_r16_highSpeedDemodFlag_r16_e_highSpeedDemodFlag_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_HighSpeedConfig_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_HighSpeedConfig_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncSQN_NR_HighSpeedConfig_r16_highSpeedMeasFlag_r16_e_highSpeedMeasFlag_r16_Optional(_buffer, _size, _lidx, &p->highSpeedMeasFlag_r16);
	_serNrSysEncSQN_NR_HighSpeedConfig_r16_highSpeedDemodFlag_r16_e_highSpeedDemodFlag_r16_Optional(_buffer, _size, _lidx, &p->highSpeedDemodFlag_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_HighSpeedConfig_r16_SQN_NR_ServingCellConfigCommonSIB_highSpeedConfig_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_HighSpeedConfig_r16_SQN_NR_ServingCellConfigCommonSIB_highSpeedConfig_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_HighSpeedConfig_r16(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_ServingCellConfigCommonSIB(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_ServingCellConfigCommonSIB* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncSQN_NR_DownlinkConfigCommonSIB(_buffer, _size, _lidx, &p->downlinkConfigCommon);
	_serNrSysEncSQN_NR_UplinkConfigCommonSIB_SQN_NR_ServingCellConfigCommonSIB_uplinkConfigCommon_Optional(_buffer, _size, _lidx, &p->uplinkConfigCommon);
	_serNrSysEncSQN_NR_UplinkConfigCommonSIB_SQN_NR_ServingCellConfigCommonSIB_supplementaryUplink_Optional(_buffer, _size, _lidx, &p->supplementaryUplink);
	_serNrSysEncSQN_NR_ServingCellConfigCommonSIB_n_TimingAdvanceOffset_e_n_TimingAdvanceOffset_Optional(_buffer, _size, _lidx, &p->n_TimingAdvanceOffset);
	_serNrSysEncSQN_NR_ServingCellConfigCommonSIB_ssb_PositionsInBurst(_buffer, _size, _lidx, &p->ssb_PositionsInBurst);
	{
		size_t _tmp = (size_t)p->ssb_PeriodicityServingCell;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_TDD_UL_DL_ConfigCommon_SQN_NR_ServingCellConfigCommonSIB_tdd_UL_DL_ConfigurationCommon_Optional(_buffer, _size, _lidx, &p->tdd_UL_DL_ConfigurationCommon);
	HTON_8(&_buffer[*_lidx], p->ss_PBCH_BlockPower, _lidx);
	_serNrSysEncSQN_NR_ServingCellConfigCommonSIB_channelAccessMode_r16_channelAccessMode_r16_Optional(_buffer, _size, _lidx, &p->channelAccessMode_r16);
	_serNrSysEncSQN_NR_ServingCellConfigCommonSIB_discoveryBurstWindowLength_r16_e_discoveryBurstWindowLength_r16_Optional(_buffer, _size, _lidx, &p->discoveryBurstWindowLength_r16);
	_serNrSysEncSQN_NR_HighSpeedConfig_r16_SQN_NR_ServingCellConfigCommonSIB_highSpeedConfig_r16_Optional(_buffer, _size, _lidx, &p->highSpeedConfig_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_ServingCellConfigCommonSIB_SQN_NR_SIB1_servingCellConfigCommon_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_ServingCellConfigCommonSIB_SQN_NR_SIB1_servingCellConfigCommon_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_ServingCellConfigCommonSIB(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SIB1_ims_EmergencySupport_e_ims_EmergencySupport_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SIB1_ims_EmergencySupport_e_ims_EmergencySupport_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SIB1_eCallOverIMS_Support_e_eCallOverIMS_Support_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SIB1_eCallOverIMS_Support_e_eCallOverIMS_Support_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_UE_TimersAndConstants(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_UE_TimersAndConstants* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->t300;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	{
		size_t _tmp = (size_t)p->t301;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	{
		size_t _tmp = (size_t)p->t310;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	{
		size_t _tmp = (size_t)p->n310;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	{
		size_t _tmp = (size_t)p->t311;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	{
		size_t _tmp = (size_t)p->n311;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	{
		size_t _tmp = (size_t)p->t319;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_UE_TimersAndConstants_SQN_NR_SIB1_ue_TimersAndConstants_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_UE_TimersAndConstants_SQN_NR_SIB1_ue_TimersAndConstants_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_UE_TimersAndConstants(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_UAC_BarringPerCat(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_UAC_BarringPerCat* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->accessCategory, _lidx);
	HTON_8(&_buffer[*_lidx], p->uac_barringInfoSetIndex, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_UAC_BarringPerCatList_SQN_NR_SIB1_uac_BarringInfo_uac_BarringForCommon_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_UAC_BarringPerCatList_SQN_NR_SIB1_uac_BarringInfo_uac_BarringForCommon_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i1 = 0; i1 < p->v.d; i1++) {
		_serNrSysEncSQN_NR_UAC_BarringPerCat(_buffer, _size, _lidx, &p->v.v[i1]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_UAC_BarringPerPLMN_uac_ACBarringListType_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SQN_NR_UAC_BarringPerPLMN_uac_ACBarringListType_Value* p, enum SQN_NR_UAC_BarringPerPLMN_uac_ACBarringListType_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_UAC_BarringPerPLMN_uac_ACBarringListType_uac_ImplicitACBarringList) {
		for (size_t i2 = 0; i2 < 63; i2++) {
			HTON_8(&_buffer[*_lidx], p->uac_ImplicitACBarringList[i2], _lidx);
		}
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_UAC_BarringPerPLMN_uac_ACBarringListType_uac_ExplicitACBarringList) {
		HTON_32(&_buffer[*_lidx], p->uac_ExplicitACBarringList.d, _lidx);
		for (size_t i2 = 0; i2 < p->uac_ExplicitACBarringList.d; i2++) {
			_serNrSysEncSQN_NR_UAC_BarringPerCat(_buffer, _size, _lidx, &p->uac_ExplicitACBarringList.v[i2]);
		}
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncSQN_NR_UAC_BarringPerPLMN_uac_ACBarringListType(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_UAC_BarringPerPLMN_uac_ACBarringListType* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_UAC_BarringPerPLMN_uac_ACBarringListType_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_UAC_BarringPerPLMN_uac_ACBarringListType_uac_ACBarringListType_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_UAC_BarringPerPLMN_uac_ACBarringListType_uac_ACBarringListType_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_UAC_BarringPerPLMN_uac_ACBarringListType(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_UAC_BarringPerPLMN(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_UAC_BarringPerPLMN* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->plmn_IdentityIndex, _lidx);
	_serNrSysEncSQN_NR_UAC_BarringPerPLMN_uac_ACBarringListType_uac_ACBarringListType_Optional(_buffer, _size, _lidx, &p->uac_ACBarringListType);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_UAC_BarringPerPLMN_List_SQN_NR_SIB1_uac_BarringInfo_uac_BarringPerPLMN_List_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_UAC_BarringPerPLMN_List_SQN_NR_SIB1_uac_BarringInfo_uac_BarringPerPLMN_List_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i1 = 0; i1 < p->v.d; i1++) {
		_serNrSysEncSQN_NR_UAC_BarringPerPLMN(_buffer, _size, _lidx, &p->v.v[i1]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_UAC_BarringInfoSet(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_UAC_BarringInfoSet* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->uac_BarringFactor;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	{
		size_t _tmp = (size_t)p->uac_BarringTime;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	for (size_t i2 = 0; i2 < 7; i2++) {
		HTON_8(&_buffer[*_lidx], p->uac_BarringForAccessIdentity[i2], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SIB1_uac_BarringInfo_uac_AccessCategory1_SelectionAssistanceInfo_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SQN_NR_SIB1_uac_BarringInfo_uac_AccessCategory1_SelectionAssistanceInfo_Value* p, enum SQN_NR_SIB1_uac_BarringInfo_uac_AccessCategory1_SelectionAssistanceInfo_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SIB1_uac_BarringInfo_uac_AccessCategory1_SelectionAssistanceInfo_plmnCommon) {
		{
			size_t _tmp = (size_t)p->plmnCommon;
			HTON_32(&_buffer[*_lidx], _tmp, _lidx);
		}
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SIB1_uac_BarringInfo_uac_AccessCategory1_SelectionAssistanceInfo_individualPLMNList) {
		HTON_32(&_buffer[*_lidx], p->individualPLMNList.d, _lidx);
		for (size_t i1 = 0; i1 < p->individualPLMNList.d; i1++) {
			{
				size_t _tmp = (size_t)p->individualPLMNList.v[i1];
				HTON_32(&_buffer[*_lidx], _tmp, _lidx);
			}
		}
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncSQN_NR_SIB1_uac_BarringInfo_uac_AccessCategory1_SelectionAssistanceInfo(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SIB1_uac_BarringInfo_uac_AccessCategory1_SelectionAssistanceInfo* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_SIB1_uac_BarringInfo_uac_AccessCategory1_SelectionAssistanceInfo_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SIB1_uac_BarringInfo_uac_AccessCategory1_SelectionAssistanceInfo_uac_AccessCategory1_SelectionAssistanceInfo_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SIB1_uac_BarringInfo_uac_AccessCategory1_SelectionAssistanceInfo_uac_AccessCategory1_SelectionAssistanceInfo_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_SIB1_uac_BarringInfo_uac_AccessCategory1_SelectionAssistanceInfo(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SIB1_uac_BarringInfo(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SIB1_uac_BarringInfo* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncSQN_NR_UAC_BarringPerCatList_SQN_NR_SIB1_uac_BarringInfo_uac_BarringForCommon_Optional(_buffer, _size, _lidx, &p->uac_BarringForCommon);
	_serNrSysEncSQN_NR_UAC_BarringPerPLMN_List_SQN_NR_SIB1_uac_BarringInfo_uac_BarringPerPLMN_List_Optional(_buffer, _size, _lidx, &p->uac_BarringPerPLMN_List);
	HTON_32(&_buffer[*_lidx], p->uac_BarringInfoSetList.d, _lidx);
	for (size_t i1 = 0; i1 < p->uac_BarringInfoSetList.d; i1++) {
		_serNrSysEncSQN_NR_UAC_BarringInfoSet(_buffer, _size, _lidx, &p->uac_BarringInfoSetList.v[i1]);
	}
	_serNrSysEncSQN_NR_SIB1_uac_BarringInfo_uac_AccessCategory1_SelectionAssistanceInfo_uac_AccessCategory1_SelectionAssistanceInfo_Optional(_buffer, _size, _lidx, &p->uac_AccessCategory1_SelectionAssistanceInfo);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SIB1_uac_BarringInfo_uac_BarringInfo_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SIB1_uac_BarringInfo_uac_BarringInfo_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_SIB1_uac_BarringInfo(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SIB1_useFullResumeID_e_useFullResumeID_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SIB1_useFullResumeID_e_useFullResumeID_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncOCTET_STRING_SQN_NR_SIB1_lateNonCriticalExtension_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct OCTET_STRING_SQN_NR_SIB1_lateNonCriticalExtension_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i1 = 0; i1 < p->v.d; i1++) {
		HTON_8(&_buffer[*_lidx], p->v.v[i1], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SIB1_v1610_IEs_idleModeMeasurementsEUTRA_r16_e_idleModeMeasurementsEUTRA_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SIB1_v1610_IEs_idleModeMeasurementsEUTRA_r16_e_idleModeMeasurementsEUTRA_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SIB1_v1610_IEs_idleModeMeasurementsNR_r16_e_idleModeMeasurementsNR_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SIB1_v1610_IEs_idleModeMeasurementsNR_r16_e_idleModeMeasurementsNR_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PosSchedulingInfo_r16_offsetToSI_Used_r16_e_offsetToSI_Used_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PosSchedulingInfo_r16_offsetToSI_Used_r16_e_offsetToSI_Used_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PosSIB_Type_r16_encrypted_r16_e_encrypted_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PosSIB_Type_r16_encrypted_r16_e_encrypted_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_GNSS_ID_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_GNSS_ID_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->gnss_id_r16;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_GNSS_ID_r16_SQN_NR_PosSIB_Type_r16_gnss_id_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_GNSS_ID_r16_SQN_NR_PosSIB_Type_r16_gnss_id_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_GNSS_ID_r16(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SBAS_ID_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SBAS_ID_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->sbas_id_r16;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SBAS_ID_r16_SQN_NR_PosSIB_Type_r16_sbas_id_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SBAS_ID_r16_SQN_NR_PosSIB_Type_r16_sbas_id_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_SBAS_ID_r16(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PosSIB_Type_r16_areaScope_r16_e_areaScope_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PosSIB_Type_r16_areaScope_r16_e_areaScope_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PosSIB_Type_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PosSIB_Type_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncSQN_NR_PosSIB_Type_r16_encrypted_r16_e_encrypted_r16_Optional(_buffer, _size, _lidx, &p->encrypted_r16);
	_serNrSysEncSQN_NR_GNSS_ID_r16_SQN_NR_PosSIB_Type_r16_gnss_id_r16_Optional(_buffer, _size, _lidx, &p->gnss_id_r16);
	_serNrSysEncSQN_NR_SBAS_ID_r16_SQN_NR_PosSIB_Type_r16_sbas_id_r16_Optional(_buffer, _size, _lidx, &p->sbas_id_r16);
	{
		size_t _tmp = (size_t)p->posSibType_r16;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_PosSIB_Type_r16_areaScope_r16_e_areaScope_r16_Optional(_buffer, _size, _lidx, &p->areaScope_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PosSchedulingInfo_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PosSchedulingInfo_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncSQN_NR_PosSchedulingInfo_r16_offsetToSI_Used_r16_e_offsetToSI_Used_r16_Optional(_buffer, _size, _lidx, &p->offsetToSI_Used_r16);
	{
		size_t _tmp = (size_t)p->posSI_Periodicity_r16;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	{
		size_t _tmp = (size_t)p->posSI_BroadcastStatus_r16;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	HTON_32(&_buffer[*_lidx], p->posSIB_MappingInfo_r16.d, _lidx);
	for (size_t i2 = 0; i2 < p->posSIB_MappingInfo_r16.d; i2++) {
		_serNrSysEncSQN_NR_PosSIB_Type_r16(_buffer, _size, _lidx, &p->posSIB_MappingInfo_r16.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SI_RequestConfig_SQN_NR_PosSI_SchedulingInfo_r16_posSI_RequestConfig_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SI_RequestConfig_SQN_NR_PosSI_SchedulingInfo_r16_posSI_RequestConfig_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_SI_RequestConfig(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SI_RequestConfig_SQN_NR_PosSI_SchedulingInfo_r16_posSI_RequestConfigSUL_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SI_RequestConfig_SQN_NR_PosSI_SchedulingInfo_r16_posSI_RequestConfigSUL_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_SI_RequestConfig(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PosSI_SchedulingInfo_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PosSI_SchedulingInfo_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_32(&_buffer[*_lidx], p->posSchedulingInfoList_r16.d, _lidx);
	for (size_t i1 = 0; i1 < p->posSchedulingInfoList_r16.d; i1++) {
		_serNrSysEncSQN_NR_PosSchedulingInfo_r16(_buffer, _size, _lidx, &p->posSchedulingInfoList_r16.v[i1]);
	}
	_serNrSysEncSQN_NR_SI_RequestConfig_SQN_NR_PosSI_SchedulingInfo_r16_posSI_RequestConfig_r16_Optional(_buffer, _size, _lidx, &p->posSI_RequestConfig_r16);
	_serNrSysEncSQN_NR_SI_RequestConfig_SQN_NR_PosSI_SchedulingInfo_r16_posSI_RequestConfigSUL_r16_Optional(_buffer, _size, _lidx, &p->posSI_RequestConfigSUL_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PosSI_SchedulingInfo_r16_SQN_NR_SIB1_v1610_IEs_posSI_SchedulingInfo_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PosSI_SchedulingInfo_r16_SQN_NR_SIB1_v1610_IEs_posSI_SchedulingInfo_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_PosSI_SchedulingInfo_r16(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SIB1_v1610_IEs_nonCriticalExtension(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SIB1_v1610_IEs_nonCriticalExtension* p)
{
	(void)_size; // TODO: generate boundaries checking

	(void)_buffer;
	(void)_size;
	(void)_lidx;
	(void)p;

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SIB1_v1610_IEs_nonCriticalExtension_nonCriticalExtension_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SIB1_v1610_IEs_nonCriticalExtension_nonCriticalExtension_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_SIB1_v1610_IEs_nonCriticalExtension(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SIB1_v1610_IEs(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SIB1_v1610_IEs* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncSQN_NR_SIB1_v1610_IEs_idleModeMeasurementsEUTRA_r16_e_idleModeMeasurementsEUTRA_r16_Optional(_buffer, _size, _lidx, &p->idleModeMeasurementsEUTRA_r16);
	_serNrSysEncSQN_NR_SIB1_v1610_IEs_idleModeMeasurementsNR_r16_e_idleModeMeasurementsNR_r16_Optional(_buffer, _size, _lidx, &p->idleModeMeasurementsNR_r16);
	_serNrSysEncSQN_NR_PosSI_SchedulingInfo_r16_SQN_NR_SIB1_v1610_IEs_posSI_SchedulingInfo_r16_Optional(_buffer, _size, _lidx, &p->posSI_SchedulingInfo_r16);
	_serNrSysEncSQN_NR_SIB1_v1610_IEs_nonCriticalExtension_nonCriticalExtension_Optional(_buffer, _size, _lidx, &p->nonCriticalExtension);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SIB1_v1610_IEs_SQN_NR_SIB1_nonCriticalExtension_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SIB1_v1610_IEs_SQN_NR_SIB1_nonCriticalExtension_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_SIB1_v1610_IEs(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SIB1(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SIB1* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncSQN_NR_SIB1_cellSelectionInfo_cellSelectionInfo_Optional(_buffer, _size, _lidx, &p->cellSelectionInfo);
	_serNrSysEncSQN_NR_CellAccessRelatedInfo(_buffer, _size, _lidx, &p->cellAccessRelatedInfo);
	_serNrSysEncSQN_NR_ConnEstFailureControl_SQN_NR_SIB1_connEstFailureControl_Optional(_buffer, _size, _lidx, &p->connEstFailureControl);
	_serNrSysEncSQN_NR_SI_SchedulingInfo_SQN_NR_SIB1_si_SchedulingInfo_Optional(_buffer, _size, _lidx, &p->si_SchedulingInfo);
	_serNrSysEncSQN_NR_ServingCellConfigCommonSIB_SQN_NR_SIB1_servingCellConfigCommon_Optional(_buffer, _size, _lidx, &p->servingCellConfigCommon);
	_serNrSysEncSQN_NR_SIB1_ims_EmergencySupport_e_ims_EmergencySupport_Optional(_buffer, _size, _lidx, &p->ims_EmergencySupport);
	_serNrSysEncSQN_NR_SIB1_eCallOverIMS_Support_e_eCallOverIMS_Support_Optional(_buffer, _size, _lidx, &p->eCallOverIMS_Support);
	_serNrSysEncSQN_NR_UE_TimersAndConstants_SQN_NR_SIB1_ue_TimersAndConstants_Optional(_buffer, _size, _lidx, &p->ue_TimersAndConstants);
	_serNrSysEncSQN_NR_SIB1_uac_BarringInfo_uac_BarringInfo_Optional(_buffer, _size, _lidx, &p->uac_BarringInfo);
	_serNrSysEncSQN_NR_SIB1_useFullResumeID_e_useFullResumeID_Optional(_buffer, _size, _lidx, &p->useFullResumeID);
	_serNrSysEncOCTET_STRING_SQN_NR_SIB1_lateNonCriticalExtension_Optional(_buffer, _size, _lidx, &p->lateNonCriticalExtension);
	_serNrSysEncSQN_NR_SIB1_v1610_IEs_SQN_NR_SIB1_nonCriticalExtension_Optional(_buffer, _size, _lidx, &p->nonCriticalExtension);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_BCCH_DL_SCH_MessageType_c1_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SQN_NR_BCCH_DL_SCH_MessageType_c1_Value* p, enum SQN_NR_BCCH_DL_SCH_MessageType_c1_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_BCCH_DL_SCH_MessageType_c1_systemInformation) {
		_serNrSysEncSQN_NR_SystemInformation(_buffer, _size, _lidx, &p->systemInformation);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_BCCH_DL_SCH_MessageType_c1_systemInformationBlockType1) {
		_serNrSysEncSQN_NR_SIB1(_buffer, _size, _lidx, &p->systemInformationBlockType1);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncSQN_NR_BCCH_DL_SCH_MessageType_c1(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_BCCH_DL_SCH_MessageType_c1* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_BCCH_DL_SCH_MessageType_c1_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_BCCH_DL_SCH_MessageType_messageClassExtension(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_BCCH_DL_SCH_MessageType_messageClassExtension* p)
{
	(void)_size; // TODO: generate boundaries checking

	(void)_buffer;
	(void)_size;
	(void)_lidx;
	(void)p;

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_BCCH_DL_SCH_MessageType_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SQN_NR_BCCH_DL_SCH_MessageType_Value* p, enum SQN_NR_BCCH_DL_SCH_MessageType_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_BCCH_DL_SCH_MessageType_c1) {
		_serNrSysEncSQN_NR_BCCH_DL_SCH_MessageType_c1(_buffer, _size, _lidx, &p->c1);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_BCCH_DL_SCH_MessageType_messageClassExtension) {
		_serNrSysEncSQN_NR_BCCH_DL_SCH_MessageType_messageClassExtension(_buffer, _size, _lidx, &p->messageClassExtension);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncSQN_NR_BCCH_DL_SCH_MessageType(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_BCCH_DL_SCH_MessageType* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_BCCH_DL_SCH_MessageType_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_BCCH_DL_SCH_Message(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_BCCH_DL_SCH_Message* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncSQN_NR_BCCH_DL_SCH_MessageType(_buffer, _size, _lidx, &p->message);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_BCCH_DL_SCH_Message_SIB1_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_BCCH_DL_SCH_Message_SIB1_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_BCCH_DL_SCH_Message(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_SI_List_Type_SIs_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_SI_List_Type_SIs_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i1 = 0; i1 < p->v.d; i1++) {
		_serNrSysEncSQN_NR_BCCH_DL_SCH_Message(_buffer, _size, _lidx, &p->v.v[i1]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_SegmentedSI_List_Type_SegmentedSIs_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_SegmentedSI_List_Type_SegmentedSIs_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i1 = 0; i1 < p->v.d; i1++) {
		HTON_32(&_buffer[*_lidx], p->v.v[i1].d, _lidx);
		for (size_t i2 = 0; i2 < p->v.v[i1].d; i2++) {
			_serNrSysEncSQN_NR_BCCH_DL_SCH_Message(_buffer, _size, _lidx, &p->v.v[i1].v[i2]);
		}
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_BcchInfo_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_BcchInfo_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncSQN_NR_BCCH_BCH_Message_MIB_Optional(_buffer, _size, _lidx, &p->MIB);
	_serNrSysEncSQN_NR_BCCH_DL_SCH_Message_SIB1_Optional(_buffer, _size, _lidx, &p->SIB1);
	_serNrSysEncNR_SI_List_Type_SIs_Optional(_buffer, _size, _lidx, &p->SIs);
	_serNrSysEncNR_SegmentedSI_List_Type_SegmentedSIs_Optional(_buffer, _size, _lidx, &p->SegmentedSIs);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_BcchInfo_Type_BcchInfo_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_BcchInfo_Type_BcchInfo_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncNR_BcchInfo_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_BcchConfig_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_BcchConfig_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncNR_BcchToPbchConfig_Type_Pbch_Optional(_buffer, _size, _lidx, &p->Pbch);
	_serNrSysEncNR_BcchToPdschConfig_Type_Pdsch_Optional(_buffer, _size, _lidx, &p->Pdsch);
	_serNrSysEncNR_BcchInfo_Type_BcchInfo_Optional(_buffer, _size, _lidx, &p->BcchInfo);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_BcchConfig_Type_BcchConfig_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_BcchConfig_Type_BcchConfig_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncNR_BcchConfig_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_SearchSpaceDlDciAssignment_Type_NR_PcchConfig_Type_SearchSpaceAndDci_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_SearchSpaceDlDciAssignment_Type_NR_PcchConfig_Type_SearchSpaceAndDci_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncNR_SearchSpaceDlDciAssignment_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_PcchConfig_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_PcchConfig_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncNR_SearchSpaceDlDciAssignment_Type_NR_PcchConfig_Type_SearchSpaceAndDci_Optional(_buffer, _size, _lidx, &p->SearchSpaceAndDci);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_PcchConfig_Type_PcchConfig_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_PcchConfig_Type_PcchConfig_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncNR_PcchConfig_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_SearchSpaceDlDciAssignment_Type_NR_RandomAccessResponseConfig_Type_SearchSpaceAndDci_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_SearchSpaceDlDciAssignment_Type_NR_RandomAccessResponseConfig_Type_SearchSpaceAndDci_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncNR_SearchSpaceDlDciAssignment_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncRAR_RapIdCtrl_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union RAR_RapIdCtrl_Type_Value* p, enum RAR_RapIdCtrl_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == RAR_RapIdCtrl_Type_Automatic) {
		HTON_8(&_buffer[*_lidx], p->Automatic, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == RAR_RapIdCtrl_Type_Unmatched) {
		HTON_8(&_buffer[*_lidx], p->Unmatched, _lidx);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncRAR_RapIdCtrl_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct RAR_RapIdCtrl_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncRAR_RapIdCtrl_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_RAR_RapIdOnly_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_RAR_RapIdOnly_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncRAR_RapIdCtrl_Type(_buffer, _size, _lidx, &p->RapId);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_RAR_UplinkGrant_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_RAR_UplinkGrant_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	for (size_t i3 = 0; i3 < 1; i3++) {
		HTON_8(&_buffer[*_lidx], p->HoppingFlag[i3], _lidx);
	}
	for (size_t i3 = 0; i3 < 14; i3++) {
		HTON_8(&_buffer[*_lidx], p->Msg3FrequencyResourceAllocation[i3], _lidx);
	}
	for (size_t i3 = 0; i3 < 4; i3++) {
		HTON_8(&_buffer[*_lidx], p->Msg3TimeResourceAllocation[i3], _lidx);
	}
	for (size_t i3 = 0; i3 < 4; i3++) {
		HTON_8(&_buffer[*_lidx], p->MCS[i3], _lidx);
	}
	for (size_t i3 = 0; i3 < 3; i3++) {
		HTON_8(&_buffer[*_lidx], p->TPC_Command[i3], _lidx);
	}
	for (size_t i3 = 0; i3 < 1; i3++) {
		HTON_8(&_buffer[*_lidx], p->CQI_Req[i3], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_TempC_RNTI_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union NR_TempC_RNTI_Type_Value* p, enum NR_TempC_RNTI_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_TempC_RNTI_Type_SameAsC_RNTI) {
		HTON_8(&_buffer[*_lidx], p->SameAsC_RNTI, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == NR_TempC_RNTI_Type_Explicit) {
		HTON_16(&_buffer[*_lidx], p->Explicit, _lidx);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncNR_TempC_RNTI_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_TempC_RNTI_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncNR_TempC_RNTI_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_RAR_Payload_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_RAR_Payload_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_16(&_buffer[*_lidx], p->TimingAdvance, _lidx);
	_serNrSysEncNR_RAR_UplinkGrant_Type(_buffer, _size, _lidx, &p->UplinkGrant);
	_serNrSysEncNR_TempC_RNTI_Type(_buffer, _size, _lidx, &p->TempC_RNTI);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_RAR_RapIdAndPayload_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_RAR_RapIdAndPayload_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncRAR_RapIdCtrl_Type(_buffer, _size, _lidx, &p->RapId);
	_serNrSysEncNR_RAR_Payload_Type(_buffer, _size, _lidx, &p->Payload);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_RAR_SubPdu_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union NR_RAR_SubPdu_Type_Value* p, enum NR_RAR_SubPdu_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_RAR_SubPdu_Type_BackoffIndicator) {
		HTON_8(&_buffer[*_lidx], p->BackoffIndicator, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == NR_RAR_SubPdu_Type_RapIdOnly) {
		_serNrSysEncNR_RAR_RapIdOnly_Type(_buffer, _size, _lidx, &p->RapIdOnly);
		return SIDL_STATUS_OK;
	}
	if (d == NR_RAR_SubPdu_Type_RapIdAndPayload) {
		_serNrSysEncNR_RAR_RapIdAndPayload_Type(_buffer, _size, _lidx, &p->RapIdAndPayload);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncNR_RAR_SubPdu_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_RAR_SubPdu_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncNR_RAR_SubPdu_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_RAR_SubPduList_Type_SubPduList_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_RAR_SubPduList_Type_SubPduList_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serNrSysEncNR_RAR_SubPdu_Type(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncBool_NR_RAR_MacPdu_Type_CrcError_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct bool_NR_RAR_MacPdu_Type_CrcError_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_RAR_MacPdu_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_RAR_MacPdu_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncNR_RAR_SubPduList_Type_SubPduList_Optional(_buffer, _size, _lidx, &p->SubPduList);
	_serNrSysEncBool_NR_RAR_MacPdu_Type_CrcError_Optional(_buffer, _size, _lidx, &p->CrcError);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_RAR_MacPdu_Type_MacPdu_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_RAR_MacPdu_Type_MacPdu_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncNR_RAR_MacPdu_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_RandomAccessResponseConfig_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_RandomAccessResponseConfig_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncNR_SearchSpaceDlDciAssignment_Type_NR_RandomAccessResponseConfig_Type_SearchSpaceAndDci_Optional(_buffer, _size, _lidx, &p->SearchSpaceAndDci);
	_serNrSysEncNR_RAR_MacPdu_Type_MacPdu_Optional(_buffer, _size, _lidx, &p->MacPdu);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_RandomAccessResponseConfig_Type_RandomAccessResponse_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_RandomAccessResponseConfig_Type_RandomAccessResponse_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncNR_RandomAccessResponseConfig_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_AssignedBWPs_Type_NR_SearchSpaceUlDciAssignment_Type_AssignedBWPs_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_AssignedBWPs_Type_NR_SearchSpaceUlDciAssignment_Type_AssignedBWPs_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncNR_AssignedBWPs_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_SearchSpaceType_Type_NR_SearchSpaceUlDciAssignment_Type_SearchSpaceType_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_SearchSpaceType_Type_NR_SearchSpaceUlDciAssignment_Type_SearchSpaceType_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_ResourceAllocationType_Type_NR_DciFormat_0_X_ResourceAssignment_Type_ResourceAllocationType_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_ResourceAllocationType_Type_NR_DciFormat_0_X_ResourceAssignment_Type_ResourceAllocationType_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_FreqDomainSchedulExplicit_Type_FreqDomain_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_FreqDomainSchedulExplicit_Type_FreqDomain_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncNR_FreqDomainSchedulExplicit_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_DciCommon_TimeDomainResourceAssignment_Type_NR_DciFormat_0_X_ResourceAssignment_Type_TimeDomain_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_DciCommon_TimeDomainResourceAssignment_Type_NR_DciFormat_0_X_ResourceAssignment_Type_TimeDomain_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncNR_DciCommon_TimeDomainResourceAssignment_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_TransportBlockRetransmissionList_Type_TransportBlockScheduling_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_TransportBlockRetransmissionList_Type_TransportBlockScheduling_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serNrSysEncNR_TransportBlockSingleTransmission_Type(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_HarqProcessConfig_Type_NR_DciFormat_0_X_ResourceAssignment_Type_HarqProcessConfig_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_HarqProcessConfig_Type_NR_DciFormat_0_X_ResourceAssignment_Type_HarqProcessConfig_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncNR_HarqProcessConfig_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_DciFormat_0_X_ResourceAssignment_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_DciFormat_0_X_ResourceAssignment_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncNR_ResourceAllocationType_Type_NR_DciFormat_0_X_ResourceAssignment_Type_ResourceAllocationType_Optional(_buffer, _size, _lidx, &p->ResourceAllocationType);
	_serNrSysEncNR_FreqDomainSchedulExplicit_Type_FreqDomain_Optional(_buffer, _size, _lidx, &p->FreqDomain);
	_serNrSysEncNR_DciCommon_TimeDomainResourceAssignment_Type_NR_DciFormat_0_X_ResourceAssignment_Type_TimeDomain_Optional(_buffer, _size, _lidx, &p->TimeDomain);
	_serNrSysEncNR_TransportBlockRetransmissionList_Type_TransportBlockScheduling_Optional(_buffer, _size, _lidx, &p->TransportBlockScheduling);
	_serNrSysEncNR_HarqProcessConfig_Type_NR_DciFormat_0_X_ResourceAssignment_Type_HarqProcessConfig_Optional(_buffer, _size, _lidx, &p->HarqProcessConfig);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_DciFormat_0_X_ResourceAssignment_Type_ResoureAssignment_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_DciFormat_0_X_ResourceAssignment_Type_ResoureAssignment_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncNR_DciFormat_0_X_ResourceAssignment_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_DciFormat_0_X_PuschHoppingCtrl_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union NR_DciFormat_0_X_PuschHoppingCtrl_Type_Value* p, enum NR_DciFormat_0_X_PuschHoppingCtrl_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_DciFormat_0_X_PuschHoppingCtrl_Type_None) {
		HTON_8(&_buffer[*_lidx], p->None, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == NR_DciFormat_0_X_PuschHoppingCtrl_Type_Flag) {
		for (size_t i2 = 0; i2 < 1; i2++) {
			HTON_8(&_buffer[*_lidx], p->Flag[i2], _lidx);
		}
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncNR_DciFormat_0_X_PuschHoppingCtrl_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_DciFormat_0_X_PuschHoppingCtrl_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncNR_DciFormat_0_X_PuschHoppingCtrl_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_DciFormat_0_X_PuschHoppingCtrl_Type_PuschHoppingCtrl_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_DciFormat_0_X_PuschHoppingCtrl_Type_PuschHoppingCtrl_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncNR_DciFormat_0_X_PuschHoppingCtrl_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_DciCommon_TpcCommand_Type_TpcCommandPusch_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_DciCommon_TpcCommand_Type_TpcCommandPusch_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncNR_DciCommon_TpcCommand_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_DciCommon_UL_SUL_Indicator_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union NR_DciCommon_UL_SUL_Indicator_Type_Value* p, enum NR_DciCommon_UL_SUL_Indicator_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_DciCommon_UL_SUL_Indicator_Type_None) {
		HTON_8(&_buffer[*_lidx], p->None, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == NR_DciCommon_UL_SUL_Indicator_Type_Value) {
		for (size_t i2 = 0; i2 < 1; i2++) {
			HTON_8(&_buffer[*_lidx], p->Value[i2], _lidx);
		}
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncNR_DciCommon_UL_SUL_Indicator_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_DciCommon_UL_SUL_Indicator_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncNR_DciCommon_UL_SUL_Indicator_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_DciCommon_UL_SUL_Indicator_Type_UL_SUL_Indicator_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_DciCommon_UL_SUL_Indicator_Type_UL_SUL_Indicator_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncNR_DciCommon_UL_SUL_Indicator_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_DciFormat_X_0_ChannelAccessCPext_Type_NR_DciFormat_0_0_SpecificInfo_Type_ChannelAccessCPext_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_DciFormat_X_0_ChannelAccessCPext_Type_NR_DciFormat_0_0_SpecificInfo_Type_ChannelAccessCPext_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncNR_DciFormat_X_0_ChannelAccessCPext_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_DciFormat_0_0_SpecificInfo_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_DciFormat_0_0_SpecificInfo_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncNR_DciFormat_X_0_ChannelAccessCPext_Type_NR_DciFormat_0_0_SpecificInfo_Type_ChannelAccessCPext_Optional(_buffer, _size, _lidx, &p->ChannelAccessCPext);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_DciCommon_CarrierIndicator_Type_NR_DciFormat_0_1_SpecificInfo_Type_CarrierIndicator_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_DciCommon_CarrierIndicator_Type_NR_DciFormat_0_1_SpecificInfo_Type_CarrierIndicator_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncNR_DciCommon_CarrierIndicator_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_DciFormat_0_1_DfiFlag_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union NR_DciFormat_0_1_DfiFlag_Type_Value* p, enum NR_DciFormat_0_1_DfiFlag_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_DciFormat_0_1_DfiFlag_Type_None) {
		HTON_8(&_buffer[*_lidx], p->None, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == NR_DciFormat_0_1_DfiFlag_Type_Flag) {
		for (size_t i2 = 0; i2 < 1; i2++) {
			HTON_8(&_buffer[*_lidx], p->Flag[i2], _lidx);
		}
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncNR_DciFormat_0_1_DfiFlag_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_DciFormat_0_1_DfiFlag_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncNR_DciFormat_0_1_DfiFlag_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_DciFormat_0_1_DfiFlag_Type_DfiFlag_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_DciFormat_0_1_DfiFlag_Type_DfiFlag_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncNR_DciFormat_0_1_DfiFlag_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_DciCommon_BWPIndicator_Type_NR_DciFormat_0_1_SpecificInfo_Type_BWPIndicator_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_DciCommon_BWPIndicator_Type_NR_DciFormat_0_1_SpecificInfo_Type_BWPIndicator_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncNR_DciCommon_BWPIndicator_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncDAI_B1_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union DAI_B1_Type_Value* p, enum DAI_B1_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == DAI_B1_Type_Index) {
		for (size_t i2 = 0; i2 < 1; i2++) {
			HTON_8(&_buffer[*_lidx], p->Index[i2], _lidx);
		}
		return SIDL_STATUS_OK;
	}
	if (d == DAI_B1_Type_Automatic) {
		HTON_8(&_buffer[*_lidx], p->Automatic, _lidx);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncDAI_B1_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct DAI_B1_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncDAI_B1_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_DciFormat_0_1_FirstDAI_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union NR_DciFormat_0_1_FirstDAI_Type_Value* p, enum NR_DciFormat_0_1_FirstDAI_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_DciFormat_0_1_FirstDAI_Type_SemiStaticCodebook) {
		_serNrSysEncDAI_B1_Type(_buffer, _size, _lidx, &p->SemiStaticCodebook);
		return SIDL_STATUS_OK;
	}
	if (d == NR_DciFormat_0_1_FirstDAI_Type_DynamicCodebook) {
		_serNrSysEncDAI_B2_Type(_buffer, _size, _lidx, &p->DynamicCodebook);
		return SIDL_STATUS_OK;
	}
	if (d == NR_DciFormat_0_1_FirstDAI_Type_EnhancedDynamicCodebook) {
		_serNrSysEncDAI_B4_Type(_buffer, _size, _lidx, &p->EnhancedDynamicCodebook);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncNR_DciFormat_0_1_FirstDAI_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_DciFormat_0_1_FirstDAI_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncNR_DciFormat_0_1_FirstDAI_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_DciFormat_0_1_FirstDAI_Type_FirstDAI_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_DciFormat_0_1_FirstDAI_Type_FirstDAI_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncNR_DciFormat_0_1_FirstDAI_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_DciFormat_0_1_SecondDAI_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union NR_DciFormat_0_1_SecondDAI_Type_Value* p, enum NR_DciFormat_0_1_SecondDAI_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_DciFormat_0_1_SecondDAI_Type_None) {
		HTON_8(&_buffer[*_lidx], p->None, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == NR_DciFormat_0_1_SecondDAI_Type_DynamicCodebook) {
		_serNrSysEncDAI_B2_Type(_buffer, _size, _lidx, &p->DynamicCodebook);
		return SIDL_STATUS_OK;
	}
	if (d == NR_DciFormat_0_1_SecondDAI_Type_EnhancedDynamicCodebook) {
		_serNrSysEncDAI_B4_Type(_buffer, _size, _lidx, &p->EnhancedDynamicCodebook);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncNR_DciFormat_0_1_SecondDAI_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_DciFormat_0_1_SecondDAI_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncNR_DciFormat_0_1_SecondDAI_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_DciFormat_0_1_SecondDAI_Type_SecondDAI_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_DciFormat_0_1_SecondDAI_Type_SecondDAI_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncNR_DciFormat_0_1_SecondDAI_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_DciFormat_0_1_SrsResourceIndicator_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union NR_DciFormat_0_1_SrsResourceIndicator_Type_Value* p, enum NR_DciFormat_0_1_SrsResourceIndicator_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_DciFormat_0_1_SrsResourceIndicator_Type_NonCodeBook) {
		HTON_32(&_buffer[*_lidx], p->NonCodeBook.d, _lidx);
		for (size_t i2 = 0; i2 < p->NonCodeBook.d; i2++) {
			HTON_8(&_buffer[*_lidx], p->NonCodeBook.v[i2], _lidx);
		}
		return SIDL_STATUS_OK;
	}
	if (d == NR_DciFormat_0_1_SrsResourceIndicator_Type_CodeBook) {
		HTON_32(&_buffer[*_lidx], p->CodeBook.d, _lidx);
		for (size_t i2 = 0; i2 < p->CodeBook.d; i2++) {
			HTON_8(&_buffer[*_lidx], p->CodeBook.v[i2], _lidx);
		}
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncNR_DciFormat_0_1_SrsResourceIndicator_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_DciFormat_0_1_SrsResourceIndicator_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncNR_DciFormat_0_1_SrsResourceIndicator_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_DciFormat_0_1_SrsResourceIndicator_Type_SrsResourceIndicator_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_DciFormat_0_1_SrsResourceIndicator_Type_SrsResourceIndicator_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncNR_DciFormat_0_1_SrsResourceIndicator_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_DciFormat_0_1_PrecodingInfo_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union NR_DciFormat_0_1_PrecodingInfo_Type_Value* p, enum NR_DciFormat_0_1_PrecodingInfo_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_DciFormat_0_1_PrecodingInfo_Type_NonCodeBook) {
		HTON_8(&_buffer[*_lidx], p->NonCodeBook, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == NR_DciFormat_0_1_PrecodingInfo_Type_CodeBook) {
		HTON_32(&_buffer[*_lidx], p->CodeBook.d, _lidx);
		for (size_t i2 = 0; i2 < p->CodeBook.d; i2++) {
			HTON_8(&_buffer[*_lidx], p->CodeBook.v[i2], _lidx);
		}
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncNR_DciFormat_0_1_PrecodingInfo_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_DciFormat_0_1_PrecodingInfo_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncNR_DciFormat_0_1_PrecodingInfo_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_DciFormat_0_1_PrecodingInfo_Type_PrecodingInfo_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_DciFormat_0_1_PrecodingInfo_Type_PrecodingInfo_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncNR_DciFormat_0_1_PrecodingInfo_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_DciFormat_0_1_AntennaPorts_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union NR_DciFormat_0_1_AntennaPorts_Type_Value* p, enum NR_DciFormat_0_1_AntennaPorts_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_DciFormat_0_1_AntennaPorts_Type_Index) {
		HTON_32(&_buffer[*_lidx], p->Index.d, _lidx);
		for (size_t i2 = 0; i2 < p->Index.d; i2++) {
			HTON_8(&_buffer[*_lidx], p->Index.v[i2], _lidx);
		}
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncNR_DciFormat_0_1_AntennaPorts_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_DciFormat_0_1_AntennaPorts_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncNR_DciFormat_0_1_AntennaPorts_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_DciFormat_0_1_AntennaPorts_Type_AntennaPorts_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_DciFormat_0_1_AntennaPorts_Type_AntennaPorts_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncNR_DciFormat_0_1_AntennaPorts_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_DciFormat_X_1_SrsRequest_Type_NR_DciFormat_0_1_SpecificInfo_Type_SrsRequest_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_DciFormat_X_1_SrsRequest_Type_NR_DciFormat_0_1_SpecificInfo_Type_SrsRequest_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncNR_DciFormat_X_1_SrsRequest_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_DciFormat_0_1_CsiRequest_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union NR_DciFormat_0_1_CsiRequest_Type_Value* p, enum NR_DciFormat_0_1_CsiRequest_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_DciFormat_0_1_CsiRequest_Type_Index) {
		HTON_32(&_buffer[*_lidx], p->Index.d, _lidx);
		for (size_t i2 = 0; i2 < p->Index.d; i2++) {
			HTON_8(&_buffer[*_lidx], p->Index.v[i2], _lidx);
		}
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncNR_DciFormat_0_1_CsiRequest_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_DciFormat_0_1_CsiRequest_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncNR_DciFormat_0_1_CsiRequest_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_DciFormat_0_1_CsiRequest_Type_CsiRequest_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_DciFormat_0_1_CsiRequest_Type_CsiRequest_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncNR_DciFormat_0_1_CsiRequest_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_DciFormat_0_1_CBGTI_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union NR_DciFormat_0_1_CBGTI_Type_Value* p, enum NR_DciFormat_0_1_CBGTI_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_DciFormat_0_1_CBGTI_Type_Index) {
		HTON_32(&_buffer[*_lidx], p->Index.d, _lidx);
		for (size_t i2 = 0; i2 < p->Index.d; i2++) {
			HTON_8(&_buffer[*_lidx], p->Index.v[i2], _lidx);
		}
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncNR_DciFormat_0_1_CBGTI_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_DciFormat_0_1_CBGTI_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncNR_DciFormat_0_1_CBGTI_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_DciFormat_0_1_CBGTI_Type_CBGTI_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_DciFormat_0_1_CBGTI_Type_CBGTI_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncNR_DciFormat_0_1_CBGTI_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_DciFormat_0_1_PtrsDmrsAssociation_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union NR_DciFormat_0_1_PtrsDmrsAssociation_Type_Value* p, enum NR_DciFormat_0_1_PtrsDmrsAssociation_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_DciFormat_0_1_PtrsDmrsAssociation_Type_None) {
		HTON_8(&_buffer[*_lidx], p->None, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == NR_DciFormat_0_1_PtrsDmrsAssociation_Type_Value) {
		for (size_t i2 = 0; i2 < 2; i2++) {
			HTON_8(&_buffer[*_lidx], p->Value[i2], _lidx);
		}
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncNR_DciFormat_0_1_PtrsDmrsAssociation_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_DciFormat_0_1_PtrsDmrsAssociation_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncNR_DciFormat_0_1_PtrsDmrsAssociation_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_DciFormat_0_1_PtrsDmrsAssociation_Type_PtrsDmrsAssociation_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_DciFormat_0_1_PtrsDmrsAssociation_Type_PtrsDmrsAssociation_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncNR_DciFormat_0_1_PtrsDmrsAssociation_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_DciFormat_0_1_BetaOffsetIndicator_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union NR_DciFormat_0_1_BetaOffsetIndicator_Type_Value* p, enum NR_DciFormat_0_1_BetaOffsetIndicator_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_DciFormat_0_1_BetaOffsetIndicator_Type_None) {
		HTON_8(&_buffer[*_lidx], p->None, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == NR_DciFormat_0_1_BetaOffsetIndicator_Type_Value) {
		for (size_t i2 = 0; i2 < 2; i2++) {
			HTON_8(&_buffer[*_lidx], p->Value[i2], _lidx);
		}
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncNR_DciFormat_0_1_BetaOffsetIndicator_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_DciFormat_0_1_BetaOffsetIndicator_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncNR_DciFormat_0_1_BetaOffsetIndicator_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_DciFormat_0_1_BetaOffsetIndicator_Type_BetaOffsetIndicator_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_DciFormat_0_1_BetaOffsetIndicator_Type_BetaOffsetIndicator_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncNR_DciFormat_0_1_BetaOffsetIndicator_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_DciFormat_X_1_DmrsSequenceInit_Type_NR_DciFormat_0_1_SpecificInfo_Type_DmrsSequenceInit_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_DciFormat_X_1_DmrsSequenceInit_Type_NR_DciFormat_0_1_SpecificInfo_Type_DmrsSequenceInit_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncNR_DciFormat_X_1_DmrsSequenceInit_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_DciFormat_0_1_UlschIndicator_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union NR_DciFormat_0_1_UlschIndicator_Type_Value* p, enum NR_DciFormat_0_1_UlschIndicator_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_DciFormat_0_1_UlschIndicator_Type_None) {
		HTON_8(&_buffer[*_lidx], p->None, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == NR_DciFormat_0_1_UlschIndicator_Type_Value) {
		for (size_t i2 = 0; i2 < 1; i2++) {
			HTON_8(&_buffer[*_lidx], p->Value[i2], _lidx);
		}
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncNR_DciFormat_0_1_UlschIndicator_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_DciFormat_0_1_UlschIndicator_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncNR_DciFormat_0_1_UlschIndicator_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_DciFormat_0_1_UlschIndicator_Type_UlschIndicator_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_DciFormat_0_1_UlschIndicator_Type_UlschIndicator_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncNR_DciFormat_0_1_UlschIndicator_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_DciFormat_0_1_ChannelAccessCPextCAPC_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union NR_DciFormat_0_1_ChannelAccessCPextCAPC_Type_Value* p, enum NR_DciFormat_0_1_ChannelAccessCPextCAPC_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_DciFormat_0_1_ChannelAccessCPextCAPC_Type_None) {
		HTON_8(&_buffer[*_lidx], p->None, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == NR_DciFormat_0_1_ChannelAccessCPextCAPC_Type_Value) {
		HTON_32(&_buffer[*_lidx], p->Value.d, _lidx);
		for (size_t i2 = 0; i2 < p->Value.d; i2++) {
			HTON_8(&_buffer[*_lidx], p->Value.v[i2], _lidx);
		}
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncNR_DciFormat_0_1_ChannelAccessCPextCAPC_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_DciFormat_0_1_ChannelAccessCPextCAPC_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncNR_DciFormat_0_1_ChannelAccessCPextCAPC_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_DciFormat_0_1_ChannelAccessCPextCAPC_Type_ChannelAccessCPextCAPC_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_DciFormat_0_1_ChannelAccessCPextCAPC_Type_ChannelAccessCPextCAPC_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncNR_DciFormat_0_1_ChannelAccessCPextCAPC_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_DciFormat_0_1_OpenLoopPowerControl_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union NR_DciFormat_0_1_OpenLoopPowerControl_Type_Value* p, enum NR_DciFormat_0_1_OpenLoopPowerControl_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_DciFormat_0_1_OpenLoopPowerControl_Type_None) {
		HTON_8(&_buffer[*_lidx], p->None, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == NR_DciFormat_0_1_OpenLoopPowerControl_Type_Value) {
		HTON_32(&_buffer[*_lidx], p->Value.d, _lidx);
		for (size_t i2 = 0; i2 < p->Value.d; i2++) {
			HTON_8(&_buffer[*_lidx], p->Value.v[i2], _lidx);
		}
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncNR_DciFormat_0_1_OpenLoopPowerControl_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_DciFormat_0_1_OpenLoopPowerControl_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncNR_DciFormat_0_1_OpenLoopPowerControl_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_DciFormat_0_1_OpenLoopPowerControl_Type_OpenLoopPowerControl_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_DciFormat_0_1_OpenLoopPowerControl_Type_OpenLoopPowerControl_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncNR_DciFormat_0_1_OpenLoopPowerControl_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_DciFormat_X_1_PriorityIndicator_Type_NR_DciFormat_0_1_SpecificInfo_Type_PriorityIndicator_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_DciFormat_X_1_PriorityIndicator_Type_NR_DciFormat_0_1_SpecificInfo_Type_PriorityIndicator_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncNR_DciFormat_X_1_PriorityIndicator_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_DciFormat_0_1_InvalidSymbolPatternIndicator_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union NR_DciFormat_0_1_InvalidSymbolPatternIndicator_Type_Value* p, enum NR_DciFormat_0_1_InvalidSymbolPatternIndicator_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_DciFormat_0_1_InvalidSymbolPatternIndicator_Type_None) {
		HTON_8(&_buffer[*_lidx], p->None, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == NR_DciFormat_0_1_InvalidSymbolPatternIndicator_Type_Value) {
		for (size_t i2 = 0; i2 < 1; i2++) {
			HTON_8(&_buffer[*_lidx], p->Value[i2], _lidx);
		}
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncNR_DciFormat_0_1_InvalidSymbolPatternIndicator_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_DciFormat_0_1_InvalidSymbolPatternIndicator_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncNR_DciFormat_0_1_InvalidSymbolPatternIndicator_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_DciFormat_0_1_InvalidSymbolPatternIndicator_Type_InvalidSymbolPatternIndicator_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_DciFormat_0_1_InvalidSymbolPatternIndicator_Type_InvalidSymbolPatternIndicator_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncNR_DciFormat_0_1_InvalidSymbolPatternIndicator_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_DciFormat_X_1_MinimumApplicableSchedulingOffset_Type_NR_DciFormat_0_1_SpecificInfo_Type_MinimumApplicableSchedulingOffset_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_DciFormat_X_1_MinimumApplicableSchedulingOffset_Type_NR_DciFormat_0_1_SpecificInfo_Type_MinimumApplicableSchedulingOffset_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncNR_DciFormat_X_1_MinimumApplicableSchedulingOffset_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_DciFormat_X_1_SCellDormancyIndication_Type_NR_DciFormat_0_1_SpecificInfo_Type_SCellDormancyIndication_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_DciFormat_X_1_SCellDormancyIndication_Type_NR_DciFormat_0_1_SpecificInfo_Type_SCellDormancyIndication_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncNR_DciFormat_X_1_SCellDormancyIndication_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_DciFormat_0_1_SidelinkAssignmentIndex_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union NR_DciFormat_0_1_SidelinkAssignmentIndex_Type_Value* p, enum NR_DciFormat_0_1_SidelinkAssignmentIndex_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_DciFormat_0_1_SidelinkAssignmentIndex_Type_None) {
		HTON_8(&_buffer[*_lidx], p->None, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == NR_DciFormat_0_1_SidelinkAssignmentIndex_Type_Value) {
		HTON_32(&_buffer[*_lidx], p->Value.d, _lidx);
		for (size_t i2 = 0; i2 < p->Value.d; i2++) {
			HTON_8(&_buffer[*_lidx], p->Value.v[i2], _lidx);
		}
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncNR_DciFormat_0_1_SidelinkAssignmentIndex_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_DciFormat_0_1_SidelinkAssignmentIndex_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncNR_DciFormat_0_1_SidelinkAssignmentIndex_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_DciFormat_0_1_SidelinkAssignmentIndex_Type_SidelinkAssignmentIndex_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_DciFormat_0_1_SidelinkAssignmentIndex_Type_SidelinkAssignmentIndex_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncNR_DciFormat_0_1_SidelinkAssignmentIndex_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_DciFormat_0_1_SpecificInfo_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_DciFormat_0_1_SpecificInfo_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncNR_DciCommon_CarrierIndicator_Type_NR_DciFormat_0_1_SpecificInfo_Type_CarrierIndicator_Optional(_buffer, _size, _lidx, &p->CarrierIndicator);
	_serNrSysEncNR_DciFormat_0_1_DfiFlag_Type_DfiFlag_Optional(_buffer, _size, _lidx, &p->DfiFlag);
	_serNrSysEncNR_DciCommon_BWPIndicator_Type_NR_DciFormat_0_1_SpecificInfo_Type_BWPIndicator_Optional(_buffer, _size, _lidx, &p->BWPIndicator);
	_serNrSysEncNR_DciFormat_0_1_FirstDAI_Type_FirstDAI_Optional(_buffer, _size, _lidx, &p->FirstDAI);
	_serNrSysEncNR_DciFormat_0_1_SecondDAI_Type_SecondDAI_Optional(_buffer, _size, _lidx, &p->SecondDAI);
	_serNrSysEncNR_DciFormat_0_1_SrsResourceIndicator_Type_SrsResourceIndicator_Optional(_buffer, _size, _lidx, &p->SrsResourceIndicator);
	_serNrSysEncNR_DciFormat_0_1_PrecodingInfo_Type_PrecodingInfo_Optional(_buffer, _size, _lidx, &p->PrecodingInfo);
	_serNrSysEncNR_DciFormat_0_1_AntennaPorts_Type_AntennaPorts_Optional(_buffer, _size, _lidx, &p->AntennaPorts);
	_serNrSysEncNR_DciFormat_X_1_SrsRequest_Type_NR_DciFormat_0_1_SpecificInfo_Type_SrsRequest_Optional(_buffer, _size, _lidx, &p->SrsRequest);
	_serNrSysEncNR_DciFormat_0_1_CsiRequest_Type_CsiRequest_Optional(_buffer, _size, _lidx, &p->CsiRequest);
	_serNrSysEncNR_DciFormat_0_1_CBGTI_Type_CBGTI_Optional(_buffer, _size, _lidx, &p->CBGTI);
	_serNrSysEncNR_DciFormat_0_1_PtrsDmrsAssociation_Type_PtrsDmrsAssociation_Optional(_buffer, _size, _lidx, &p->PtrsDmrsAssociation);
	_serNrSysEncNR_DciFormat_0_1_BetaOffsetIndicator_Type_BetaOffsetIndicator_Optional(_buffer, _size, _lidx, &p->BetaOffsetIndicator);
	_serNrSysEncNR_DciFormat_X_1_DmrsSequenceInit_Type_NR_DciFormat_0_1_SpecificInfo_Type_DmrsSequenceInit_Optional(_buffer, _size, _lidx, &p->DmrsSequenceInit);
	_serNrSysEncNR_DciFormat_0_1_UlschIndicator_Type_UlschIndicator_Optional(_buffer, _size, _lidx, &p->UlschIndicator);
	_serNrSysEncNR_DciFormat_0_1_ChannelAccessCPextCAPC_Type_ChannelAccessCPextCAPC_Optional(_buffer, _size, _lidx, &p->ChannelAccessCPextCAPC);
	_serNrSysEncNR_DciFormat_0_1_OpenLoopPowerControl_Type_OpenLoopPowerControl_Optional(_buffer, _size, _lidx, &p->OpenLoopPowerControl);
	_serNrSysEncNR_DciFormat_X_1_PriorityIndicator_Type_NR_DciFormat_0_1_SpecificInfo_Type_PriorityIndicator_Optional(_buffer, _size, _lidx, &p->PriorityIndicator);
	_serNrSysEncNR_DciFormat_0_1_InvalidSymbolPatternIndicator_Type_InvalidSymbolPatternIndicator_Optional(_buffer, _size, _lidx, &p->InvalidSymbolPatternIndicator);
	_serNrSysEncNR_DciFormat_X_1_MinimumApplicableSchedulingOffset_Type_NR_DciFormat_0_1_SpecificInfo_Type_MinimumApplicableSchedulingOffset_Optional(_buffer, _size, _lidx, &p->MinimumApplicableSchedulingOffset);
	_serNrSysEncNR_DciFormat_X_1_SCellDormancyIndication_Type_NR_DciFormat_0_1_SpecificInfo_Type_SCellDormancyIndication_Optional(_buffer, _size, _lidx, &p->SCellDormancyIndication);
	_serNrSysEncNR_DciFormat_0_1_SidelinkAssignmentIndex_Type_SidelinkAssignmentIndex_Optional(_buffer, _size, _lidx, &p->SidelinkAssignmentIndex);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_DciFormat_0_X_SpecificInfo_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union NR_DciFormat_0_X_SpecificInfo_Type_Value* p, enum NR_DciFormat_0_X_SpecificInfo_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_DciFormat_0_X_SpecificInfo_Type_Format_0_0) {
		_serNrSysEncNR_DciFormat_0_0_SpecificInfo_Type(_buffer, _size, _lidx, &p->Format_0_0);
		return SIDL_STATUS_OK;
	}
	if (d == NR_DciFormat_0_X_SpecificInfo_Type_Format_0_1) {
		_serNrSysEncNR_DciFormat_0_1_SpecificInfo_Type(_buffer, _size, _lidx, &p->Format_0_1);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncNR_DciFormat_0_X_SpecificInfo_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_DciFormat_0_X_SpecificInfo_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncNR_DciFormat_0_X_SpecificInfo_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_DciFormat_0_X_SpecificInfo_Type_Format_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_DciFormat_0_X_SpecificInfo_Type_Format_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncNR_DciFormat_0_X_SpecificInfo_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_DciUlInfo_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_DciUlInfo_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncNR_DciFormat_0_X_ResourceAssignment_Type_ResoureAssignment_Optional(_buffer, _size, _lidx, &p->ResoureAssignment);
	_serNrSysEncNR_DciFormat_0_X_PuschHoppingCtrl_Type_PuschHoppingCtrl_Optional(_buffer, _size, _lidx, &p->PuschHoppingCtrl);
	_serNrSysEncNR_DciCommon_TpcCommand_Type_TpcCommandPusch_Optional(_buffer, _size, _lidx, &p->TpcCommandPusch);
	_serNrSysEncNR_DciCommon_UL_SUL_Indicator_Type_UL_SUL_Indicator_Optional(_buffer, _size, _lidx, &p->UL_SUL_Indicator);
	_serNrSysEncNR_DciFormat_0_X_SpecificInfo_Type_Format_Optional(_buffer, _size, _lidx, &p->Format);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_DciUlInfo_Type_DciInfo_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_DciUlInfo_Type_DciInfo_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncNR_DciUlInfo_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_SearchSpaceUlDciAssignment_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_SearchSpaceUlDciAssignment_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncNR_AssignedBWPs_Type_NR_SearchSpaceUlDciAssignment_Type_AssignedBWPs_Optional(_buffer, _size, _lidx, &p->AssignedBWPs);
	_serNrSysEncNR_SearchSpaceType_Type_NR_SearchSpaceUlDciAssignment_Type_SearchSpaceType_Optional(_buffer, _size, _lidx, &p->SearchSpaceType);
	_serNrSysEncNR_DciUlInfo_Type_DciInfo_Optional(_buffer, _size, _lidx, &p->DciInfo);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_SearchSpaceDlDciAssignment_Type_NR_RachProcedureMsg4_Type_SearchSpaceAndDci_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_SearchSpaceDlDciAssignment_Type_NR_RachProcedureMsg4_Type_SearchSpaceAndDci_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncNR_SearchSpaceDlDciAssignment_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_ContentionResolutionId_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union NR_ContentionResolutionId_Type_Value* p, enum NR_ContentionResolutionId_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_ContentionResolutionId_Type_XorMask) {
		for (size_t i2 = 0; i2 < 48; i2++) {
			HTON_8(&_buffer[*_lidx], p->XorMask[i2], _lidx);
		}
		return SIDL_STATUS_OK;
	}
	if (d == NR_ContentionResolutionId_Type_None) {
		HTON_8(&_buffer[*_lidx], p->None, _lidx);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncNR_ContentionResolutionId_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_ContentionResolutionId_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncNR_ContentionResolutionId_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_ContentionResolutionId_Type_ContentionResolutionId_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_ContentionResolutionId_Type_ContentionResolutionId_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncNR_ContentionResolutionId_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_RachProcedureMsg4RrcMsg_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union NR_RachProcedureMsg4RrcMsg_Type_Value* p, enum NR_RachProcedureMsg4RrcMsg_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_RachProcedureMsg4RrcMsg_Type_RrcCcchMsg) {
		HTON_32(&_buffer[*_lidx], p->RrcCcchMsg.d, _lidx);
		for (size_t i2 = 0; i2 < p->RrcCcchMsg.d; i2++) {
			HTON_8(&_buffer[*_lidx], p->RrcCcchMsg.v[i2], _lidx);
		}
		return SIDL_STATUS_OK;
	}
	if (d == NR_RachProcedureMsg4RrcMsg_Type_RrcDcchMsg) {
		HTON_32(&_buffer[*_lidx], p->RrcDcchMsg.d, _lidx);
		for (size_t i2 = 0; i2 < p->RrcDcchMsg.d; i2++) {
			HTON_8(&_buffer[*_lidx], p->RrcDcchMsg.v[i2], _lidx);
		}
		return SIDL_STATUS_OK;
	}
	if (d == NR_RachProcedureMsg4RrcMsg_Type_None) {
		HTON_8(&_buffer[*_lidx], p->None, _lidx);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncNR_RachProcedureMsg4RrcMsg_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_RachProcedureMsg4RrcMsg_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncNR_RachProcedureMsg4RrcMsg_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_RachProcedureMsg4RrcMsg_Type_RrcPdu_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_RachProcedureMsg4RrcMsg_Type_RrcPdu_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncNR_RachProcedureMsg4RrcMsg_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncBool_NR_RachProcedureMsg4_Type_CrcError_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct bool_NR_RachProcedureMsg4_Type_CrcError_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_RachProcedureMsg4_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_RachProcedureMsg4_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncNR_SearchSpaceDlDciAssignment_Type_NR_RachProcedureMsg4_Type_SearchSpaceAndDci_Optional(_buffer, _size, _lidx, &p->SearchSpaceAndDci);
	_serNrSysEncNR_ContentionResolutionId_Type_ContentionResolutionId_Optional(_buffer, _size, _lidx, &p->ContentionResolutionId);
	_serNrSysEncNR_RachProcedureMsg4RrcMsg_Type_RrcPdu_Optional(_buffer, _size, _lidx, &p->RrcPdu);
	_serNrSysEncBool_NR_RachProcedureMsg4_Type_CrcError_Optional(_buffer, _size, _lidx, &p->CrcError);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_ContentionResolutionCtrl_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union NR_ContentionResolutionCtrl_Type_Value* p, enum NR_ContentionResolutionCtrl_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_ContentionResolutionCtrl_Type_None) {
		HTON_8(&_buffer[*_lidx], p->None, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == NR_ContentionResolutionCtrl_Type_CRNTI_Based) {
		_serNrSysEncNR_SearchSpaceUlDciAssignment_Type(_buffer, _size, _lidx, &p->CRNTI_Based);
		return SIDL_STATUS_OK;
	}
	if (d == NR_ContentionResolutionCtrl_Type_Msg4_Based) {
		_serNrSysEncNR_RachProcedureMsg4_Type(_buffer, _size, _lidx, &p->Msg4_Based);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncNR_ContentionResolutionCtrl_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_ContentionResolutionCtrl_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncNR_ContentionResolutionCtrl_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_ContentionResolutionCtrl_Type_ContentionResolution_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_ContentionResolutionCtrl_Type_ContentionResolution_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncNR_ContentionResolutionCtrl_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_RachProcedure_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_RachProcedure_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncNR_RandomAccessResponseConfig_Type_RandomAccessResponse_Optional(_buffer, _size, _lidx, &p->RandomAccessResponse);
	_serNrSysEncNR_ContentionResolutionCtrl_Type_ContentionResolution_Optional(_buffer, _size, _lidx, &p->ContentionResolution);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_RachProcedureList_Type_RachProcedureList_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_RachProcedureList_Type_RachProcedureList_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i1 = 0; i1 < p->v.d; i1++) {
		_serNrSysEncNR_RachProcedure_Type(_buffer, _size, _lidx, &p->v.v[i1]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_RachProcedureConfig_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_RachProcedureConfig_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncNR_RachProcedureList_Type_RachProcedureList_Optional(_buffer, _size, _lidx, &p->RachProcedureList);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_RachProcedureConfig_Type_RachProcedureConfig_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_RachProcedureConfig_Type_RachProcedureConfig_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncNR_RachProcedureConfig_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_SearchSpaceDlDciAssignment_Type_NR_DcchDtchConfigDL_Type_SearchSpaceAndDci_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_SearchSpaceDlDciAssignment_Type_NR_DcchDtchConfigDL_Type_SearchSpaceAndDci_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncNR_SearchSpaceDlDciAssignment_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_DcchDtchConfigDL_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_DcchDtchConfigDL_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncNR_SearchSpaceDlDciAssignment_Type_NR_DcchDtchConfigDL_Type_SearchSpaceAndDci_Optional(_buffer, _size, _lidx, &p->SearchSpaceAndDci);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_DcchDtchConfigDL_Type_DL_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_DcchDtchConfigDL_Type_DL_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncNR_DcchDtchConfigDL_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_SearchSpaceUlDciAssignment_Type_SearchSpaceAndDci_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_SearchSpaceUlDciAssignment_Type_SearchSpaceAndDci_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncNR_SearchSpaceUlDciAssignment_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_UplinkTimeAlignment_AutoSynch_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_UplinkTimeAlignment_AutoSynch_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->TimingAdvance, _lidx);
	HTON_16(&_buffer[*_lidx], p->TA_Period, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_UplinkTimeAlignment_Synch_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union NR_UplinkTimeAlignment_Synch_Type_Value* p, enum NR_UplinkTimeAlignment_Synch_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_UplinkTimeAlignment_Synch_Type_None) {
		HTON_8(&_buffer[*_lidx], p->None, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == NR_UplinkTimeAlignment_Synch_Type_Auto) {
		_serNrSysEncNR_UplinkTimeAlignment_AutoSynch_Type(_buffer, _size, _lidx, &p->Auto);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncNR_UplinkTimeAlignment_Synch_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_UplinkTimeAlignment_Synch_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncNR_UplinkTimeAlignment_Synch_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_UplinkTimeAlignment_Synch_Type_PUCCH_Synch_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_UplinkTimeAlignment_Synch_Type_PUCCH_Synch_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncNR_UplinkTimeAlignment_Synch_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncULGrant_Period_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union ULGrant_Period_Type_Value* p, enum ULGrant_Period_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == ULGrant_Period_Type_OnlyOnce) {
		HTON_8(&_buffer[*_lidx], p->OnlyOnce, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == ULGrant_Period_Type_Duration) {
		HTON_32(&_buffer[*_lidx], p->Duration, _lidx);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncULGrant_Period_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct ULGrant_Period_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncULGrant_Period_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncTransmissionRepetition_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union TransmissionRepetition_Type_Value* p, enum TransmissionRepetition_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == TransmissionRepetition_Type_Continuous) {
		HTON_8(&_buffer[*_lidx], p->Continuous, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == TransmissionRepetition_Type_NumOfCycles) {
		HTON_32(&_buffer[*_lidx], p->NumOfCycles, _lidx);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncTransmissionRepetition_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct TransmissionRepetition_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncTransmissionRepetition_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncPeriodicGrant_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct PeriodicGrant_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncULGrant_Period_Type(_buffer, _size, _lidx, &p->Period);
	_serNrSysEncTransmissionRepetition_Type(_buffer, _size, _lidx, &p->NoOfRepetitions);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncUL_GrantConfig_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union UL_GrantConfig_Type_Value* p, enum UL_GrantConfig_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == UL_GrantConfig_Type_OnSR_Reception) {
		HTON_8(&_buffer[*_lidx], p->OnSR_Reception, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == UL_GrantConfig_Type_Periodic) {
		_serNrSysEncPeriodicGrant_Type(_buffer, _size, _lidx, &p->Periodic);
		return SIDL_STATUS_OK;
	}
	if (d == UL_GrantConfig_Type_PeriodicOnSR_Reception) {
		_serNrSysEncPeriodicGrant_Type(_buffer, _size, _lidx, &p->PeriodicOnSR_Reception);
		return SIDL_STATUS_OK;
	}
	if (d == UL_GrantConfig_Type_None) {
		HTON_8(&_buffer[*_lidx], p->None, _lidx);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncUL_GrantConfig_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct UL_GrantConfig_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncUL_GrantConfig_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncUL_GrantConfig_Type_GrantConfig_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct UL_GrantConfig_Type_GrantConfig_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncUL_GrantConfig_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_DcchDtchConfigUL_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_DcchDtchConfigUL_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncNR_SearchSpaceUlDciAssignment_Type_SearchSpaceAndDci_Optional(_buffer, _size, _lidx, &p->SearchSpaceAndDci);
	_serNrSysEncNR_UplinkTimeAlignment_Synch_Type_PUCCH_Synch_Optional(_buffer, _size, _lidx, &p->PUCCH_Synch);
	_serNrSysEncUL_GrantConfig_Type_GrantConfig_Optional(_buffer, _size, _lidx, &p->GrantConfig);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_DcchDtchConfigUL_Type_UL_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_DcchDtchConfigUL_Type_UL_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncNR_DcchDtchConfigUL_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_DRX_Config_drx_onDurationTimer_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SQN_NR_DRX_Config_drx_onDurationTimer_Value* p, enum SQN_NR_DRX_Config_drx_onDurationTimer_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_DRX_Config_drx_onDurationTimer_subMilliSeconds) {
		HTON_8(&_buffer[*_lidx], p->subMilliSeconds, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_DRX_Config_drx_onDurationTimer_milliSeconds) {
		{
			size_t _tmp = (size_t)p->milliSeconds;
			HTON_32(&_buffer[*_lidx], _tmp, _lidx);
		}
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncSQN_NR_DRX_Config_drx_onDurationTimer(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_DRX_Config_drx_onDurationTimer* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_DRX_Config_drx_onDurationTimer_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_DRX_Config_drx_LongCycleStartOffset_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SQN_NR_DRX_Config_drx_LongCycleStartOffset_Value* p, enum SQN_NR_DRX_Config_drx_LongCycleStartOffset_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_DRX_Config_drx_LongCycleStartOffset_ms10) {
		HTON_8(&_buffer[*_lidx], p->ms10, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_DRX_Config_drx_LongCycleStartOffset_ms20) {
		HTON_8(&_buffer[*_lidx], p->ms20, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_DRX_Config_drx_LongCycleStartOffset_ms32) {
		HTON_8(&_buffer[*_lidx], p->ms32, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_DRX_Config_drx_LongCycleStartOffset_ms40) {
		HTON_8(&_buffer[*_lidx], p->ms40, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_DRX_Config_drx_LongCycleStartOffset_ms60) {
		HTON_8(&_buffer[*_lidx], p->ms60, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_DRX_Config_drx_LongCycleStartOffset_ms64) {
		HTON_8(&_buffer[*_lidx], p->ms64, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_DRX_Config_drx_LongCycleStartOffset_ms70) {
		HTON_8(&_buffer[*_lidx], p->ms70, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_DRX_Config_drx_LongCycleStartOffset_ms80) {
		HTON_8(&_buffer[*_lidx], p->ms80, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_DRX_Config_drx_LongCycleStartOffset_ms128) {
		HTON_8(&_buffer[*_lidx], p->ms128, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_DRX_Config_drx_LongCycleStartOffset_ms160) {
		HTON_8(&_buffer[*_lidx], p->ms160, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_DRX_Config_drx_LongCycleStartOffset_ms256) {
		HTON_8(&_buffer[*_lidx], p->ms256, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_DRX_Config_drx_LongCycleStartOffset_ms320) {
		HTON_16(&_buffer[*_lidx], p->ms320, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_DRX_Config_drx_LongCycleStartOffset_ms512) {
		HTON_16(&_buffer[*_lidx], p->ms512, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_DRX_Config_drx_LongCycleStartOffset_ms640) {
		HTON_16(&_buffer[*_lidx], p->ms640, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_DRX_Config_drx_LongCycleStartOffset_ms1024) {
		HTON_16(&_buffer[*_lidx], p->ms1024, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_DRX_Config_drx_LongCycleStartOffset_ms1280) {
		HTON_16(&_buffer[*_lidx], p->ms1280, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_DRX_Config_drx_LongCycleStartOffset_ms2048) {
		HTON_16(&_buffer[*_lidx], p->ms2048, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_DRX_Config_drx_LongCycleStartOffset_ms2560) {
		HTON_16(&_buffer[*_lidx], p->ms2560, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_DRX_Config_drx_LongCycleStartOffset_ms5120) {
		HTON_16(&_buffer[*_lidx], p->ms5120, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_DRX_Config_drx_LongCycleStartOffset_ms10240) {
		HTON_16(&_buffer[*_lidx], p->ms10240, _lidx);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncSQN_NR_DRX_Config_drx_LongCycleStartOffset(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_DRX_Config_drx_LongCycleStartOffset* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_DRX_Config_drx_LongCycleStartOffset_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_DRX_Config_shortDRX(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_DRX_Config_shortDRX* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->drx_ShortCycle;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	HTON_8(&_buffer[*_lidx], p->drx_ShortCycleTimer, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_DRX_Config_shortDRX_shortDRX_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_DRX_Config_shortDRX_shortDRX_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_DRX_Config_shortDRX(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_DRX_Config(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_DRX_Config* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncSQN_NR_DRX_Config_drx_onDurationTimer(_buffer, _size, _lidx, &p->drx_onDurationTimer);
	{
		size_t _tmp = (size_t)p->drx_InactivityTimer;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	HTON_8(&_buffer[*_lidx], p->drx_HARQ_RTT_TimerDL, _lidx);
	HTON_8(&_buffer[*_lidx], p->drx_HARQ_RTT_TimerUL, _lidx);
	{
		size_t _tmp = (size_t)p->drx_RetransmissionTimerDL;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	{
		size_t _tmp = (size_t)p->drx_RetransmissionTimerUL;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_DRX_Config_drx_LongCycleStartOffset(_buffer, _size, _lidx, &p->drx_LongCycleStartOffset);
	_serNrSysEncSQN_NR_DRX_Config_shortDRX_shortDRX_Optional(_buffer, _size, _lidx, &p->shortDRX);
	HTON_8(&_buffer[*_lidx], p->drx_SlotOffset, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_ASN1_DRX_Config_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union NR_ASN1_DRX_Config_Type_Value* p, enum NR_ASN1_DRX_Config_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_ASN1_DRX_Config_Type_R15) {
		_serNrSysEncSQN_NR_DRX_Config(_buffer, _size, _lidx, &p->R15);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncNR_ASN1_DRX_Config_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_ASN1_DRX_Config_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncNR_ASN1_DRX_Config_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_DrxCtrl_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union NR_DrxCtrl_Type_Value* p, enum NR_DrxCtrl_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_DrxCtrl_Type_None) {
		HTON_8(&_buffer[*_lidx], p->None, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == NR_DrxCtrl_Type_Config) {
		_serNrSysEncNR_ASN1_DRX_Config_Type(_buffer, _size, _lidx, &p->Config);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncNR_DrxCtrl_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_DrxCtrl_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncNR_DrxCtrl_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_DrxCtrl_Type_DrxCtrl_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_DrxCtrl_Type_DrxCtrl_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncNR_DrxCtrl_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_GapConfig_refServCellIndicator_e_refServCellIndicator_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_GapConfig_refServCellIndicator_e_refServCellIndicator_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_ServCellIndex_SQN_NR_GapConfig_refFR2ServCellAsyncCA_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_ServCellIndex_SQN_NR_GapConfig_refFR2ServCellAsyncCA_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_GapConfig_mgl_r16_e_mgl_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_GapConfig_mgl_r16_e_mgl_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_GapConfig(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_GapConfig* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->gapOffset, _lidx);
	{
		size_t _tmp = (size_t)p->mgl;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	{
		size_t _tmp = (size_t)p->mgrp;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	{
		size_t _tmp = (size_t)p->mgta;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_GapConfig_refServCellIndicator_e_refServCellIndicator_Optional(_buffer, _size, _lidx, &p->refServCellIndicator);
	_serNrSysEncSQN_NR_ServCellIndex_SQN_NR_GapConfig_refFR2ServCellAsyncCA_r16_Optional(_buffer, _size, _lidx, &p->refFR2ServCellAsyncCA_r16);
	_serNrSysEncSQN_NR_GapConfig_mgl_r16_e_mgl_r16_Optional(_buffer, _size, _lidx, &p->mgl_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SetupRelease_MeasGapConfig_gapFR2_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SQN_NR_SetupRelease_MeasGapConfig_gapFR2_Value* p, enum SQN_NR_SetupRelease_MeasGapConfig_gapFR2_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SetupRelease_MeasGapConfig_gapFR2_release) {
		HTON_8(&_buffer[*_lidx], p->release, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SetupRelease_MeasGapConfig_gapFR2_setup) {
		_serNrSysEncSQN_NR_GapConfig(_buffer, _size, _lidx, &p->setup);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncSQN_NR_SetupRelease_MeasGapConfig_gapFR2(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SetupRelease_MeasGapConfig_gapFR2* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_SetupRelease_MeasGapConfig_gapFR2_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SetupRelease_MeasGapConfig_gapFR2_SQN_NR_MeasGapConfig_gapFR2_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SetupRelease_MeasGapConfig_gapFR2_SQN_NR_MeasGapConfig_gapFR2_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_SetupRelease_MeasGapConfig_gapFR2(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SetupRelease_MeasGapConfig_gapFR1_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SQN_NR_SetupRelease_MeasGapConfig_gapFR1_Value* p, enum SQN_NR_SetupRelease_MeasGapConfig_gapFR1_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SetupRelease_MeasGapConfig_gapFR1_release) {
		HTON_8(&_buffer[*_lidx], p->release, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SetupRelease_MeasGapConfig_gapFR1_setup) {
		_serNrSysEncSQN_NR_GapConfig(_buffer, _size, _lidx, &p->setup);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncSQN_NR_SetupRelease_MeasGapConfig_gapFR1(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SetupRelease_MeasGapConfig_gapFR1* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_SetupRelease_MeasGapConfig_gapFR1_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SetupRelease_MeasGapConfig_gapFR1_SQN_NR_MeasGapConfig_gapFR1_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SetupRelease_MeasGapConfig_gapFR1_SQN_NR_MeasGapConfig_gapFR1_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_SetupRelease_MeasGapConfig_gapFR1(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SetupRelease_MeasGapConfig_gapUE_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SQN_NR_SetupRelease_MeasGapConfig_gapUE_Value* p, enum SQN_NR_SetupRelease_MeasGapConfig_gapUE_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SetupRelease_MeasGapConfig_gapUE_release) {
		HTON_8(&_buffer[*_lidx], p->release, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SetupRelease_MeasGapConfig_gapUE_setup) {
		_serNrSysEncSQN_NR_GapConfig(_buffer, _size, _lidx, &p->setup);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncSQN_NR_SetupRelease_MeasGapConfig_gapUE(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SetupRelease_MeasGapConfig_gapUE* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_SetupRelease_MeasGapConfig_gapUE_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SetupRelease_MeasGapConfig_gapUE_SQN_NR_MeasGapConfig_gapUE_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SetupRelease_MeasGapConfig_gapUE_SQN_NR_MeasGapConfig_gapUE_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_SetupRelease_MeasGapConfig_gapUE(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_MeasGapConfig(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_MeasGapConfig* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncSQN_NR_SetupRelease_MeasGapConfig_gapFR2_SQN_NR_MeasGapConfig_gapFR2_Optional(_buffer, _size, _lidx, &p->gapFR2);
	_serNrSysEncSQN_NR_SetupRelease_MeasGapConfig_gapFR1_SQN_NR_MeasGapConfig_gapFR1_Optional(_buffer, _size, _lidx, &p->gapFR1);
	_serNrSysEncSQN_NR_SetupRelease_MeasGapConfig_gapUE_SQN_NR_MeasGapConfig_gapUE_Optional(_buffer, _size, _lidx, &p->gapUE);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_ASN1_MeasGapConfig_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union NR_ASN1_MeasGapConfig_Type_Value* p, enum NR_ASN1_MeasGapConfig_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_ASN1_MeasGapConfig_Type_R15) {
		_serNrSysEncSQN_NR_MeasGapConfig(_buffer, _size, _lidx, &p->R15);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncNR_ASN1_MeasGapConfig_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_ASN1_MeasGapConfig_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncNR_ASN1_MeasGapConfig_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_MeasGapCtrl_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union NR_MeasGapCtrl_Type_Value* p, enum NR_MeasGapCtrl_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_MeasGapCtrl_Type_None) {
		HTON_8(&_buffer[*_lidx], p->None, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == NR_MeasGapCtrl_Type_Config) {
		_serNrSysEncNR_ASN1_MeasGapConfig_Type(_buffer, _size, _lidx, &p->Config);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncNR_MeasGapCtrl_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_MeasGapCtrl_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncNR_MeasGapCtrl_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_MeasGapCtrl_Type_MeasGapCtrl_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_MeasGapCtrl_Type_MeasGapCtrl_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncNR_MeasGapCtrl_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_DcchDtchConfig_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_DcchDtchConfig_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncNR_DcchDtchConfigDL_Type_DL_Optional(_buffer, _size, _lidx, &p->DL);
	_serNrSysEncNR_DcchDtchConfigUL_Type_UL_Optional(_buffer, _size, _lidx, &p->UL);
	_serNrSysEncNR_DrxCtrl_Type_DrxCtrl_Optional(_buffer, _size, _lidx, &p->DrxCtrl);
	_serNrSysEncNR_MeasGapCtrl_Type_MeasGapCtrl_Optional(_buffer, _size, _lidx, &p->MeasGapCtrl);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_DcchDtchConfig_Type_DcchDtchConfig_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_DcchDtchConfig_Type_DcchDtchConfig_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncNR_DcchDtchConfig_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_ServingCellIndex_Type_NR_SpCellConfig_Type_ServingCellIndex_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_ServingCellIndex_Type_NR_SpCellConfig_Type_ServingCellIndex_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_CellGroupId_CellGroupId_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_CellGroupId_CellGroupId_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_CellIdList_Type_SCellList_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_CellIdList_Type_SCellList_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i1 = 0; i1 < p->v.d; i1++) {
		{
			size_t _tmp = (size_t)p->v.v[i1];
			HTON_32(&_buffer[*_lidx], _tmp, _lidx);
		}
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SetupRelease_MAC_CellGroupConfig_drx_Config_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SQN_NR_SetupRelease_MAC_CellGroupConfig_drx_Config_Value* p, enum SQN_NR_SetupRelease_MAC_CellGroupConfig_drx_Config_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SetupRelease_MAC_CellGroupConfig_drx_Config_release) {
		HTON_8(&_buffer[*_lidx], p->release, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SetupRelease_MAC_CellGroupConfig_drx_Config_setup) {
		_serNrSysEncSQN_NR_DRX_Config(_buffer, _size, _lidx, &p->setup);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncSQN_NR_SetupRelease_MAC_CellGroupConfig_drx_Config(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SetupRelease_MAC_CellGroupConfig_drx_Config* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_SetupRelease_MAC_CellGroupConfig_drx_Config_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SetupRelease_MAC_CellGroupConfig_drx_Config_SQN_NR_MAC_CellGroupConfig_drx_Config_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SetupRelease_MAC_CellGroupConfig_drx_Config_SQN_NR_MAC_CellGroupConfig_drx_Config_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_SetupRelease_MAC_CellGroupConfig_drx_Config(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SchedulingRequestToAddMod_sr_ProhibitTimer_e_sr_ProhibitTimer_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SchedulingRequestToAddMod_sr_ProhibitTimer_e_sr_ProhibitTimer_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SchedulingRequestToAddMod(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SchedulingRequestToAddMod* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->schedulingRequestId, _lidx);
	_serNrSysEncSQN_NR_SchedulingRequestToAddMod_sr_ProhibitTimer_e_sr_ProhibitTimer_Optional(_buffer, _size, _lidx, &p->sr_ProhibitTimer);
	{
		size_t _tmp = (size_t)p->sr_TransMax;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SchedulingRequestToAddMod_SQN_NR_SchedulingRequestConfig_schedulingRequestToAddModList_DynamicOptional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SchedulingRequestToAddMod_SQN_NR_SchedulingRequestConfig_schedulingRequestToAddModList_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i1 = 0; i1 < p->v.d; i1++) {
		_serNrSysEncSQN_NR_SchedulingRequestToAddMod(_buffer, _size, _lidx, &p->v.v[i1]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SchedulingRequestId_SQN_NR_SchedulingRequestConfig_schedulingRequestToReleaseList_DynamicOptional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SchedulingRequestId_SQN_NR_SchedulingRequestConfig_schedulingRequestToReleaseList_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i1 = 0; i1 < p->v.d; i1++) {
		HTON_8(&_buffer[*_lidx], p->v.v[i1], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SchedulingRequestConfig(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SchedulingRequestConfig* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncSQN_NR_SchedulingRequestToAddMod_SQN_NR_SchedulingRequestConfig_schedulingRequestToAddModList_DynamicOptional(_buffer, _size, _lidx, &p->schedulingRequestToAddModList);
	_serNrSysEncSQN_NR_SchedulingRequestId_SQN_NR_SchedulingRequestConfig_schedulingRequestToReleaseList_DynamicOptional(_buffer, _size, _lidx, &p->schedulingRequestToReleaseList);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SchedulingRequestConfig_SQN_NR_MAC_CellGroupConfig_schedulingRequestConfig_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SchedulingRequestConfig_SQN_NR_MAC_CellGroupConfig_schedulingRequestConfig_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_SchedulingRequestConfig(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_BSR_Config_logicalChannelSR_DelayTimer_e_logicalChannelSR_DelayTimer_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_BSR_Config_logicalChannelSR_DelayTimer_e_logicalChannelSR_DelayTimer_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_BSR_Config(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_BSR_Config* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->periodicBSR_Timer;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	{
		size_t _tmp = (size_t)p->retxBSR_Timer;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_BSR_Config_logicalChannelSR_DelayTimer_e_logicalChannelSR_DelayTimer_Optional(_buffer, _size, _lidx, &p->logicalChannelSR_DelayTimer);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_BSR_Config_SQN_NR_MAC_CellGroupConfig_bsr_Config_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_BSR_Config_SQN_NR_MAC_CellGroupConfig_bsr_Config_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_BSR_Config(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_TAG_Id_SQN_NR_TAG_Config_tag_ToReleaseList_DynamicOptional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_TAG_Id_SQN_NR_TAG_Config_tag_ToReleaseList_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i1 = 0; i1 < p->v.d; i1++) {
		HTON_8(&_buffer[*_lidx], p->v.v[i1], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_TAG(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_TAG* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->tag_Id, _lidx);
	{
		size_t _tmp = (size_t)p->timeAlignmentTimer;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_TAG_SQN_NR_TAG_Config_tag_ToAddModList_DynamicOptional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_TAG_SQN_NR_TAG_Config_tag_ToAddModList_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i1 = 0; i1 < p->v.d; i1++) {
		_serNrSysEncSQN_NR_TAG(_buffer, _size, _lidx, &p->v.v[i1]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_TAG_Config(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_TAG_Config* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncSQN_NR_TAG_Id_SQN_NR_TAG_Config_tag_ToReleaseList_DynamicOptional(_buffer, _size, _lidx, &p->tag_ToReleaseList);
	_serNrSysEncSQN_NR_TAG_SQN_NR_TAG_Config_tag_ToAddModList_DynamicOptional(_buffer, _size, _lidx, &p->tag_ToAddModList);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_TAG_Config_SQN_NR_MAC_CellGroupConfig_tag_Config_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_TAG_Config_SQN_NR_MAC_CellGroupConfig_tag_Config_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_TAG_Config(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_MPE_Config_FR2_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_MPE_Config_FR2_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->mpe_ProhibitTimer_r16;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	{
		size_t _tmp = (size_t)p->mpe_Threshold_r16;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SetupRelease_PHR_Config_mpe_Reporting_FR2_r16_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SQN_NR_SetupRelease_PHR_Config_mpe_Reporting_FR2_r16_Value* p, enum SQN_NR_SetupRelease_PHR_Config_mpe_Reporting_FR2_r16_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SetupRelease_PHR_Config_mpe_Reporting_FR2_r16_release) {
		HTON_8(&_buffer[*_lidx], p->release, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SetupRelease_PHR_Config_mpe_Reporting_FR2_r16_setup) {
		_serNrSysEncSQN_NR_MPE_Config_FR2_r16(_buffer, _size, _lidx, &p->setup);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncSQN_NR_SetupRelease_PHR_Config_mpe_Reporting_FR2_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SetupRelease_PHR_Config_mpe_Reporting_FR2_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_SetupRelease_PHR_Config_mpe_Reporting_FR2_r16_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SetupRelease_PHR_Config_mpe_Reporting_FR2_r16_SQN_NR_PHR_Config_mpe_Reporting_FR2_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SetupRelease_PHR_Config_mpe_Reporting_FR2_r16_SQN_NR_PHR_Config_mpe_Reporting_FR2_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_SetupRelease_PHR_Config_mpe_Reporting_FR2_r16(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PHR_Config(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PHR_Config* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->phr_PeriodicTimer;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	{
		size_t _tmp = (size_t)p->phr_ProhibitTimer;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	{
		size_t _tmp = (size_t)p->phr_Tx_PowerFactorChange;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	HTON_8(&_buffer[*_lidx], p->multiplePHR, _lidx);
	HTON_8(&_buffer[*_lidx], p->dummy, _lidx);
	HTON_8(&_buffer[*_lidx], p->phr_Type2OtherCell, _lidx);
	{
		size_t _tmp = (size_t)p->phr_ModeOtherCG;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_SetupRelease_PHR_Config_mpe_Reporting_FR2_r16_SQN_NR_PHR_Config_mpe_Reporting_FR2_r16_Optional(_buffer, _size, _lidx, &p->mpe_Reporting_FR2_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SetupRelease_MAC_CellGroupConfig_phr_Config_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SQN_NR_SetupRelease_MAC_CellGroupConfig_phr_Config_Value* p, enum SQN_NR_SetupRelease_MAC_CellGroupConfig_phr_Config_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SetupRelease_MAC_CellGroupConfig_phr_Config_release) {
		HTON_8(&_buffer[*_lidx], p->release, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SetupRelease_MAC_CellGroupConfig_phr_Config_setup) {
		_serNrSysEncSQN_NR_PHR_Config(_buffer, _size, _lidx, &p->setup);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncSQN_NR_SetupRelease_MAC_CellGroupConfig_phr_Config(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SetupRelease_MAC_CellGroupConfig_phr_Config* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_SetupRelease_MAC_CellGroupConfig_phr_Config_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SetupRelease_MAC_CellGroupConfig_phr_Config_SQN_NR_MAC_CellGroupConfig_phr_Config_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SetupRelease_MAC_CellGroupConfig_phr_Config_SQN_NR_MAC_CellGroupConfig_phr_Config_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_SetupRelease_MAC_CellGroupConfig_phr_Config(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncBool_SQN_NR_MAC_CellGroupConfig_csi_Mask_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct bool_SQN_NR_MAC_CellGroupConfig_csi_Mask_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SetupRelease_MAC_CellGroupConfig_dataInactivityTimer_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SQN_NR_SetupRelease_MAC_CellGroupConfig_dataInactivityTimer_Value* p, enum SQN_NR_SetupRelease_MAC_CellGroupConfig_dataInactivityTimer_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SetupRelease_MAC_CellGroupConfig_dataInactivityTimer_release) {
		HTON_8(&_buffer[*_lidx], p->release, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SetupRelease_MAC_CellGroupConfig_dataInactivityTimer_setup) {
		{
			size_t _tmp = (size_t)p->setup;
			HTON_32(&_buffer[*_lidx], _tmp, _lidx);
		}
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncSQN_NR_SetupRelease_MAC_CellGroupConfig_dataInactivityTimer(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SetupRelease_MAC_CellGroupConfig_dataInactivityTimer* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_SetupRelease_MAC_CellGroupConfig_dataInactivityTimer_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SetupRelease_MAC_CellGroupConfig_dataInactivityTimer_SQN_NR_MAC_CellGroupConfig_dataInactivityTimer_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SetupRelease_MAC_CellGroupConfig_dataInactivityTimer_SQN_NR_MAC_CellGroupConfig_dataInactivityTimer_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_SetupRelease_MAC_CellGroupConfig_dataInactivityTimer(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_MAC_CellGroupConfig_usePreBSR_r16_e_usePreBSR_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_MAC_CellGroupConfig_usePreBSR_r16_e_usePreBSR_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SchedulingRequestId_SQN_NR_MAC_CellGroupConfig_schedulingRequestID_LBT_SCell_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SchedulingRequestId_SQN_NR_MAC_CellGroupConfig_schedulingRequestID_LBT_SCell_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_MAC_CellGroupConfig_lch_BasedPrioritization_r16_e_lch_BasedPrioritization_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_MAC_CellGroupConfig_lch_BasedPrioritization_r16_e_lch_BasedPrioritization_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SchedulingRequestId_SQN_NR_MAC_CellGroupConfig_schedulingRequestID_BFR_SCell_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SchedulingRequestId_SQN_NR_MAC_CellGroupConfig_schedulingRequestID_BFR_SCell_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_DRX_ConfigSecondaryGroup_drx_onDurationTimer_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SQN_NR_DRX_ConfigSecondaryGroup_drx_onDurationTimer_Value* p, enum SQN_NR_DRX_ConfigSecondaryGroup_drx_onDurationTimer_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_DRX_ConfigSecondaryGroup_drx_onDurationTimer_subMilliSeconds) {
		HTON_8(&_buffer[*_lidx], p->subMilliSeconds, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_DRX_ConfigSecondaryGroup_drx_onDurationTimer_milliSeconds) {
		{
			size_t _tmp = (size_t)p->milliSeconds;
			HTON_32(&_buffer[*_lidx], _tmp, _lidx);
		}
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncSQN_NR_DRX_ConfigSecondaryGroup_drx_onDurationTimer(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_DRX_ConfigSecondaryGroup_drx_onDurationTimer* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_DRX_ConfigSecondaryGroup_drx_onDurationTimer_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_DRX_ConfigSecondaryGroup(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_DRX_ConfigSecondaryGroup* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncSQN_NR_DRX_ConfigSecondaryGroup_drx_onDurationTimer(_buffer, _size, _lidx, &p->drx_onDurationTimer);
	{
		size_t _tmp = (size_t)p->drx_InactivityTimer;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SetupRelease_MAC_CellGroupConfig_drx_ConfigSecondaryGroup_r16_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SQN_NR_SetupRelease_MAC_CellGroupConfig_drx_ConfigSecondaryGroup_r16_Value* p, enum SQN_NR_SetupRelease_MAC_CellGroupConfig_drx_ConfigSecondaryGroup_r16_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SetupRelease_MAC_CellGroupConfig_drx_ConfigSecondaryGroup_r16_release) {
		HTON_8(&_buffer[*_lidx], p->release, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SetupRelease_MAC_CellGroupConfig_drx_ConfigSecondaryGroup_r16_setup) {
		_serNrSysEncSQN_NR_DRX_ConfigSecondaryGroup(_buffer, _size, _lidx, &p->setup);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncSQN_NR_SetupRelease_MAC_CellGroupConfig_drx_ConfigSecondaryGroup_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SetupRelease_MAC_CellGroupConfig_drx_ConfigSecondaryGroup_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_SetupRelease_MAC_CellGroupConfig_drx_ConfigSecondaryGroup_r16_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SetupRelease_MAC_CellGroupConfig_drx_ConfigSecondaryGroup_r16_SQN_NR_MAC_CellGroupConfig_drx_ConfigSecondaryGroup_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SetupRelease_MAC_CellGroupConfig_drx_ConfigSecondaryGroup_r16_SQN_NR_MAC_CellGroupConfig_drx_ConfigSecondaryGroup_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_SetupRelease_MAC_CellGroupConfig_drx_ConfigSecondaryGroup_r16(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_MAC_CellGroupConfig(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_MAC_CellGroupConfig* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncSQN_NR_SetupRelease_MAC_CellGroupConfig_drx_Config_SQN_NR_MAC_CellGroupConfig_drx_Config_Optional(_buffer, _size, _lidx, &p->drx_Config);
	_serNrSysEncSQN_NR_SchedulingRequestConfig_SQN_NR_MAC_CellGroupConfig_schedulingRequestConfig_Optional(_buffer, _size, _lidx, &p->schedulingRequestConfig);
	_serNrSysEncSQN_NR_BSR_Config_SQN_NR_MAC_CellGroupConfig_bsr_Config_Optional(_buffer, _size, _lidx, &p->bsr_Config);
	_serNrSysEncSQN_NR_TAG_Config_SQN_NR_MAC_CellGroupConfig_tag_Config_Optional(_buffer, _size, _lidx, &p->tag_Config);
	_serNrSysEncSQN_NR_SetupRelease_MAC_CellGroupConfig_phr_Config_SQN_NR_MAC_CellGroupConfig_phr_Config_Optional(_buffer, _size, _lidx, &p->phr_Config);
	HTON_8(&_buffer[*_lidx], p->skipUplinkTxDynamic, _lidx);
	_serNrSysEncBool_SQN_NR_MAC_CellGroupConfig_csi_Mask_Optional(_buffer, _size, _lidx, &p->csi_Mask);
	_serNrSysEncSQN_NR_SetupRelease_MAC_CellGroupConfig_dataInactivityTimer_SQN_NR_MAC_CellGroupConfig_dataInactivityTimer_Optional(_buffer, _size, _lidx, &p->dataInactivityTimer);
	_serNrSysEncSQN_NR_MAC_CellGroupConfig_usePreBSR_r16_e_usePreBSR_r16_Optional(_buffer, _size, _lidx, &p->usePreBSR_r16);
	_serNrSysEncSQN_NR_SchedulingRequestId_SQN_NR_MAC_CellGroupConfig_schedulingRequestID_LBT_SCell_r16_Optional(_buffer, _size, _lidx, &p->schedulingRequestID_LBT_SCell_r16);
	_serNrSysEncSQN_NR_MAC_CellGroupConfig_lch_BasedPrioritization_r16_e_lch_BasedPrioritization_r16_Optional(_buffer, _size, _lidx, &p->lch_BasedPrioritization_r16);
	_serNrSysEncSQN_NR_SchedulingRequestId_SQN_NR_MAC_CellGroupConfig_schedulingRequestID_BFR_SCell_r16_Optional(_buffer, _size, _lidx, &p->schedulingRequestID_BFR_SCell_r16);
	_serNrSysEncSQN_NR_SetupRelease_MAC_CellGroupConfig_drx_ConfigSecondaryGroup_r16_SQN_NR_MAC_CellGroupConfig_drx_ConfigSecondaryGroup_r16_Optional(_buffer, _size, _lidx, &p->drx_ConfigSecondaryGroup_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_ASN1_MAC_CellGroupConfig_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union NR_ASN1_MAC_CellGroupConfig_Type_Value* p, enum NR_ASN1_MAC_CellGroupConfig_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_ASN1_MAC_CellGroupConfig_Type_R15) {
		_serNrSysEncSQN_NR_MAC_CellGroupConfig(_buffer, _size, _lidx, &p->R15);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncNR_ASN1_MAC_CellGroupConfig_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_ASN1_MAC_CellGroupConfig_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncNR_ASN1_MAC_CellGroupConfig_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_ASN1_MAC_CellGroupConfig_Type_MAC_CellGroupConfig_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_ASN1_MAC_CellGroupConfig_Type_MAC_CellGroupConfig_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncNR_ASN1_MAC_CellGroupConfig_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PhysicalCellGroupConfig_harq_ACK_SpatialBundlingPUCCH_e_harq_ACK_SpatialBundlingPUCCH_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PhysicalCellGroupConfig_harq_ACK_SpatialBundlingPUCCH_e_harq_ACK_SpatialBundlingPUCCH_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PhysicalCellGroupConfig_harq_ACK_SpatialBundlingPUSCH_e_harq_ACK_SpatialBundlingPUSCH_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PhysicalCellGroupConfig_harq_ACK_SpatialBundlingPUSCH_e_harq_ACK_SpatialBundlingPUSCH_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_P_Max_SQN_NR_PhysicalCellGroupConfig_p_NR_FR1_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_P_Max_SQN_NR_PhysicalCellGroupConfig_p_NR_FR1_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_RNTI_Value_SQN_NR_PhysicalCellGroupConfig_tpc_SRS_RNTI_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_RNTI_Value_SQN_NR_PhysicalCellGroupConfig_tpc_SRS_RNTI_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_16(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_RNTI_Value_SQN_NR_PhysicalCellGroupConfig_tpc_PUCCH_RNTI_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_RNTI_Value_SQN_NR_PhysicalCellGroupConfig_tpc_PUCCH_RNTI_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_16(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_RNTI_Value_SQN_NR_PhysicalCellGroupConfig_tpc_PUSCH_RNTI_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_RNTI_Value_SQN_NR_PhysicalCellGroupConfig_tpc_PUSCH_RNTI_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_16(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_RNTI_Value_SQN_NR_PhysicalCellGroupConfig_sp_CSI_RNTI_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_RNTI_Value_SQN_NR_PhysicalCellGroupConfig_sp_CSI_RNTI_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_16(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SetupRelease_PhysicalCellGroupConfig_cs_RNTI_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SQN_NR_SetupRelease_PhysicalCellGroupConfig_cs_RNTI_Value* p, enum SQN_NR_SetupRelease_PhysicalCellGroupConfig_cs_RNTI_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SetupRelease_PhysicalCellGroupConfig_cs_RNTI_release) {
		HTON_8(&_buffer[*_lidx], p->release, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SetupRelease_PhysicalCellGroupConfig_cs_RNTI_setup) {
		HTON_16(&_buffer[*_lidx], p->setup, _lidx);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncSQN_NR_SetupRelease_PhysicalCellGroupConfig_cs_RNTI(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SetupRelease_PhysicalCellGroupConfig_cs_RNTI* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_SetupRelease_PhysicalCellGroupConfig_cs_RNTI_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SetupRelease_PhysicalCellGroupConfig_cs_RNTI_SQN_NR_PhysicalCellGroupConfig_cs_RNTI_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SetupRelease_PhysicalCellGroupConfig_cs_RNTI_SQN_NR_PhysicalCellGroupConfig_cs_RNTI_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_SetupRelease_PhysicalCellGroupConfig_cs_RNTI(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_RNTI_Value_SQN_NR_PhysicalCellGroupConfig_mcs_C_RNTI_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_RNTI_Value_SQN_NR_PhysicalCellGroupConfig_mcs_C_RNTI_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_16(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_P_Max_SQN_NR_PhysicalCellGroupConfig_p_UE_FR1_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_P_Max_SQN_NR_PhysicalCellGroupConfig_p_UE_FR1_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PhysicalCellGroupConfig_xScale_e_xScale_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PhysicalCellGroupConfig_xScale_e_xScale_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SetupRelease_PhysicalCellGroupConfig_pdcch_BlindDetection_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SQN_NR_SetupRelease_PhysicalCellGroupConfig_pdcch_BlindDetection_Value* p, enum SQN_NR_SetupRelease_PhysicalCellGroupConfig_pdcch_BlindDetection_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SetupRelease_PhysicalCellGroupConfig_pdcch_BlindDetection_release) {
		HTON_8(&_buffer[*_lidx], p->release, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SetupRelease_PhysicalCellGroupConfig_pdcch_BlindDetection_setup) {
		HTON_8(&_buffer[*_lidx], p->setup, _lidx);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncSQN_NR_SetupRelease_PhysicalCellGroupConfig_pdcch_BlindDetection(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SetupRelease_PhysicalCellGroupConfig_pdcch_BlindDetection* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_SetupRelease_PhysicalCellGroupConfig_pdcch_BlindDetection_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SetupRelease_PhysicalCellGroupConfig_pdcch_BlindDetection_SQN_NR_PhysicalCellGroupConfig_pdcch_BlindDetection_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SetupRelease_PhysicalCellGroupConfig_pdcch_BlindDetection_SQN_NR_PhysicalCellGroupConfig_pdcch_BlindDetection_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_SetupRelease_PhysicalCellGroupConfig_pdcch_BlindDetection(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_DCP_Config_r16_ps_WakeUp_r16_e_ps_WakeUp_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_DCP_Config_r16_ps_WakeUp_r16_e_ps_WakeUp_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_DCP_Config_r16_ps_TransmitPeriodicL1_RSRP_r16_e_ps_TransmitPeriodicL1_RSRP_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_DCP_Config_r16_ps_TransmitPeriodicL1_RSRP_r16_e_ps_TransmitPeriodicL1_RSRP_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_DCP_Config_r16_ps_TransmitOtherPeriodicCSI_r16_e_ps_TransmitOtherPeriodicCSI_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_DCP_Config_r16_ps_TransmitOtherPeriodicCSI_r16_e_ps_TransmitOtherPeriodicCSI_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_DCP_Config_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_DCP_Config_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_16(&_buffer[*_lidx], p->ps_RNTI_r16, _lidx);
	HTON_8(&_buffer[*_lidx], p->ps_Offset_r16, _lidx);
	HTON_8(&_buffer[*_lidx], p->sizeDCI_2_6_r16, _lidx);
	HTON_8(&_buffer[*_lidx], p->ps_PositionDCI_2_6_r16, _lidx);
	_serNrSysEncSQN_NR_DCP_Config_r16_ps_WakeUp_r16_e_ps_WakeUp_r16_Optional(_buffer, _size, _lidx, &p->ps_WakeUp_r16);
	_serNrSysEncSQN_NR_DCP_Config_r16_ps_TransmitPeriodicL1_RSRP_r16_e_ps_TransmitPeriodicL1_RSRP_r16_Optional(_buffer, _size, _lidx, &p->ps_TransmitPeriodicL1_RSRP_r16);
	_serNrSysEncSQN_NR_DCP_Config_r16_ps_TransmitOtherPeriodicCSI_r16_e_ps_TransmitOtherPeriodicCSI_r16_Optional(_buffer, _size, _lidx, &p->ps_TransmitOtherPeriodicCSI_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SetupRelease_PhysicalCellGroupConfig_dcp_Config_r16_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SQN_NR_SetupRelease_PhysicalCellGroupConfig_dcp_Config_r16_Value* p, enum SQN_NR_SetupRelease_PhysicalCellGroupConfig_dcp_Config_r16_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SetupRelease_PhysicalCellGroupConfig_dcp_Config_r16_release) {
		HTON_8(&_buffer[*_lidx], p->release, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SetupRelease_PhysicalCellGroupConfig_dcp_Config_r16_setup) {
		_serNrSysEncSQN_NR_DCP_Config_r16(_buffer, _size, _lidx, &p->setup);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncSQN_NR_SetupRelease_PhysicalCellGroupConfig_dcp_Config_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SetupRelease_PhysicalCellGroupConfig_dcp_Config_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_SetupRelease_PhysicalCellGroupConfig_dcp_Config_r16_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SetupRelease_PhysicalCellGroupConfig_dcp_Config_r16_SQN_NR_PhysicalCellGroupConfig_dcp_Config_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SetupRelease_PhysicalCellGroupConfig_dcp_Config_r16_SQN_NR_PhysicalCellGroupConfig_dcp_Config_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_SetupRelease_PhysicalCellGroupConfig_dcp_Config_r16(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PhysicalCellGroupConfig_harq_ACK_SpatialBundlingPUCCH_secondaryPUCCHgroup_r16_e_harq_ACK_SpatialBundlingPUCCH_secondaryPUCCHgroup_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PhysicalCellGroupConfig_harq_ACK_SpatialBundlingPUCCH_secondaryPUCCHgroup_r16_e_harq_ACK_SpatialBundlingPUCCH_secondaryPUCCHgroup_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PhysicalCellGroupConfig_harq_ACK_SpatialBundlingPUSCH_secondaryPUCCHgroup_r16_e_harq_ACK_SpatialBundlingPUSCH_secondaryPUCCHgroup_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PhysicalCellGroupConfig_harq_ACK_SpatialBundlingPUSCH_secondaryPUCCHgroup_r16_e_harq_ACK_SpatialBundlingPUSCH_secondaryPUCCHgroup_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PhysicalCellGroupConfig_pdsch_HARQ_ACK_Codebook_secondaryPUCCHgroup_r16_e_pdsch_HARQ_ACK_Codebook_secondaryPUCCHgroup_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PhysicalCellGroupConfig_pdsch_HARQ_ACK_Codebook_secondaryPUCCHgroup_r16_e_pdsch_HARQ_ACK_Codebook_secondaryPUCCHgroup_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_P_Max_SQN_NR_PhysicalCellGroupConfig_p_NR_FR2_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_P_Max_SQN_NR_PhysicalCellGroupConfig_p_NR_FR2_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_P_Max_SQN_NR_PhysicalCellGroupConfig_p_UE_FR2_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_P_Max_SQN_NR_PhysicalCellGroupConfig_p_UE_FR2_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PhysicalCellGroupConfig_nrdc_PCmode_FR1_r16_e_nrdc_PCmode_FR1_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PhysicalCellGroupConfig_nrdc_PCmode_FR1_r16_e_nrdc_PCmode_FR1_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PhysicalCellGroupConfig_nrdc_PCmode_FR2_r16_e_nrdc_PCmode_FR2_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PhysicalCellGroupConfig_nrdc_PCmode_FR2_r16_e_nrdc_PCmode_FR2_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PhysicalCellGroupConfig_pdsch_HARQ_ACK_Codebook_r16_e_pdsch_HARQ_ACK_Codebook_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PhysicalCellGroupConfig_pdsch_HARQ_ACK_Codebook_r16_e_pdsch_HARQ_ACK_Codebook_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PhysicalCellGroupConfig_nfi_TotalDAI_Included_r16_e_nfi_TotalDAI_Included_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PhysicalCellGroupConfig_nfi_TotalDAI_Included_r16_e_nfi_TotalDAI_Included_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PhysicalCellGroupConfig_ul_TotalDAI_Included_r16_e_ul_TotalDAI_Included_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PhysicalCellGroupConfig_ul_TotalDAI_Included_r16_e_ul_TotalDAI_Included_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PhysicalCellGroupConfig_pdsch_HARQ_ACK_OneShotFeedback_r16_e_pdsch_HARQ_ACK_OneShotFeedback_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PhysicalCellGroupConfig_pdsch_HARQ_ACK_OneShotFeedback_r16_e_pdsch_HARQ_ACK_OneShotFeedback_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PhysicalCellGroupConfig_pdsch_HARQ_ACK_OneShotFeedbackNDI_r16_e_pdsch_HARQ_ACK_OneShotFeedbackNDI_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PhysicalCellGroupConfig_pdsch_HARQ_ACK_OneShotFeedbackNDI_r16_e_pdsch_HARQ_ACK_OneShotFeedbackNDI_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PhysicalCellGroupConfig_pdsch_HARQ_ACK_OneShotFeedbackCBG_r16_e_pdsch_HARQ_ACK_OneShotFeedbackCBG_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PhysicalCellGroupConfig_pdsch_HARQ_ACK_OneShotFeedbackCBG_r16_e_pdsch_HARQ_ACK_OneShotFeedbackCBG_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PhysicalCellGroupConfig_downlinkAssignmentIndexDCI_0_2_r16_e_downlinkAssignmentIndexDCI_0_2_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PhysicalCellGroupConfig_downlinkAssignmentIndexDCI_0_2_r16_e_downlinkAssignmentIndexDCI_0_2_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PhysicalCellGroupConfig_downlinkAssignmentIndexDCI_1_2_r16_e_downlinkAssignmentIndexDCI_1_2_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PhysicalCellGroupConfig_downlinkAssignmentIndexDCI_1_2_r16_e_downlinkAssignmentIndexDCI_1_2_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SetupRelease_PhysicalCellGroupConfig_pdsch_HARQ_ACK_CodebookList_r16_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SQN_NR_SetupRelease_PhysicalCellGroupConfig_pdsch_HARQ_ACK_CodebookList_r16_Value* p, enum SQN_NR_SetupRelease_PhysicalCellGroupConfig_pdsch_HARQ_ACK_CodebookList_r16_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SetupRelease_PhysicalCellGroupConfig_pdsch_HARQ_ACK_CodebookList_r16_release) {
		HTON_8(&_buffer[*_lidx], p->release, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SetupRelease_PhysicalCellGroupConfig_pdsch_HARQ_ACK_CodebookList_r16_setup) {
		HTON_32(&_buffer[*_lidx], p->setup.d, _lidx);
		for (size_t i1 = 0; i1 < p->setup.d; i1++) {
			{
				size_t _tmp = (size_t)p->setup.v[i1];
				HTON_32(&_buffer[*_lidx], _tmp, _lidx);
			}
		}
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncSQN_NR_SetupRelease_PhysicalCellGroupConfig_pdsch_HARQ_ACK_CodebookList_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SetupRelease_PhysicalCellGroupConfig_pdsch_HARQ_ACK_CodebookList_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_SetupRelease_PhysicalCellGroupConfig_pdsch_HARQ_ACK_CodebookList_r16_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SetupRelease_PhysicalCellGroupConfig_pdsch_HARQ_ACK_CodebookList_r16_SQN_NR_PhysicalCellGroupConfig_pdsch_HARQ_ACK_CodebookList_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SetupRelease_PhysicalCellGroupConfig_pdsch_HARQ_ACK_CodebookList_r16_SQN_NR_PhysicalCellGroupConfig_pdsch_HARQ_ACK_CodebookList_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_SetupRelease_PhysicalCellGroupConfig_pdsch_HARQ_ACK_CodebookList_r16(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PhysicalCellGroupConfig_ackNackFeedbackMode_r16_e_ackNackFeedbackMode_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PhysicalCellGroupConfig_ackNackFeedbackMode_r16_e_ackNackFeedbackMode_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PDCCH_BlindDetectionCA_CombIndicator_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PDCCH_BlindDetectionCA_CombIndicator_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->pdcch_BlindDetectionCA1_r16, _lidx);
	HTON_8(&_buffer[*_lidx], p->pdcch_BlindDetectionCA2_r16, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SetupRelease_PhysicalCellGroupConfig_pdcch_BlindDetectionCA_CombIndicator_r16_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SQN_NR_SetupRelease_PhysicalCellGroupConfig_pdcch_BlindDetectionCA_CombIndicator_r16_Value* p, enum SQN_NR_SetupRelease_PhysicalCellGroupConfig_pdcch_BlindDetectionCA_CombIndicator_r16_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SetupRelease_PhysicalCellGroupConfig_pdcch_BlindDetectionCA_CombIndicator_r16_release) {
		HTON_8(&_buffer[*_lidx], p->release, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SetupRelease_PhysicalCellGroupConfig_pdcch_BlindDetectionCA_CombIndicator_r16_setup) {
		_serNrSysEncSQN_NR_PDCCH_BlindDetectionCA_CombIndicator_r16(_buffer, _size, _lidx, &p->setup);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncSQN_NR_SetupRelease_PhysicalCellGroupConfig_pdcch_BlindDetectionCA_CombIndicator_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SetupRelease_PhysicalCellGroupConfig_pdcch_BlindDetectionCA_CombIndicator_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_SetupRelease_PhysicalCellGroupConfig_pdcch_BlindDetectionCA_CombIndicator_r16_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SetupRelease_PhysicalCellGroupConfig_pdcch_BlindDetectionCA_CombIndicator_r16_SQN_NR_PhysicalCellGroupConfig_pdcch_BlindDetectionCA_CombIndicator_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SetupRelease_PhysicalCellGroupConfig_pdcch_BlindDetectionCA_CombIndicator_r16_SQN_NR_PhysicalCellGroupConfig_pdcch_BlindDetectionCA_CombIndicator_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_SetupRelease_PhysicalCellGroupConfig_pdcch_BlindDetectionCA_CombIndicator_r16(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SetupRelease_PhysicalCellGroupConfig_pdcch_BlindDetection2_r16_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SQN_NR_SetupRelease_PhysicalCellGroupConfig_pdcch_BlindDetection2_r16_Value* p, enum SQN_NR_SetupRelease_PhysicalCellGroupConfig_pdcch_BlindDetection2_r16_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SetupRelease_PhysicalCellGroupConfig_pdcch_BlindDetection2_r16_release) {
		HTON_8(&_buffer[*_lidx], p->release, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SetupRelease_PhysicalCellGroupConfig_pdcch_BlindDetection2_r16_setup) {
		HTON_8(&_buffer[*_lidx], p->setup, _lidx);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncSQN_NR_SetupRelease_PhysicalCellGroupConfig_pdcch_BlindDetection2_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SetupRelease_PhysicalCellGroupConfig_pdcch_BlindDetection2_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_SetupRelease_PhysicalCellGroupConfig_pdcch_BlindDetection2_r16_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SetupRelease_PhysicalCellGroupConfig_pdcch_BlindDetection2_r16_SQN_NR_PhysicalCellGroupConfig_pdcch_BlindDetection2_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SetupRelease_PhysicalCellGroupConfig_pdcch_BlindDetection2_r16_SQN_NR_PhysicalCellGroupConfig_pdcch_BlindDetection2_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_SetupRelease_PhysicalCellGroupConfig_pdcch_BlindDetection2_r16(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SetupRelease_PhysicalCellGroupConfig_pdcch_BlindDetection3_r16_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SQN_NR_SetupRelease_PhysicalCellGroupConfig_pdcch_BlindDetection3_r16_Value* p, enum SQN_NR_SetupRelease_PhysicalCellGroupConfig_pdcch_BlindDetection3_r16_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SetupRelease_PhysicalCellGroupConfig_pdcch_BlindDetection3_r16_release) {
		HTON_8(&_buffer[*_lidx], p->release, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SetupRelease_PhysicalCellGroupConfig_pdcch_BlindDetection3_r16_setup) {
		HTON_8(&_buffer[*_lidx], p->setup, _lidx);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncSQN_NR_SetupRelease_PhysicalCellGroupConfig_pdcch_BlindDetection3_r16(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SetupRelease_PhysicalCellGroupConfig_pdcch_BlindDetection3_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_SetupRelease_PhysicalCellGroupConfig_pdcch_BlindDetection3_r16_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SetupRelease_PhysicalCellGroupConfig_pdcch_BlindDetection3_r16_SQN_NR_PhysicalCellGroupConfig_pdcch_BlindDetection3_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SetupRelease_PhysicalCellGroupConfig_pdcch_BlindDetection3_r16_SQN_NR_PhysicalCellGroupConfig_pdcch_BlindDetection3_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_SetupRelease_PhysicalCellGroupConfig_pdcch_BlindDetection3_r16(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PhysicalCellGroupConfig_bdFactorR_r16_e_bdFactorR_r16_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PhysicalCellGroupConfig_bdFactorR_r16_e_bdFactorR_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PhysicalCellGroupConfig(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PhysicalCellGroupConfig* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncSQN_NR_PhysicalCellGroupConfig_harq_ACK_SpatialBundlingPUCCH_e_harq_ACK_SpatialBundlingPUCCH_Optional(_buffer, _size, _lidx, &p->harq_ACK_SpatialBundlingPUCCH);
	_serNrSysEncSQN_NR_PhysicalCellGroupConfig_harq_ACK_SpatialBundlingPUSCH_e_harq_ACK_SpatialBundlingPUSCH_Optional(_buffer, _size, _lidx, &p->harq_ACK_SpatialBundlingPUSCH);
	_serNrSysEncSQN_NR_P_Max_SQN_NR_PhysicalCellGroupConfig_p_NR_FR1_Optional(_buffer, _size, _lidx, &p->p_NR_FR1);
	{
		size_t _tmp = (size_t)p->pdsch_HARQ_ACK_Codebook;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_RNTI_Value_SQN_NR_PhysicalCellGroupConfig_tpc_SRS_RNTI_Optional(_buffer, _size, _lidx, &p->tpc_SRS_RNTI);
	_serNrSysEncSQN_NR_RNTI_Value_SQN_NR_PhysicalCellGroupConfig_tpc_PUCCH_RNTI_Optional(_buffer, _size, _lidx, &p->tpc_PUCCH_RNTI);
	_serNrSysEncSQN_NR_RNTI_Value_SQN_NR_PhysicalCellGroupConfig_tpc_PUSCH_RNTI_Optional(_buffer, _size, _lidx, &p->tpc_PUSCH_RNTI);
	_serNrSysEncSQN_NR_RNTI_Value_SQN_NR_PhysicalCellGroupConfig_sp_CSI_RNTI_Optional(_buffer, _size, _lidx, &p->sp_CSI_RNTI);
	_serNrSysEncSQN_NR_SetupRelease_PhysicalCellGroupConfig_cs_RNTI_SQN_NR_PhysicalCellGroupConfig_cs_RNTI_Optional(_buffer, _size, _lidx, &p->cs_RNTI);
	_serNrSysEncSQN_NR_RNTI_Value_SQN_NR_PhysicalCellGroupConfig_mcs_C_RNTI_Optional(_buffer, _size, _lidx, &p->mcs_C_RNTI);
	_serNrSysEncSQN_NR_P_Max_SQN_NR_PhysicalCellGroupConfig_p_UE_FR1_Optional(_buffer, _size, _lidx, &p->p_UE_FR1);
	_serNrSysEncSQN_NR_PhysicalCellGroupConfig_xScale_e_xScale_Optional(_buffer, _size, _lidx, &p->xScale);
	_serNrSysEncSQN_NR_SetupRelease_PhysicalCellGroupConfig_pdcch_BlindDetection_SQN_NR_PhysicalCellGroupConfig_pdcch_BlindDetection_Optional(_buffer, _size, _lidx, &p->pdcch_BlindDetection);
	_serNrSysEncSQN_NR_SetupRelease_PhysicalCellGroupConfig_dcp_Config_r16_SQN_NR_PhysicalCellGroupConfig_dcp_Config_r16_Optional(_buffer, _size, _lidx, &p->dcp_Config_r16);
	_serNrSysEncSQN_NR_PhysicalCellGroupConfig_harq_ACK_SpatialBundlingPUCCH_secondaryPUCCHgroup_r16_e_harq_ACK_SpatialBundlingPUCCH_secondaryPUCCHgroup_r16_Optional(_buffer, _size, _lidx, &p->harq_ACK_SpatialBundlingPUCCH_secondaryPUCCHgroup_r16);
	_serNrSysEncSQN_NR_PhysicalCellGroupConfig_harq_ACK_SpatialBundlingPUSCH_secondaryPUCCHgroup_r16_e_harq_ACK_SpatialBundlingPUSCH_secondaryPUCCHgroup_r16_Optional(_buffer, _size, _lidx, &p->harq_ACK_SpatialBundlingPUSCH_secondaryPUCCHgroup_r16);
	_serNrSysEncSQN_NR_PhysicalCellGroupConfig_pdsch_HARQ_ACK_Codebook_secondaryPUCCHgroup_r16_e_pdsch_HARQ_ACK_Codebook_secondaryPUCCHgroup_r16_Optional(_buffer, _size, _lidx, &p->pdsch_HARQ_ACK_Codebook_secondaryPUCCHgroup_r16);
	_serNrSysEncSQN_NR_P_Max_SQN_NR_PhysicalCellGroupConfig_p_NR_FR2_r16_Optional(_buffer, _size, _lidx, &p->p_NR_FR2_r16);
	_serNrSysEncSQN_NR_P_Max_SQN_NR_PhysicalCellGroupConfig_p_UE_FR2_r16_Optional(_buffer, _size, _lidx, &p->p_UE_FR2_r16);
	_serNrSysEncSQN_NR_PhysicalCellGroupConfig_nrdc_PCmode_FR1_r16_e_nrdc_PCmode_FR1_r16_Optional(_buffer, _size, _lidx, &p->nrdc_PCmode_FR1_r16);
	_serNrSysEncSQN_NR_PhysicalCellGroupConfig_nrdc_PCmode_FR2_r16_e_nrdc_PCmode_FR2_r16_Optional(_buffer, _size, _lidx, &p->nrdc_PCmode_FR2_r16);
	_serNrSysEncSQN_NR_PhysicalCellGroupConfig_pdsch_HARQ_ACK_Codebook_r16_e_pdsch_HARQ_ACK_Codebook_r16_Optional(_buffer, _size, _lidx, &p->pdsch_HARQ_ACK_Codebook_r16);
	_serNrSysEncSQN_NR_PhysicalCellGroupConfig_nfi_TotalDAI_Included_r16_e_nfi_TotalDAI_Included_r16_Optional(_buffer, _size, _lidx, &p->nfi_TotalDAI_Included_r16);
	_serNrSysEncSQN_NR_PhysicalCellGroupConfig_ul_TotalDAI_Included_r16_e_ul_TotalDAI_Included_r16_Optional(_buffer, _size, _lidx, &p->ul_TotalDAI_Included_r16);
	_serNrSysEncSQN_NR_PhysicalCellGroupConfig_pdsch_HARQ_ACK_OneShotFeedback_r16_e_pdsch_HARQ_ACK_OneShotFeedback_r16_Optional(_buffer, _size, _lidx, &p->pdsch_HARQ_ACK_OneShotFeedback_r16);
	_serNrSysEncSQN_NR_PhysicalCellGroupConfig_pdsch_HARQ_ACK_OneShotFeedbackNDI_r16_e_pdsch_HARQ_ACK_OneShotFeedbackNDI_r16_Optional(_buffer, _size, _lidx, &p->pdsch_HARQ_ACK_OneShotFeedbackNDI_r16);
	_serNrSysEncSQN_NR_PhysicalCellGroupConfig_pdsch_HARQ_ACK_OneShotFeedbackCBG_r16_e_pdsch_HARQ_ACK_OneShotFeedbackCBG_r16_Optional(_buffer, _size, _lidx, &p->pdsch_HARQ_ACK_OneShotFeedbackCBG_r16);
	_serNrSysEncSQN_NR_PhysicalCellGroupConfig_downlinkAssignmentIndexDCI_0_2_r16_e_downlinkAssignmentIndexDCI_0_2_r16_Optional(_buffer, _size, _lidx, &p->downlinkAssignmentIndexDCI_0_2_r16);
	_serNrSysEncSQN_NR_PhysicalCellGroupConfig_downlinkAssignmentIndexDCI_1_2_r16_e_downlinkAssignmentIndexDCI_1_2_r16_Optional(_buffer, _size, _lidx, &p->downlinkAssignmentIndexDCI_1_2_r16);
	_serNrSysEncSQN_NR_SetupRelease_PhysicalCellGroupConfig_pdsch_HARQ_ACK_CodebookList_r16_SQN_NR_PhysicalCellGroupConfig_pdsch_HARQ_ACK_CodebookList_r16_Optional(_buffer, _size, _lidx, &p->pdsch_HARQ_ACK_CodebookList_r16);
	_serNrSysEncSQN_NR_PhysicalCellGroupConfig_ackNackFeedbackMode_r16_e_ackNackFeedbackMode_r16_Optional(_buffer, _size, _lidx, &p->ackNackFeedbackMode_r16);
	_serNrSysEncSQN_NR_SetupRelease_PhysicalCellGroupConfig_pdcch_BlindDetectionCA_CombIndicator_r16_SQN_NR_PhysicalCellGroupConfig_pdcch_BlindDetectionCA_CombIndicator_r16_Optional(_buffer, _size, _lidx, &p->pdcch_BlindDetectionCA_CombIndicator_r16);
	_serNrSysEncSQN_NR_SetupRelease_PhysicalCellGroupConfig_pdcch_BlindDetection2_r16_SQN_NR_PhysicalCellGroupConfig_pdcch_BlindDetection2_r16_Optional(_buffer, _size, _lidx, &p->pdcch_BlindDetection2_r16);
	_serNrSysEncSQN_NR_SetupRelease_PhysicalCellGroupConfig_pdcch_BlindDetection3_r16_SQN_NR_PhysicalCellGroupConfig_pdcch_BlindDetection3_r16_Optional(_buffer, _size, _lidx, &p->pdcch_BlindDetection3_r16);
	_serNrSysEncSQN_NR_PhysicalCellGroupConfig_bdFactorR_r16_e_bdFactorR_r16_Optional(_buffer, _size, _lidx, &p->bdFactorR_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_ASN1_PhysicalCellGroupConfig_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union NR_ASN1_PhysicalCellGroupConfig_Type_Value* p, enum NR_ASN1_PhysicalCellGroupConfig_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_ASN1_PhysicalCellGroupConfig_Type_R15) {
		_serNrSysEncSQN_NR_PhysicalCellGroupConfig(_buffer, _size, _lidx, &p->R15);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncNR_ASN1_PhysicalCellGroupConfig_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_ASN1_PhysicalCellGroupConfig_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncNR_ASN1_PhysicalCellGroupConfig_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_ASN1_PhysicalCellGroupConfig_Type_PhysicalCellGroupConfig_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_ASN1_PhysicalCellGroupConfig_Type_PhysicalCellGroupConfig_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncNR_ASN1_PhysicalCellGroupConfig_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_SpCell_CellGroupConfig_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_SpCell_CellGroupConfig_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncSQN_NR_CellGroupId_CellGroupId_Optional(_buffer, _size, _lidx, &p->CellGroupId);
	_serNrSysEncNR_CellIdList_Type_SCellList_Optional(_buffer, _size, _lidx, &p->SCellList);
	_serNrSysEncNR_ASN1_MAC_CellGroupConfig_Type_MAC_CellGroupConfig_Optional(_buffer, _size, _lidx, &p->MAC_CellGroupConfig);
	_serNrSysEncNR_ASN1_PhysicalCellGroupConfig_Type_PhysicalCellGroupConfig_Optional(_buffer, _size, _lidx, &p->PhysicalCellGroupConfig);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_SpCell_CellGroupConfig_Type_CellGroupConfig_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_SpCell_CellGroupConfig_Type_CellGroupConfig_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncNR_SpCell_CellGroupConfig_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_SpCellConfig_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_SpCellConfig_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncNR_ServingCellIndex_Type_NR_SpCellConfig_Type_ServingCellIndex_Optional(_buffer, _size, _lidx, &p->ServingCellIndex);
	_serNrSysEncNR_SpCell_CellGroupConfig_Type_CellGroupConfig_Optional(_buffer, _size, _lidx, &p->CellGroupConfig);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_ServingCellIndex_Type_NR_SCellConfig_Type_ServingCellIndex_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_ServingCellIndex_Type_NR_SCellConfig_Type_ServingCellIndex_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_TAG_Id_TAG_Id_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_TAG_Id_TAG_Id_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_SCellConfig_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_SCellConfig_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncNR_ServingCellIndex_Type_NR_SCellConfig_Type_ServingCellIndex_Optional(_buffer, _size, _lidx, &p->ServingCellIndex);
	_serNrSysEncSQN_NR_TAG_Id_TAG_Id_Optional(_buffer, _size, _lidx, &p->TAG_Id);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_ServingCellConfig_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union NR_ServingCellConfig_Type_Value* p, enum NR_ServingCellConfig_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_ServingCellConfig_Type_SpCell) {
		_serNrSysEncNR_SpCellConfig_Type(_buffer, _size, _lidx, &p->SpCell);
		return SIDL_STATUS_OK;
	}
	if (d == NR_ServingCellConfig_Type_SCell) {
		_serNrSysEncNR_SCellConfig_Type(_buffer, _size, _lidx, &p->SCell);
		return SIDL_STATUS_OK;
	}
	if (d == NR_ServingCellConfig_Type_None) {
		HTON_8(&_buffer[*_lidx], p->None, _lidx);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncNR_ServingCellConfig_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_ServingCellConfig_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncNR_ServingCellConfig_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_ServingCellConfig_Type_ServingCellConfig_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_ServingCellConfig_Type_ServingCellConfig_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncNR_ServingCellConfig_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_CellConfigInfo_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_CellConfigInfo_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncNR_SS_StaticCellResourceConfig_Type_StaticResourceConfig_Optional(_buffer, _size, _lidx, &p->StaticResourceConfig);
	_serNrSysEncNR_CellConfigCommon_Type_CellConfigCommon_Optional(_buffer, _size, _lidx, &p->CellConfigCommon);
	_serNrSysEncNR_CellConfigPhysicalLayer_Type_PhysicalLayer_Optional(_buffer, _size, _lidx, &p->PhysicalLayer);
	_serNrSysEncNR_BcchConfig_Type_BcchConfig_Optional(_buffer, _size, _lidx, &p->BcchConfig);
	_serNrSysEncNR_PcchConfig_Type_PcchConfig_Optional(_buffer, _size, _lidx, &p->PcchConfig);
	_serNrSysEncNR_RachProcedureConfig_Type_RachProcedureConfig_Optional(_buffer, _size, _lidx, &p->RachProcedureConfig);
	_serNrSysEncNR_DcchDtchConfig_Type_DcchDtchConfig_Optional(_buffer, _size, _lidx, &p->DcchDtchConfig);
	_serNrSysEncNR_ServingCellConfig_Type_ServingCellConfig_Optional(_buffer, _size, _lidx, &p->ServingCellConfig);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_CellConfigRequest_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union NR_CellConfigRequest_Type_Value* p, enum NR_CellConfigRequest_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_CellConfigRequest_Type_AddOrReconfigure) {
		_serNrSysEncNR_CellConfigInfo_Type(_buffer, _size, _lidx, &p->AddOrReconfigure);
		return SIDL_STATUS_OK;
	}
	if (d == NR_CellConfigRequest_Type_Release) {
		HTON_8(&_buffer[*_lidx], p->Release, _lidx);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncNR_CellConfigRequest_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_CellConfigRequest_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncNR_CellConfigRequest_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_Attenuation_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_Attenuation_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncNR_Attenuation_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncTimingInfo_Type_NR_TimingInfo_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct TimingInfo_Type_NR_TimingInfo_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncTimingInfo_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_CellAttenuationConfig_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_CellAttenuationConfig_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->CellId;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncNR_Attenuation_Type(_buffer, _size, _lidx, &p->Attenuation);
	_serNrSysEncTimingInfo_Type_NR_TimingInfo_Optional(_buffer, _size, _lidx, &p->TimingInfo);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSDAP_Header_Type_Sdap_HeaderDL_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SDAP_Header_Type_Sdap_HeaderDL_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncQFI_List_Type_MappedQoS_Flows_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct QFI_List_Type_MappedQoS_Flows_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		HTON_32(&_buffer[*_lidx], p->v.v[i2], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSdapConfig_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SdapConfig_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_32(&_buffer[*_lidx], p->Pdu_SessionId, _lidx);
	_serNrSysEncSDAP_Header_Type_Sdap_HeaderDL_Optional(_buffer, _size, _lidx, &p->Sdap_HeaderDL);
	_serNrSysEncQFI_List_Type_MappedQoS_Flows_Optional(_buffer, _size, _lidx, &p->MappedQoS_Flows);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSdapTransparentMode_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SdapTransparentMode_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->Sdap_HeaderUL;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSdapConfigInfo_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SdapConfigInfo_Type_Value* p, enum SdapConfigInfo_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SdapConfigInfo_Type_SdapConfig) {
		_serNrSysEncSdapConfig_Type(_buffer, _size, _lidx, &p->SdapConfig);
		return SIDL_STATUS_OK;
	}
	if (d == SdapConfigInfo_Type_TransparentMode) {
		_serNrSysEncSdapTransparentMode_Type(_buffer, _size, _lidx, &p->TransparentMode);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncSdapConfigInfo_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SdapConfigInfo_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSdapConfigInfo_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSDAP_Configuration_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SDAP_Configuration_Type_Value* p, enum SDAP_Configuration_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SDAP_Configuration_Type_None) {
		HTON_8(&_buffer[*_lidx], p->None, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SDAP_Configuration_Type_Config) {
		_serNrSysEncSdapConfigInfo_Type(_buffer, _size, _lidx, &p->Config);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncSDAP_Configuration_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SDAP_Configuration_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSDAP_Configuration_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSDAP_Configuration_Type_Sdap_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SDAP_Configuration_Type_Sdap_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSDAP_Configuration_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_PDCP_DRB_HeaderCompression_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union NR_PDCP_DRB_HeaderCompression_Type_Value* p, enum NR_PDCP_DRB_HeaderCompression_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_PDCP_DRB_HeaderCompression_Type_None) {
		HTON_8(&_buffer[*_lidx], p->None, _lidx);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncNR_PDCP_DRB_HeaderCompression_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_PDCP_DRB_HeaderCompression_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncNR_PDCP_DRB_HeaderCompression_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_PDCP_DRB_Config_Parameters_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_PDCP_DRB_Config_Parameters_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->SN_SizeUL;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	{
		size_t _tmp = (size_t)p->SN_SizeDL;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncNR_PDCP_DRB_HeaderCompression_Type(_buffer, _size, _lidx, &p->HeaderCompression);
	HTON_8(&_buffer[*_lidx], p->IntegrityProtectionEnabled, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_PDCP_RB_Config_Parameters_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union NR_PDCP_RB_Config_Parameters_Type_Value* p, enum NR_PDCP_RB_Config_Parameters_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_PDCP_RB_Config_Parameters_Type_Srb) {
		HTON_8(&_buffer[*_lidx], p->Srb, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == NR_PDCP_RB_Config_Parameters_Type_Drb) {
		_serNrSysEncNR_PDCP_DRB_Config_Parameters_Type(_buffer, _size, _lidx, &p->Drb);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncNR_PDCP_RB_Config_Parameters_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_PDCP_RB_Config_Parameters_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncNR_PDCP_RB_Config_Parameters_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_PDCP_Config_Parameters_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_PDCP_Config_Parameters_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncNR_PDCP_RB_Config_Parameters_Type(_buffer, _size, _lidx, &p->Rb);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_PDCP_TransparentMode(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_PDCP_TransparentMode* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->SN_Size;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_PDCP_RbConfig_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union NR_PDCP_RbConfig_Type_Value* p, enum NR_PDCP_RbConfig_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_PDCP_RbConfig_Type_Params) {
		_serNrSysEncNR_PDCP_Config_Parameters_Type(_buffer, _size, _lidx, &p->Params);
		return SIDL_STATUS_OK;
	}
	if (d == NR_PDCP_RbConfig_Type_TransparentMode) {
		_serNrSysEncNR_PDCP_TransparentMode(_buffer, _size, _lidx, &p->TransparentMode);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncNR_PDCP_RbConfig_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_PDCP_RbConfig_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncNR_PDCP_RbConfig_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_PDCP_RbConfig_Type_RbConfig_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_PDCP_RbConfig_Type_RbConfig_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncNR_PDCP_RbConfig_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncRlcBearerRouting_Type_LinkToOtherCellGroup_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct RlcBearerRouting_Type_LinkToOtherCellGroup_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncRlcBearerRouting_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_PDCP_RBTerminating_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_PDCP_RBTerminating_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncNR_PDCP_RbConfig_Type_RbConfig_Optional(_buffer, _size, _lidx, &p->RbConfig);
	_serNrSysEncRlcBearerRouting_Type_LinkToOtherCellGroup_Optional(_buffer, _size, _lidx, &p->LinkToOtherCellGroup);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_PDCP_Proxy_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_PDCP_Proxy_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncRlcBearerRouting_Type(_buffer, _size, _lidx, &p->LinkToOtherNode);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_PDCP_Configuration_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union NR_PDCP_Configuration_Type_Value* p, enum NR_PDCP_Configuration_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_PDCP_Configuration_Type_None) {
		HTON_8(&_buffer[*_lidx], p->None, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == NR_PDCP_Configuration_Type_RBTerminating) {
		_serNrSysEncNR_PDCP_RBTerminating_Type(_buffer, _size, _lidx, &p->RBTerminating);
		return SIDL_STATUS_OK;
	}
	if (d == NR_PDCP_Configuration_Type_Proxy) {
		_serNrSysEncNR_PDCP_Proxy_Type(_buffer, _size, _lidx, &p->Proxy);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncNR_PDCP_Configuration_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_PDCP_Configuration_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncNR_PDCP_Configuration_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_PDCP_Configuration_Type_Pdcp_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_PDCP_Configuration_Type_Pdcp_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncNR_PDCP_Configuration_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SN_FieldLengthAM_e_SQN_NR_UL_AM_RLC_sn_FieldLength_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SN_FieldLengthAM_e_SQN_NR_UL_AM_RLC_sn_FieldLength_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_UL_AM_RLC(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_UL_AM_RLC* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncSQN_NR_SN_FieldLengthAM_e_SQN_NR_UL_AM_RLC_sn_FieldLength_Optional(_buffer, _size, _lidx, &p->sn_FieldLength);
	{
		size_t _tmp = (size_t)p->t_PollRetransmit;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	{
		size_t _tmp = (size_t)p->pollPDU;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	{
		size_t _tmp = (size_t)p->pollByte;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	{
		size_t _tmp = (size_t)p->maxRetxThreshold;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_ASN1_UL_AM_RLC_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union NR_ASN1_UL_AM_RLC_Type_Value* p, enum NR_ASN1_UL_AM_RLC_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_ASN1_UL_AM_RLC_Type_R15) {
		_serNrSysEncSQN_NR_UL_AM_RLC(_buffer, _size, _lidx, &p->R15);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncNR_ASN1_UL_AM_RLC_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_ASN1_UL_AM_RLC_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncNR_ASN1_UL_AM_RLC_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_ASN1_UL_AM_RLC_Type_Tx_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_ASN1_UL_AM_RLC_Type_Tx_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncNR_ASN1_UL_AM_RLC_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SN_FieldLengthAM_e_SQN_NR_DL_AM_RLC_sn_FieldLength_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SN_FieldLengthAM_e_SQN_NR_DL_AM_RLC_sn_FieldLength_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_DL_AM_RLC(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_DL_AM_RLC* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncSQN_NR_SN_FieldLengthAM_e_SQN_NR_DL_AM_RLC_sn_FieldLength_Optional(_buffer, _size, _lidx, &p->sn_FieldLength);
	{
		size_t _tmp = (size_t)p->t_Reassembly;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	{
		size_t _tmp = (size_t)p->t_StatusProhibit;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_ASN1_DL_AM_RLC_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union NR_ASN1_DL_AM_RLC_Type_Value* p, enum NR_ASN1_DL_AM_RLC_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_ASN1_DL_AM_RLC_Type_R15) {
		_serNrSysEncSQN_NR_DL_AM_RLC(_buffer, _size, _lidx, &p->R15);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncNR_ASN1_DL_AM_RLC_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_ASN1_DL_AM_RLC_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncNR_ASN1_DL_AM_RLC_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_ASN1_DL_AM_RLC_Type_Rx_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_ASN1_DL_AM_RLC_Type_Rx_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncNR_ASN1_DL_AM_RLC_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_SS_RLC_AM_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_SS_RLC_AM_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncNR_ASN1_UL_AM_RLC_Type_Tx_Optional(_buffer, _size, _lidx, &p->Tx);
	_serNrSysEncNR_ASN1_DL_AM_RLC_Type_Rx_Optional(_buffer, _size, _lidx, &p->Rx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SN_FieldLengthUM_e_SQN_NR_UL_UM_RLC_sn_FieldLength_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SN_FieldLengthUM_e_SQN_NR_UL_UM_RLC_sn_FieldLength_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_UL_UM_RLC(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_UL_UM_RLC* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncSQN_NR_SN_FieldLengthUM_e_SQN_NR_UL_UM_RLC_sn_FieldLength_Optional(_buffer, _size, _lidx, &p->sn_FieldLength);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_ASN1_UL_UM_RLC_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union NR_ASN1_UL_UM_RLC_Type_Value* p, enum NR_ASN1_UL_UM_RLC_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_ASN1_UL_UM_RLC_Type_R15) {
		_serNrSysEncSQN_NR_UL_UM_RLC(_buffer, _size, _lidx, &p->R15);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncNR_ASN1_UL_UM_RLC_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_ASN1_UL_UM_RLC_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncNR_ASN1_UL_UM_RLC_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_ASN1_UL_UM_RLC_Type_Tx_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_ASN1_UL_UM_RLC_Type_Tx_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncNR_ASN1_UL_UM_RLC_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_SN_FieldLengthUM_e_SQN_NR_DL_UM_RLC_sn_FieldLength_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_SN_FieldLengthUM_e_SQN_NR_DL_UM_RLC_sn_FieldLength_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_DL_UM_RLC(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_DL_UM_RLC* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncSQN_NR_SN_FieldLengthUM_e_SQN_NR_DL_UM_RLC_sn_FieldLength_Optional(_buffer, _size, _lidx, &p->sn_FieldLength);
	{
		size_t _tmp = (size_t)p->t_Reassembly;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_ASN1_DL_UM_RLC_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union NR_ASN1_DL_UM_RLC_Type_Value* p, enum NR_ASN1_DL_UM_RLC_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_ASN1_DL_UM_RLC_Type_R15) {
		_serNrSysEncSQN_NR_DL_UM_RLC(_buffer, _size, _lidx, &p->R15);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncNR_ASN1_DL_UM_RLC_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_ASN1_DL_UM_RLC_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncNR_ASN1_DL_UM_RLC_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_ASN1_DL_UM_RLC_Type_Rx_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_ASN1_DL_UM_RLC_Type_Rx_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncNR_ASN1_DL_UM_RLC_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_SS_RLC_UM_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_SS_RLC_UM_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncNR_ASN1_UL_UM_RLC_Type_Tx_Optional(_buffer, _size, _lidx, &p->Tx);
	_serNrSysEncNR_ASN1_DL_UM_RLC_Type_Rx_Optional(_buffer, _size, _lidx, &p->Rx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_RLC_RbConfig_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union NR_RLC_RbConfig_Type_Value* p, enum NR_RLC_RbConfig_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_RLC_RbConfig_Type_AM) {
		_serNrSysEncNR_SS_RLC_AM_Type(_buffer, _size, _lidx, &p->AM);
		return SIDL_STATUS_OK;
	}
	if (d == NR_RLC_RbConfig_Type_UM) {
		_serNrSysEncNR_SS_RLC_UM_Type(_buffer, _size, _lidx, &p->UM);
		return SIDL_STATUS_OK;
	}
	if (d == NR_RLC_RbConfig_Type_TM) {
		HTON_8(&_buffer[*_lidx], p->TM, _lidx);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncNR_RLC_RbConfig_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_RLC_RbConfig_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncNR_RLC_RbConfig_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_RLC_RbConfig_Type_Rb_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_RLC_RbConfig_Type_Rb_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncNR_RLC_RbConfig_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_RLC_TransparentMode_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union NR_RLC_TransparentMode_Value* p, enum NR_RLC_TransparentMode_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_RLC_TransparentMode_Umd) {
		{
			size_t _tmp = (size_t)p->Umd;
			HTON_32(&_buffer[*_lidx], _tmp, _lidx);
		}
		return SIDL_STATUS_OK;
	}
	if (d == NR_RLC_TransparentMode_Amd) {
		{
			size_t _tmp = (size_t)p->Amd;
			HTON_32(&_buffer[*_lidx], _tmp, _lidx);
		}
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncNR_RLC_TransparentMode(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_RLC_TransparentMode* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncNR_RLC_TransparentMode_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_RLC_TestModeInfo_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union NR_RLC_TestModeInfo_Type_Value* p, enum NR_RLC_TestModeInfo_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_RLC_TestModeInfo_Type_AckProhibit) {
		{
			size_t _tmp = (size_t)p->AckProhibit;
			HTON_32(&_buffer[*_lidx], _tmp, _lidx);
		}
		return SIDL_STATUS_OK;
	}
	if (d == NR_RLC_TestModeInfo_Type_NotACK_NextRLC_PDU) {
		{
			size_t _tmp = (size_t)p->NotACK_NextRLC_PDU;
			HTON_32(&_buffer[*_lidx], _tmp, _lidx);
		}
		return SIDL_STATUS_OK;
	}
	if (d == NR_RLC_TestModeInfo_Type_TransparentMode) {
		_serNrSysEncNR_RLC_TransparentMode(_buffer, _size, _lidx, &p->TransparentMode);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncNR_RLC_TestModeInfo_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_RLC_TestModeInfo_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncNR_RLC_TestModeInfo_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_RLC_TestModeConfig_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union NR_RLC_TestModeConfig_Type_Value* p, enum NR_RLC_TestModeConfig_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_RLC_TestModeConfig_Type_None) {
		HTON_8(&_buffer[*_lidx], p->None, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == NR_RLC_TestModeConfig_Type_Info) {
		_serNrSysEncNR_RLC_TestModeInfo_Type(_buffer, _size, _lidx, &p->Info);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncNR_RLC_TestModeConfig_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_RLC_TestModeConfig_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncNR_RLC_TestModeConfig_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_RLC_TestModeConfig_Type_TestMode_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_RLC_TestModeConfig_Type_TestMode_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncNR_RLC_TestModeConfig_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_RLC_Configuration_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_RLC_Configuration_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncNR_RLC_RbConfig_Type_Rb_Optional(_buffer, _size, _lidx, &p->Rb);
	_serNrSysEncNR_RLC_TestModeConfig_Type_TestMode_Optional(_buffer, _size, _lidx, &p->TestMode);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_RLC_Configuration_Type_Rlc_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_RLC_Configuration_Type_Rlc_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncNR_RLC_Configuration_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_LogicalChannelId_Type_LogicalChannelId_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_LogicalChannelId_Type_LogicalChannelId_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_MAC_LogicalChannelConfig_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_MAC_LogicalChannelConfig_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_32(&_buffer[*_lidx], p->Priority, _lidx);
	{
		size_t _tmp = (size_t)p->PrioritizedBitRate;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_MAC_LogicalChannelConfig_Type_LogicalChannel_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_MAC_LogicalChannelConfig_Type_LogicalChannel_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncNR_MAC_LogicalChannelConfig_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_MAC_Test_DLLogChID_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_MAC_Test_DLLogChID_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_32(&_buffer[*_lidx], p->LogChId, _lidx);
	HTON_8(&_buffer[*_lidx], p->ConfigLchId, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_MAC_TestModeInfo_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_MAC_TestModeInfo_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncNR_MAC_Test_DLLogChID_Type(_buffer, _size, _lidx, &p->DiffLogChId);
	{
		size_t _tmp = (size_t)p->No_HeaderManipulation;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_MAC_TestModeConfig_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union NR_MAC_TestModeConfig_Type_Value* p, enum NR_MAC_TestModeConfig_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_MAC_TestModeConfig_Type_None) {
		HTON_8(&_buffer[*_lidx], p->None, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == NR_MAC_TestModeConfig_Type_Info) {
		_serNrSysEncNR_MAC_TestModeInfo_Type(_buffer, _size, _lidx, &p->Info);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncNR_MAC_TestModeConfig_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_MAC_TestModeConfig_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncNR_MAC_TestModeConfig_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_MAC_TestModeConfig_Type_TestMode_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_MAC_TestModeConfig_Type_TestMode_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncNR_MAC_TestModeConfig_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_MAC_Configuration_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_MAC_Configuration_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncNR_MAC_LogicalChannelConfig_Type_LogicalChannel_Optional(_buffer, _size, _lidx, &p->LogicalChannel);
	_serNrSysEncNR_MAC_TestModeConfig_Type_TestMode_Optional(_buffer, _size, _lidx, &p->TestMode);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_MAC_Configuration_Type_Mac_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_MAC_Configuration_Type_Mac_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncNR_MAC_Configuration_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncBool_NR_RlcBearerConfigInfo_Type_DiscardULData_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct bool_NR_RlcBearerConfigInfo_Type_DiscardULData_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_8(&_buffer[*_lidx], p->v, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_RlcBearerConfigInfo_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_RlcBearerConfigInfo_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncNR_RLC_Configuration_Type_Rlc_Optional(_buffer, _size, _lidx, &p->Rlc);
	_serNrSysEncNR_LogicalChannelId_Type_LogicalChannelId_Optional(_buffer, _size, _lidx, &p->LogicalChannelId);
	_serNrSysEncNR_MAC_Configuration_Type_Mac_Optional(_buffer, _size, _lidx, &p->Mac);
	_serNrSysEncBool_NR_RlcBearerConfigInfo_Type_DiscardULData_Optional(_buffer, _size, _lidx, &p->DiscardULData);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_RlcBearerConfig_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union NR_RlcBearerConfig_Type_Value* p, enum NR_RlcBearerConfig_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_RlcBearerConfig_Type_Config) {
		_serNrSysEncNR_RlcBearerConfigInfo_Type(_buffer, _size, _lidx, &p->Config);
		return SIDL_STATUS_OK;
	}
	if (d == NR_RlcBearerConfig_Type_None) {
		HTON_8(&_buffer[*_lidx], p->None, _lidx);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncNR_RlcBearerConfig_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_RlcBearerConfig_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncNR_RlcBearerConfig_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_RlcBearerConfig_Type_RlcBearer_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_RlcBearerConfig_Type_RlcBearer_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncNR_RlcBearerConfig_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_RadioBearerConfigInfo_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_RadioBearerConfigInfo_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncSDAP_Configuration_Type_Sdap_Optional(_buffer, _size, _lidx, &p->Sdap);
	_serNrSysEncNR_PDCP_Configuration_Type_Pdcp_Optional(_buffer, _size, _lidx, &p->Pdcp);
	_serNrSysEncNR_RlcBearerConfig_Type_RlcBearer_Optional(_buffer, _size, _lidx, &p->RlcBearer);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_RadioBearerConfig_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union NR_RadioBearerConfig_Type_Value* p, enum NR_RadioBearerConfig_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_RadioBearerConfig_Type_AddOrReconfigure) {
		_serNrSysEncNR_RadioBearerConfigInfo_Type(_buffer, _size, _lidx, &p->AddOrReconfigure);
		return SIDL_STATUS_OK;
	}
	if (d == NR_RadioBearerConfig_Type_Release) {
		HTON_8(&_buffer[*_lidx], p->Release, _lidx);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncNR_RadioBearerConfig_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_RadioBearerConfig_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncNR_RadioBearerConfig_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_RadioBearer_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_RadioBearer_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncNR_RadioBearerId_Type(_buffer, _size, _lidx, &p->Id);
	_serNrSysEncNR_RadioBearerConfig_Type(_buffer, _size, _lidx, &p->Config);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncB128_Key_Type_KUPint_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct B128_Key_Type_KUPint_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	for (size_t i1 = 0; i1 < 128; i1++) {
		HTON_8(&_buffer[*_lidx], p->v[i1], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_PdcpSQN_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_PdcpSQN_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->Format;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	HTON_32(&_buffer[*_lidx], p->Value, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_PDCP_ActTime_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union NR_PDCP_ActTime_Type_Value* p, enum NR_PDCP_ActTime_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_PDCP_ActTime_Type_None) {
		HTON_8(&_buffer[*_lidx], p->None, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == NR_PDCP_ActTime_Type_SQN) {
		_serNrSysEncNR_PdcpSQN_Type(_buffer, _size, _lidx, &p->SQN);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncNR_PDCP_ActTime_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_PDCP_ActTime_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncNR_PDCP_ActTime_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_SecurityActTime_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_SecurityActTime_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncNR_RadioBearerId_Type(_buffer, _size, _lidx, &p->RadioBearerId);
	_serNrSysEncNR_PDCP_ActTime_Type(_buffer, _size, _lidx, &p->UL);
	_serNrSysEncNR_PDCP_ActTime_Type(_buffer, _size, _lidx, &p->DL);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_SecurityActTimeList_Type_ActTimeList_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_SecurityActTimeList_Type_ActTimeList_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i1 = 0; i1 < p->v.d; i1++) {
		_serNrSysEncNR_SecurityActTime_Type(_buffer, _size, _lidx, &p->v.v[i1]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_AS_IntegrityInfo_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_AS_IntegrityInfo_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->Algorithm;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	for (size_t i1 = 0; i1 < 128; i1++) {
		HTON_8(&_buffer[*_lidx], p->KRRCint[i1], _lidx);
	}
	_serNrSysEncB128_Key_Type_KUPint_Optional(_buffer, _size, _lidx, &p->KUPint);
	_serNrSysEncNR_SecurityActTimeList_Type_ActTimeList_Optional(_buffer, _size, _lidx, &p->ActTimeList);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_AS_IntegrityInfo_Type_Integrity_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_AS_IntegrityInfo_Type_Integrity_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncNR_AS_IntegrityInfo_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_AS_CipheringInfo_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_AS_CipheringInfo_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->Algorithm;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	for (size_t i1 = 0; i1 < 128; i1++) {
		HTON_8(&_buffer[*_lidx], p->KRRCenc[i1], _lidx);
	}
	for (size_t i1 = 0; i1 < 128; i1++) {
		HTON_8(&_buffer[*_lidx], p->KUPenc[i1], _lidx);
	}
	HTON_32(&_buffer[*_lidx], p->ActTimeList.d, _lidx);
	for (size_t i1 = 0; i1 < p->ActTimeList.d; i1++) {
		_serNrSysEncNR_SecurityActTime_Type(_buffer, _size, _lidx, &p->ActTimeList.v[i1]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_AS_CipheringInfo_Type_Ciphering_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_AS_CipheringInfo_Type_Ciphering_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncNR_AS_CipheringInfo_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_AS_SecStartRestart_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_AS_SecStartRestart_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncNR_AS_IntegrityInfo_Type_Integrity_Optional(_buffer, _size, _lidx, &p->Integrity);
	_serNrSysEncNR_AS_CipheringInfo_Type_Ciphering_Optional(_buffer, _size, _lidx, &p->Ciphering);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_AS_Security_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union NR_AS_Security_Type_Value* p, enum NR_AS_Security_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_AS_Security_Type_StartRestart) {
		_serNrSysEncNR_AS_SecStartRestart_Type(_buffer, _size, _lidx, &p->StartRestart);
		return SIDL_STATUS_OK;
	}
	if (d == NR_AS_Security_Type_Release) {
		HTON_8(&_buffer[*_lidx], p->Release, _lidx);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncNR_AS_Security_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_AS_Security_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncNR_AS_Security_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_PdcpCountGetReq_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union NR_PdcpCountGetReq_Type_Value* p, enum NR_PdcpCountGetReq_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_PdcpCountGetReq_Type_AllRBs) {
		HTON_8(&_buffer[*_lidx], p->AllRBs, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == NR_PdcpCountGetReq_Type_SingleRB) {
		_serNrSysEncNR_RadioBearerId_Type(_buffer, _size, _lidx, &p->SingleRB);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncNR_PdcpCountGetReq_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_PdcpCountGetReq_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncNR_PdcpCountGetReq_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_PdcpCount_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_PdcpCount_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->Format;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	for (size_t i2 = 0; i2 < 32; i2++) {
		HTON_8(&_buffer[*_lidx], p->Value[i2], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_PdcpCount_Type_UL_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_PdcpCount_Type_UL_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncNR_PdcpCount_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_PdcpCount_Type_DL_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_PdcpCount_Type_DL_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncNR_PdcpCount_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_PdcpCountInfo_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_PdcpCountInfo_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncNR_RadioBearerId_Type(_buffer, _size, _lidx, &p->RadioBearerId);
	_serNrSysEncNR_PdcpCount_Type_UL_Optional(_buffer, _size, _lidx, &p->UL);
	_serNrSysEncNR_PdcpCount_Type_DL_Optional(_buffer, _size, _lidx, &p->DL);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_PDCP_CountReq_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union NR_PDCP_CountReq_Type_Value* p, enum NR_PDCP_CountReq_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_PDCP_CountReq_Type_Get) {
		_serNrSysEncNR_PdcpCountGetReq_Type(_buffer, _size, _lidx, &p->Get);
		return SIDL_STATUS_OK;
	}
	if (d == NR_PDCP_CountReq_Type_Set) {
		HTON_32(&_buffer[*_lidx], p->Set.d, _lidx);
		for (size_t i1 = 0; i1 < p->Set.d; i1++) {
			_serNrSysEncNR_PdcpCountInfo_Type(_buffer, _size, _lidx, &p->Set.v[i1]);
		}
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncNR_PDCP_CountReq_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_PDCP_CountReq_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncNR_PDCP_CountReq_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PagingUE_Identity_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SQN_NR_PagingUE_Identity_Value* p, enum SQN_NR_PagingUE_Identity_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_PagingUE_Identity_ng_5G_S_TMSI) {
		for (size_t i2 = 0; i2 < 48; i2++) {
			HTON_8(&_buffer[*_lidx], p->ng_5G_S_TMSI[i2], _lidx);
		}
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_PagingUE_Identity_fullI_RNTI) {
		for (size_t i2 = 0; i2 < 40; i2++) {
			HTON_8(&_buffer[*_lidx], p->fullI_RNTI[i2], _lidx);
		}
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncSQN_NR_PagingUE_Identity(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PagingUE_Identity* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_PagingUE_Identity_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PagingRecord_accessType_e_accessType_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PagingRecord_accessType_e_accessType_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp = (size_t)p->v;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PagingRecord(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PagingRecord* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncSQN_NR_PagingUE_Identity(_buffer, _size, _lidx, &p->ue_Identity);
	_serNrSysEncSQN_NR_PagingRecord_accessType_e_accessType_Optional(_buffer, _size, _lidx, &p->accessType);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PagingRecordList_SQN_NR_Paging_pagingRecordList_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PagingRecordList_SQN_NR_Paging_pagingRecordList_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i1 = 0; i1 < p->v.d; i1++) {
		_serNrSysEncSQN_NR_PagingRecord(_buffer, _size, _lidx, &p->v.v[i1]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncOCTET_STRING_SQN_NR_Paging_lateNonCriticalExtension_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct OCTET_STRING_SQN_NR_Paging_lateNonCriticalExtension_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i1 = 0; i1 < p->v.d; i1++) {
		HTON_8(&_buffer[*_lidx], p->v.v[i1], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_Paging_nonCriticalExtension(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_Paging_nonCriticalExtension* p)
{
	(void)_size; // TODO: generate boundaries checking

	(void)_buffer;
	(void)_size;
	(void)_lidx;
	(void)p;

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_Paging_nonCriticalExtension_nonCriticalExtension_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_Paging_nonCriticalExtension_nonCriticalExtension_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncSQN_NR_Paging_nonCriticalExtension(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_Paging(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_Paging* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncSQN_NR_PagingRecordList_SQN_NR_Paging_pagingRecordList_Optional(_buffer, _size, _lidx, &p->pagingRecordList);
	_serNrSysEncOCTET_STRING_SQN_NR_Paging_lateNonCriticalExtension_Optional(_buffer, _size, _lidx, &p->lateNonCriticalExtension);
	_serNrSysEncSQN_NR_Paging_nonCriticalExtension_nonCriticalExtension_Optional(_buffer, _size, _lidx, &p->nonCriticalExtension);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PCCH_MessageType_c1_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SQN_NR_PCCH_MessageType_c1_Value* p, enum SQN_NR_PCCH_MessageType_c1_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_PCCH_MessageType_c1_paging) {
		_serNrSysEncSQN_NR_Paging(_buffer, _size, _lidx, &p->paging);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_PCCH_MessageType_c1_spare1) {
		HTON_8(&_buffer[*_lidx], p->spare1, _lidx);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncSQN_NR_PCCH_MessageType_c1(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PCCH_MessageType_c1* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_PCCH_MessageType_c1_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PCCH_MessageType_messageClassExtension(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PCCH_MessageType_messageClassExtension* p)
{
	(void)_size; // TODO: generate boundaries checking

	(void)_buffer;
	(void)_size;
	(void)_lidx;
	(void)p;

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PCCH_MessageType_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union SQN_NR_PCCH_MessageType_Value* p, enum SQN_NR_PCCH_MessageType_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_PCCH_MessageType_c1) {
		_serNrSysEncSQN_NR_PCCH_MessageType_c1(_buffer, _size, _lidx, &p->c1);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_PCCH_MessageType_messageClassExtension) {
		_serNrSysEncSQN_NR_PCCH_MessageType_messageClassExtension(_buffer, _size, _lidx, &p->messageClassExtension);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncSQN_NR_PCCH_MessageType(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PCCH_MessageType* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncSQN_NR_PCCH_MessageType_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncSQN_NR_PCCH_Message(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct SQN_NR_PCCH_Message* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncSQN_NR_PCCH_MessageType(_buffer, _size, _lidx, &p->message);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_SlotOffsetList_Type_SlotOffsetList_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_SlotOffsetList_Type_SlotOffsetList_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	HTON_32(&_buffer[*_lidx], p->v.d, _lidx);
	for (size_t i1 = 0; i1 < p->v.d; i1++) {
		HTON_32(&_buffer[*_lidx], p->v.v[i1], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_PagingTrigger_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_PagingTrigger_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncSQN_NR_PCCH_Message(_buffer, _size, _lidx, &p->Paging);
	_serNrSysEncNR_SlotOffsetList_Type_SlotOffsetList_Optional(_buffer, _size, _lidx, &p->SlotOffsetList);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_ASN1_ARFCN_ValueNR_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union NR_ASN1_ARFCN_ValueNR_Type_Value* p, enum NR_ASN1_ARFCN_ValueNR_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_ASN1_ARFCN_ValueNR_Type_R15) {
		HTON_32(&_buffer[*_lidx], p->R15, _lidx);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncNR_ASN1_ARFCN_ValueNR_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_ASN1_ARFCN_ValueNR_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncNR_ASN1_ARFCN_ValueNR_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_ASN1_ARFCN_ValueNR_Type_Ssb_NRf1_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_ASN1_ARFCN_ValueNR_Type_Ssb_NRf1_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncNR_ASN1_ARFCN_ValueNR_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_ASN1_ARFCN_ValueNR_Type_Ssb_NRf2_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_ASN1_ARFCN_ValueNR_Type_Ssb_NRf2_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncNR_ASN1_ARFCN_ValueNR_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_ASN1_ARFCN_ValueNR_Type_Ssb_NRf3_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_ASN1_ARFCN_ValueNR_Type_Ssb_NRf3_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncNR_ASN1_ARFCN_ValueNR_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_ASN1_ARFCN_ValueNR_Type_Ssb_NRf4_Optional(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_ASN1_ARFCN_ValueNR_Type_Ssb_NRf4_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_8(&_buffer[*_lidx], p->d, _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysEncNR_ASN1_ARFCN_ValueNR_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncBand_SsbInfo_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct Band_SsbInfo_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_16(&_buffer[*_lidx], p->DeltaBand, _lidx);
	_serNrSysEncNR_ASN1_ARFCN_ValueNR_Type_Ssb_NRf1_Optional(_buffer, _size, _lidx, &p->Ssb_NRf1);
	_serNrSysEncNR_ASN1_ARFCN_ValueNR_Type_Ssb_NRf2_Optional(_buffer, _size, _lidx, &p->Ssb_NRf2);
	_serNrSysEncNR_ASN1_ARFCN_ValueNR_Type_Ssb_NRf3_Optional(_buffer, _size, _lidx, &p->Ssb_NRf3);
	_serNrSysEncNR_ASN1_ARFCN_ValueNR_Type_Ssb_NRf4_Optional(_buffer, _size, _lidx, &p->Ssb_NRf4);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_Band_SsbForDelta_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_Band_SsbForDelta_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncBand_SsbInfo_Type(_buffer, _size, _lidx, &p->DeltaPrimary);
	_serNrSysEncBand_SsbInfo_Type(_buffer, _size, _lidx, &p->DeltaSecondary);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_SystemRequest_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union NR_SystemRequest_Type_Value* p, enum NR_SystemRequest_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_SystemRequest_Type_Cell) {
		_serNrSysEncNR_CellConfigRequest_Type(_buffer, _size, _lidx, &p->Cell);
		return SIDL_STATUS_OK;
	}
	if (d == NR_SystemRequest_Type_CellAttenuationList) {
		HTON_32(&_buffer[*_lidx], p->CellAttenuationList.d, _lidx);
		for (size_t i1 = 0; i1 < p->CellAttenuationList.d; i1++) {
			_serNrSysEncNR_CellAttenuationConfig_Type(_buffer, _size, _lidx, &p->CellAttenuationList.v[i1]);
		}
		return SIDL_STATUS_OK;
	}
	if (d == NR_SystemRequest_Type_RadioBearerList) {
		HTON_32(&_buffer[*_lidx], p->RadioBearerList.d, _lidx);
		for (size_t i1 = 0; i1 < p->RadioBearerList.d; i1++) {
			_serNrSysEncNR_RadioBearer_Type(_buffer, _size, _lidx, &p->RadioBearerList.v[i1]);
		}
		return SIDL_STATUS_OK;
	}
	if (d == NR_SystemRequest_Type_EnquireTiming) {
		HTON_8(&_buffer[*_lidx], p->EnquireTiming, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == NR_SystemRequest_Type_AS_Security) {
		_serNrSysEncNR_AS_Security_Type(_buffer, _size, _lidx, &p->AS_Security);
		return SIDL_STATUS_OK;
	}
	if (d == NR_SystemRequest_Type_PdcpCount) {
		_serNrSysEncNR_PDCP_CountReq_Type(_buffer, _size, _lidx, &p->PdcpCount);
		return SIDL_STATUS_OK;
	}
	if (d == NR_SystemRequest_Type_Paging) {
		_serNrSysEncNR_PagingTrigger_Type(_buffer, _size, _lidx, &p->Paging);
		return SIDL_STATUS_OK;
	}
	if (d == NR_SystemRequest_Type_DeltaValues) {
		_serNrSysEncNR_Band_SsbForDelta_Type(_buffer, _size, _lidx, &p->DeltaValues);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncNR_SystemRequest_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_SystemRequest_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncNR_SystemRequest_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_SYSTEM_CTRL_REQ(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_SYSTEM_CTRL_REQ* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncNR_ReqAspCommonPart_Type(_buffer, _size, _lidx, &p->Common);
	_serNrSysEncNR_SystemRequest_Type(_buffer, _size, _lidx, &p->Request);

	return SIDL_STATUS_OK;
}

int serNrSysProcessEncClt(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_SYSTEM_CTRL_REQ* FromSS)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncNR_SYSTEM_CTRL_REQ(_buffer, _size, _lidx, FromSS);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_RadioBearerId_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union NR_RadioBearerId_Type_Value* p, enum NR_RadioBearerId_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_RadioBearerId_Type_Srb) {
		NTOH_8(p->Srb, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == NR_RadioBearerId_Type_Drb) {
		NTOH_8(p->Drb, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecNR_RadioBearerId_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_RadioBearerId_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum NR_RadioBearerId_Type_Sel)_tmp;
	}
	_serNrSysDecNR_RadioBearerId_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecQosFlow_Identification_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct QosFlow_Identification_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_32(p->PDU_SessionId, &_buffer[*_lidx], _lidx);
	NTOH_32(p->QFI, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_RoutingInfo_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union NR_RoutingInfo_Type_Value* p, enum NR_RoutingInfo_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_RoutingInfo_Type_None) {
		NTOH_8(p->None, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == NR_RoutingInfo_Type_RadioBearerId) {
		_serNrSysDecNR_RadioBearerId_Type(_buffer, _size, _lidx, &p->RadioBearerId);
		return SIDL_STATUS_OK;
	}
	if (d == NR_RoutingInfo_Type_QosFlow) {
		_serNrSysDecQosFlow_Identification_Type(_buffer, _size, _lidx, &p->QosFlow);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecNR_RoutingInfo_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_RoutingInfo_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum NR_RoutingInfo_Type_Sel)_tmp;
	}
	_serNrSysDecNR_RoutingInfo_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecRlcBearerRouting_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union RlcBearerRouting_Type_Value* p, enum RlcBearerRouting_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == RlcBearerRouting_Type_EUTRA) {
		{
			size_t _tmp;
			NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
			p->EUTRA = (EUTRA_CellId_Type)_tmp;
		}
		return SIDL_STATUS_OK;
	}
	if (d == RlcBearerRouting_Type_NR) {
		{
			size_t _tmp;
			NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
			p->NR = (NR_CellId_Type)_tmp;
		}
		return SIDL_STATUS_OK;
	}
	if (d == RlcBearerRouting_Type_None) {
		NTOH_8(p->None, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecRlcBearerRouting_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct RlcBearerRouting_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum RlcBearerRouting_Type_Sel)_tmp;
	}
	_serNrSysDecRlcBearerRouting_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSystemFrameNumberInfo_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union SystemFrameNumberInfo_Type_Value* p, enum SystemFrameNumberInfo_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SystemFrameNumberInfo_Type_Number) {
		NTOH_16(p->Number, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SystemFrameNumberInfo_Type_Any) {
		NTOH_8(p->Any, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecSystemFrameNumberInfo_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SystemFrameNumberInfo_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SystemFrameNumberInfo_Type_Sel)_tmp;
	}
	_serNrSysDecSystemFrameNumberInfo_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSubFrameInfo_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union SubFrameInfo_Type_Value* p, enum SubFrameInfo_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SubFrameInfo_Type_Number) {
		NTOH_8(p->Number, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SubFrameInfo_Type_Any) {
		NTOH_8(p->Any, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecSubFrameInfo_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SubFrameInfo_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SubFrameInfo_Type_Sel)_tmp;
	}
	_serNrSysDecSubFrameInfo_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecHyperSystemFrameNumberInfo_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, HyperSystemFrameNumberInfo_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SystemFrameNumberInfo_Type_Sel)_tmp;
	}
	_serNrSysDecSystemFrameNumberInfo_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSlotOffset_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union SlotOffset_Type_Value* p, enum SlotOffset_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SlotOffset_Type_Numerology0) {
		NTOH_8(p->Numerology0, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SlotOffset_Type_Numerology1) {
		NTOH_8(p->Numerology1, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SlotOffset_Type_Numerology2) {
		NTOH_8(p->Numerology2, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SlotOffset_Type_Numerology3) {
		NTOH_8(p->Numerology3, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SlotOffset_Type_Numerology4) {
		NTOH_8(p->Numerology4, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecSlotOffset_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SlotOffset_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SlotOffset_Type_Sel)_tmp;
	}
	_serNrSysDecSlotOffset_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSlotTimingInfo_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union SlotTimingInfo_Type_Value* p, enum SlotTimingInfo_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SlotTimingInfo_Type_SlotOffset) {
		_serNrSysDecSlotOffset_Type(_buffer, _size, _lidx, &p->SlotOffset);
		return SIDL_STATUS_OK;
	}
	if (d == SlotTimingInfo_Type_FirstSlot) {
		NTOH_8(p->FirstSlot, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SlotTimingInfo_Type_Any) {
		NTOH_8(p->Any, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecSlotTimingInfo_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SlotTimingInfo_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SlotTimingInfo_Type_Sel)_tmp;
	}
	_serNrSysDecSlotTimingInfo_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSubFrameTiming_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SubFrameTiming_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecSystemFrameNumberInfo_Type(_buffer, _size, _lidx, &p->SFN);
	_serNrSysDecSubFrameInfo_Type(_buffer, _size, _lidx, &p->Subframe);
	_serNrSysDecHyperSystemFrameNumberInfo_Type(_buffer, _size, _lidx, &p->HSFN);
	_serNrSysDecSlotTimingInfo_Type(_buffer, _size, _lidx, &p->Slot);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecTimingInfo_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union TimingInfo_Type_Value* p, enum TimingInfo_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == TimingInfo_Type_SubFrame) {
		_serNrSysDecSubFrameTiming_Type(_buffer, _size, _lidx, &p->SubFrame);
		return SIDL_STATUS_OK;
	}
	if (d == TimingInfo_Type_Now) {
		NTOH_8(p->Now, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == TimingInfo_Type_None) {
		NTOH_8(p->None, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecTimingInfo_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct TimingInfo_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum TimingInfo_Type_Sel)_tmp;
	}
	_serNrSysDecTimingInfo_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecReqAspControlInfo_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct ReqAspControlInfo_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->CnfFlag, &_buffer[*_lidx], _lidx);
	NTOH_8(p->FollowOnFlag, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_ReqAspCommonPart_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_ReqAspCommonPart_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->CellId = (NR_CellId_Type)_tmp;
	}
	_serNrSysDecNR_RoutingInfo_Type(_buffer, _size, _lidx, &p->RoutingInfo);
	_serNrSysDecRlcBearerRouting_Type(_buffer, _size, _lidx, &p->RlcBearerRouting);
	_serNrSysDecTimingInfo_Type(_buffer, _size, _lidx, &p->TimingInfo);
	_serNrSysDecReqAspControlInfo_Type(_buffer, _size, _lidx, &p->ControlInfo);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_SS_StaticCellResourceConfig_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_SS_StaticCellResourceConfig_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->CellCapability = (NR_CellCapability_Type)_tmp;
	}
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->CarrierAggregation = (NR_CellInitialCAConfig_Type)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_SS_StaticCellResourceConfig_Type_StaticResourceConfig_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_SS_StaticCellResourceConfig_Type_StaticResourceConfig_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecNR_SS_StaticCellResourceConfig_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecRNTI_Value_Type_C_RNTI_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct RNTI_Value_Type_C_RNTI_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_16(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecUint8_t_TcOffset_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct uint8_t_TcOffset_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecCellTimingInfo_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CellTimingInfo_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecUint8_t_TcOffset_Optional(_buffer, _size, _lidx, &p->TcOffset);
	NTOH_32(p->Tcell, &_buffer[*_lidx], _lidx);
	NTOH_16(p->SfnOffset, &_buffer[*_lidx], _lidx);
	NTOH_16(p->HsfnOffset, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecCellTimingInfo_Type_CellTimingInfo_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct CellTimingInfo_Type_CellTimingInfo_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecCellTimingInfo_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_Attenuation_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union NR_Attenuation_Type_Value* p, enum NR_Attenuation_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_Attenuation_Type_Value) {
		NTOH_8(p->Value, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == NR_Attenuation_Type_Off) {
		NTOH_8(p->Off, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecNR_InitialAttenuation_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, NR_InitialAttenuation_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum NR_Attenuation_Type_Sel)_tmp;
	}
	_serNrSysDecNR_Attenuation_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_InitialCellPower_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_InitialCellPower_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_32(p->MaxReferencePower, &_buffer[*_lidx], _lidx);
	_serNrSysDecNR_InitialAttenuation_Type(_buffer, _size, _lidx, &p->Attenuation);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_InitialCellPower_Type_InitialCellPower_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_InitialCellPower_Type_InitialCellPower_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecNR_InitialCellPower_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_CellConfigCommon_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_CellConfigCommon_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecRNTI_Value_Type_C_RNTI_Optional(_buffer, _size, _lidx, &p->C_RNTI);
	_serNrSysDecCellTimingInfo_Type_CellTimingInfo_Optional(_buffer, _size, _lidx, &p->CellTimingInfo);
	_serNrSysDecNR_InitialCellPower_Type_InitialCellPower_Optional(_buffer, _size, _lidx, &p->InitialCellPower);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_CellConfigCommon_Type_CellConfigCommon_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_CellConfigCommon_Type_CellConfigCommon_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecNR_CellConfigCommon_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PhysCellId_PhysicalCellId_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_PhysCellId_PhysicalCellId_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_16(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_FDD_Info_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_FDD_Info_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	(void)_buffer;
	(void)_size;
	(void)_lidx;
	(void)p;

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_TDD_UL_DL_Pattern_dl_UL_TransmissionPeriodicity_v1530_e_dl_UL_TransmissionPeriodicity_v1530_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_TDD_UL_DL_Pattern_dl_UL_TransmissionPeriodicity_v1530_e_dl_UL_TransmissionPeriodicity_v1530_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_TDD_UL_DL_Pattern_dl_UL_TransmissionPeriodicity_v1530_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_TDD_UL_DL_Pattern(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_TDD_UL_DL_Pattern* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->dl_UL_TransmissionPeriodicity = (SQN_NR_TDD_UL_DL_Pattern_dl_UL_TransmissionPeriodicity_e)_tmp;
	}
	NTOH_16(p->nrofDownlinkSlots, &_buffer[*_lidx], _lidx);
	NTOH_8(p->nrofDownlinkSymbols, &_buffer[*_lidx], _lidx);
	NTOH_16(p->nrofUplinkSlots, &_buffer[*_lidx], _lidx);
	NTOH_8(p->nrofUplinkSymbols, &_buffer[*_lidx], _lidx);
	_serNrSysDecSQN_NR_TDD_UL_DL_Pattern_dl_UL_TransmissionPeriodicity_v1530_e_dl_UL_TransmissionPeriodicity_v1530_Optional(_buffer, _size, _lidx, &p->dl_UL_TransmissionPeriodicity_v1530);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_TDD_UL_DL_Pattern_SQN_NR_TDD_UL_DL_ConfigCommon_pattern2_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_TDD_UL_DL_Pattern_SQN_NR_TDD_UL_DL_ConfigCommon_pattern2_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_TDD_UL_DL_Pattern(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_TDD_UL_DL_ConfigCommon(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_TDD_UL_DL_ConfigCommon* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->referenceSubcarrierSpacing = (SQN_NR_SubcarrierSpacing_e)_tmp;
	}
	_serNrSysDecSQN_NR_TDD_UL_DL_Pattern(_buffer, _size, _lidx, &p->pattern1);
	_serNrSysDecSQN_NR_TDD_UL_DL_Pattern_SQN_NR_TDD_UL_DL_ConfigCommon_pattern2_Optional(_buffer, _size, _lidx, &p->pattern2);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_ASN1_TDD_UL_DL_ConfigCommon_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union NR_ASN1_TDD_UL_DL_ConfigCommon_Type_Value* p, enum NR_ASN1_TDD_UL_DL_ConfigCommon_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_ASN1_TDD_UL_DL_ConfigCommon_Type_R15) {
		_serNrSysDecSQN_NR_TDD_UL_DL_ConfigCommon(_buffer, _size, _lidx, &p->R15);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecNR_ASN1_TDD_UL_DL_ConfigCommon_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_ASN1_TDD_UL_DL_ConfigCommon_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum NR_ASN1_TDD_UL_DL_ConfigCommon_Type_Sel)_tmp;
	}
	_serNrSysDecNR_ASN1_TDD_UL_DL_ConfigCommon_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_ASN1_TDD_UL_DL_ConfigCommon_Type_Common_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_ASN1_TDD_UL_DL_ConfigCommon_Type_Common_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecNR_ASN1_TDD_UL_DL_ConfigCommon_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecUint8_t_SQN_NR_TDD_UL_DL_SlotConfig_symbols_explicit__nrofDownlinkSymbols_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct uint8_t_SQN_NR_TDD_UL_DL_SlotConfig_symbols_explicit__nrofDownlinkSymbols_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecUint8_t_SQN_NR_TDD_UL_DL_SlotConfig_symbols_explicit__nrofUplinkSymbols_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct uint8_t_SQN_NR_TDD_UL_DL_SlotConfig_symbols_explicit__nrofUplinkSymbols_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_TDD_UL_DL_SlotConfig_symbols_explicit_(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_TDD_UL_DL_SlotConfig_symbols_explicit_* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecUint8_t_SQN_NR_TDD_UL_DL_SlotConfig_symbols_explicit__nrofDownlinkSymbols_Optional(_buffer, _size, _lidx, &p->nrofDownlinkSymbols);
	_serNrSysDecUint8_t_SQN_NR_TDD_UL_DL_SlotConfig_symbols_explicit__nrofUplinkSymbols_Optional(_buffer, _size, _lidx, &p->nrofUplinkSymbols);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_TDD_UL_DL_SlotConfig_symbols_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union SQN_NR_TDD_UL_DL_SlotConfig_symbols_Value* p, enum SQN_NR_TDD_UL_DL_SlotConfig_symbols_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_TDD_UL_DL_SlotConfig_symbols_allDownlink) {
		NTOH_8(p->allDownlink, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_TDD_UL_DL_SlotConfig_symbols_allUplink) {
		NTOH_8(p->allUplink, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_TDD_UL_DL_SlotConfig_symbols_explicit_) {
		_serNrSysDecSQN_NR_TDD_UL_DL_SlotConfig_symbols_explicit_(_buffer, _size, _lidx, &p->explicit_);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecSQN_NR_TDD_UL_DL_SlotConfig_symbols(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_TDD_UL_DL_SlotConfig_symbols* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SQN_NR_TDD_UL_DL_SlotConfig_symbols_Sel)_tmp;
	}
	_serNrSysDecSQN_NR_TDD_UL_DL_SlotConfig_symbols_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_TDD_UL_DL_SlotConfig(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_TDD_UL_DL_SlotConfig* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_16(p->slotIndex, &_buffer[*_lidx], _lidx);
	_serNrSysDecSQN_NR_TDD_UL_DL_SlotConfig_symbols(_buffer, _size, _lidx, &p->symbols);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_ASN1_TDD_UL_DL_SlotConfig_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union NR_ASN1_TDD_UL_DL_SlotConfig_Type_Value* p, enum NR_ASN1_TDD_UL_DL_SlotConfig_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_ASN1_TDD_UL_DL_SlotConfig_Type_R15) {
		_serNrSysDecSQN_NR_TDD_UL_DL_SlotConfig(_buffer, _size, _lidx, &p->R15);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecNR_ASN1_TDD_UL_DL_SlotConfig_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_ASN1_TDD_UL_DL_SlotConfig_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum NR_ASN1_TDD_UL_DL_SlotConfig_Type_Sel)_tmp;
	}
	_serNrSysDecNR_ASN1_TDD_UL_DL_SlotConfig_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_TDD_UL_DL_SlotConfigList_Type_Dedicated_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_TDD_UL_DL_SlotConfigList_Type_Dedicated_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = (struct NR_ASN1_TDD_UL_DL_SlotConfig_Type*)serMalloc(_mem, p->v.d * sizeof(struct NR_ASN1_TDD_UL_DL_SlotConfig_Type));
	for (size_t i1 = 0; i1 < p->v.d; i1++) {
		_serNrSysDecNR_ASN1_TDD_UL_DL_SlotConfig_Type(_buffer, _size, _lidx, &p->v.v[i1]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_TDD_Config_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_TDD_Config_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecNR_ASN1_TDD_UL_DL_ConfigCommon_Type_Common_Optional(_buffer, _size, _lidx, &p->Common);
	_serNrSysDecNR_TDD_UL_DL_SlotConfigList_Type_Dedicated_Optional(_buffer, _size, _lidx, _mem, &p->Dedicated);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_TDD_Info_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union NR_TDD_Info_Type_Value* p, enum NR_TDD_Info_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_TDD_Info_Type_Config) {
		_serNrSysDecNR_TDD_Config_Type(_buffer, _size, _lidx, _mem, &p->Config);
		return SIDL_STATUS_OK;
	}
	if (d == NR_TDD_Info_Type_FullFlexible) {
		NTOH_8(p->FullFlexible, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecNR_TDD_Info_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_TDD_Info_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum NR_TDD_Info_Type_Sel)_tmp;
	}
	_serNrSysDecNR_TDD_Info_Type_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_DuplexMode_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union NR_DuplexMode_Type_Value* p, enum NR_DuplexMode_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_DuplexMode_Type_FDD) {
		_serNrSysDecNR_FDD_Info_Type(_buffer, _size, _lidx, &p->FDD);
		return SIDL_STATUS_OK;
	}
	if (d == NR_DuplexMode_Type_TDD) {
		_serNrSysDecNR_TDD_Info_Type(_buffer, _size, _lidx, _mem, &p->TDD);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecNR_DuplexMode_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_DuplexMode_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum NR_DuplexMode_Type_Sel)_tmp;
	}
	_serNrSysDecNR_DuplexMode_Type_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_DuplexMode_Type_DuplexMode_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_DuplexMode_Type_DuplexMode_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecNR_DuplexMode_Type(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_CellConfigPhysicalLayerCommon_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_CellConfigPhysicalLayerCommon_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecSQN_NR_PhysCellId_PhysicalCellId_Optional(_buffer, _size, _lidx, &p->PhysicalCellId);
	_serNrSysDecNR_DuplexMode_Type_DuplexMode_Optional(_buffer, _size, _lidx, _mem, &p->DuplexMode);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_CellConfigPhysicalLayerCommon_Type_Common_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_CellConfigPhysicalLayerCommon_Type_Common_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecNR_CellConfigPhysicalLayerCommon_Type(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_ARFCN_ValueNR_SQN_NR_FrequencyInfoDL_absoluteFrequencySSB_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_ARFCN_ValueNR_SQN_NR_FrequencyInfoDL_absoluteFrequencySSB_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecUint16_t_SQN_NR_SCS_SpecificCarrier_txDirectCurrentLocation_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct uint16_t_SQN_NR_SCS_SpecificCarrier_txDirectCurrentLocation_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_16(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SCS_SpecificCarrier(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SCS_SpecificCarrier* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_16(p->offsetToCarrier, &_buffer[*_lidx], _lidx);
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->subcarrierSpacing = (SQN_NR_SubcarrierSpacing_e)_tmp;
	}
	NTOH_16(p->carrierBandwidth, &_buffer[*_lidx], _lidx);
	_serNrSysDecUint16_t_SQN_NR_SCS_SpecificCarrier_txDirectCurrentLocation_Optional(_buffer, _size, _lidx, &p->txDirectCurrentLocation);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_FrequencyInfoDL(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_FrequencyInfoDL* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecSQN_NR_ARFCN_ValueNR_SQN_NR_FrequencyInfoDL_absoluteFrequencySSB_Optional(_buffer, _size, _lidx, &p->absoluteFrequencySSB);
	NTOH_32(p->frequencyBandList.d, &_buffer[*_lidx], _lidx);
	p->frequencyBandList.v = (SQN_NR_FreqBandIndicatorNR*)serMalloc(_mem, p->frequencyBandList.d * sizeof(SQN_NR_FreqBandIndicatorNR));
	for (size_t i1 = 0; i1 < p->frequencyBandList.d; i1++) {
		NTOH_16(p->frequencyBandList.v[i1], &_buffer[*_lidx], _lidx);
	}
	NTOH_32(p->absoluteFrequencyPointA, &_buffer[*_lidx], _lidx);
	NTOH_32(p->scs_SpecificCarrierList.d, &_buffer[*_lidx], _lidx);
	p->scs_SpecificCarrierList.v = (struct SQN_NR_SCS_SpecificCarrier*)serMalloc(_mem, p->scs_SpecificCarrierList.d * sizeof(struct SQN_NR_SCS_SpecificCarrier));
	for (size_t i1 = 0; i1 < p->scs_SpecificCarrierList.d; i1++) {
		_serNrSysDecSQN_NR_SCS_SpecificCarrier(_buffer, _size, _lidx, &p->scs_SpecificCarrierList.v[i1]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_ASN1_FrequencyInfoDL_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union NR_ASN1_FrequencyInfoDL_Type_Value* p, enum NR_ASN1_FrequencyInfoDL_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_ASN1_FrequencyInfoDL_Type_R15) {
		_serNrSysDecSQN_NR_FrequencyInfoDL(_buffer, _size, _lidx, _mem, &p->R15);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecNR_ASN1_FrequencyInfoDL_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_ASN1_FrequencyInfoDL_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum NR_ASN1_FrequencyInfoDL_Type_Sel)_tmp;
	}
	_serNrSysDecNR_ASN1_FrequencyInfoDL_Type_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_ASN1_FrequencyInfoDL_Type_FrequencyInfoDL_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_ASN1_FrequencyInfoDL_Type_FrequencyInfoDL_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecNR_ASN1_FrequencyInfoDL_Type(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SubcarrierSpacing_e_SubCarrierSpacing_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SubcarrierSpacing_e_SubCarrierSpacing_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_SubcarrierSpacing_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecInt32_t_NR_SSB_Config_Type_SubcarrierOffset_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct int32_t_NR_SSB_Config_Type_SubcarrierOffset_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_SSB_Periodicity_Type_Periodicity_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_SSB_Periodicity_Type_Periodicity_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (NR_SSB_Periodicity_Type)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecInt32_t_NR_SSB_Config_Type_HalfFrameOffset_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct int32_t_NR_SSB_Config_Type_HalfFrameOffset_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_SS_BlockPattern_Type_BlockPattern_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_SS_BlockPattern_Type_BlockPattern_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (NR_SS_BlockPattern_Type)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_ServingCellConfigCommon_ssb_PositionsInBurst_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union SQN_NR_ServingCellConfigCommon_ssb_PositionsInBurst_Value* p, enum SQN_NR_ServingCellConfigCommon_ssb_PositionsInBurst_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_ServingCellConfigCommon_ssb_PositionsInBurst_shortBitmap) {
		for (size_t i1 = 0; i1 < 4; i1++) {
			NTOH_8(p->shortBitmap[i1], &_buffer[*_lidx], _lidx);
		}
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_ServingCellConfigCommon_ssb_PositionsInBurst_mediumBitmap) {
		for (size_t i1 = 0; i1 < 8; i1++) {
			NTOH_8(p->mediumBitmap[i1], &_buffer[*_lidx], _lidx);
		}
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_ServingCellConfigCommon_ssb_PositionsInBurst_longBitmap) {
		for (size_t i1 = 0; i1 < 64; i1++) {
			NTOH_8(p->longBitmap[i1], &_buffer[*_lidx], _lidx);
		}
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecNR_SSB_PositionsInBurst_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, NR_SSB_PositionsInBurst_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SQN_NR_ServingCellConfigCommon_ssb_PositionsInBurst_Sel)_tmp;
	}
	_serNrSysDecSQN_NR_ServingCellConfigCommon_ssb_PositionsInBurst_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_SSB_PositionsInBurst_Type_PositionsInBurst_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_SSB_PositionsInBurst_Type_PositionsInBurst_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecNR_SSB_PositionsInBurst_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecInt32_t_NR_SSB_Beam_Type_SsbIndex_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct int32_t_NR_SSB_Beam_Type_SsbIndex_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecInt32_t_NR_SSB_Beam_Type_Attenuation_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct int32_t_NR_SSB_Beam_Type_Attenuation_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_SSB_Beam_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_SSB_Beam_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecInt32_t_NR_SSB_Beam_Type_SsbIndex_Optional(_buffer, _size, _lidx, &p->SsbIndex);
	_serNrSysDecInt32_t_NR_SSB_Beam_Type_Attenuation_Optional(_buffer, _size, _lidx, &p->Attenuation);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_SSB_BeamArray_Type_BeamArray_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_SSB_BeamArray_Type_BeamArray_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = (struct NR_SSB_Beam_Type*)serMalloc(_mem, p->v.d * sizeof(struct NR_SSB_Beam_Type));
	for (size_t i1 = 0; i1 < p->v.d; i1++) {
		_serNrSysDecNR_SSB_Beam_Type(_buffer, _size, _lidx, &p->v.v[i1]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_SSB_BurstConfig_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_SSB_BurstConfig_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecNR_SS_BlockPattern_Type_BlockPattern_Optional(_buffer, _size, _lidx, &p->BlockPattern);
	_serNrSysDecNR_SSB_PositionsInBurst_Type_PositionsInBurst_Optional(_buffer, _size, _lidx, &p->PositionsInBurst);
	_serNrSysDecNR_SSB_BeamArray_Type_BeamArray_Optional(_buffer, _size, _lidx, _mem, &p->BeamArray);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_SSB_BurstConfig_Type_BurstConfig_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_SSB_BurstConfig_Type_BurstConfig_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecNR_SSB_BurstConfig_Type(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_EPRE_Ratio_Type_PbchToDmrs_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_EPRE_Ratio_Type_PbchToDmrs_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_EPRE_Ratio_Type_PssToSss_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_EPRE_Ratio_Type_PssToSss_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_EPRE_Ratio_Type_SssToSsbBeam_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_EPRE_Ratio_Type_SssToSsbBeam_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_EPRE_Ratio_Type_DmrsToSss_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_EPRE_Ratio_Type_DmrsToSss_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_SSB_EPREs_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_SSB_EPREs_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecNR_EPRE_Ratio_Type_PbchToDmrs_Optional(_buffer, _size, _lidx, &p->PbchToDmrs);
	_serNrSysDecNR_EPRE_Ratio_Type_PssToSss_Optional(_buffer, _size, _lidx, &p->PssToSss);
	_serNrSysDecNR_EPRE_Ratio_Type_SssToSsbBeam_Optional(_buffer, _size, _lidx, &p->SssToSsbBeam);
	_serNrSysDecNR_EPRE_Ratio_Type_DmrsToSss_Optional(_buffer, _size, _lidx, &p->DmrsToSss);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_SSB_EPREs_Type_RelativeTxPower_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_SSB_EPREs_Type_RelativeTxPower_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecNR_SSB_EPREs_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_SSB_Config_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_SSB_Config_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecSQN_NR_SubcarrierSpacing_e_SubCarrierSpacing_Optional(_buffer, _size, _lidx, &p->SubCarrierSpacing);
	_serNrSysDecInt32_t_NR_SSB_Config_Type_SubcarrierOffset_Optional(_buffer, _size, _lidx, &p->SubcarrierOffset);
	_serNrSysDecNR_SSB_Periodicity_Type_Periodicity_Optional(_buffer, _size, _lidx, &p->Periodicity);
	_serNrSysDecInt32_t_NR_SSB_Config_Type_HalfFrameOffset_Optional(_buffer, _size, _lidx, &p->HalfFrameOffset);
	_serNrSysDecNR_SSB_BurstConfig_Type_BurstConfig_Optional(_buffer, _size, _lidx, _mem, &p->BurstConfig);
	_serNrSysDecNR_SSB_EPREs_Type_RelativeTxPower_Optional(_buffer, _size, _lidx, &p->RelativeTxPower);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_SSB_Config_Type_SSPbchBlock_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_SSB_Config_Type_SSPbchBlock_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecNR_SSB_Config_Type(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_PDSCH_DMRS_TypeA_Position_Type_DMRS_TypeA_Position_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_PDSCH_DMRS_TypeA_Position_Type_DMRS_TypeA_Position_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (NR_PDSCH_DMRS_TypeA_Position_Type)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_RateMatchPattern_patternType_bitmaps_symbolsInResourceBlock_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union SQN_NR_RateMatchPattern_patternType_bitmaps_symbolsInResourceBlock_Value* p, enum SQN_NR_RateMatchPattern_patternType_bitmaps_symbolsInResourceBlock_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_RateMatchPattern_patternType_bitmaps_symbolsInResourceBlock_oneSlot) {
		for (size_t i2 = 0; i2 < 14; i2++) {
			NTOH_8(p->oneSlot[i2], &_buffer[*_lidx], _lidx);
		}
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_RateMatchPattern_patternType_bitmaps_symbolsInResourceBlock_twoSlots) {
		for (size_t i2 = 0; i2 < 28; i2++) {
			NTOH_8(p->twoSlots[i2], &_buffer[*_lidx], _lidx);
		}
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecSQN_NR_RateMatchPattern_patternType_bitmaps_symbolsInResourceBlock(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_RateMatchPattern_patternType_bitmaps_symbolsInResourceBlock* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SQN_NR_RateMatchPattern_patternType_bitmaps_symbolsInResourceBlock_Sel)_tmp;
	}
	_serNrSysDecSQN_NR_RateMatchPattern_patternType_bitmaps_symbolsInResourceBlock_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_RateMatchPattern_patternType_bitmaps_periodicityAndPattern_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union SQN_NR_RateMatchPattern_patternType_bitmaps_periodicityAndPattern_Value* p, enum SQN_NR_RateMatchPattern_patternType_bitmaps_periodicityAndPattern_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_RateMatchPattern_patternType_bitmaps_periodicityAndPattern_n2) {
		for (size_t i2 = 0; i2 < 2; i2++) {
			NTOH_8(p->n2[i2], &_buffer[*_lidx], _lidx);
		}
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_RateMatchPattern_patternType_bitmaps_periodicityAndPattern_n4) {
		for (size_t i2 = 0; i2 < 4; i2++) {
			NTOH_8(p->n4[i2], &_buffer[*_lidx], _lidx);
		}
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_RateMatchPattern_patternType_bitmaps_periodicityAndPattern_n5) {
		for (size_t i2 = 0; i2 < 5; i2++) {
			NTOH_8(p->n5[i2], &_buffer[*_lidx], _lidx);
		}
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_RateMatchPattern_patternType_bitmaps_periodicityAndPattern_n8) {
		for (size_t i2 = 0; i2 < 8; i2++) {
			NTOH_8(p->n8[i2], &_buffer[*_lidx], _lidx);
		}
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_RateMatchPattern_patternType_bitmaps_periodicityAndPattern_n10) {
		for (size_t i2 = 0; i2 < 10; i2++) {
			NTOH_8(p->n10[i2], &_buffer[*_lidx], _lidx);
		}
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_RateMatchPattern_patternType_bitmaps_periodicityAndPattern_n20) {
		for (size_t i2 = 0; i2 < 20; i2++) {
			NTOH_8(p->n20[i2], &_buffer[*_lidx], _lidx);
		}
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_RateMatchPattern_patternType_bitmaps_periodicityAndPattern_n40) {
		for (size_t i2 = 0; i2 < 40; i2++) {
			NTOH_8(p->n40[i2], &_buffer[*_lidx], _lidx);
		}
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecSQN_NR_RateMatchPattern_patternType_bitmaps_periodicityAndPattern(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_RateMatchPattern_patternType_bitmaps_periodicityAndPattern* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SQN_NR_RateMatchPattern_patternType_bitmaps_periodicityAndPattern_Sel)_tmp;
	}
	_serNrSysDecSQN_NR_RateMatchPattern_patternType_bitmaps_periodicityAndPattern_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_RateMatchPattern_patternType_bitmaps_periodicityAndPattern_periodicityAndPattern_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_RateMatchPattern_patternType_bitmaps_periodicityAndPattern_periodicityAndPattern_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_RateMatchPattern_patternType_bitmaps_periodicityAndPattern(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_RateMatchPattern_patternType_bitmaps(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_RateMatchPattern_patternType_bitmaps* p)
{
	(void)_size; // TODO: generate boundaries checking

	for (size_t i2 = 0; i2 < 275; i2++) {
		NTOH_8(p->resourceBlocks[i2], &_buffer[*_lidx], _lidx);
	}
	_serNrSysDecSQN_NR_RateMatchPattern_patternType_bitmaps_symbolsInResourceBlock(_buffer, _size, _lidx, &p->symbolsInResourceBlock);
	_serNrSysDecSQN_NR_RateMatchPattern_patternType_bitmaps_periodicityAndPattern_periodicityAndPattern_Optional(_buffer, _size, _lidx, &p->periodicityAndPattern);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_RateMatchPattern_patternType_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union SQN_NR_RateMatchPattern_patternType_Value* p, enum SQN_NR_RateMatchPattern_patternType_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_RateMatchPattern_patternType_bitmaps) {
		_serNrSysDecSQN_NR_RateMatchPattern_patternType_bitmaps(_buffer, _size, _lidx, &p->bitmaps);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_RateMatchPattern_patternType_controlResourceSet) {
		NTOH_8(p->controlResourceSet, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecSQN_NR_RateMatchPattern_patternType(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_RateMatchPattern_patternType* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SQN_NR_RateMatchPattern_patternType_Sel)_tmp;
	}
	_serNrSysDecSQN_NR_RateMatchPattern_patternType_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SubcarrierSpacing_e_SQN_NR_RateMatchPattern_subcarrierSpacing_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SubcarrierSpacing_e_SQN_NR_RateMatchPattern_subcarrierSpacing_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_SubcarrierSpacing_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_ControlResourceSetId_r16_SQN_NR_RateMatchPattern_controlResourceSet_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_ControlResourceSetId_r16_SQN_NR_RateMatchPattern_controlResourceSet_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_RateMatchPattern(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_RateMatchPattern* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->rateMatchPatternId, &_buffer[*_lidx], _lidx);
	_serNrSysDecSQN_NR_RateMatchPattern_patternType(_buffer, _size, _lidx, &p->patternType);
	_serNrSysDecSQN_NR_SubcarrierSpacing_e_SQN_NR_RateMatchPattern_subcarrierSpacing_Optional(_buffer, _size, _lidx, &p->subcarrierSpacing);
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->dummy = (SQN_NR_RateMatchPattern_dummy_e)_tmp;
	}
	_serNrSysDecSQN_NR_ControlResourceSetId_r16_SQN_NR_RateMatchPattern_controlResourceSet_r16_Optional(_buffer, _size, _lidx, &p->controlResourceSet_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_ASN1_RateMatchPattern_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union NR_ASN1_RateMatchPattern_Type_Value* p, enum NR_ASN1_RateMatchPattern_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_ASN1_RateMatchPattern_Type_R15) {
		_serNrSysDecSQN_NR_RateMatchPattern(_buffer, _size, _lidx, &p->R15);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecNR_ASN1_RateMatchPattern_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_ASN1_RateMatchPattern_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum NR_ASN1_RateMatchPattern_Type_Sel)_tmp;
	}
	_serNrSysDecNR_ASN1_RateMatchPattern_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_RateMatchPatternList_Type_PatternList_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_RateMatchPatternList_Type_PatternList_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = (struct NR_ASN1_RateMatchPattern_Type*)serMalloc(_mem, p->v.d * sizeof(struct NR_ASN1_RateMatchPattern_Type));
	for (size_t i1 = 0; i1 < p->v.d; i1++) {
		_serNrSysDecNR_ASN1_RateMatchPattern_Type(_buffer, _size, _lidx, &p->v.v[i1]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_EUTRA_MBSFN_SubframeConfig_subframeAllocation1_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union SQN_NR_EUTRA_MBSFN_SubframeConfig_subframeAllocation1_Value* p, enum SQN_NR_EUTRA_MBSFN_SubframeConfig_subframeAllocation1_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_EUTRA_MBSFN_SubframeConfig_subframeAllocation1_oneFrame) {
		for (size_t i3 = 0; i3 < 6; i3++) {
			NTOH_8(p->oneFrame[i3], &_buffer[*_lidx], _lidx);
		}
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_EUTRA_MBSFN_SubframeConfig_subframeAllocation1_fourFrames) {
		for (size_t i3 = 0; i3 < 24; i3++) {
			NTOH_8(p->fourFrames[i3], &_buffer[*_lidx], _lidx);
		}
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecSQN_NR_EUTRA_MBSFN_SubframeConfig_subframeAllocation1(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_EUTRA_MBSFN_SubframeConfig_subframeAllocation1* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SQN_NR_EUTRA_MBSFN_SubframeConfig_subframeAllocation1_Sel)_tmp;
	}
	_serNrSysDecSQN_NR_EUTRA_MBSFN_SubframeConfig_subframeAllocation1_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_EUTRA_MBSFN_SubframeConfig_subframeAllocation2_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union SQN_NR_EUTRA_MBSFN_SubframeConfig_subframeAllocation2_Value* p, enum SQN_NR_EUTRA_MBSFN_SubframeConfig_subframeAllocation2_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_EUTRA_MBSFN_SubframeConfig_subframeAllocation2_oneFrame) {
		for (size_t i3 = 0; i3 < 2; i3++) {
			NTOH_8(p->oneFrame[i3], &_buffer[*_lidx], _lidx);
		}
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_EUTRA_MBSFN_SubframeConfig_subframeAllocation2_fourFrames) {
		for (size_t i3 = 0; i3 < 8; i3++) {
			NTOH_8(p->fourFrames[i3], &_buffer[*_lidx], _lidx);
		}
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecSQN_NR_EUTRA_MBSFN_SubframeConfig_subframeAllocation2(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_EUTRA_MBSFN_SubframeConfig_subframeAllocation2* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SQN_NR_EUTRA_MBSFN_SubframeConfig_subframeAllocation2_Sel)_tmp;
	}
	_serNrSysDecSQN_NR_EUTRA_MBSFN_SubframeConfig_subframeAllocation2_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_EUTRA_MBSFN_SubframeConfig_subframeAllocation2_subframeAllocation2_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_EUTRA_MBSFN_SubframeConfig_subframeAllocation2_subframeAllocation2_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_EUTRA_MBSFN_SubframeConfig_subframeAllocation2(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_EUTRA_MBSFN_SubframeConfig(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_EUTRA_MBSFN_SubframeConfig* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->radioframeAllocationPeriod = (SQN_NR_EUTRA_MBSFN_SubframeConfig_radioframeAllocationPeriod_e)_tmp;
	}
	NTOH_8(p->radioframeAllocationOffset, &_buffer[*_lidx], _lidx);
	_serNrSysDecSQN_NR_EUTRA_MBSFN_SubframeConfig_subframeAllocation1(_buffer, _size, _lidx, &p->subframeAllocation1);
	_serNrSysDecSQN_NR_EUTRA_MBSFN_SubframeConfig_subframeAllocation2_subframeAllocation2_Optional(_buffer, _size, _lidx, &p->subframeAllocation2);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_EUTRA_MBSFN_SubframeConfigList_SQN_NR_RateMatchPatternLTE_CRS_mbsfn_SubframeConfigList_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_EUTRA_MBSFN_SubframeConfigList_SQN_NR_RateMatchPatternLTE_CRS_mbsfn_SubframeConfigList_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = (struct SQN_NR_EUTRA_MBSFN_SubframeConfig*)serMalloc(_mem, p->v.d * sizeof(struct SQN_NR_EUTRA_MBSFN_SubframeConfig));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serNrSysDecSQN_NR_EUTRA_MBSFN_SubframeConfig(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_RateMatchPatternLTE_CRS(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_RateMatchPatternLTE_CRS* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_16(p->carrierFreqDL, &_buffer[*_lidx], _lidx);
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->carrierBandwidthDL = (SQN_NR_RateMatchPatternLTE_CRS_carrierBandwidthDL_e)_tmp;
	}
	_serNrSysDecSQN_NR_EUTRA_MBSFN_SubframeConfigList_SQN_NR_RateMatchPatternLTE_CRS_mbsfn_SubframeConfigList_Optional(_buffer, _size, _lidx, _mem, &p->mbsfn_SubframeConfigList);
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->nrofCRS_Ports = (SQN_NR_RateMatchPatternLTE_CRS_nrofCRS_Ports_e)_tmp;
	}
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v_Shift = (SQN_NR_RateMatchPatternLTE_CRS_v_Shift_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_ASN1_RateMatchPatternLTE_CRS_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union NR_ASN1_RateMatchPatternLTE_CRS_Type_Value* p, enum NR_ASN1_RateMatchPatternLTE_CRS_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_ASN1_RateMatchPatternLTE_CRS_Type_R15) {
		_serNrSysDecSQN_NR_RateMatchPatternLTE_CRS(_buffer, _size, _lidx, _mem, &p->R15);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecNR_ASN1_RateMatchPatternLTE_CRS_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_ASN1_RateMatchPatternLTE_CRS_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum NR_ASN1_RateMatchPatternLTE_CRS_Type_Sel)_tmp;
	}
	_serNrSysDecNR_ASN1_RateMatchPatternLTE_CRS_Type_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_RateMatchPatternLteCrsList_Type_PatternListLteCrs_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_RateMatchPatternLteCrsList_Type_PatternListLteCrs_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = (struct NR_ASN1_RateMatchPatternLTE_CRS_Type*)serMalloc(_mem, p->v.d * sizeof(struct NR_ASN1_RateMatchPatternLTE_CRS_Type));
	for (size_t i1 = 0; i1 < p->v.d; i1++) {
		_serNrSysDecNR_ASN1_RateMatchPatternLTE_CRS_Type(_buffer, _size, _lidx, _mem, &p->v.v[i1]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_CellLevelRateMatchPattern_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_CellLevelRateMatchPattern_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecNR_RateMatchPatternList_Type_PatternList_Optional(_buffer, _size, _lidx, _mem, &p->PatternList);
	_serNrSysDecNR_RateMatchPatternLteCrsList_Type_PatternListLteCrs_Optional(_buffer, _size, _lidx, _mem, &p->PatternListLteCrs);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_CellLevelRateMatchPattern_Type_RateMatchPattern_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_CellLevelRateMatchPattern_Type_RateMatchPattern_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecNR_CellLevelRateMatchPattern_Type(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PDSCH_CodeBlockGroupTransmission(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_PDSCH_CodeBlockGroupTransmission* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->maxCodeBlockGroupsPerTransportBlock = (SQN_NR_PDSCH_CodeBlockGroupTransmission_maxCodeBlockGroupsPerTransportBlock_e)_tmp;
	}
	NTOH_8(p->codeBlockGroupFlushIndicator, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SetupRelease_PDSCH_ServingCellConfig_codeBlockGroupTransmission_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union SQN_NR_SetupRelease_PDSCH_ServingCellConfig_codeBlockGroupTransmission_Value* p, enum SQN_NR_SetupRelease_PDSCH_ServingCellConfig_codeBlockGroupTransmission_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SetupRelease_PDSCH_ServingCellConfig_codeBlockGroupTransmission_release) {
		NTOH_8(p->release, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SetupRelease_PDSCH_ServingCellConfig_codeBlockGroupTransmission_setup) {
		_serNrSysDecSQN_NR_PDSCH_CodeBlockGroupTransmission(_buffer, _size, _lidx, &p->setup);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecSQN_NR_SetupRelease_PDSCH_ServingCellConfig_codeBlockGroupTransmission(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SetupRelease_PDSCH_ServingCellConfig_codeBlockGroupTransmission* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SQN_NR_SetupRelease_PDSCH_ServingCellConfig_codeBlockGroupTransmission_Sel)_tmp;
	}
	_serNrSysDecSQN_NR_SetupRelease_PDSCH_ServingCellConfig_codeBlockGroupTransmission_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SetupRelease_PDSCH_ServingCellConfig_codeBlockGroupTransmission_SQN_NR_PDSCH_ServingCellConfig_codeBlockGroupTransmission_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SetupRelease_PDSCH_ServingCellConfig_codeBlockGroupTransmission_SQN_NR_PDSCH_ServingCellConfig_codeBlockGroupTransmission_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_SetupRelease_PDSCH_ServingCellConfig_codeBlockGroupTransmission(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PDSCH_ServingCellConfig_xOverhead_e_xOverhead_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_PDSCH_ServingCellConfig_xOverhead_e_xOverhead_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_PDSCH_ServingCellConfig_xOverhead_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PDSCH_ServingCellConfig_nrofHARQ_ProcessesForPDSCH_e_nrofHARQ_ProcessesForPDSCH_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_PDSCH_ServingCellConfig_nrofHARQ_ProcessesForPDSCH_e_nrofHARQ_ProcessesForPDSCH_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_PDSCH_ServingCellConfig_nrofHARQ_ProcessesForPDSCH_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_ServCellIndex_SQN_NR_PDSCH_ServingCellConfig_pucch_Cell_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_ServCellIndex_SQN_NR_PDSCH_ServingCellConfig_pucch_Cell_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecUint8_t_SQN_NR_PDSCH_ServingCellConfig_maxMIMO_Layers_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct uint8_t_SQN_NR_PDSCH_ServingCellConfig_maxMIMO_Layers_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecBool_SQN_NR_PDSCH_ServingCellConfig_processingType2Enabled_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct bool_SQN_NR_PDSCH_ServingCellConfig_processingType2Enabled_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SetupRelease_PDSCH_ServingCellConfig_pdsch_CodeBlockGroupTransmissionList_r16_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union SQN_NR_SetupRelease_PDSCH_ServingCellConfig_pdsch_CodeBlockGroupTransmissionList_r16_Value* p, enum SQN_NR_SetupRelease_PDSCH_ServingCellConfig_pdsch_CodeBlockGroupTransmissionList_r16_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SetupRelease_PDSCH_ServingCellConfig_pdsch_CodeBlockGroupTransmissionList_r16_release) {
		NTOH_8(p->release, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SetupRelease_PDSCH_ServingCellConfig_pdsch_CodeBlockGroupTransmissionList_r16_setup) {
		NTOH_32(p->setup.d, &_buffer[*_lidx], _lidx);
		p->setup.v = (struct SQN_NR_PDSCH_CodeBlockGroupTransmission*)serMalloc(_mem, p->setup.d * sizeof(struct SQN_NR_PDSCH_CodeBlockGroupTransmission));
		for (size_t i1 = 0; i1 < p->setup.d; i1++) {
			_serNrSysDecSQN_NR_PDSCH_CodeBlockGroupTransmission(_buffer, _size, _lidx, &p->setup.v[i1]);
		}
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecSQN_NR_SetupRelease_PDSCH_ServingCellConfig_pdsch_CodeBlockGroupTransmissionList_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_SetupRelease_PDSCH_ServingCellConfig_pdsch_CodeBlockGroupTransmissionList_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SQN_NR_SetupRelease_PDSCH_ServingCellConfig_pdsch_CodeBlockGroupTransmissionList_r16_Sel)_tmp;
	}
	_serNrSysDecSQN_NR_SetupRelease_PDSCH_ServingCellConfig_pdsch_CodeBlockGroupTransmissionList_r16_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SetupRelease_PDSCH_ServingCellConfig_pdsch_CodeBlockGroupTransmissionList_r16_SQN_NR_PDSCH_ServingCellConfig_pdsch_CodeBlockGroupTransmissionList_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_SetupRelease_PDSCH_ServingCellConfig_pdsch_CodeBlockGroupTransmissionList_r16_SQN_NR_PDSCH_ServingCellConfig_pdsch_CodeBlockGroupTransmissionList_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_SetupRelease_PDSCH_ServingCellConfig_pdsch_CodeBlockGroupTransmissionList_r16(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PDSCH_ServingCellConfig(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_PDSCH_ServingCellConfig* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecSQN_NR_SetupRelease_PDSCH_ServingCellConfig_codeBlockGroupTransmission_SQN_NR_PDSCH_ServingCellConfig_codeBlockGroupTransmission_Optional(_buffer, _size, _lidx, &p->codeBlockGroupTransmission);
	_serNrSysDecSQN_NR_PDSCH_ServingCellConfig_xOverhead_e_xOverhead_Optional(_buffer, _size, _lidx, &p->xOverhead);
	_serNrSysDecSQN_NR_PDSCH_ServingCellConfig_nrofHARQ_ProcessesForPDSCH_e_nrofHARQ_ProcessesForPDSCH_Optional(_buffer, _size, _lidx, &p->nrofHARQ_ProcessesForPDSCH);
	_serNrSysDecSQN_NR_ServCellIndex_SQN_NR_PDSCH_ServingCellConfig_pucch_Cell_Optional(_buffer, _size, _lidx, &p->pucch_Cell);
	_serNrSysDecUint8_t_SQN_NR_PDSCH_ServingCellConfig_maxMIMO_Layers_Optional(_buffer, _size, _lidx, &p->maxMIMO_Layers);
	_serNrSysDecBool_SQN_NR_PDSCH_ServingCellConfig_processingType2Enabled_Optional(_buffer, _size, _lidx, &p->processingType2Enabled);
	_serNrSysDecSQN_NR_SetupRelease_PDSCH_ServingCellConfig_pdsch_CodeBlockGroupTransmissionList_r16_SQN_NR_PDSCH_ServingCellConfig_pdsch_CodeBlockGroupTransmissionList_r16_Optional(_buffer, _size, _lidx, _mem, &p->pdsch_CodeBlockGroupTransmissionList_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_ASN1_PDSCH_ServingCellConfig_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union NR_ASN1_PDSCH_ServingCellConfig_Type_Value* p, enum NR_ASN1_PDSCH_ServingCellConfig_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_ASN1_PDSCH_ServingCellConfig_Type_R15) {
		_serNrSysDecSQN_NR_PDSCH_ServingCellConfig(_buffer, _size, _lidx, _mem, &p->R15);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecNR_ASN1_PDSCH_ServingCellConfig_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_ASN1_PDSCH_ServingCellConfig_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum NR_ASN1_PDSCH_ServingCellConfig_Type_Sel)_tmp;
	}
	_serNrSysDecNR_ASN1_PDSCH_ServingCellConfig_Type_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_ASN1_PDSCH_ServingCellConfig_Type_ServingCellConfig_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_ASN1_PDSCH_ServingCellConfig_Type_ServingCellConfig_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecNR_ASN1_PDSCH_ServingCellConfig_Type(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_PDSCH_CellLevelConfig_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_PDSCH_CellLevelConfig_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecNR_PDSCH_DMRS_TypeA_Position_Type_DMRS_TypeA_Position_Optional(_buffer, _size, _lidx, &p->DMRS_TypeA_Position);
	_serNrSysDecNR_CellLevelRateMatchPattern_Type_RateMatchPattern_Optional(_buffer, _size, _lidx, _mem, &p->RateMatchPattern);
	_serNrSysDecNR_ASN1_PDSCH_ServingCellConfig_Type_ServingCellConfig_Optional(_buffer, _size, _lidx, _mem, &p->ServingCellConfig);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_PDSCH_CellLevelConfig_Type_PdschCellLevelConfig_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_PDSCH_CellLevelConfig_Type_PdschCellLevelConfig_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecNR_PDSCH_CellLevelConfig_Type(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_BWP_Id_ActiveBWP_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_BWP_Id_ActiveBWP_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_BWP_Id_NR_DownlinkBWP_Type_Id_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_BWP_Id_NR_DownlinkBWP_Type_Id_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_BWP_cyclicPrefix_e_cyclicPrefix_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_BWP_cyclicPrefix_e_cyclicPrefix_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_BWP_cyclicPrefix_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_BWP(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_BWP* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_16(p->locationAndBandwidth, &_buffer[*_lidx], _lidx);
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->subcarrierSpacing = (SQN_NR_SubcarrierSpacing_e)_tmp;
	}
	_serNrSysDecSQN_NR_BWP_cyclicPrefix_e_cyclicPrefix_Optional(_buffer, _size, _lidx, &p->cyclicPrefix);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_ASN1_BWP_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union NR_ASN1_BWP_Type_Value* p, enum NR_ASN1_BWP_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_ASN1_BWP_Type_R15) {
		_serNrSysDecSQN_NR_BWP(_buffer, _size, _lidx, &p->R15);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecNR_ASN1_BWP_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_ASN1_BWP_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum NR_ASN1_BWP_Type_Sel)_tmp;
	}
	_serNrSysDecNR_ASN1_BWP_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_ASN1_BWP_Type_BWP_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_ASN1_BWP_Type_BWP_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecNR_ASN1_BWP_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_SearchSpaceTypeAndPriority_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_SearchSpaceTypeAndPriority_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->Type = (NR_SearchSpaceType_Type)_tmp;
	}
	NTOH_32(p->CandidatePriority, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_ControlResourceSetId_SQN_NR_SearchSpace_controlResourceSetId_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_ControlResourceSetId_SQN_NR_SearchSpace_controlResourceSetId_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SearchSpace_monitoringSlotPeriodicityAndOffset_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union SQN_NR_SearchSpace_monitoringSlotPeriodicityAndOffset_Value* p, enum SQN_NR_SearchSpace_monitoringSlotPeriodicityAndOffset_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SearchSpace_monitoringSlotPeriodicityAndOffset_sl1) {
		NTOH_8(p->sl1, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SearchSpace_monitoringSlotPeriodicityAndOffset_sl2) {
		NTOH_8(p->sl2, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SearchSpace_monitoringSlotPeriodicityAndOffset_sl4) {
		NTOH_8(p->sl4, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SearchSpace_monitoringSlotPeriodicityAndOffset_sl5) {
		NTOH_8(p->sl5, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SearchSpace_monitoringSlotPeriodicityAndOffset_sl8) {
		NTOH_8(p->sl8, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SearchSpace_monitoringSlotPeriodicityAndOffset_sl10) {
		NTOH_8(p->sl10, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SearchSpace_monitoringSlotPeriodicityAndOffset_sl16) {
		NTOH_8(p->sl16, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SearchSpace_monitoringSlotPeriodicityAndOffset_sl20) {
		NTOH_8(p->sl20, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SearchSpace_monitoringSlotPeriodicityAndOffset_sl40) {
		NTOH_8(p->sl40, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SearchSpace_monitoringSlotPeriodicityAndOffset_sl80) {
		NTOH_8(p->sl80, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SearchSpace_monitoringSlotPeriodicityAndOffset_sl160) {
		NTOH_8(p->sl160, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SearchSpace_monitoringSlotPeriodicityAndOffset_sl320) {
		NTOH_16(p->sl320, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SearchSpace_monitoringSlotPeriodicityAndOffset_sl640) {
		NTOH_16(p->sl640, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SearchSpace_monitoringSlotPeriodicityAndOffset_sl1280) {
		NTOH_16(p->sl1280, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SearchSpace_monitoringSlotPeriodicityAndOffset_sl2560) {
		NTOH_16(p->sl2560, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecSQN_NR_SearchSpace_monitoringSlotPeriodicityAndOffset(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SearchSpace_monitoringSlotPeriodicityAndOffset* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SQN_NR_SearchSpace_monitoringSlotPeriodicityAndOffset_Sel)_tmp;
	}
	_serNrSysDecSQN_NR_SearchSpace_monitoringSlotPeriodicityAndOffset_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SearchSpace_monitoringSlotPeriodicityAndOffset_monitoringSlotPeriodicityAndOffset_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SearchSpace_monitoringSlotPeriodicityAndOffset_monitoringSlotPeriodicityAndOffset_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_SearchSpace_monitoringSlotPeriodicityAndOffset(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecUint16_t_SQN_NR_SearchSpace_duration_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct uint16_t_SQN_NR_SearchSpace_duration_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_16(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecB14_SQN_NR_SearchSpace_monitoringSymbolsWithinSlot_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct B14_SQN_NR_SearchSpace_monitoringSymbolsWithinSlot_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	for (size_t i3 = 0; i3 < 14; i3++) {
		NTOH_8(p->v[i3], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SearchSpace_nrofCandidates(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SearchSpace_nrofCandidates* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->aggregationLevel1 = (SQN_NR_SearchSpace_nrofCandidates_aggregationLevel1_e)_tmp;
	}
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->aggregationLevel2 = (SQN_NR_SearchSpace_nrofCandidates_aggregationLevel2_e)_tmp;
	}
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->aggregationLevel4 = (SQN_NR_SearchSpace_nrofCandidates_aggregationLevel4_e)_tmp;
	}
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->aggregationLevel8 = (SQN_NR_SearchSpace_nrofCandidates_aggregationLevel8_e)_tmp;
	}
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->aggregationLevel16 = (SQN_NR_SearchSpace_nrofCandidates_aggregationLevel16_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SearchSpace_nrofCandidates_nrofCandidates_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SearchSpace_nrofCandidates_nrofCandidates_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_SearchSpace_nrofCandidates(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SearchSpace_searchSpaceType_common_dci_Format0_0_AndFormat1_0(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SearchSpace_searchSpaceType_common_dci_Format0_0_AndFormat1_0* p)
{
	(void)_size; // TODO: generate boundaries checking

	(void)_buffer;
	(void)_size;
	(void)_lidx;
	(void)p;

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SearchSpace_searchSpaceType_common_dci_Format0_0_AndFormat1_0_dci_Format0_0_AndFormat1_0_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SearchSpace_searchSpaceType_common_dci_Format0_0_AndFormat1_0_dci_Format0_0_AndFormat1_0_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_SearchSpace_searchSpaceType_common_dci_Format0_0_AndFormat1_0(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SearchSpace_searchSpaceType_common_dci_Format2_0nrofCandidates_SFIaggregationLevel1_e_aggregationLevel1_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SearchSpace_searchSpaceType_common_dci_Format2_0nrofCandidates_SFIaggregationLevel1_e_aggregationLevel1_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_SearchSpace_searchSpaceType_common_dci_Format2_0nrofCandidates_SFIaggregationLevel1_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SearchSpace_searchSpaceType_common_dci_Format2_0nrofCandidates_SFIaggregationLevel2_e_aggregationLevel2_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SearchSpace_searchSpaceType_common_dci_Format2_0nrofCandidates_SFIaggregationLevel2_e_aggregationLevel2_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_SearchSpace_searchSpaceType_common_dci_Format2_0nrofCandidates_SFIaggregationLevel2_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SearchSpace_searchSpaceType_common_dci_Format2_0nrofCandidates_SFIaggregationLevel4_e_aggregationLevel4_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SearchSpace_searchSpaceType_common_dci_Format2_0nrofCandidates_SFIaggregationLevel4_e_aggregationLevel4_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_SearchSpace_searchSpaceType_common_dci_Format2_0nrofCandidates_SFIaggregationLevel4_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SearchSpace_searchSpaceType_common_dci_Format2_0nrofCandidates_SFIaggregationLevel8_e_aggregationLevel8_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SearchSpace_searchSpaceType_common_dci_Format2_0nrofCandidates_SFIaggregationLevel8_e_aggregationLevel8_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_SearchSpace_searchSpaceType_common_dci_Format2_0nrofCandidates_SFIaggregationLevel8_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SearchSpace_searchSpaceType_common_dci_Format2_0nrofCandidates_SFIaggregationLevel16_e_aggregationLevel16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SearchSpace_searchSpaceType_common_dci_Format2_0nrofCandidates_SFIaggregationLevel16_e_aggregationLevel16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_SearchSpace_searchSpaceType_common_dci_Format2_0nrofCandidates_SFIaggregationLevel16_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SearchSpace_searchSpaceType_common_dci_Format2_0nrofCandidates_SFI(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SearchSpace_searchSpaceType_common_dci_Format2_0nrofCandidates_SFI* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecSQN_NR_SearchSpace_searchSpaceType_common_dci_Format2_0nrofCandidates_SFIaggregationLevel1_e_aggregationLevel1_Optional(_buffer, _size, _lidx, &p->aggregationLevel1);
	_serNrSysDecSQN_NR_SearchSpace_searchSpaceType_common_dci_Format2_0nrofCandidates_SFIaggregationLevel2_e_aggregationLevel2_Optional(_buffer, _size, _lidx, &p->aggregationLevel2);
	_serNrSysDecSQN_NR_SearchSpace_searchSpaceType_common_dci_Format2_0nrofCandidates_SFIaggregationLevel4_e_aggregationLevel4_Optional(_buffer, _size, _lidx, &p->aggregationLevel4);
	_serNrSysDecSQN_NR_SearchSpace_searchSpaceType_common_dci_Format2_0nrofCandidates_SFIaggregationLevel8_e_aggregationLevel8_Optional(_buffer, _size, _lidx, &p->aggregationLevel8);
	_serNrSysDecSQN_NR_SearchSpace_searchSpaceType_common_dci_Format2_0nrofCandidates_SFIaggregationLevel16_e_aggregationLevel16_Optional(_buffer, _size, _lidx, &p->aggregationLevel16);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SearchSpace_searchSpaceType_common_dci_Format2_0(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SearchSpace_searchSpaceType_common_dci_Format2_0* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecSQN_NR_SearchSpace_searchSpaceType_common_dci_Format2_0nrofCandidates_SFI(_buffer, _size, _lidx, &p->nrofCandidates_SFI);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SearchSpace_searchSpaceType_common_dci_Format2_0_dci_Format2_0_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SearchSpace_searchSpaceType_common_dci_Format2_0_dci_Format2_0_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_SearchSpace_searchSpaceType_common_dci_Format2_0(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SearchSpace_searchSpaceType_common_dci_Format2_1(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SearchSpace_searchSpaceType_common_dci_Format2_1* p)
{
	(void)_size; // TODO: generate boundaries checking

	(void)_buffer;
	(void)_size;
	(void)_lidx;
	(void)p;

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SearchSpace_searchSpaceType_common_dci_Format2_1_dci_Format2_1_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SearchSpace_searchSpaceType_common_dci_Format2_1_dci_Format2_1_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_SearchSpace_searchSpaceType_common_dci_Format2_1(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SearchSpace_searchSpaceType_common_dci_Format2_2(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SearchSpace_searchSpaceType_common_dci_Format2_2* p)
{
	(void)_size; // TODO: generate boundaries checking

	(void)_buffer;
	(void)_size;
	(void)_lidx;
	(void)p;

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SearchSpace_searchSpaceType_common_dci_Format2_2_dci_Format2_2_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SearchSpace_searchSpaceType_common_dci_Format2_2_dci_Format2_2_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_SearchSpace_searchSpaceType_common_dci_Format2_2(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SearchSpace_searchSpaceType_common_dci_Format2_3dummy1_e_dummy1_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SearchSpace_searchSpaceType_common_dci_Format2_3dummy1_e_dummy1_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_SearchSpace_searchSpaceType_common_dci_Format2_3dummy1_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SearchSpace_searchSpaceType_common_dci_Format2_3(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SearchSpace_searchSpaceType_common_dci_Format2_3* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecSQN_NR_SearchSpace_searchSpaceType_common_dci_Format2_3dummy1_e_dummy1_Optional(_buffer, _size, _lidx, &p->dummy1);
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->dummy2 = (SQN_NR_SearchSpace_searchSpaceType_common_dci_Format2_3dummy2_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SearchSpace_searchSpaceType_common_dci_Format2_3_dci_Format2_3_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SearchSpace_searchSpaceType_common_dci_Format2_3_dci_Format2_3_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_SearchSpace_searchSpaceType_common_dci_Format2_3(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SearchSpace_searchSpaceType_common(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SearchSpace_searchSpaceType_common* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecSQN_NR_SearchSpace_searchSpaceType_common_dci_Format0_0_AndFormat1_0_dci_Format0_0_AndFormat1_0_Optional(_buffer, _size, _lidx, &p->dci_Format0_0_AndFormat1_0);
	_serNrSysDecSQN_NR_SearchSpace_searchSpaceType_common_dci_Format2_0_dci_Format2_0_Optional(_buffer, _size, _lidx, &p->dci_Format2_0);
	_serNrSysDecSQN_NR_SearchSpace_searchSpaceType_common_dci_Format2_1_dci_Format2_1_Optional(_buffer, _size, _lidx, &p->dci_Format2_1);
	_serNrSysDecSQN_NR_SearchSpace_searchSpaceType_common_dci_Format2_2_dci_Format2_2_Optional(_buffer, _size, _lidx, &p->dci_Format2_2);
	_serNrSysDecSQN_NR_SearchSpace_searchSpaceType_common_dci_Format2_3_dci_Format2_3_Optional(_buffer, _size, _lidx, &p->dci_Format2_3);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SearchSpace_searchSpaceType_ue_Specific_dci_Formats_MT_r16_e_dci_Formats_MT_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SearchSpace_searchSpaceType_ue_Specific_dci_Formats_MT_r16_e_dci_Formats_MT_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_SearchSpace_searchSpaceType_ue_Specific_dci_Formats_MT_r16_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SearchSpace_searchSpaceType_ue_Specific_dci_FormatsSL_r16_e_dci_FormatsSL_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SearchSpace_searchSpaceType_ue_Specific_dci_FormatsSL_r16_e_dci_FormatsSL_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_SearchSpace_searchSpaceType_ue_Specific_dci_FormatsSL_r16_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SearchSpace_searchSpaceType_ue_Specific_dci_FormatsExt_r16_e_dci_FormatsExt_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SearchSpace_searchSpaceType_ue_Specific_dci_FormatsExt_r16_e_dci_FormatsExt_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_SearchSpace_searchSpaceType_ue_Specific_dci_FormatsExt_r16_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SearchSpace_searchSpaceType_ue_Specific(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SearchSpace_searchSpaceType_ue_Specific* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->dci_Formats = (SQN_NR_SearchSpace_searchSpaceType_ue_Specific_dci_Formats_e)_tmp;
	}
	_serNrSysDecSQN_NR_SearchSpace_searchSpaceType_ue_Specific_dci_Formats_MT_r16_e_dci_Formats_MT_r16_Optional(_buffer, _size, _lidx, &p->dci_Formats_MT_r16);
	_serNrSysDecSQN_NR_SearchSpace_searchSpaceType_ue_Specific_dci_FormatsSL_r16_e_dci_FormatsSL_r16_Optional(_buffer, _size, _lidx, &p->dci_FormatsSL_r16);
	_serNrSysDecSQN_NR_SearchSpace_searchSpaceType_ue_Specific_dci_FormatsExt_r16_e_dci_FormatsExt_r16_Optional(_buffer, _size, _lidx, &p->dci_FormatsExt_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SearchSpace_searchSpaceType_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union SQN_NR_SearchSpace_searchSpaceType_Value* p, enum SQN_NR_SearchSpace_searchSpaceType_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SearchSpace_searchSpaceType_common) {
		_serNrSysDecSQN_NR_SearchSpace_searchSpaceType_common(_buffer, _size, _lidx, &p->common);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SearchSpace_searchSpaceType_ue_Specific) {
		_serNrSysDecSQN_NR_SearchSpace_searchSpaceType_ue_Specific(_buffer, _size, _lidx, &p->ue_Specific);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecSQN_NR_SearchSpace_searchSpaceType(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SearchSpace_searchSpaceType* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SQN_NR_SearchSpace_searchSpaceType_Sel)_tmp;
	}
	_serNrSysDecSQN_NR_SearchSpace_searchSpaceType_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SearchSpace_searchSpaceType_searchSpaceType_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SearchSpace_searchSpaceType_searchSpaceType_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_SearchSpace_searchSpaceType(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SearchSpace(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SearchSpace* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->searchSpaceId, &_buffer[*_lidx], _lidx);
	_serNrSysDecSQN_NR_ControlResourceSetId_SQN_NR_SearchSpace_controlResourceSetId_Optional(_buffer, _size, _lidx, &p->controlResourceSetId);
	_serNrSysDecSQN_NR_SearchSpace_monitoringSlotPeriodicityAndOffset_monitoringSlotPeriodicityAndOffset_Optional(_buffer, _size, _lidx, &p->monitoringSlotPeriodicityAndOffset);
	_serNrSysDecUint16_t_SQN_NR_SearchSpace_duration_Optional(_buffer, _size, _lidx, &p->duration);
	_serNrSysDecB14_SQN_NR_SearchSpace_monitoringSymbolsWithinSlot_Optional(_buffer, _size, _lidx, &p->monitoringSymbolsWithinSlot);
	_serNrSysDecSQN_NR_SearchSpace_nrofCandidates_nrofCandidates_Optional(_buffer, _size, _lidx, &p->nrofCandidates);
	_serNrSysDecSQN_NR_SearchSpace_searchSpaceType_searchSpaceType_Optional(_buffer, _size, _lidx, &p->searchSpaceType);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_ASN1_SearchSpace_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union NR_ASN1_SearchSpace_Type_Value* p, enum NR_ASN1_SearchSpace_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_ASN1_SearchSpace_Type_R15) {
		_serNrSysDecSQN_NR_SearchSpace(_buffer, _size, _lidx, &p->R15);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecNR_ASN1_SearchSpace_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_ASN1_SearchSpace_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum NR_ASN1_SearchSpace_Type_Sel)_tmp;
	}
	_serNrSysDecNR_ASN1_SearchSpace_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_BWP_SearchSpaceConfig_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_BWP_SearchSpaceConfig_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_32(p->TypeAndPriorityList.d, &_buffer[*_lidx], _lidx);
	p->TypeAndPriorityList.v = (struct NR_SearchSpaceTypeAndPriority_Type*)serMalloc(_mem, p->TypeAndPriorityList.d * sizeof(struct NR_SearchSpaceTypeAndPriority_Type));
	for (size_t i3 = 0; i3 < p->TypeAndPriorityList.d; i3++) {
		_serNrSysDecNR_SearchSpaceTypeAndPriority_Type(_buffer, _size, _lidx, &p->TypeAndPriorityList.v[i3]);
	}
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->AggregationLevel = (NR_PDCCH_CCE_AggregationLevel_Type)_tmp;
	}
	_serNrSysDecNR_ASN1_SearchSpace_Type(_buffer, _size, _lidx, &p->SearchSpaceConfigAtUE);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_BWP_SearchSpaceList_Type_SearchSpaceArray_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_BWP_SearchSpaceList_Type_SearchSpaceArray_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = (struct NR_BWP_SearchSpaceConfig_Type*)serMalloc(_mem, p->v.d * sizeof(struct NR_BWP_SearchSpaceConfig_Type));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serNrSysDecNR_BWP_SearchSpaceConfig_Type(_buffer, _size, _lidx, _mem, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecUint16_t_SQN_NR_ControlResourceSet_cce_REG_MappingType_interleaved_shiftIndex_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct uint16_t_SQN_NR_ControlResourceSet_cce_REG_MappingType_interleaved_shiftIndex_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_16(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_ControlResourceSet_cce_REG_MappingType_interleaved(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_ControlResourceSet_cce_REG_MappingType_interleaved* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->reg_BundleSize = (SQN_NR_ControlResourceSet_cce_REG_MappingType_interleaved_reg_BundleSize_e)_tmp;
	}
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->interleaverSize = (SQN_NR_ControlResourceSet_cce_REG_MappingType_interleaved_interleaverSize_e)_tmp;
	}
	_serNrSysDecUint16_t_SQN_NR_ControlResourceSet_cce_REG_MappingType_interleaved_shiftIndex_Optional(_buffer, _size, _lidx, &p->shiftIndex);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_ControlResourceSet_cce_REG_MappingType_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union SQN_NR_ControlResourceSet_cce_REG_MappingType_Value* p, enum SQN_NR_ControlResourceSet_cce_REG_MappingType_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_ControlResourceSet_cce_REG_MappingType_interleaved) {
		_serNrSysDecSQN_NR_ControlResourceSet_cce_REG_MappingType_interleaved(_buffer, _size, _lidx, &p->interleaved);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_ControlResourceSet_cce_REG_MappingType_nonInterleaved) {
		NTOH_8(p->nonInterleaved, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecSQN_NR_ControlResourceSet_cce_REG_MappingType(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_ControlResourceSet_cce_REG_MappingType* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SQN_NR_ControlResourceSet_cce_REG_MappingType_Sel)_tmp;
	}
	_serNrSysDecSQN_NR_ControlResourceSet_cce_REG_MappingType_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_TCI_StateId_SQN_NR_ControlResourceSet_tci_StatesPDCCH_ToAddList_DynamicOptional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_TCI_StateId_SQN_NR_ControlResourceSet_tci_StatesPDCCH_ToAddList_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = (SQN_NR_TCI_StateId*)serMalloc(_mem, p->v.d * sizeof(SQN_NR_TCI_StateId));
	for (size_t i3 = 0; i3 < p->v.d; i3++) {
		NTOH_8(p->v.v[i3], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_TCI_StateId_SQN_NR_ControlResourceSet_tci_StatesPDCCH_ToReleaseList_DynamicOptional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_TCI_StateId_SQN_NR_ControlResourceSet_tci_StatesPDCCH_ToReleaseList_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = (SQN_NR_TCI_StateId*)serMalloc(_mem, p->v.d * sizeof(SQN_NR_TCI_StateId));
	for (size_t i3 = 0; i3 < p->v.d; i3++) {
		NTOH_8(p->v.v[i3], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_ControlResourceSet_tci_PresentInDCI_e_tci_PresentInDCI_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_ControlResourceSet_tci_PresentInDCI_e_tci_PresentInDCI_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_ControlResourceSet_tci_PresentInDCI_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecUint16_t_SQN_NR_ControlResourceSet_pdcch_DMRS_ScramblingID_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct uint16_t_SQN_NR_ControlResourceSet_pdcch_DMRS_ScramblingID_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_16(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecUint8_t_SQN_NR_ControlResourceSet_rb_Offset_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct uint8_t_SQN_NR_ControlResourceSet_rb_Offset_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecUint8_t_SQN_NR_ControlResourceSet_tci_PresentDCI_1_2_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct uint8_t_SQN_NR_ControlResourceSet_tci_PresentDCI_1_2_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecUint8_t_SQN_NR_ControlResourceSet_coresetPoolIndex_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct uint8_t_SQN_NR_ControlResourceSet_coresetPoolIndex_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_ControlResourceSetId_v1610_SQN_NR_ControlResourceSet_controlResourceSetId_v1610_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_ControlResourceSetId_v1610_SQN_NR_ControlResourceSet_controlResourceSetId_v1610_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_ControlResourceSet(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_ControlResourceSet* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->controlResourceSetId, &_buffer[*_lidx], _lidx);
	for (size_t i3 = 0; i3 < 45; i3++) {
		NTOH_8(p->frequencyDomainResources[i3], &_buffer[*_lidx], _lidx);
	}
	NTOH_8(p->duration, &_buffer[*_lidx], _lidx);
	_serNrSysDecSQN_NR_ControlResourceSet_cce_REG_MappingType(_buffer, _size, _lidx, &p->cce_REG_MappingType);
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->precoderGranularity = (SQN_NR_ControlResourceSet_precoderGranularity_e)_tmp;
	}
	_serNrSysDecSQN_NR_TCI_StateId_SQN_NR_ControlResourceSet_tci_StatesPDCCH_ToAddList_DynamicOptional(_buffer, _size, _lidx, _mem, &p->tci_StatesPDCCH_ToAddList);
	_serNrSysDecSQN_NR_TCI_StateId_SQN_NR_ControlResourceSet_tci_StatesPDCCH_ToReleaseList_DynamicOptional(_buffer, _size, _lidx, _mem, &p->tci_StatesPDCCH_ToReleaseList);
	_serNrSysDecSQN_NR_ControlResourceSet_tci_PresentInDCI_e_tci_PresentInDCI_Optional(_buffer, _size, _lidx, &p->tci_PresentInDCI);
	_serNrSysDecUint16_t_SQN_NR_ControlResourceSet_pdcch_DMRS_ScramblingID_Optional(_buffer, _size, _lidx, &p->pdcch_DMRS_ScramblingID);
	_serNrSysDecUint8_t_SQN_NR_ControlResourceSet_rb_Offset_r16_Optional(_buffer, _size, _lidx, &p->rb_Offset_r16);
	_serNrSysDecUint8_t_SQN_NR_ControlResourceSet_tci_PresentDCI_1_2_r16_Optional(_buffer, _size, _lidx, &p->tci_PresentDCI_1_2_r16);
	_serNrSysDecUint8_t_SQN_NR_ControlResourceSet_coresetPoolIndex_r16_Optional(_buffer, _size, _lidx, &p->coresetPoolIndex_r16);
	_serNrSysDecSQN_NR_ControlResourceSetId_v1610_SQN_NR_ControlResourceSet_controlResourceSetId_v1610_Optional(_buffer, _size, _lidx, &p->controlResourceSetId_v1610);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_ASN1_ControlResourceSet_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union NR_ASN1_ControlResourceSet_Type_Value* p, enum NR_ASN1_ControlResourceSet_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_ASN1_ControlResourceSet_Type_R15) {
		_serNrSysDecSQN_NR_ControlResourceSet(_buffer, _size, _lidx, _mem, &p->R15);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecNR_ASN1_ControlResourceSet_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_ASN1_ControlResourceSet_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum NR_ASN1_ControlResourceSet_Type_Sel)_tmp;
	}
	_serNrSysDecNR_ASN1_ControlResourceSet_Type_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_BWP_CoresetList_Type_CoresetArray_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_BWP_CoresetList_Type_CoresetArray_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = (struct NR_ASN1_ControlResourceSet_Type*)serMalloc(_mem, p->v.d * sizeof(struct NR_ASN1_ControlResourceSet_Type));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serNrSysDecNR_ASN1_ControlResourceSet_Type(_buffer, _size, _lidx, _mem, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_EPRE_Ratio_Type_PdcchToCell_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_EPRE_Ratio_Type_PdcchToCell_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_EPRE_Ratio_Type_PdcchToDmrs_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_EPRE_Ratio_Type_PdcchToDmrs_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_PDCCH_EPREs_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_PDCCH_EPREs_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecNR_EPRE_Ratio_Type_PdcchToCell_Optional(_buffer, _size, _lidx, &p->PdcchToCell);
	_serNrSysDecNR_EPRE_Ratio_Type_PdcchToDmrs_Optional(_buffer, _size, _lidx, &p->PdcchToDmrs);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_PDCCH_EPREs_Type_RelativeTxPower_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_PDCCH_EPREs_Type_RelativeTxPower_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecNR_PDCCH_EPREs_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecInt32_t_NR_BWP_PDCCH_Configuration_Type_Coreset0_OffsetRBs_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct int32_t_NR_BWP_PDCCH_Configuration_Type_Coreset0_OffsetRBs_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_BWP_PDCCH_Configuration_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_BWP_PDCCH_Configuration_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecNR_BWP_SearchSpaceList_Type_SearchSpaceArray_Optional(_buffer, _size, _lidx, _mem, &p->SearchSpaceArray);
	_serNrSysDecNR_BWP_CoresetList_Type_CoresetArray_Optional(_buffer, _size, _lidx, _mem, &p->CoresetArray);
	_serNrSysDecNR_PDCCH_EPREs_Type_RelativeTxPower_Optional(_buffer, _size, _lidx, &p->RelativeTxPower);
	_serNrSysDecInt32_t_NR_BWP_PDCCH_Configuration_Type_Coreset0_OffsetRBs_Optional(_buffer, _size, _lidx, &p->Coreset0_OffsetRBs);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_BWP_PDCCH_Configuration_Type_Pdcch_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_BWP_PDCCH_Configuration_Type_Pdcch_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecNR_BWP_PDCCH_Configuration_Type(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecUint8_t_SQN_NR_PDSCH_TimeDomainResourceAllocation_k0_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct uint8_t_SQN_NR_PDSCH_TimeDomainResourceAllocation_k0_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PDSCH_TimeDomainResourceAllocation(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_PDSCH_TimeDomainResourceAllocation* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecUint8_t_SQN_NR_PDSCH_TimeDomainResourceAllocation_k0_Optional(_buffer, _size, _lidx, &p->k0);
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->mappingType = (SQN_NR_PDSCH_TimeDomainResourceAllocation_mappingType_e)_tmp;
	}
	NTOH_8(p->startSymbolAndLength, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PDSCH_TimeDomainResourceAllocationList_SQN_NR_PDSCH_ConfigCommon_pdsch_TimeDomainAllocationList_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_PDSCH_TimeDomainResourceAllocationList_SQN_NR_PDSCH_ConfigCommon_pdsch_TimeDomainAllocationList_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = (struct SQN_NR_PDSCH_TimeDomainResourceAllocation*)serMalloc(_mem, p->v.d * sizeof(struct SQN_NR_PDSCH_TimeDomainResourceAllocation));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serNrSysDecSQN_NR_PDSCH_TimeDomainResourceAllocation(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PDSCH_ConfigCommon(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_PDSCH_ConfigCommon* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecSQN_NR_PDSCH_TimeDomainResourceAllocationList_SQN_NR_PDSCH_ConfigCommon_pdsch_TimeDomainAllocationList_Optional(_buffer, _size, _lidx, _mem, &p->pdsch_TimeDomainAllocationList);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_ASN1_PDSCH_ConfigCommon_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union NR_ASN1_PDSCH_ConfigCommon_Type_Value* p, enum NR_ASN1_PDSCH_ConfigCommon_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_ASN1_PDSCH_ConfigCommon_Type_R15) {
		_serNrSysDecSQN_NR_PDSCH_ConfigCommon(_buffer, _size, _lidx, _mem, &p->R15);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecNR_ASN1_PDSCH_ConfigCommon_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_ASN1_PDSCH_ConfigCommon_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum NR_ASN1_PDSCH_ConfigCommon_Type_Sel)_tmp;
	}
	_serNrSysDecNR_ASN1_PDSCH_ConfigCommon_Type_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_ASN1_PDSCH_ConfigCommon_Type_ConfigCommon_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_ASN1_PDSCH_ConfigCommon_Type_ConfigCommon_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecNR_ASN1_PDSCH_ConfigCommon_Type(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecUint16_t_SQN_NR_PDSCH_Config_dataScramblingIdentityPDSCH_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct uint16_t_SQN_NR_PDSCH_Config_dataScramblingIdentityPDSCH_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_16(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_DMRS_DownlinkConfig_dmrs_Type_e_dmrs_Type_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_DMRS_DownlinkConfig_dmrs_Type_e_dmrs_Type_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_DMRS_DownlinkConfig_dmrs_Type_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_DMRS_DownlinkConfig_dmrs_AdditionalPosition_e_dmrs_AdditionalPosition_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_DMRS_DownlinkConfig_dmrs_AdditionalPosition_e_dmrs_AdditionalPosition_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_DMRS_DownlinkConfig_dmrs_AdditionalPosition_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_DMRS_DownlinkConfig_maxLength_e_maxLength_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_DMRS_DownlinkConfig_maxLength_e_maxLength_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_DMRS_DownlinkConfig_maxLength_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecUint16_t_SQN_NR_DMRS_DownlinkConfig_scramblingID0_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct uint16_t_SQN_NR_DMRS_DownlinkConfig_scramblingID0_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_16(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecUint16_t_SQN_NR_DMRS_DownlinkConfig_scramblingID1_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct uint16_t_SQN_NR_DMRS_DownlinkConfig_scramblingID1_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_16(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecUint16_t_SQN_NR_PTRS_DownlinkConfig_frequencyDensity_ArrayOptional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct uint16_t_SQN_NR_PTRS_DownlinkConfig_frequencyDensity_ArrayOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	for (size_t i2 = 0; i2 < 2; i2++) {
		NTOH_16(p->v[i2], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecUint8_t_SQN_NR_PTRS_DownlinkConfig_timeDensity_ArrayOptional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct uint8_t_SQN_NR_PTRS_DownlinkConfig_timeDensity_ArrayOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	for (size_t i2 = 0; i2 < 3; i2++) {
		NTOH_8(p->v[i2], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecUint8_t_SQN_NR_PTRS_DownlinkConfig_epre_Ratio_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct uint8_t_SQN_NR_PTRS_DownlinkConfig_epre_Ratio_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PTRS_DownlinkConfig_resourceElementOffset_e_resourceElementOffset_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_PTRS_DownlinkConfig_resourceElementOffset_e_resourceElementOffset_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_PTRS_DownlinkConfig_resourceElementOffset_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PTRS_DownlinkConfig_maxNrofPorts_r16_e_maxNrofPorts_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_PTRS_DownlinkConfig_maxNrofPorts_r16_e_maxNrofPorts_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_PTRS_DownlinkConfig_maxNrofPorts_r16_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PTRS_DownlinkConfig(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_PTRS_DownlinkConfig* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecUint16_t_SQN_NR_PTRS_DownlinkConfig_frequencyDensity_ArrayOptional(_buffer, _size, _lidx, &p->frequencyDensity);
	_serNrSysDecUint8_t_SQN_NR_PTRS_DownlinkConfig_timeDensity_ArrayOptional(_buffer, _size, _lidx, &p->timeDensity);
	_serNrSysDecUint8_t_SQN_NR_PTRS_DownlinkConfig_epre_Ratio_Optional(_buffer, _size, _lidx, &p->epre_Ratio);
	_serNrSysDecSQN_NR_PTRS_DownlinkConfig_resourceElementOffset_e_resourceElementOffset_Optional(_buffer, _size, _lidx, &p->resourceElementOffset);
	_serNrSysDecSQN_NR_PTRS_DownlinkConfig_maxNrofPorts_r16_e_maxNrofPorts_r16_Optional(_buffer, _size, _lidx, &p->maxNrofPorts_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SetupRelease_DMRS_DownlinkConfig_phaseTrackingRS_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union SQN_NR_SetupRelease_DMRS_DownlinkConfig_phaseTrackingRS_Value* p, enum SQN_NR_SetupRelease_DMRS_DownlinkConfig_phaseTrackingRS_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SetupRelease_DMRS_DownlinkConfig_phaseTrackingRS_release) {
		NTOH_8(p->release, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SetupRelease_DMRS_DownlinkConfig_phaseTrackingRS_setup) {
		_serNrSysDecSQN_NR_PTRS_DownlinkConfig(_buffer, _size, _lidx, &p->setup);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecSQN_NR_SetupRelease_DMRS_DownlinkConfig_phaseTrackingRS(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SetupRelease_DMRS_DownlinkConfig_phaseTrackingRS* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SQN_NR_SetupRelease_DMRS_DownlinkConfig_phaseTrackingRS_Sel)_tmp;
	}
	_serNrSysDecSQN_NR_SetupRelease_DMRS_DownlinkConfig_phaseTrackingRS_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SetupRelease_DMRS_DownlinkConfig_phaseTrackingRS_SQN_NR_DMRS_DownlinkConfig_phaseTrackingRS_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SetupRelease_DMRS_DownlinkConfig_phaseTrackingRS_SQN_NR_DMRS_DownlinkConfig_phaseTrackingRS_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_SetupRelease_DMRS_DownlinkConfig_phaseTrackingRS(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_DMRS_DownlinkConfig_dmrs_Downlink_r16_e_dmrs_Downlink_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_DMRS_DownlinkConfig_dmrs_Downlink_r16_e_dmrs_Downlink_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_DMRS_DownlinkConfig_dmrs_Downlink_r16_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_DMRS_DownlinkConfig(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_DMRS_DownlinkConfig* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecSQN_NR_DMRS_DownlinkConfig_dmrs_Type_e_dmrs_Type_Optional(_buffer, _size, _lidx, &p->dmrs_Type);
	_serNrSysDecSQN_NR_DMRS_DownlinkConfig_dmrs_AdditionalPosition_e_dmrs_AdditionalPosition_Optional(_buffer, _size, _lidx, &p->dmrs_AdditionalPosition);
	_serNrSysDecSQN_NR_DMRS_DownlinkConfig_maxLength_e_maxLength_Optional(_buffer, _size, _lidx, &p->maxLength);
	_serNrSysDecUint16_t_SQN_NR_DMRS_DownlinkConfig_scramblingID0_Optional(_buffer, _size, _lidx, &p->scramblingID0);
	_serNrSysDecUint16_t_SQN_NR_DMRS_DownlinkConfig_scramblingID1_Optional(_buffer, _size, _lidx, &p->scramblingID1);
	_serNrSysDecSQN_NR_SetupRelease_DMRS_DownlinkConfig_phaseTrackingRS_SQN_NR_DMRS_DownlinkConfig_phaseTrackingRS_Optional(_buffer, _size, _lidx, &p->phaseTrackingRS);
	_serNrSysDecSQN_NR_DMRS_DownlinkConfig_dmrs_Downlink_r16_e_dmrs_Downlink_r16_Optional(_buffer, _size, _lidx, &p->dmrs_Downlink_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SetupRelease_PDSCH_Config_dmrs_DownlinkForPDSCH_MappingTypeA_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union SQN_NR_SetupRelease_PDSCH_Config_dmrs_DownlinkForPDSCH_MappingTypeA_Value* p, enum SQN_NR_SetupRelease_PDSCH_Config_dmrs_DownlinkForPDSCH_MappingTypeA_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SetupRelease_PDSCH_Config_dmrs_DownlinkForPDSCH_MappingTypeA_release) {
		NTOH_8(p->release, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SetupRelease_PDSCH_Config_dmrs_DownlinkForPDSCH_MappingTypeA_setup) {
		_serNrSysDecSQN_NR_DMRS_DownlinkConfig(_buffer, _size, _lidx, &p->setup);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecSQN_NR_SetupRelease_PDSCH_Config_dmrs_DownlinkForPDSCH_MappingTypeA(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SetupRelease_PDSCH_Config_dmrs_DownlinkForPDSCH_MappingTypeA* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SQN_NR_SetupRelease_PDSCH_Config_dmrs_DownlinkForPDSCH_MappingTypeA_Sel)_tmp;
	}
	_serNrSysDecSQN_NR_SetupRelease_PDSCH_Config_dmrs_DownlinkForPDSCH_MappingTypeA_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SetupRelease_PDSCH_Config_dmrs_DownlinkForPDSCH_MappingTypeA_SQN_NR_PDSCH_Config_dmrs_DownlinkForPDSCH_MappingTypeA_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SetupRelease_PDSCH_Config_dmrs_DownlinkForPDSCH_MappingTypeA_SQN_NR_PDSCH_Config_dmrs_DownlinkForPDSCH_MappingTypeA_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_SetupRelease_PDSCH_Config_dmrs_DownlinkForPDSCH_MappingTypeA(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SetupRelease_PDSCH_Config_dmrs_DownlinkForPDSCH_MappingTypeB_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union SQN_NR_SetupRelease_PDSCH_Config_dmrs_DownlinkForPDSCH_MappingTypeB_Value* p, enum SQN_NR_SetupRelease_PDSCH_Config_dmrs_DownlinkForPDSCH_MappingTypeB_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SetupRelease_PDSCH_Config_dmrs_DownlinkForPDSCH_MappingTypeB_release) {
		NTOH_8(p->release, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SetupRelease_PDSCH_Config_dmrs_DownlinkForPDSCH_MappingTypeB_setup) {
		_serNrSysDecSQN_NR_DMRS_DownlinkConfig(_buffer, _size, _lidx, &p->setup);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecSQN_NR_SetupRelease_PDSCH_Config_dmrs_DownlinkForPDSCH_MappingTypeB(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SetupRelease_PDSCH_Config_dmrs_DownlinkForPDSCH_MappingTypeB* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SQN_NR_SetupRelease_PDSCH_Config_dmrs_DownlinkForPDSCH_MappingTypeB_Sel)_tmp;
	}
	_serNrSysDecSQN_NR_SetupRelease_PDSCH_Config_dmrs_DownlinkForPDSCH_MappingTypeB_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SetupRelease_PDSCH_Config_dmrs_DownlinkForPDSCH_MappingTypeB_SQN_NR_PDSCH_Config_dmrs_DownlinkForPDSCH_MappingTypeB_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SetupRelease_PDSCH_Config_dmrs_DownlinkForPDSCH_MappingTypeB_SQN_NR_PDSCH_Config_dmrs_DownlinkForPDSCH_MappingTypeB_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_SetupRelease_PDSCH_Config_dmrs_DownlinkForPDSCH_MappingTypeB(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_ServCellIndex_SQN_NR_QCL_Info_cell_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_ServCellIndex_SQN_NR_QCL_Info_cell_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_BWP_Id_SQN_NR_QCL_Info_bwp_Id_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_BWP_Id_SQN_NR_QCL_Info_bwp_Id_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_QCL_Info_referenceSignal_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union SQN_NR_QCL_Info_referenceSignal_Value* p, enum SQN_NR_QCL_Info_referenceSignal_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_QCL_Info_referenceSignal_csi_rs) {
		NTOH_8(p->csi_rs, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_QCL_Info_referenceSignal_ssb) {
		NTOH_8(p->ssb, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecSQN_NR_QCL_Info_referenceSignal(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_QCL_Info_referenceSignal* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SQN_NR_QCL_Info_referenceSignal_Sel)_tmp;
	}
	_serNrSysDecSQN_NR_QCL_Info_referenceSignal_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_QCL_Info(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_QCL_Info* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecSQN_NR_ServCellIndex_SQN_NR_QCL_Info_cell_Optional(_buffer, _size, _lidx, &p->cell);
	_serNrSysDecSQN_NR_BWP_Id_SQN_NR_QCL_Info_bwp_Id_Optional(_buffer, _size, _lidx, &p->bwp_Id);
	_serNrSysDecSQN_NR_QCL_Info_referenceSignal(_buffer, _size, _lidx, &p->referenceSignal);
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->qcl_Type = (SQN_NR_QCL_Info_qcl_Type_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_QCL_Info_SQN_NR_TCI_State_qcl_Type2_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_QCL_Info_SQN_NR_TCI_State_qcl_Type2_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_QCL_Info(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_TCI_State(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_TCI_State* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->tci_StateId, &_buffer[*_lidx], _lidx);
	_serNrSysDecSQN_NR_QCL_Info(_buffer, _size, _lidx, &p->qcl_Type1);
	_serNrSysDecSQN_NR_QCL_Info_SQN_NR_TCI_State_qcl_Type2_Optional(_buffer, _size, _lidx, &p->qcl_Type2);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_TCI_State_SQN_NR_PDSCH_Config_tci_StatesToAddModList_DynamicOptional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_TCI_State_SQN_NR_PDSCH_Config_tci_StatesToAddModList_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = (struct SQN_NR_TCI_State*)serMalloc(_mem, p->v.d * sizeof(struct SQN_NR_TCI_State));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serNrSysDecSQN_NR_TCI_State(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_TCI_StateId_SQN_NR_PDSCH_Config_tci_StatesToReleaseList_DynamicOptional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_TCI_StateId_SQN_NR_PDSCH_Config_tci_StatesToReleaseList_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = (SQN_NR_TCI_StateId*)serMalloc(_mem, p->v.d * sizeof(SQN_NR_TCI_StateId));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		NTOH_8(p->v.v[i2], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PDSCH_Config_vrb_ToPRB_Interleaver_e_vrb_ToPRB_Interleaver_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_PDSCH_Config_vrb_ToPRB_Interleaver_e_vrb_ToPRB_Interleaver_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_PDSCH_Config_vrb_ToPRB_Interleaver_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SetupRelease_PDSCH_Config_pdsch_TimeDomainAllocationList_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union SQN_NR_SetupRelease_PDSCH_Config_pdsch_TimeDomainAllocationList_Value* p, enum SQN_NR_SetupRelease_PDSCH_Config_pdsch_TimeDomainAllocationList_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SetupRelease_PDSCH_Config_pdsch_TimeDomainAllocationList_release) {
		NTOH_8(p->release, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SetupRelease_PDSCH_Config_pdsch_TimeDomainAllocationList_setup) {
		NTOH_32(p->setup.d, &_buffer[*_lidx], _lidx);
		p->setup.v = (struct SQN_NR_PDSCH_TimeDomainResourceAllocation*)serMalloc(_mem, p->setup.d * sizeof(struct SQN_NR_PDSCH_TimeDomainResourceAllocation));
		for (size_t i2 = 0; i2 < p->setup.d; i2++) {
			_serNrSysDecSQN_NR_PDSCH_TimeDomainResourceAllocation(_buffer, _size, _lidx, &p->setup.v[i2]);
		}
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecSQN_NR_SetupRelease_PDSCH_Config_pdsch_TimeDomainAllocationList(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_SetupRelease_PDSCH_Config_pdsch_TimeDomainAllocationList* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SQN_NR_SetupRelease_PDSCH_Config_pdsch_TimeDomainAllocationList_Sel)_tmp;
	}
	_serNrSysDecSQN_NR_SetupRelease_PDSCH_Config_pdsch_TimeDomainAllocationList_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SetupRelease_PDSCH_Config_pdsch_TimeDomainAllocationList_SQN_NR_PDSCH_Config_pdsch_TimeDomainAllocationList_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_SetupRelease_PDSCH_Config_pdsch_TimeDomainAllocationList_SQN_NR_PDSCH_Config_pdsch_TimeDomainAllocationList_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_SetupRelease_PDSCH_Config_pdsch_TimeDomainAllocationList(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PDSCH_Config_pdsch_AggregationFactor_e_pdsch_AggregationFactor_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_PDSCH_Config_pdsch_AggregationFactor_e_pdsch_AggregationFactor_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_PDSCH_Config_pdsch_AggregationFactor_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_RateMatchPattern_SQN_NR_PDSCH_Config_rateMatchPatternToAddModList_DynamicOptional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_RateMatchPattern_SQN_NR_PDSCH_Config_rateMatchPatternToAddModList_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = (struct SQN_NR_RateMatchPattern*)serMalloc(_mem, p->v.d * sizeof(struct SQN_NR_RateMatchPattern));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serNrSysDecSQN_NR_RateMatchPattern(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_RateMatchPatternId_SQN_NR_PDSCH_Config_rateMatchPatternToReleaseList_DynamicOptional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_RateMatchPatternId_SQN_NR_PDSCH_Config_rateMatchPatternToReleaseList_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = (SQN_NR_RateMatchPatternId*)serMalloc(_mem, p->v.d * sizeof(SQN_NR_RateMatchPatternId));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		NTOH_8(p->v.v[i2], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_RateMatchPatternGroup_s_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union SQN_NR_RateMatchPatternGroup_s_Value* p, enum SQN_NR_RateMatchPatternGroup_s_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_RateMatchPatternGroup_s_cellLevel) {
		NTOH_8(p->cellLevel, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_RateMatchPatternGroup_s_bwpLevel) {
		NTOH_8(p->bwpLevel, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecSQN_NR_RateMatchPatternGroup_s(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_RateMatchPatternGroup_s* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SQN_NR_RateMatchPatternGroup_s_Sel)_tmp;
	}
	_serNrSysDecSQN_NR_RateMatchPatternGroup_s_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_RateMatchPatternGroup_SQN_NR_PDSCH_Config_rateMatchPatternGroup1_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_RateMatchPatternGroup_SQN_NR_PDSCH_Config_rateMatchPatternGroup1_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = (struct SQN_NR_RateMatchPatternGroup_s*)serMalloc(_mem, p->v.d * sizeof(struct SQN_NR_RateMatchPatternGroup_s));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serNrSysDecSQN_NR_RateMatchPatternGroup_s(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_RateMatchPatternGroup_SQN_NR_PDSCH_Config_rateMatchPatternGroup2_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_RateMatchPatternGroup_SQN_NR_PDSCH_Config_rateMatchPatternGroup2_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = (struct SQN_NR_RateMatchPatternGroup_s*)serMalloc(_mem, p->v.d * sizeof(struct SQN_NR_RateMatchPatternGroup_s));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serNrSysDecSQN_NR_RateMatchPatternGroup_s(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PDSCH_Config_mcs_Table_e_mcs_Table_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_PDSCH_Config_mcs_Table_e_mcs_Table_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_PDSCH_Config_mcs_Table_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PDSCH_Config_maxNrofCodeWordsScheduledByDCI_e_maxNrofCodeWordsScheduledByDCI_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_PDSCH_Config_maxNrofCodeWordsScheduledByDCI_e_maxNrofCodeWordsScheduledByDCI_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_PDSCH_Config_maxNrofCodeWordsScheduledByDCI_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PDSCH_Config_prb_BundlingType_staticBundling_bundleSize_e_bundleSize_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_PDSCH_Config_prb_BundlingType_staticBundling_bundleSize_e_bundleSize_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_PDSCH_Config_prb_BundlingType_staticBundling_bundleSize_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PDSCH_Config_prb_BundlingType_staticBundling(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_PDSCH_Config_prb_BundlingType_staticBundling* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecSQN_NR_PDSCH_Config_prb_BundlingType_staticBundling_bundleSize_e_bundleSize_Optional(_buffer, _size, _lidx, &p->bundleSize);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PDSCH_Config_prb_BundlingType_dynamicBundling_bundleSizeSet1_e_bundleSizeSet1_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_PDSCH_Config_prb_BundlingType_dynamicBundling_bundleSizeSet1_e_bundleSizeSet1_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_PDSCH_Config_prb_BundlingType_dynamicBundling_bundleSizeSet1_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PDSCH_Config_prb_BundlingType_dynamicBundling_bundleSizeSet2_e_bundleSizeSet2_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_PDSCH_Config_prb_BundlingType_dynamicBundling_bundleSizeSet2_e_bundleSizeSet2_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_PDSCH_Config_prb_BundlingType_dynamicBundling_bundleSizeSet2_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PDSCH_Config_prb_BundlingType_dynamicBundling(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_PDSCH_Config_prb_BundlingType_dynamicBundling* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecSQN_NR_PDSCH_Config_prb_BundlingType_dynamicBundling_bundleSizeSet1_e_bundleSizeSet1_Optional(_buffer, _size, _lidx, &p->bundleSizeSet1);
	_serNrSysDecSQN_NR_PDSCH_Config_prb_BundlingType_dynamicBundling_bundleSizeSet2_e_bundleSizeSet2_Optional(_buffer, _size, _lidx, &p->bundleSizeSet2);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PDSCH_Config_prb_BundlingType_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union SQN_NR_PDSCH_Config_prb_BundlingType_Value* p, enum SQN_NR_PDSCH_Config_prb_BundlingType_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_PDSCH_Config_prb_BundlingType_staticBundling) {
		_serNrSysDecSQN_NR_PDSCH_Config_prb_BundlingType_staticBundling(_buffer, _size, _lidx, &p->staticBundling);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_PDSCH_Config_prb_BundlingType_dynamicBundling) {
		_serNrSysDecSQN_NR_PDSCH_Config_prb_BundlingType_dynamicBundling(_buffer, _size, _lidx, &p->dynamicBundling);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecSQN_NR_PDSCH_Config_prb_BundlingType(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_PDSCH_Config_prb_BundlingType* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SQN_NR_PDSCH_Config_prb_BundlingType_Sel)_tmp;
	}
	_serNrSysDecSQN_NR_PDSCH_Config_prb_BundlingType_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_CSI_RS_ResourceMapping_frequencyDomainAllocation_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union SQN_NR_CSI_RS_ResourceMapping_frequencyDomainAllocation_Value* p, enum SQN_NR_CSI_RS_ResourceMapping_frequencyDomainAllocation_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_CSI_RS_ResourceMapping_frequencyDomainAllocation_row1) {
		for (size_t i3 = 0; i3 < 4; i3++) {
			NTOH_8(p->row1[i3], &_buffer[*_lidx], _lidx);
		}
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_CSI_RS_ResourceMapping_frequencyDomainAllocation_row2) {
		for (size_t i3 = 0; i3 < 12; i3++) {
			NTOH_8(p->row2[i3], &_buffer[*_lidx], _lidx);
		}
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_CSI_RS_ResourceMapping_frequencyDomainAllocation_row4) {
		for (size_t i3 = 0; i3 < 3; i3++) {
			NTOH_8(p->row4[i3], &_buffer[*_lidx], _lidx);
		}
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_CSI_RS_ResourceMapping_frequencyDomainAllocation_other) {
		for (size_t i3 = 0; i3 < 6; i3++) {
			NTOH_8(p->other[i3], &_buffer[*_lidx], _lidx);
		}
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecSQN_NR_CSI_RS_ResourceMapping_frequencyDomainAllocation(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_CSI_RS_ResourceMapping_frequencyDomainAllocation* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SQN_NR_CSI_RS_ResourceMapping_frequencyDomainAllocation_Sel)_tmp;
	}
	_serNrSysDecSQN_NR_CSI_RS_ResourceMapping_frequencyDomainAllocation_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecUint8_t_SQN_NR_CSI_RS_ResourceMapping_firstOFDMSymbolInTimeDomain2_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct uint8_t_SQN_NR_CSI_RS_ResourceMapping_firstOFDMSymbolInTimeDomain2_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_CSI_RS_ResourceMapping_density_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union SQN_NR_CSI_RS_ResourceMapping_density_Value* p, enum SQN_NR_CSI_RS_ResourceMapping_density_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_CSI_RS_ResourceMapping_density_dot5) {
		{
			size_t _tmp;
			NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
			p->dot5 = (SQN_NR_CSI_RS_ResourceMapping_density_dot5_e)_tmp;
		}
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_CSI_RS_ResourceMapping_density_one) {
		NTOH_8(p->one, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_CSI_RS_ResourceMapping_density_three) {
		NTOH_8(p->three, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_CSI_RS_ResourceMapping_density_spare) {
		NTOH_8(p->spare, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecSQN_NR_CSI_RS_ResourceMapping_density(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_CSI_RS_ResourceMapping_density* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SQN_NR_CSI_RS_ResourceMapping_density_Sel)_tmp;
	}
	_serNrSysDecSQN_NR_CSI_RS_ResourceMapping_density_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_CSI_FrequencyOccupation(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_CSI_FrequencyOccupation* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_16(p->startingRB, &_buffer[*_lidx], _lidx);
	NTOH_16(p->nrofRBs, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_CSI_RS_ResourceMapping(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_CSI_RS_ResourceMapping* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecSQN_NR_CSI_RS_ResourceMapping_frequencyDomainAllocation(_buffer, _size, _lidx, &p->frequencyDomainAllocation);
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->nrofPorts = (SQN_NR_CSI_RS_ResourceMapping_nrofPorts_e)_tmp;
	}
	NTOH_8(p->firstOFDMSymbolInTimeDomain, &_buffer[*_lidx], _lidx);
	_serNrSysDecUint8_t_SQN_NR_CSI_RS_ResourceMapping_firstOFDMSymbolInTimeDomain2_Optional(_buffer, _size, _lidx, &p->firstOFDMSymbolInTimeDomain2);
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->cdm_Type = (SQN_NR_CSI_RS_ResourceMapping_cdm_Type_e)_tmp;
	}
	_serNrSysDecSQN_NR_CSI_RS_ResourceMapping_density(_buffer, _size, _lidx, &p->density);
	_serNrSysDecSQN_NR_CSI_FrequencyOccupation(_buffer, _size, _lidx, &p->freqBand);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_CSI_ResourcePeriodicityAndOffset_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union SQN_NR_CSI_ResourcePeriodicityAndOffset_Value* p, enum SQN_NR_CSI_ResourcePeriodicityAndOffset_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_CSI_ResourcePeriodicityAndOffset_slots4) {
		NTOH_8(p->slots4, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_CSI_ResourcePeriodicityAndOffset_slots5) {
		NTOH_8(p->slots5, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_CSI_ResourcePeriodicityAndOffset_slots8) {
		NTOH_8(p->slots8, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_CSI_ResourcePeriodicityAndOffset_slots10) {
		NTOH_8(p->slots10, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_CSI_ResourcePeriodicityAndOffset_slots16) {
		NTOH_8(p->slots16, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_CSI_ResourcePeriodicityAndOffset_slots20) {
		NTOH_8(p->slots20, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_CSI_ResourcePeriodicityAndOffset_slots32) {
		NTOH_8(p->slots32, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_CSI_ResourcePeriodicityAndOffset_slots40) {
		NTOH_8(p->slots40, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_CSI_ResourcePeriodicityAndOffset_slots64) {
		NTOH_8(p->slots64, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_CSI_ResourcePeriodicityAndOffset_slots80) {
		NTOH_8(p->slots80, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_CSI_ResourcePeriodicityAndOffset_slots160) {
		NTOH_8(p->slots160, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_CSI_ResourcePeriodicityAndOffset_slots320) {
		NTOH_16(p->slots320, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_CSI_ResourcePeriodicityAndOffset_slots640) {
		NTOH_16(p->slots640, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecSQN_NR_CSI_ResourcePeriodicityAndOffset(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_CSI_ResourcePeriodicityAndOffset* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SQN_NR_CSI_ResourcePeriodicityAndOffset_Sel)_tmp;
	}
	_serNrSysDecSQN_NR_CSI_ResourcePeriodicityAndOffset_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_CSI_ResourcePeriodicityAndOffset_SQN_NR_ZP_CSI_RS_Resource_periodicityAndOffset_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_CSI_ResourcePeriodicityAndOffset_SQN_NR_ZP_CSI_RS_Resource_periodicityAndOffset_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_CSI_ResourcePeriodicityAndOffset(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_ZP_CSI_RS_Resource(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_ZP_CSI_RS_Resource* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->zp_CSI_RS_ResourceId, &_buffer[*_lidx], _lidx);
	_serNrSysDecSQN_NR_CSI_RS_ResourceMapping(_buffer, _size, _lidx, &p->resourceMapping);
	_serNrSysDecSQN_NR_CSI_ResourcePeriodicityAndOffset_SQN_NR_ZP_CSI_RS_Resource_periodicityAndOffset_Optional(_buffer, _size, _lidx, &p->periodicityAndOffset);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_ZP_CSI_RS_Resource_SQN_NR_PDSCH_Config_zp_CSI_RS_ResourceToAddModList_DynamicOptional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_ZP_CSI_RS_Resource_SQN_NR_PDSCH_Config_zp_CSI_RS_ResourceToAddModList_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = (struct SQN_NR_ZP_CSI_RS_Resource*)serMalloc(_mem, p->v.d * sizeof(struct SQN_NR_ZP_CSI_RS_Resource));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serNrSysDecSQN_NR_ZP_CSI_RS_Resource(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_ZP_CSI_RS_ResourceId_SQN_NR_PDSCH_Config_zp_CSI_RS_ResourceToReleaseList_DynamicOptional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_ZP_CSI_RS_ResourceId_SQN_NR_PDSCH_Config_zp_CSI_RS_ResourceToReleaseList_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = (SQN_NR_ZP_CSI_RS_ResourceId*)serMalloc(_mem, p->v.d * sizeof(SQN_NR_ZP_CSI_RS_ResourceId));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		NTOH_8(p->v.v[i2], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_ZP_CSI_RS_ResourceSet(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_ZP_CSI_RS_ResourceSet* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->zp_CSI_RS_ResourceSetId, &_buffer[*_lidx], _lidx);
	NTOH_32(p->zp_CSI_RS_ResourceIdList.d, &_buffer[*_lidx], _lidx);
	p->zp_CSI_RS_ResourceIdList.v = (SQN_NR_ZP_CSI_RS_ResourceId*)serMalloc(_mem, p->zp_CSI_RS_ResourceIdList.d * sizeof(SQN_NR_ZP_CSI_RS_ResourceId));
	for (size_t i3 = 0; i3 < p->zp_CSI_RS_ResourceIdList.d; i3++) {
		NTOH_8(p->zp_CSI_RS_ResourceIdList.v[i3], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_ZP_CSI_RS_ResourceSet_SQN_NR_PDSCH_Config_aperiodic_ZP_CSI_RS_ResourceSetsToAddModList_DynamicOptional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_ZP_CSI_RS_ResourceSet_SQN_NR_PDSCH_Config_aperiodic_ZP_CSI_RS_ResourceSetsToAddModList_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = (struct SQN_NR_ZP_CSI_RS_ResourceSet*)serMalloc(_mem, p->v.d * sizeof(struct SQN_NR_ZP_CSI_RS_ResourceSet));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serNrSysDecSQN_NR_ZP_CSI_RS_ResourceSet(_buffer, _size, _lidx, _mem, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_ZP_CSI_RS_ResourceSetId_SQN_NR_PDSCH_Config_aperiodic_ZP_CSI_RS_ResourceSetsToReleaseList_DynamicOptional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_ZP_CSI_RS_ResourceSetId_SQN_NR_PDSCH_Config_aperiodic_ZP_CSI_RS_ResourceSetsToReleaseList_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = (SQN_NR_ZP_CSI_RS_ResourceSetId*)serMalloc(_mem, p->v.d * sizeof(SQN_NR_ZP_CSI_RS_ResourceSetId));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		NTOH_8(p->v.v[i2], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_ZP_CSI_RS_ResourceSet_SQN_NR_PDSCH_Config_sp_ZP_CSI_RS_ResourceSetsToAddModList_DynamicOptional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_ZP_CSI_RS_ResourceSet_SQN_NR_PDSCH_Config_sp_ZP_CSI_RS_ResourceSetsToAddModList_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = (struct SQN_NR_ZP_CSI_RS_ResourceSet*)serMalloc(_mem, p->v.d * sizeof(struct SQN_NR_ZP_CSI_RS_ResourceSet));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serNrSysDecSQN_NR_ZP_CSI_RS_ResourceSet(_buffer, _size, _lidx, _mem, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_ZP_CSI_RS_ResourceSetId_SQN_NR_PDSCH_Config_sp_ZP_CSI_RS_ResourceSetsToReleaseList_DynamicOptional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_ZP_CSI_RS_ResourceSetId_SQN_NR_PDSCH_Config_sp_ZP_CSI_RS_ResourceSetsToReleaseList_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = (SQN_NR_ZP_CSI_RS_ResourceSetId*)serMalloc(_mem, p->v.d * sizeof(SQN_NR_ZP_CSI_RS_ResourceSetId));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		NTOH_8(p->v.v[i2], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SetupRelease_PDSCH_Config_p_ZP_CSI_RS_ResourceSet_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union SQN_NR_SetupRelease_PDSCH_Config_p_ZP_CSI_RS_ResourceSet_Value* p, enum SQN_NR_SetupRelease_PDSCH_Config_p_ZP_CSI_RS_ResourceSet_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SetupRelease_PDSCH_Config_p_ZP_CSI_RS_ResourceSet_release) {
		NTOH_8(p->release, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SetupRelease_PDSCH_Config_p_ZP_CSI_RS_ResourceSet_setup) {
		_serNrSysDecSQN_NR_ZP_CSI_RS_ResourceSet(_buffer, _size, _lidx, _mem, &p->setup);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecSQN_NR_SetupRelease_PDSCH_Config_p_ZP_CSI_RS_ResourceSet(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_SetupRelease_PDSCH_Config_p_ZP_CSI_RS_ResourceSet* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SQN_NR_SetupRelease_PDSCH_Config_p_ZP_CSI_RS_ResourceSet_Sel)_tmp;
	}
	_serNrSysDecSQN_NR_SetupRelease_PDSCH_Config_p_ZP_CSI_RS_ResourceSet_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SetupRelease_PDSCH_Config_p_ZP_CSI_RS_ResourceSet_SQN_NR_PDSCH_Config_p_ZP_CSI_RS_ResourceSet_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_SetupRelease_PDSCH_Config_p_ZP_CSI_RS_ResourceSet_SQN_NR_PDSCH_Config_p_ZP_CSI_RS_ResourceSet_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_SetupRelease_PDSCH_Config_p_ZP_CSI_RS_ResourceSet(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SetupRelease_PDSCH_Config_maxMIMO_Layers_r16_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union SQN_NR_SetupRelease_PDSCH_Config_maxMIMO_Layers_r16_Value* p, enum SQN_NR_SetupRelease_PDSCH_Config_maxMIMO_Layers_r16_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SetupRelease_PDSCH_Config_maxMIMO_Layers_r16_release) {
		NTOH_8(p->release, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SetupRelease_PDSCH_Config_maxMIMO_Layers_r16_setup) {
		NTOH_8(p->setup, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecSQN_NR_SetupRelease_PDSCH_Config_maxMIMO_Layers_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SetupRelease_PDSCH_Config_maxMIMO_Layers_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SQN_NR_SetupRelease_PDSCH_Config_maxMIMO_Layers_r16_Sel)_tmp;
	}
	_serNrSysDecSQN_NR_SetupRelease_PDSCH_Config_maxMIMO_Layers_r16_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SetupRelease_PDSCH_Config_maxMIMO_Layers_r16_SQN_NR_PDSCH_Config_maxMIMO_Layers_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SetupRelease_PDSCH_Config_maxMIMO_Layers_r16_SQN_NR_PDSCH_Config_maxMIMO_Layers_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_SetupRelease_PDSCH_Config_maxMIMO_Layers_r16(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SetupRelease_PDSCH_Config_minimumSchedulingOffsetK0_r16_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union SQN_NR_SetupRelease_PDSCH_Config_minimumSchedulingOffsetK0_r16_Value* p, enum SQN_NR_SetupRelease_PDSCH_Config_minimumSchedulingOffsetK0_r16_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SetupRelease_PDSCH_Config_minimumSchedulingOffsetK0_r16_release) {
		NTOH_8(p->release, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SetupRelease_PDSCH_Config_minimumSchedulingOffsetK0_r16_setup) {
		NTOH_32(p->setup.d, &_buffer[*_lidx], _lidx);
		p->setup.v = (uint8_t*)serMalloc(_mem, p->setup.d * sizeof(uint8_t));
		for (size_t i2 = 0; i2 < p->setup.d; i2++) {
			NTOH_8(p->setup.v[i2], &_buffer[*_lidx], _lidx);
		}
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecSQN_NR_SetupRelease_PDSCH_Config_minimumSchedulingOffsetK0_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_SetupRelease_PDSCH_Config_minimumSchedulingOffsetK0_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SQN_NR_SetupRelease_PDSCH_Config_minimumSchedulingOffsetK0_r16_Sel)_tmp;
	}
	_serNrSysDecSQN_NR_SetupRelease_PDSCH_Config_minimumSchedulingOffsetK0_r16_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SetupRelease_PDSCH_Config_minimumSchedulingOffsetK0_r16_SQN_NR_PDSCH_Config_minimumSchedulingOffsetK0_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_SetupRelease_PDSCH_Config_minimumSchedulingOffsetK0_r16_SQN_NR_PDSCH_Config_minimumSchedulingOffsetK0_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_SetupRelease_PDSCH_Config_minimumSchedulingOffsetK0_r16(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PDSCH_Config_antennaPortsFieldPresenceDCI_1_2_r16_e_antennaPortsFieldPresenceDCI_1_2_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_PDSCH_Config_antennaPortsFieldPresenceDCI_1_2_r16_e_antennaPortsFieldPresenceDCI_1_2_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_PDSCH_Config_antennaPortsFieldPresenceDCI_1_2_r16_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_ZP_CSI_RS_ResourceSet_SQN_NR_PDSCH_Config_aperiodicZP_CSI_RS_ResourceSetsToAddModListDCI_1_2_r16_DynamicOptional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_ZP_CSI_RS_ResourceSet_SQN_NR_PDSCH_Config_aperiodicZP_CSI_RS_ResourceSetsToAddModListDCI_1_2_r16_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = (struct SQN_NR_ZP_CSI_RS_ResourceSet*)serMalloc(_mem, p->v.d * sizeof(struct SQN_NR_ZP_CSI_RS_ResourceSet));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serNrSysDecSQN_NR_ZP_CSI_RS_ResourceSet(_buffer, _size, _lidx, _mem, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_ZP_CSI_RS_ResourceSetId_SQN_NR_PDSCH_Config_aperiodicZP_CSI_RS_ResourceSetsToReleaseListDCI_1_2_r16_DynamicOptional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_ZP_CSI_RS_ResourceSetId_SQN_NR_PDSCH_Config_aperiodicZP_CSI_RS_ResourceSetsToReleaseListDCI_1_2_r16_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = (SQN_NR_ZP_CSI_RS_ResourceSetId*)serMalloc(_mem, p->v.d * sizeof(SQN_NR_ZP_CSI_RS_ResourceSetId));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		NTOH_8(p->v.v[i2], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SetupRelease_PDSCH_Config_dmrs_DownlinkForPDSCH_MappingTypeA_DCI_1_2_r16_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union SQN_NR_SetupRelease_PDSCH_Config_dmrs_DownlinkForPDSCH_MappingTypeA_DCI_1_2_r16_Value* p, enum SQN_NR_SetupRelease_PDSCH_Config_dmrs_DownlinkForPDSCH_MappingTypeA_DCI_1_2_r16_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SetupRelease_PDSCH_Config_dmrs_DownlinkForPDSCH_MappingTypeA_DCI_1_2_r16_release) {
		NTOH_8(p->release, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SetupRelease_PDSCH_Config_dmrs_DownlinkForPDSCH_MappingTypeA_DCI_1_2_r16_setup) {
		_serNrSysDecSQN_NR_DMRS_DownlinkConfig(_buffer, _size, _lidx, &p->setup);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecSQN_NR_SetupRelease_PDSCH_Config_dmrs_DownlinkForPDSCH_MappingTypeA_DCI_1_2_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SetupRelease_PDSCH_Config_dmrs_DownlinkForPDSCH_MappingTypeA_DCI_1_2_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SQN_NR_SetupRelease_PDSCH_Config_dmrs_DownlinkForPDSCH_MappingTypeA_DCI_1_2_r16_Sel)_tmp;
	}
	_serNrSysDecSQN_NR_SetupRelease_PDSCH_Config_dmrs_DownlinkForPDSCH_MappingTypeA_DCI_1_2_r16_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SetupRelease_PDSCH_Config_dmrs_DownlinkForPDSCH_MappingTypeA_DCI_1_2_r16_SQN_NR_PDSCH_Config_dmrs_DownlinkForPDSCH_MappingTypeA_DCI_1_2_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SetupRelease_PDSCH_Config_dmrs_DownlinkForPDSCH_MappingTypeA_DCI_1_2_r16_SQN_NR_PDSCH_Config_dmrs_DownlinkForPDSCH_MappingTypeA_DCI_1_2_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_SetupRelease_PDSCH_Config_dmrs_DownlinkForPDSCH_MappingTypeA_DCI_1_2_r16(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SetupRelease_PDSCH_Config_dmrs_DownlinkForPDSCH_MappingTypeB_DCI_1_2_r16_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union SQN_NR_SetupRelease_PDSCH_Config_dmrs_DownlinkForPDSCH_MappingTypeB_DCI_1_2_r16_Value* p, enum SQN_NR_SetupRelease_PDSCH_Config_dmrs_DownlinkForPDSCH_MappingTypeB_DCI_1_2_r16_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SetupRelease_PDSCH_Config_dmrs_DownlinkForPDSCH_MappingTypeB_DCI_1_2_r16_release) {
		NTOH_8(p->release, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SetupRelease_PDSCH_Config_dmrs_DownlinkForPDSCH_MappingTypeB_DCI_1_2_r16_setup) {
		_serNrSysDecSQN_NR_DMRS_DownlinkConfig(_buffer, _size, _lidx, &p->setup);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecSQN_NR_SetupRelease_PDSCH_Config_dmrs_DownlinkForPDSCH_MappingTypeB_DCI_1_2_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SetupRelease_PDSCH_Config_dmrs_DownlinkForPDSCH_MappingTypeB_DCI_1_2_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SQN_NR_SetupRelease_PDSCH_Config_dmrs_DownlinkForPDSCH_MappingTypeB_DCI_1_2_r16_Sel)_tmp;
	}
	_serNrSysDecSQN_NR_SetupRelease_PDSCH_Config_dmrs_DownlinkForPDSCH_MappingTypeB_DCI_1_2_r16_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SetupRelease_PDSCH_Config_dmrs_DownlinkForPDSCH_MappingTypeB_DCI_1_2_r16_SQN_NR_PDSCH_Config_dmrs_DownlinkForPDSCH_MappingTypeB_DCI_1_2_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SetupRelease_PDSCH_Config_dmrs_DownlinkForPDSCH_MappingTypeB_DCI_1_2_r16_SQN_NR_PDSCH_Config_dmrs_DownlinkForPDSCH_MappingTypeB_DCI_1_2_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_SetupRelease_PDSCH_Config_dmrs_DownlinkForPDSCH_MappingTypeB_DCI_1_2_r16(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PDSCH_Config_dmrs_SequenceInitializationDCI_1_2_r16_e_dmrs_SequenceInitializationDCI_1_2_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_PDSCH_Config_dmrs_SequenceInitializationDCI_1_2_r16_e_dmrs_SequenceInitializationDCI_1_2_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_PDSCH_Config_dmrs_SequenceInitializationDCI_1_2_r16_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecUint8_t_SQN_NR_PDSCH_Config_harq_ProcessNumberSizeDCI_1_2_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct uint8_t_SQN_NR_PDSCH_Config_harq_ProcessNumberSizeDCI_1_2_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PDSCH_Config_mcs_TableDCI_1_2_r16_e_mcs_TableDCI_1_2_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_PDSCH_Config_mcs_TableDCI_1_2_r16_e_mcs_TableDCI_1_2_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_PDSCH_Config_mcs_TableDCI_1_2_r16_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecUint8_t_SQN_NR_PDSCH_Config_numberOfBitsForRV_DCI_1_2_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct uint8_t_SQN_NR_PDSCH_Config_numberOfBitsForRV_DCI_1_2_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecUint8_t_SQN_NR_PDSCH_TimeDomainResourceAllocation_r16_k0_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct uint8_t_SQN_NR_PDSCH_TimeDomainResourceAllocation_r16_k0_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PDSCH_TimeDomainResourceAllocation_r16_repetitionNumber_r16_e_repetitionNumber_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_PDSCH_TimeDomainResourceAllocation_r16_repetitionNumber_r16_e_repetitionNumber_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_PDSCH_TimeDomainResourceAllocation_r16_repetitionNumber_r16_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PDSCH_TimeDomainResourceAllocation_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_PDSCH_TimeDomainResourceAllocation_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecUint8_t_SQN_NR_PDSCH_TimeDomainResourceAllocation_r16_k0_r16_Optional(_buffer, _size, _lidx, &p->k0_r16);
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->mappingType_r16 = (SQN_NR_PDSCH_TimeDomainResourceAllocation_r16_mappingType_r16_e)_tmp;
	}
	NTOH_8(p->startSymbolAndLength_r16, &_buffer[*_lidx], _lidx);
	_serNrSysDecSQN_NR_PDSCH_TimeDomainResourceAllocation_r16_repetitionNumber_r16_e_repetitionNumber_r16_Optional(_buffer, _size, _lidx, &p->repetitionNumber_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SetupRelease_PDSCH_Config_pdsch_TimeDomainAllocationListDCI_1_2_r16_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union SQN_NR_SetupRelease_PDSCH_Config_pdsch_TimeDomainAllocationListDCI_1_2_r16_Value* p, enum SQN_NR_SetupRelease_PDSCH_Config_pdsch_TimeDomainAllocationListDCI_1_2_r16_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SetupRelease_PDSCH_Config_pdsch_TimeDomainAllocationListDCI_1_2_r16_release) {
		NTOH_8(p->release, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SetupRelease_PDSCH_Config_pdsch_TimeDomainAllocationListDCI_1_2_r16_setup) {
		NTOH_32(p->setup.d, &_buffer[*_lidx], _lidx);
		p->setup.v = (struct SQN_NR_PDSCH_TimeDomainResourceAllocation_r16*)serMalloc(_mem, p->setup.d * sizeof(struct SQN_NR_PDSCH_TimeDomainResourceAllocation_r16));
		for (size_t i2 = 0; i2 < p->setup.d; i2++) {
			_serNrSysDecSQN_NR_PDSCH_TimeDomainResourceAllocation_r16(_buffer, _size, _lidx, &p->setup.v[i2]);
		}
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecSQN_NR_SetupRelease_PDSCH_Config_pdsch_TimeDomainAllocationListDCI_1_2_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_SetupRelease_PDSCH_Config_pdsch_TimeDomainAllocationListDCI_1_2_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SQN_NR_SetupRelease_PDSCH_Config_pdsch_TimeDomainAllocationListDCI_1_2_r16_Sel)_tmp;
	}
	_serNrSysDecSQN_NR_SetupRelease_PDSCH_Config_pdsch_TimeDomainAllocationListDCI_1_2_r16_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SetupRelease_PDSCH_Config_pdsch_TimeDomainAllocationListDCI_1_2_r16_SQN_NR_PDSCH_Config_pdsch_TimeDomainAllocationListDCI_1_2_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_SetupRelease_PDSCH_Config_pdsch_TimeDomainAllocationListDCI_1_2_r16_SQN_NR_PDSCH_Config_pdsch_TimeDomainAllocationListDCI_1_2_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_SetupRelease_PDSCH_Config_pdsch_TimeDomainAllocationListDCI_1_2_r16(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PDSCH_Config_prb_BundlingTypeDCI_1_2_r16_staticBundling_r16_bundleSize_r16_e_bundleSize_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_PDSCH_Config_prb_BundlingTypeDCI_1_2_r16_staticBundling_r16_bundleSize_r16_e_bundleSize_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_PDSCH_Config_prb_BundlingTypeDCI_1_2_r16_staticBundling_r16_bundleSize_r16_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PDSCH_Config_prb_BundlingTypeDCI_1_2_r16_staticBundling_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_PDSCH_Config_prb_BundlingTypeDCI_1_2_r16_staticBundling_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecSQN_NR_PDSCH_Config_prb_BundlingTypeDCI_1_2_r16_staticBundling_r16_bundleSize_r16_e_bundleSize_r16_Optional(_buffer, _size, _lidx, &p->bundleSize_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PDSCH_Config_prb_BundlingTypeDCI_1_2_r16_dynamicBundling_r16_bundleSizeSet1_r16_e_bundleSizeSet1_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_PDSCH_Config_prb_BundlingTypeDCI_1_2_r16_dynamicBundling_r16_bundleSizeSet1_r16_e_bundleSizeSet1_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_PDSCH_Config_prb_BundlingTypeDCI_1_2_r16_dynamicBundling_r16_bundleSizeSet1_r16_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PDSCH_Config_prb_BundlingTypeDCI_1_2_r16_dynamicBundling_r16_bundleSizeSet2_r16_e_bundleSizeSet2_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_PDSCH_Config_prb_BundlingTypeDCI_1_2_r16_dynamicBundling_r16_bundleSizeSet2_r16_e_bundleSizeSet2_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_PDSCH_Config_prb_BundlingTypeDCI_1_2_r16_dynamicBundling_r16_bundleSizeSet2_r16_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PDSCH_Config_prb_BundlingTypeDCI_1_2_r16_dynamicBundling_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_PDSCH_Config_prb_BundlingTypeDCI_1_2_r16_dynamicBundling_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecSQN_NR_PDSCH_Config_prb_BundlingTypeDCI_1_2_r16_dynamicBundling_r16_bundleSizeSet1_r16_e_bundleSizeSet1_r16_Optional(_buffer, _size, _lidx, &p->bundleSizeSet1_r16);
	_serNrSysDecSQN_NR_PDSCH_Config_prb_BundlingTypeDCI_1_2_r16_dynamicBundling_r16_bundleSizeSet2_r16_e_bundleSizeSet2_r16_Optional(_buffer, _size, _lidx, &p->bundleSizeSet2_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PDSCH_Config_prb_BundlingTypeDCI_1_2_r16_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union SQN_NR_PDSCH_Config_prb_BundlingTypeDCI_1_2_r16_Value* p, enum SQN_NR_PDSCH_Config_prb_BundlingTypeDCI_1_2_r16_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_PDSCH_Config_prb_BundlingTypeDCI_1_2_r16_staticBundling_r16) {
		_serNrSysDecSQN_NR_PDSCH_Config_prb_BundlingTypeDCI_1_2_r16_staticBundling_r16(_buffer, _size, _lidx, &p->staticBundling_r16);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_PDSCH_Config_prb_BundlingTypeDCI_1_2_r16_dynamicBundling_r16) {
		_serNrSysDecSQN_NR_PDSCH_Config_prb_BundlingTypeDCI_1_2_r16_dynamicBundling_r16(_buffer, _size, _lidx, &p->dynamicBundling_r16);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecSQN_NR_PDSCH_Config_prb_BundlingTypeDCI_1_2_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_PDSCH_Config_prb_BundlingTypeDCI_1_2_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SQN_NR_PDSCH_Config_prb_BundlingTypeDCI_1_2_r16_Sel)_tmp;
	}
	_serNrSysDecSQN_NR_PDSCH_Config_prb_BundlingTypeDCI_1_2_r16_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PDSCH_Config_prb_BundlingTypeDCI_1_2_r16_prb_BundlingTypeDCI_1_2_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_PDSCH_Config_prb_BundlingTypeDCI_1_2_r16_prb_BundlingTypeDCI_1_2_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_PDSCH_Config_prb_BundlingTypeDCI_1_2_r16(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PDSCH_Config_priorityIndicatorDCI_1_2_r16_e_priorityIndicatorDCI_1_2_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_PDSCH_Config_priorityIndicatorDCI_1_2_r16_e_priorityIndicatorDCI_1_2_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_PDSCH_Config_priorityIndicatorDCI_1_2_r16_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_RateMatchPatternGroup_SQN_NR_PDSCH_Config_rateMatchPatternGroup1DCI_1_2_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_RateMatchPatternGroup_SQN_NR_PDSCH_Config_rateMatchPatternGroup1DCI_1_2_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = (struct SQN_NR_RateMatchPatternGroup_s*)serMalloc(_mem, p->v.d * sizeof(struct SQN_NR_RateMatchPatternGroup_s));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serNrSysDecSQN_NR_RateMatchPatternGroup_s(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_RateMatchPatternGroup_SQN_NR_PDSCH_Config_rateMatchPatternGroup2DCI_1_2_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_RateMatchPatternGroup_SQN_NR_PDSCH_Config_rateMatchPatternGroup2DCI_1_2_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = (struct SQN_NR_RateMatchPatternGroup_s*)serMalloc(_mem, p->v.d * sizeof(struct SQN_NR_RateMatchPatternGroup_s));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serNrSysDecSQN_NR_RateMatchPatternGroup_s(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PDSCH_Config_resourceAllocationType1GranularityDCI_1_2_r16_e_resourceAllocationType1GranularityDCI_1_2_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_PDSCH_Config_resourceAllocationType1GranularityDCI_1_2_r16_e_resourceAllocationType1GranularityDCI_1_2_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_PDSCH_Config_resourceAllocationType1GranularityDCI_1_2_r16_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PDSCH_Config_vrb_ToPRB_InterleaverDCI_1_2_r16_e_vrb_ToPRB_InterleaverDCI_1_2_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_PDSCH_Config_vrb_ToPRB_InterleaverDCI_1_2_r16_e_vrb_ToPRB_InterleaverDCI_1_2_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_PDSCH_Config_vrb_ToPRB_InterleaverDCI_1_2_r16_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PDSCH_Config_referenceOfSLIVDCI_1_2_r16_e_referenceOfSLIVDCI_1_2_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_PDSCH_Config_referenceOfSLIVDCI_1_2_r16_e_referenceOfSLIVDCI_1_2_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_PDSCH_Config_referenceOfSLIVDCI_1_2_r16_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PDSCH_Config_resourceAllocationDCI_1_2_r16_e_resourceAllocationDCI_1_2_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_PDSCH_Config_resourceAllocationDCI_1_2_r16_e_resourceAllocationDCI_1_2_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_PDSCH_Config_resourceAllocationDCI_1_2_r16_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PDSCH_Config_priorityIndicatorDCI_1_1_r16_e_priorityIndicatorDCI_1_1_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_PDSCH_Config_priorityIndicatorDCI_1_1_r16_e_priorityIndicatorDCI_1_1_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_PDSCH_Config_priorityIndicatorDCI_1_1_r16_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecUint16_t_SQN_NR_PDSCH_Config_dataScramblingIdentityPDSCH2_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct uint16_t_SQN_NR_PDSCH_Config_dataScramblingIdentityPDSCH2_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_16(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SetupRelease_PDSCH_Config_pdsch_TimeDomainAllocationList_r16_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union SQN_NR_SetupRelease_PDSCH_Config_pdsch_TimeDomainAllocationList_r16_Value* p, enum SQN_NR_SetupRelease_PDSCH_Config_pdsch_TimeDomainAllocationList_r16_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SetupRelease_PDSCH_Config_pdsch_TimeDomainAllocationList_r16_release) {
		NTOH_8(p->release, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SetupRelease_PDSCH_Config_pdsch_TimeDomainAllocationList_r16_setup) {
		NTOH_32(p->setup.d, &_buffer[*_lidx], _lidx);
		p->setup.v = (struct SQN_NR_PDSCH_TimeDomainResourceAllocation_r16*)serMalloc(_mem, p->setup.d * sizeof(struct SQN_NR_PDSCH_TimeDomainResourceAllocation_r16));
		for (size_t i2 = 0; i2 < p->setup.d; i2++) {
			_serNrSysDecSQN_NR_PDSCH_TimeDomainResourceAllocation_r16(_buffer, _size, _lidx, &p->setup.v[i2]);
		}
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecSQN_NR_SetupRelease_PDSCH_Config_pdsch_TimeDomainAllocationList_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_SetupRelease_PDSCH_Config_pdsch_TimeDomainAllocationList_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SQN_NR_SetupRelease_PDSCH_Config_pdsch_TimeDomainAllocationList_r16_Sel)_tmp;
	}
	_serNrSysDecSQN_NR_SetupRelease_PDSCH_Config_pdsch_TimeDomainAllocationList_r16_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SetupRelease_PDSCH_Config_pdsch_TimeDomainAllocationList_r16_SQN_NR_PDSCH_Config_pdsch_TimeDomainAllocationList_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_SetupRelease_PDSCH_Config_pdsch_TimeDomainAllocationList_r16_SQN_NR_PDSCH_Config_pdsch_TimeDomainAllocationList_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_SetupRelease_PDSCH_Config_pdsch_TimeDomainAllocationList_r16(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecUint8_t_SQN_NR_FDM_TDM_r16_startingSymbolOffsetK_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct uint8_t_SQN_NR_FDM_TDM_r16_startingSymbolOffsetK_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_FDM_TDM_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_FDM_TDM_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->repetitionScheme_r16 = (SQN_NR_FDM_TDM_r16_repetitionScheme_r16_e)_tmp;
	}
	_serNrSysDecUint8_t_SQN_NR_FDM_TDM_r16_startingSymbolOffsetK_r16_Optional(_buffer, _size, _lidx, &p->startingSymbolOffsetK_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SetupRelease_RepetitionSchemeConfig_r16_fdm_TDM_r16_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union SQN_NR_SetupRelease_RepetitionSchemeConfig_r16_fdm_TDM_r16_Value* p, enum SQN_NR_SetupRelease_RepetitionSchemeConfig_r16_fdm_TDM_r16_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SetupRelease_RepetitionSchemeConfig_r16_fdm_TDM_r16_release) {
		NTOH_8(p->release, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SetupRelease_RepetitionSchemeConfig_r16_fdm_TDM_r16_setup) {
		_serNrSysDecSQN_NR_FDM_TDM_r16(_buffer, _size, _lidx, &p->setup);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecSQN_NR_SetupRelease_RepetitionSchemeConfig_r16_fdm_TDM_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SetupRelease_RepetitionSchemeConfig_r16_fdm_TDM_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SQN_NR_SetupRelease_RepetitionSchemeConfig_r16_fdm_TDM_r16_Sel)_tmp;
	}
	_serNrSysDecSQN_NR_SetupRelease_RepetitionSchemeConfig_r16_fdm_TDM_r16_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SlotBased_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SlotBased_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->tciMapping_r16 = (SQN_NR_SlotBased_r16_tciMapping_r16_e)_tmp;
	}
	NTOH_8(p->sequenceOffsetforRV_r16, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SetupRelease_RepetitionSchemeConfig_r16_slotBased_r16_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union SQN_NR_SetupRelease_RepetitionSchemeConfig_r16_slotBased_r16_Value* p, enum SQN_NR_SetupRelease_RepetitionSchemeConfig_r16_slotBased_r16_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SetupRelease_RepetitionSchemeConfig_r16_slotBased_r16_release) {
		NTOH_8(p->release, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SetupRelease_RepetitionSchemeConfig_r16_slotBased_r16_setup) {
		_serNrSysDecSQN_NR_SlotBased_r16(_buffer, _size, _lidx, &p->setup);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecSQN_NR_SetupRelease_RepetitionSchemeConfig_r16_slotBased_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SetupRelease_RepetitionSchemeConfig_r16_slotBased_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SQN_NR_SetupRelease_RepetitionSchemeConfig_r16_slotBased_r16_Sel)_tmp;
	}
	_serNrSysDecSQN_NR_SetupRelease_RepetitionSchemeConfig_r16_slotBased_r16_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_RepetitionSchemeConfig_r16_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union SQN_NR_RepetitionSchemeConfig_r16_Value* p, enum SQN_NR_RepetitionSchemeConfig_r16_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_RepetitionSchemeConfig_r16_fdm_TDM_r16) {
		_serNrSysDecSQN_NR_SetupRelease_RepetitionSchemeConfig_r16_fdm_TDM_r16(_buffer, _size, _lidx, &p->fdm_TDM_r16);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_RepetitionSchemeConfig_r16_slotBased_r16) {
		_serNrSysDecSQN_NR_SetupRelease_RepetitionSchemeConfig_r16_slotBased_r16(_buffer, _size, _lidx, &p->slotBased_r16);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecSQN_NR_RepetitionSchemeConfig_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_RepetitionSchemeConfig_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SQN_NR_RepetitionSchemeConfig_r16_Sel)_tmp;
	}
	_serNrSysDecSQN_NR_RepetitionSchemeConfig_r16_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SetupRelease_PDSCH_Config_repetitionSchemeConfig_r16_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union SQN_NR_SetupRelease_PDSCH_Config_repetitionSchemeConfig_r16_Value* p, enum SQN_NR_SetupRelease_PDSCH_Config_repetitionSchemeConfig_r16_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SetupRelease_PDSCH_Config_repetitionSchemeConfig_r16_release) {
		NTOH_8(p->release, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SetupRelease_PDSCH_Config_repetitionSchemeConfig_r16_setup) {
		_serNrSysDecSQN_NR_RepetitionSchemeConfig_r16(_buffer, _size, _lidx, &p->setup);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecSQN_NR_SetupRelease_PDSCH_Config_repetitionSchemeConfig_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SetupRelease_PDSCH_Config_repetitionSchemeConfig_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SQN_NR_SetupRelease_PDSCH_Config_repetitionSchemeConfig_r16_Sel)_tmp;
	}
	_serNrSysDecSQN_NR_SetupRelease_PDSCH_Config_repetitionSchemeConfig_r16_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SetupRelease_PDSCH_Config_repetitionSchemeConfig_r16_SQN_NR_PDSCH_Config_repetitionSchemeConfig_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SetupRelease_PDSCH_Config_repetitionSchemeConfig_r16_SQN_NR_PDSCH_Config_repetitionSchemeConfig_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_SetupRelease_PDSCH_Config_repetitionSchemeConfig_r16(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PDSCH_Config(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_PDSCH_Config* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecUint16_t_SQN_NR_PDSCH_Config_dataScramblingIdentityPDSCH_Optional(_buffer, _size, _lidx, &p->dataScramblingIdentityPDSCH);
	_serNrSysDecSQN_NR_SetupRelease_PDSCH_Config_dmrs_DownlinkForPDSCH_MappingTypeA_SQN_NR_PDSCH_Config_dmrs_DownlinkForPDSCH_MappingTypeA_Optional(_buffer, _size, _lidx, &p->dmrs_DownlinkForPDSCH_MappingTypeA);
	_serNrSysDecSQN_NR_SetupRelease_PDSCH_Config_dmrs_DownlinkForPDSCH_MappingTypeB_SQN_NR_PDSCH_Config_dmrs_DownlinkForPDSCH_MappingTypeB_Optional(_buffer, _size, _lidx, &p->dmrs_DownlinkForPDSCH_MappingTypeB);
	_serNrSysDecSQN_NR_TCI_State_SQN_NR_PDSCH_Config_tci_StatesToAddModList_DynamicOptional(_buffer, _size, _lidx, _mem, &p->tci_StatesToAddModList);
	_serNrSysDecSQN_NR_TCI_StateId_SQN_NR_PDSCH_Config_tci_StatesToReleaseList_DynamicOptional(_buffer, _size, _lidx, _mem, &p->tci_StatesToReleaseList);
	_serNrSysDecSQN_NR_PDSCH_Config_vrb_ToPRB_Interleaver_e_vrb_ToPRB_Interleaver_Optional(_buffer, _size, _lidx, &p->vrb_ToPRB_Interleaver);
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->resourceAllocation = (SQN_NR_PDSCH_Config_resourceAllocation_e)_tmp;
	}
	_serNrSysDecSQN_NR_SetupRelease_PDSCH_Config_pdsch_TimeDomainAllocationList_SQN_NR_PDSCH_Config_pdsch_TimeDomainAllocationList_Optional(_buffer, _size, _lidx, _mem, &p->pdsch_TimeDomainAllocationList);
	_serNrSysDecSQN_NR_PDSCH_Config_pdsch_AggregationFactor_e_pdsch_AggregationFactor_Optional(_buffer, _size, _lidx, &p->pdsch_AggregationFactor);
	_serNrSysDecSQN_NR_RateMatchPattern_SQN_NR_PDSCH_Config_rateMatchPatternToAddModList_DynamicOptional(_buffer, _size, _lidx, _mem, &p->rateMatchPatternToAddModList);
	_serNrSysDecSQN_NR_RateMatchPatternId_SQN_NR_PDSCH_Config_rateMatchPatternToReleaseList_DynamicOptional(_buffer, _size, _lidx, _mem, &p->rateMatchPatternToReleaseList);
	_serNrSysDecSQN_NR_RateMatchPatternGroup_SQN_NR_PDSCH_Config_rateMatchPatternGroup1_Optional(_buffer, _size, _lidx, _mem, &p->rateMatchPatternGroup1);
	_serNrSysDecSQN_NR_RateMatchPatternGroup_SQN_NR_PDSCH_Config_rateMatchPatternGroup2_Optional(_buffer, _size, _lidx, _mem, &p->rateMatchPatternGroup2);
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->rbg_Size = (SQN_NR_PDSCH_Config_rbg_Size_e)_tmp;
	}
	_serNrSysDecSQN_NR_PDSCH_Config_mcs_Table_e_mcs_Table_Optional(_buffer, _size, _lidx, &p->mcs_Table);
	_serNrSysDecSQN_NR_PDSCH_Config_maxNrofCodeWordsScheduledByDCI_e_maxNrofCodeWordsScheduledByDCI_Optional(_buffer, _size, _lidx, &p->maxNrofCodeWordsScheduledByDCI);
	_serNrSysDecSQN_NR_PDSCH_Config_prb_BundlingType(_buffer, _size, _lidx, &p->prb_BundlingType);
	_serNrSysDecSQN_NR_ZP_CSI_RS_Resource_SQN_NR_PDSCH_Config_zp_CSI_RS_ResourceToAddModList_DynamicOptional(_buffer, _size, _lidx, _mem, &p->zp_CSI_RS_ResourceToAddModList);
	_serNrSysDecSQN_NR_ZP_CSI_RS_ResourceId_SQN_NR_PDSCH_Config_zp_CSI_RS_ResourceToReleaseList_DynamicOptional(_buffer, _size, _lidx, _mem, &p->zp_CSI_RS_ResourceToReleaseList);
	_serNrSysDecSQN_NR_ZP_CSI_RS_ResourceSet_SQN_NR_PDSCH_Config_aperiodic_ZP_CSI_RS_ResourceSetsToAddModList_DynamicOptional(_buffer, _size, _lidx, _mem, &p->aperiodic_ZP_CSI_RS_ResourceSetsToAddModList);
	_serNrSysDecSQN_NR_ZP_CSI_RS_ResourceSetId_SQN_NR_PDSCH_Config_aperiodic_ZP_CSI_RS_ResourceSetsToReleaseList_DynamicOptional(_buffer, _size, _lidx, _mem, &p->aperiodic_ZP_CSI_RS_ResourceSetsToReleaseList);
	_serNrSysDecSQN_NR_ZP_CSI_RS_ResourceSet_SQN_NR_PDSCH_Config_sp_ZP_CSI_RS_ResourceSetsToAddModList_DynamicOptional(_buffer, _size, _lidx, _mem, &p->sp_ZP_CSI_RS_ResourceSetsToAddModList);
	_serNrSysDecSQN_NR_ZP_CSI_RS_ResourceSetId_SQN_NR_PDSCH_Config_sp_ZP_CSI_RS_ResourceSetsToReleaseList_DynamicOptional(_buffer, _size, _lidx, _mem, &p->sp_ZP_CSI_RS_ResourceSetsToReleaseList);
	_serNrSysDecSQN_NR_SetupRelease_PDSCH_Config_p_ZP_CSI_RS_ResourceSet_SQN_NR_PDSCH_Config_p_ZP_CSI_RS_ResourceSet_Optional(_buffer, _size, _lidx, _mem, &p->p_ZP_CSI_RS_ResourceSet);
	_serNrSysDecSQN_NR_SetupRelease_PDSCH_Config_maxMIMO_Layers_r16_SQN_NR_PDSCH_Config_maxMIMO_Layers_r16_Optional(_buffer, _size, _lidx, &p->maxMIMO_Layers_r16);
	_serNrSysDecSQN_NR_SetupRelease_PDSCH_Config_minimumSchedulingOffsetK0_r16_SQN_NR_PDSCH_Config_minimumSchedulingOffsetK0_r16_Optional(_buffer, _size, _lidx, _mem, &p->minimumSchedulingOffsetK0_r16);
	_serNrSysDecSQN_NR_PDSCH_Config_antennaPortsFieldPresenceDCI_1_2_r16_e_antennaPortsFieldPresenceDCI_1_2_r16_Optional(_buffer, _size, _lidx, &p->antennaPortsFieldPresenceDCI_1_2_r16);
	_serNrSysDecSQN_NR_ZP_CSI_RS_ResourceSet_SQN_NR_PDSCH_Config_aperiodicZP_CSI_RS_ResourceSetsToAddModListDCI_1_2_r16_DynamicOptional(_buffer, _size, _lidx, _mem, &p->aperiodicZP_CSI_RS_ResourceSetsToAddModListDCI_1_2_r16);
	_serNrSysDecSQN_NR_ZP_CSI_RS_ResourceSetId_SQN_NR_PDSCH_Config_aperiodicZP_CSI_RS_ResourceSetsToReleaseListDCI_1_2_r16_DynamicOptional(_buffer, _size, _lidx, _mem, &p->aperiodicZP_CSI_RS_ResourceSetsToReleaseListDCI_1_2_r16);
	_serNrSysDecSQN_NR_SetupRelease_PDSCH_Config_dmrs_DownlinkForPDSCH_MappingTypeA_DCI_1_2_r16_SQN_NR_PDSCH_Config_dmrs_DownlinkForPDSCH_MappingTypeA_DCI_1_2_r16_Optional(_buffer, _size, _lidx, &p->dmrs_DownlinkForPDSCH_MappingTypeA_DCI_1_2_r16);
	_serNrSysDecSQN_NR_SetupRelease_PDSCH_Config_dmrs_DownlinkForPDSCH_MappingTypeB_DCI_1_2_r16_SQN_NR_PDSCH_Config_dmrs_DownlinkForPDSCH_MappingTypeB_DCI_1_2_r16_Optional(_buffer, _size, _lidx, &p->dmrs_DownlinkForPDSCH_MappingTypeB_DCI_1_2_r16);
	_serNrSysDecSQN_NR_PDSCH_Config_dmrs_SequenceInitializationDCI_1_2_r16_e_dmrs_SequenceInitializationDCI_1_2_r16_Optional(_buffer, _size, _lidx, &p->dmrs_SequenceInitializationDCI_1_2_r16);
	_serNrSysDecUint8_t_SQN_NR_PDSCH_Config_harq_ProcessNumberSizeDCI_1_2_r16_Optional(_buffer, _size, _lidx, &p->harq_ProcessNumberSizeDCI_1_2_r16);
	_serNrSysDecSQN_NR_PDSCH_Config_mcs_TableDCI_1_2_r16_e_mcs_TableDCI_1_2_r16_Optional(_buffer, _size, _lidx, &p->mcs_TableDCI_1_2_r16);
	_serNrSysDecUint8_t_SQN_NR_PDSCH_Config_numberOfBitsForRV_DCI_1_2_r16_Optional(_buffer, _size, _lidx, &p->numberOfBitsForRV_DCI_1_2_r16);
	_serNrSysDecSQN_NR_SetupRelease_PDSCH_Config_pdsch_TimeDomainAllocationListDCI_1_2_r16_SQN_NR_PDSCH_Config_pdsch_TimeDomainAllocationListDCI_1_2_r16_Optional(_buffer, _size, _lidx, _mem, &p->pdsch_TimeDomainAllocationListDCI_1_2_r16);
	_serNrSysDecSQN_NR_PDSCH_Config_prb_BundlingTypeDCI_1_2_r16_prb_BundlingTypeDCI_1_2_r16_Optional(_buffer, _size, _lidx, &p->prb_BundlingTypeDCI_1_2_r16);
	_serNrSysDecSQN_NR_PDSCH_Config_priorityIndicatorDCI_1_2_r16_e_priorityIndicatorDCI_1_2_r16_Optional(_buffer, _size, _lidx, &p->priorityIndicatorDCI_1_2_r16);
	_serNrSysDecSQN_NR_RateMatchPatternGroup_SQN_NR_PDSCH_Config_rateMatchPatternGroup1DCI_1_2_r16_Optional(_buffer, _size, _lidx, _mem, &p->rateMatchPatternGroup1DCI_1_2_r16);
	_serNrSysDecSQN_NR_RateMatchPatternGroup_SQN_NR_PDSCH_Config_rateMatchPatternGroup2DCI_1_2_r16_Optional(_buffer, _size, _lidx, _mem, &p->rateMatchPatternGroup2DCI_1_2_r16);
	_serNrSysDecSQN_NR_PDSCH_Config_resourceAllocationType1GranularityDCI_1_2_r16_e_resourceAllocationType1GranularityDCI_1_2_r16_Optional(_buffer, _size, _lidx, &p->resourceAllocationType1GranularityDCI_1_2_r16);
	_serNrSysDecSQN_NR_PDSCH_Config_vrb_ToPRB_InterleaverDCI_1_2_r16_e_vrb_ToPRB_InterleaverDCI_1_2_r16_Optional(_buffer, _size, _lidx, &p->vrb_ToPRB_InterleaverDCI_1_2_r16);
	_serNrSysDecSQN_NR_PDSCH_Config_referenceOfSLIVDCI_1_2_r16_e_referenceOfSLIVDCI_1_2_r16_Optional(_buffer, _size, _lidx, &p->referenceOfSLIVDCI_1_2_r16);
	_serNrSysDecSQN_NR_PDSCH_Config_resourceAllocationDCI_1_2_r16_e_resourceAllocationDCI_1_2_r16_Optional(_buffer, _size, _lidx, &p->resourceAllocationDCI_1_2_r16);
	_serNrSysDecSQN_NR_PDSCH_Config_priorityIndicatorDCI_1_1_r16_e_priorityIndicatorDCI_1_1_r16_Optional(_buffer, _size, _lidx, &p->priorityIndicatorDCI_1_1_r16);
	_serNrSysDecUint16_t_SQN_NR_PDSCH_Config_dataScramblingIdentityPDSCH2_r16_Optional(_buffer, _size, _lidx, &p->dataScramblingIdentityPDSCH2_r16);
	_serNrSysDecSQN_NR_SetupRelease_PDSCH_Config_pdsch_TimeDomainAllocationList_r16_SQN_NR_PDSCH_Config_pdsch_TimeDomainAllocationList_r16_Optional(_buffer, _size, _lidx, _mem, &p->pdsch_TimeDomainAllocationList_r16);
	_serNrSysDecSQN_NR_SetupRelease_PDSCH_Config_repetitionSchemeConfig_r16_SQN_NR_PDSCH_Config_repetitionSchemeConfig_r16_Optional(_buffer, _size, _lidx, &p->repetitionSchemeConfig_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_ASN1_PDSCH_Config_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union NR_ASN1_PDSCH_Config_Type_Value* p, enum NR_ASN1_PDSCH_Config_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_ASN1_PDSCH_Config_Type_R15) {
		_serNrSysDecSQN_NR_PDSCH_Config(_buffer, _size, _lidx, _mem, &p->R15);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecNR_ASN1_PDSCH_Config_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_ASN1_PDSCH_Config_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum NR_ASN1_PDSCH_Config_Type_Sel)_tmp;
	}
	_serNrSysDecNR_ASN1_PDSCH_Config_Type_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_ASN1_PDSCH_Config_Type_ConfigDedicated_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_ASN1_PDSCH_Config_Type_ConfigDedicated_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecNR_ASN1_PDSCH_Config_Type(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_EPRE_Ratio_Type_PdschToCell_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_EPRE_Ratio_Type_PdschToCell_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_EPRE_Ratio_Type_PdschToDmrs_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_EPRE_Ratio_Type_PdschToDmrs_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_EPRE_Ratio_Type_PdschToPtrs_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_EPRE_Ratio_Type_PdschToPtrs_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_PDSCH_EPREs_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_PDSCH_EPREs_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecNR_EPRE_Ratio_Type_PdschToCell_Optional(_buffer, _size, _lidx, &p->PdschToCell);
	_serNrSysDecNR_EPRE_Ratio_Type_PdschToDmrs_Optional(_buffer, _size, _lidx, &p->PdschToDmrs);
	_serNrSysDecNR_EPRE_Ratio_Type_PdschToPtrs_Optional(_buffer, _size, _lidx, &p->PdschToPtrs);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_PDSCH_EPREs_Type_RelativeTxPower_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_PDSCH_EPREs_Type_RelativeTxPower_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecNR_PDSCH_EPREs_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_BWP_PDSCH_Configuration_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_BWP_PDSCH_Configuration_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecNR_ASN1_PDSCH_ConfigCommon_Type_ConfigCommon_Optional(_buffer, _size, _lidx, _mem, &p->ConfigCommon);
	_serNrSysDecNR_ASN1_PDSCH_Config_Type_ConfigDedicated_Optional(_buffer, _size, _lidx, _mem, &p->ConfigDedicated);
	_serNrSysDecNR_PDSCH_EPREs_Type_RelativeTxPower_Optional(_buffer, _size, _lidx, &p->RelativeTxPower);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_BWP_PDSCH_Configuration_Type_Pdsch_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_BWP_PDSCH_Configuration_Type_Pdsch_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecNR_BWP_PDSCH_Configuration_Type(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PUCCH_ResourceId_SQN_NR_SPS_Config_n1PUCCH_AN_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_PUCCH_ResourceId_SQN_NR_SPS_Config_n1PUCCH_AN_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SPS_Config_mcs_Table_e_mcs_Table_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SPS_Config_mcs_Table_e_mcs_Table_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_SPS_Config_mcs_Table_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SPS_ConfigIndex_r16_SQN_NR_SPS_Config_sps_ConfigIndex_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SPS_ConfigIndex_r16_SQN_NR_SPS_Config_sps_ConfigIndex_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecUint8_t_SQN_NR_SPS_Config_harq_ProcID_Offset_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct uint8_t_SQN_NR_SPS_Config_harq_ProcID_Offset_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecUint16_t_SQN_NR_SPS_Config_periodicityExt_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct uint16_t_SQN_NR_SPS_Config_periodicityExt_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_16(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecUint8_t_SQN_NR_SPS_Config_harq_CodebookID_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct uint8_t_SQN_NR_SPS_Config_harq_CodebookID_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SPS_Config_pdsch_AggregationFactor_r16_e_pdsch_AggregationFactor_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SPS_Config_pdsch_AggregationFactor_r16_e_pdsch_AggregationFactor_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_SPS_Config_pdsch_AggregationFactor_r16_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SPS_Config(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SPS_Config* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->periodicity = (SQN_NR_SPS_Config_periodicity_e)_tmp;
	}
	NTOH_8(p->nrofHARQ_Processes, &_buffer[*_lidx], _lidx);
	_serNrSysDecSQN_NR_PUCCH_ResourceId_SQN_NR_SPS_Config_n1PUCCH_AN_Optional(_buffer, _size, _lidx, &p->n1PUCCH_AN);
	_serNrSysDecSQN_NR_SPS_Config_mcs_Table_e_mcs_Table_Optional(_buffer, _size, _lidx, &p->mcs_Table);
	_serNrSysDecSQN_NR_SPS_ConfigIndex_r16_SQN_NR_SPS_Config_sps_ConfigIndex_r16_Optional(_buffer, _size, _lidx, &p->sps_ConfigIndex_r16);
	_serNrSysDecUint8_t_SQN_NR_SPS_Config_harq_ProcID_Offset_r16_Optional(_buffer, _size, _lidx, &p->harq_ProcID_Offset_r16);
	_serNrSysDecUint16_t_SQN_NR_SPS_Config_periodicityExt_r16_Optional(_buffer, _size, _lidx, &p->periodicityExt_r16);
	_serNrSysDecUint8_t_SQN_NR_SPS_Config_harq_CodebookID_r16_Optional(_buffer, _size, _lidx, &p->harq_CodebookID_r16);
	_serNrSysDecSQN_NR_SPS_Config_pdsch_AggregationFactor_r16_e_pdsch_AggregationFactor_r16_Optional(_buffer, _size, _lidx, &p->pdsch_AggregationFactor_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_ASN1_SPS_Config_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union NR_ASN1_SPS_Config_Type_Value* p, enum NR_ASN1_SPS_Config_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_ASN1_SPS_Config_Type_R15) {
		_serNrSysDecSQN_NR_SPS_Config(_buffer, _size, _lidx, &p->R15);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecNR_ASN1_SPS_Config_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_ASN1_SPS_Config_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum NR_ASN1_SPS_Config_Type_Sel)_tmp;
	}
	_serNrSysDecNR_ASN1_SPS_Config_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_ASN1_SPS_Config_Type_Sps_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_ASN1_SPS_Config_Type_Sps_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecNR_ASN1_SPS_Config_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_DownlinkBWP_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_DownlinkBWP_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecSQN_NR_BWP_Id_NR_DownlinkBWP_Type_Id_Optional(_buffer, _size, _lidx, &p->Id);
	_serNrSysDecNR_ASN1_BWP_Type_BWP_Optional(_buffer, _size, _lidx, &p->BWP);
	_serNrSysDecNR_BWP_PDCCH_Configuration_Type_Pdcch_Optional(_buffer, _size, _lidx, _mem, &p->Pdcch);
	_serNrSysDecNR_BWP_PDSCH_Configuration_Type_Pdsch_Optional(_buffer, _size, _lidx, _mem, &p->Pdsch);
	_serNrSysDecNR_ASN1_SPS_Config_Type_Sps_Optional(_buffer, _size, _lidx, &p->Sps);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_DownlinkBWP_List_Type_BwpArray_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_DownlinkBWP_List_Type_BwpArray_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = (struct NR_DownlinkBWP_Type*)serMalloc(_mem, p->v.d * sizeof(struct NR_DownlinkBWP_Type));
	for (size_t i1 = 0; i1 < p->v.d; i1++) {
		_serNrSysDecNR_DownlinkBWP_Type(_buffer, _size, _lidx, _mem, &p->v.v[i1]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_DownlinkBWPs_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_DownlinkBWPs_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecSQN_NR_BWP_Id_ActiveBWP_Optional(_buffer, _size, _lidx, &p->ActiveBWP);
	_serNrSysDecNR_DownlinkBWP_List_Type_BwpArray_Optional(_buffer, _size, _lidx, _mem, &p->BwpArray);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_DownlinkBWPs_Type_BWPs_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_DownlinkBWPs_Type_BWPs_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecNR_DownlinkBWPs_Type(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_ScramblingId_ScramblingId_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_ScramblingId_ScramblingId_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_16(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_CSI_RS_ResourceMapping_ResourceMapping_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_CSI_RS_ResourceMapping_ResourceMapping_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_CSI_RS_ResourceMapping(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecInt32_t_NR_NZP_CSI_RS_Config_Type_OffsetToFreqBand_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct int32_t_NR_NZP_CSI_RS_Config_Type_OffsetToFreqBand_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_CSI_RS_Periodicity_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union NR_CSI_RS_Periodicity_Type_Value* p, enum NR_CSI_RS_Periodicity_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_CSI_RS_Periodicity_Type_PeriodicityAndOffset) {
		_serNrSysDecSQN_NR_CSI_ResourcePeriodicityAndOffset(_buffer, _size, _lidx, &p->PeriodicityAndOffset);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecNR_CSI_RS_Periodicity_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_CSI_RS_Periodicity_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum NR_CSI_RS_Periodicity_Type_Sel)_tmp;
	}
	_serNrSysDecNR_CSI_RS_Periodicity_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_CSI_RS_Periodicity_Type_Periodicity_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_CSI_RS_Periodicity_Type_Periodicity_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecNR_CSI_RS_Periodicity_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecInt32_t_NR_NZP_CSI_RS_Config_Type_Attenuation_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct int32_t_NR_NZP_CSI_RS_Config_Type_Attenuation_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_NZP_CSI_RS_Config_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_NZP_CSI_RS_Config_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecSQN_NR_ScramblingId_ScramblingId_Optional(_buffer, _size, _lidx, &p->ScramblingId);
	_serNrSysDecSQN_NR_CSI_RS_ResourceMapping_ResourceMapping_Optional(_buffer, _size, _lidx, &p->ResourceMapping);
	_serNrSysDecInt32_t_NR_NZP_CSI_RS_Config_Type_OffsetToFreqBand_Optional(_buffer, _size, _lidx, &p->OffsetToFreqBand);
	_serNrSysDecNR_CSI_RS_Periodicity_Type_Periodicity_Optional(_buffer, _size, _lidx, &p->Periodicity);
	_serNrSysDecInt32_t_NR_NZP_CSI_RS_Config_Type_Attenuation_Optional(_buffer, _size, _lidx, &p->Attenuation);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_CSI_Config_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union NR_CSI_Config_Type_Value* p, enum NR_CSI_Config_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_CSI_Config_Type_CSI_RS) {
		NTOH_32(p->CSI_RS.d, &_buffer[*_lidx], _lidx);
		p->CSI_RS.v = (struct NR_NZP_CSI_RS_Config_Type*)serMalloc(_mem, p->CSI_RS.d * sizeof(struct NR_NZP_CSI_RS_Config_Type));
		for (size_t i1 = 0; i1 < p->CSI_RS.d; i1++) {
			_serNrSysDecNR_NZP_CSI_RS_Config_Type(_buffer, _size, _lidx, &p->CSI_RS.v[i1]);
		}
		return SIDL_STATUS_OK;
	}
	if (d == NR_CSI_Config_Type_None) {
		NTOH_8(p->None, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecNR_CSI_Config_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_CSI_Config_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum NR_CSI_Config_Type_Sel)_tmp;
	}
	_serNrSysDecNR_CSI_Config_Type_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_CSI_Config_Type_CsiConfig_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_CSI_Config_Type_CsiConfig_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecNR_CSI_Config_Type(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_CellConfigPhysicalLayerDownlink_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_CellConfigPhysicalLayerDownlink_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecNR_ASN1_FrequencyInfoDL_Type_FrequencyInfoDL_Optional(_buffer, _size, _lidx, _mem, &p->FrequencyInfoDL);
	_serNrSysDecNR_SSB_Config_Type_SSPbchBlock_Optional(_buffer, _size, _lidx, _mem, &p->SSPbchBlock);
	_serNrSysDecNR_PDSCH_CellLevelConfig_Type_PdschCellLevelConfig_Optional(_buffer, _size, _lidx, _mem, &p->PdschCellLevelConfig);
	_serNrSysDecNR_DownlinkBWPs_Type_BWPs_Optional(_buffer, _size, _lidx, _mem, &p->BWPs);
	_serNrSysDecNR_CSI_Config_Type_CsiConfig_Optional(_buffer, _size, _lidx, _mem, &p->CsiConfig);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_CellConfigPhysicalLayerDownlink_Type_Downlink_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_CellConfigPhysicalLayerDownlink_Type_Downlink_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecNR_CellConfigPhysicalLayerDownlink_Type(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_MultiFrequencyBandListNR_SQN_NR_FrequencyInfoUL_frequencyBandList_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_MultiFrequencyBandListNR_SQN_NR_FrequencyInfoUL_frequencyBandList_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = (SQN_NR_FreqBandIndicatorNR*)serMalloc(_mem, p->v.d * sizeof(SQN_NR_FreqBandIndicatorNR));
	for (size_t i1 = 0; i1 < p->v.d; i1++) {
		NTOH_16(p->v.v[i1], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_ARFCN_ValueNR_SQN_NR_FrequencyInfoUL_absoluteFrequencyPointA_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_ARFCN_ValueNR_SQN_NR_FrequencyInfoUL_absoluteFrequencyPointA_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_AdditionalSpectrumEmission_SQN_NR_FrequencyInfoUL_additionalSpectrumEmission_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_AdditionalSpectrumEmission_SQN_NR_FrequencyInfoUL_additionalSpectrumEmission_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_P_Max_SQN_NR_FrequencyInfoUL_p_Max_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_P_Max_SQN_NR_FrequencyInfoUL_p_Max_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_FrequencyInfoUL_frequencyShift7p5khz_e_frequencyShift7p5khz_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_FrequencyInfoUL_frequencyShift7p5khz_e_frequencyShift7p5khz_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_FrequencyInfoUL_frequencyShift7p5khz_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_FrequencyInfoUL(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_FrequencyInfoUL* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecSQN_NR_MultiFrequencyBandListNR_SQN_NR_FrequencyInfoUL_frequencyBandList_Optional(_buffer, _size, _lidx, _mem, &p->frequencyBandList);
	_serNrSysDecSQN_NR_ARFCN_ValueNR_SQN_NR_FrequencyInfoUL_absoluteFrequencyPointA_Optional(_buffer, _size, _lidx, &p->absoluteFrequencyPointA);
	NTOH_32(p->scs_SpecificCarrierList.d, &_buffer[*_lidx], _lidx);
	p->scs_SpecificCarrierList.v = (struct SQN_NR_SCS_SpecificCarrier*)serMalloc(_mem, p->scs_SpecificCarrierList.d * sizeof(struct SQN_NR_SCS_SpecificCarrier));
	for (size_t i1 = 0; i1 < p->scs_SpecificCarrierList.d; i1++) {
		_serNrSysDecSQN_NR_SCS_SpecificCarrier(_buffer, _size, _lidx, &p->scs_SpecificCarrierList.v[i1]);
	}
	_serNrSysDecSQN_NR_AdditionalSpectrumEmission_SQN_NR_FrequencyInfoUL_additionalSpectrumEmission_Optional(_buffer, _size, _lidx, &p->additionalSpectrumEmission);
	_serNrSysDecSQN_NR_P_Max_SQN_NR_FrequencyInfoUL_p_Max_Optional(_buffer, _size, _lidx, &p->p_Max);
	_serNrSysDecSQN_NR_FrequencyInfoUL_frequencyShift7p5khz_e_frequencyShift7p5khz_Optional(_buffer, _size, _lidx, &p->frequencyShift7p5khz);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_ASN1_FrequencyInfoUL_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union NR_ASN1_FrequencyInfoUL_Type_Value* p, enum NR_ASN1_FrequencyInfoUL_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_ASN1_FrequencyInfoUL_Type_R15) {
		_serNrSysDecSQN_NR_FrequencyInfoUL(_buffer, _size, _lidx, _mem, &p->R15);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecNR_ASN1_FrequencyInfoUL_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_ASN1_FrequencyInfoUL_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum NR_ASN1_FrequencyInfoUL_Type_Sel)_tmp;
	}
	_serNrSysDecNR_ASN1_FrequencyInfoUL_Type_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_ASN1_FrequencyInfoUL_Type_FrequencyInfoUL_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_ASN1_FrequencyInfoUL_Type_FrequencyInfoUL_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecNR_ASN1_FrequencyInfoUL_Type(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_ActiveUplinkBWP_Id_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union NR_ActiveUplinkBWP_Id_Type_Value* p, enum NR_ActiveUplinkBWP_Id_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_ActiveUplinkBWP_Id_Type_Explicit) {
		NTOH_8(p->Explicit, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == NR_ActiveUplinkBWP_Id_Type_SameIdAsDL) {
		NTOH_8(p->SameIdAsDL, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecNR_ActiveUplinkBWP_Id_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_ActiveUplinkBWP_Id_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum NR_ActiveUplinkBWP_Id_Type_Sel)_tmp;
	}
	_serNrSysDecNR_ActiveUplinkBWP_Id_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_ActiveUplinkBWP_Id_Type_ActiveBWP_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_ActiveUplinkBWP_Id_Type_ActiveBWP_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecNR_ActiveUplinkBWP_Id_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_BWP_Id_NR_UplinkBWP_Type_Id_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_BWP_Id_NR_UplinkBWP_Type_Id_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_RACH_ConfigGeneric_prach_ConfigurationPeriodScaling_IAB_r16_e_prach_ConfigurationPeriodScaling_IAB_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_RACH_ConfigGeneric_prach_ConfigurationPeriodScaling_IAB_r16_e_prach_ConfigurationPeriodScaling_IAB_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_RACH_ConfigGeneric_prach_ConfigurationPeriodScaling_IAB_r16_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecUint8_t_SQN_NR_RACH_ConfigGeneric_prach_ConfigurationFrameOffset_IAB_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct uint8_t_SQN_NR_RACH_ConfigGeneric_prach_ConfigurationFrameOffset_IAB_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecUint8_t_SQN_NR_RACH_ConfigGeneric_prach_ConfigurationSOffset_IAB_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct uint8_t_SQN_NR_RACH_ConfigGeneric_prach_ConfigurationSOffset_IAB_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_RACH_ConfigGeneric_ra_ResponseWindow_v1610_e_ra_ResponseWindow_v1610_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_RACH_ConfigGeneric_ra_ResponseWindow_v1610_e_ra_ResponseWindow_v1610_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_RACH_ConfigGeneric_ra_ResponseWindow_v1610_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecUint16_t_SQN_NR_RACH_ConfigGeneric_prach_ConfigurationIndex_v1610_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct uint16_t_SQN_NR_RACH_ConfigGeneric_prach_ConfigurationIndex_v1610_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_16(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_RACH_ConfigGeneric(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_RACH_ConfigGeneric* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->prach_ConfigurationIndex, &_buffer[*_lidx], _lidx);
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->msg1_FDM = (SQN_NR_RACH_ConfigGeneric_msg1_FDM_e)_tmp;
	}
	NTOH_16(p->msg1_FrequencyStart, &_buffer[*_lidx], _lidx);
	NTOH_8(p->zeroCorrelationZoneConfig, &_buffer[*_lidx], _lidx);
	NTOH_16(p->preambleReceivedTargetPower, &_buffer[*_lidx], _lidx);
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->preambleTransMax = (SQN_NR_RACH_ConfigGeneric_preambleTransMax_e)_tmp;
	}
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->powerRampingStep = (SQN_NR_RACH_ConfigGeneric_powerRampingStep_e)_tmp;
	}
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->ra_ResponseWindow = (SQN_NR_RACH_ConfigGeneric_ra_ResponseWindow_e)_tmp;
	}
	_serNrSysDecSQN_NR_RACH_ConfigGeneric_prach_ConfigurationPeriodScaling_IAB_r16_e_prach_ConfigurationPeriodScaling_IAB_r16_Optional(_buffer, _size, _lidx, &p->prach_ConfigurationPeriodScaling_IAB_r16);
	_serNrSysDecUint8_t_SQN_NR_RACH_ConfigGeneric_prach_ConfigurationFrameOffset_IAB_r16_Optional(_buffer, _size, _lidx, &p->prach_ConfigurationFrameOffset_IAB_r16);
	_serNrSysDecUint8_t_SQN_NR_RACH_ConfigGeneric_prach_ConfigurationSOffset_IAB_r16_Optional(_buffer, _size, _lidx, &p->prach_ConfigurationSOffset_IAB_r16);
	_serNrSysDecSQN_NR_RACH_ConfigGeneric_ra_ResponseWindow_v1610_e_ra_ResponseWindow_v1610_Optional(_buffer, _size, _lidx, &p->ra_ResponseWindow_v1610);
	_serNrSysDecUint16_t_SQN_NR_RACH_ConfigGeneric_prach_ConfigurationIndex_v1610_Optional(_buffer, _size, _lidx, &p->prach_ConfigurationIndex_v1610);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecUint8_t_SQN_NR_RACH_ConfigCommon_totalNumberOfRA_Preambles_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct uint8_t_SQN_NR_RACH_ConfigCommon_totalNumberOfRA_Preambles_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_RACH_ConfigCommon_ssb_perRACH_OccasionAndCB_PreamblesPerSSB_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union SQN_NR_RACH_ConfigCommon_ssb_perRACH_OccasionAndCB_PreamblesPerSSB_Value* p, enum SQN_NR_RACH_ConfigCommon_ssb_perRACH_OccasionAndCB_PreamblesPerSSB_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_RACH_ConfigCommon_ssb_perRACH_OccasionAndCB_PreamblesPerSSB_oneEighth) {
		{
			size_t _tmp;
			NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
			p->oneEighth = (SQN_NR_RACH_ConfigCommon_ssb_perRACH_OccasionAndCB_PreamblesPerSSB_oneEighth_e)_tmp;
		}
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_RACH_ConfigCommon_ssb_perRACH_OccasionAndCB_PreamblesPerSSB_oneFourth) {
		{
			size_t _tmp;
			NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
			p->oneFourth = (SQN_NR_RACH_ConfigCommon_ssb_perRACH_OccasionAndCB_PreamblesPerSSB_oneFourth_e)_tmp;
		}
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_RACH_ConfigCommon_ssb_perRACH_OccasionAndCB_PreamblesPerSSB_oneHalf) {
		{
			size_t _tmp;
			NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
			p->oneHalf = (SQN_NR_RACH_ConfigCommon_ssb_perRACH_OccasionAndCB_PreamblesPerSSB_oneHalf_e)_tmp;
		}
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_RACH_ConfigCommon_ssb_perRACH_OccasionAndCB_PreamblesPerSSB_one) {
		{
			size_t _tmp;
			NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
			p->one = (SQN_NR_RACH_ConfigCommon_ssb_perRACH_OccasionAndCB_PreamblesPerSSB_one_e)_tmp;
		}
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_RACH_ConfigCommon_ssb_perRACH_OccasionAndCB_PreamblesPerSSB_two) {
		{
			size_t _tmp;
			NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
			p->two = (SQN_NR_RACH_ConfigCommon_ssb_perRACH_OccasionAndCB_PreamblesPerSSB_two_e)_tmp;
		}
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_RACH_ConfigCommon_ssb_perRACH_OccasionAndCB_PreamblesPerSSB_four) {
		NTOH_8(p->four, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_RACH_ConfigCommon_ssb_perRACH_OccasionAndCB_PreamblesPerSSB_eight) {
		NTOH_8(p->eight, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_RACH_ConfigCommon_ssb_perRACH_OccasionAndCB_PreamblesPerSSB_sixteen) {
		NTOH_8(p->sixteen, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecSQN_NR_RACH_ConfigCommon_ssb_perRACH_OccasionAndCB_PreamblesPerSSB(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_RACH_ConfigCommon_ssb_perRACH_OccasionAndCB_PreamblesPerSSB* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SQN_NR_RACH_ConfigCommon_ssb_perRACH_OccasionAndCB_PreamblesPerSSB_Sel)_tmp;
	}
	_serNrSysDecSQN_NR_RACH_ConfigCommon_ssb_perRACH_OccasionAndCB_PreamblesPerSSB_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_RACH_ConfigCommon_ssb_perRACH_OccasionAndCB_PreamblesPerSSB_ssb_perRACH_OccasionAndCB_PreamblesPerSSB_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_RACH_ConfigCommon_ssb_perRACH_OccasionAndCB_PreamblesPerSSB_ssb_perRACH_OccasionAndCB_PreamblesPerSSB_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_RACH_ConfigCommon_ssb_perRACH_OccasionAndCB_PreamblesPerSSB(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_RACH_ConfigCommon_groupBconfigured(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_RACH_ConfigCommon_groupBconfigured* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->ra_Msg3SizeGroupA = (SQN_NR_RACH_ConfigCommon_groupBconfigured_ra_Msg3SizeGroupA_e)_tmp;
	}
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->messagePowerOffsetGroupB = (SQN_NR_RACH_ConfigCommon_groupBconfigured_messagePowerOffsetGroupB_e)_tmp;
	}
	NTOH_8(p->numberOfRA_PreamblesGroupA, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_RACH_ConfigCommon_groupBconfigured_groupBconfigured_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_RACH_ConfigCommon_groupBconfigured_groupBconfigured_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_RACH_ConfigCommon_groupBconfigured(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_RSRP_Range_SQN_NR_RACH_ConfigCommon_rsrp_ThresholdSSB_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_RSRP_Range_SQN_NR_RACH_ConfigCommon_rsrp_ThresholdSSB_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_RSRP_Range_SQN_NR_RACH_ConfigCommon_rsrp_ThresholdSSB_SUL_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_RSRP_Range_SQN_NR_RACH_ConfigCommon_rsrp_ThresholdSSB_SUL_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_RACH_ConfigCommon_prach_RootSequenceIndex_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union SQN_NR_RACH_ConfigCommon_prach_RootSequenceIndex_Value* p, enum SQN_NR_RACH_ConfigCommon_prach_RootSequenceIndex_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_RACH_ConfigCommon_prach_RootSequenceIndex_l839) {
		NTOH_16(p->l839, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_RACH_ConfigCommon_prach_RootSequenceIndex_l139) {
		NTOH_8(p->l139, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecSQN_NR_RACH_ConfigCommon_prach_RootSequenceIndex(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_RACH_ConfigCommon_prach_RootSequenceIndex* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SQN_NR_RACH_ConfigCommon_prach_RootSequenceIndex_Sel)_tmp;
	}
	_serNrSysDecSQN_NR_RACH_ConfigCommon_prach_RootSequenceIndex_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SubcarrierSpacing_e_SQN_NR_RACH_ConfigCommon_msg1_SubcarrierSpacing_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SubcarrierSpacing_e_SQN_NR_RACH_ConfigCommon_msg1_SubcarrierSpacing_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_SubcarrierSpacing_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_RACH_ConfigCommon_msg3_transformPrecoder_e_msg3_transformPrecoder_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_RACH_ConfigCommon_msg3_transformPrecoder_e_msg3_transformPrecoder_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_RACH_ConfigCommon_msg3_transformPrecoder_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_RA_Prioritization_scalingFactorBI_e_scalingFactorBI_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_RA_Prioritization_scalingFactorBI_e_scalingFactorBI_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_RA_Prioritization_scalingFactorBI_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_RA_Prioritization(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_RA_Prioritization* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->powerRampingStepHighPriority = (SQN_NR_RA_Prioritization_powerRampingStepHighPriority_e)_tmp;
	}
	_serNrSysDecSQN_NR_RA_Prioritization_scalingFactorBI_e_scalingFactorBI_Optional(_buffer, _size, _lidx, &p->scalingFactorBI);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_RACH_ConfigCommon_ra_PrioritizationForAccessIdentity_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_RACH_ConfigCommon_ra_PrioritizationForAccessIdentity_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecSQN_NR_RA_Prioritization(_buffer, _size, _lidx, &p->ra_Prioritization_r16);
	for (size_t i2 = 0; i2 < 2; i2++) {
		NTOH_8(p->ra_PrioritizationForAI_r16[i2], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_RACH_ConfigCommon_ra_PrioritizationForAccessIdentity_r16_ra_PrioritizationForAccessIdentity_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_RACH_ConfigCommon_ra_PrioritizationForAccessIdentity_r16_ra_PrioritizationForAccessIdentity_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_RACH_ConfigCommon_ra_PrioritizationForAccessIdentity_r16(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_RACH_ConfigCommon_prach_RootSequenceIndex_r16_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union SQN_NR_RACH_ConfigCommon_prach_RootSequenceIndex_r16_Value* p, enum SQN_NR_RACH_ConfigCommon_prach_RootSequenceIndex_r16_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_RACH_ConfigCommon_prach_RootSequenceIndex_r16_l571) {
		NTOH_16(p->l571, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_RACH_ConfigCommon_prach_RootSequenceIndex_r16_l1151) {
		NTOH_16(p->l1151, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecSQN_NR_RACH_ConfigCommon_prach_RootSequenceIndex_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_RACH_ConfigCommon_prach_RootSequenceIndex_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SQN_NR_RACH_ConfigCommon_prach_RootSequenceIndex_r16_Sel)_tmp;
	}
	_serNrSysDecSQN_NR_RACH_ConfigCommon_prach_RootSequenceIndex_r16_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_RACH_ConfigCommon_prach_RootSequenceIndex_r16_prach_RootSequenceIndex_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_RACH_ConfigCommon_prach_RootSequenceIndex_r16_prach_RootSequenceIndex_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_RACH_ConfigCommon_prach_RootSequenceIndex_r16(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_RACH_ConfigCommon(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_RACH_ConfigCommon* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecSQN_NR_RACH_ConfigGeneric(_buffer, _size, _lidx, &p->rach_ConfigGeneric);
	_serNrSysDecUint8_t_SQN_NR_RACH_ConfigCommon_totalNumberOfRA_Preambles_Optional(_buffer, _size, _lidx, &p->totalNumberOfRA_Preambles);
	_serNrSysDecSQN_NR_RACH_ConfigCommon_ssb_perRACH_OccasionAndCB_PreamblesPerSSB_ssb_perRACH_OccasionAndCB_PreamblesPerSSB_Optional(_buffer, _size, _lidx, &p->ssb_perRACH_OccasionAndCB_PreamblesPerSSB);
	_serNrSysDecSQN_NR_RACH_ConfigCommon_groupBconfigured_groupBconfigured_Optional(_buffer, _size, _lidx, &p->groupBconfigured);
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->ra_ContentionResolutionTimer = (SQN_NR_RACH_ConfigCommon_ra_ContentionResolutionTimer_e)_tmp;
	}
	_serNrSysDecSQN_NR_RSRP_Range_SQN_NR_RACH_ConfigCommon_rsrp_ThresholdSSB_Optional(_buffer, _size, _lidx, &p->rsrp_ThresholdSSB);
	_serNrSysDecSQN_NR_RSRP_Range_SQN_NR_RACH_ConfigCommon_rsrp_ThresholdSSB_SUL_Optional(_buffer, _size, _lidx, &p->rsrp_ThresholdSSB_SUL);
	_serNrSysDecSQN_NR_RACH_ConfigCommon_prach_RootSequenceIndex(_buffer, _size, _lidx, &p->prach_RootSequenceIndex);
	_serNrSysDecSQN_NR_SubcarrierSpacing_e_SQN_NR_RACH_ConfigCommon_msg1_SubcarrierSpacing_Optional(_buffer, _size, _lidx, &p->msg1_SubcarrierSpacing);
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->restrictedSetConfig = (SQN_NR_RACH_ConfigCommon_restrictedSetConfig_e)_tmp;
	}
	_serNrSysDecSQN_NR_RACH_ConfigCommon_msg3_transformPrecoder_e_msg3_transformPrecoder_Optional(_buffer, _size, _lidx, &p->msg3_transformPrecoder);
	_serNrSysDecSQN_NR_RACH_ConfigCommon_ra_PrioritizationForAccessIdentity_r16_ra_PrioritizationForAccessIdentity_r16_Optional(_buffer, _size, _lidx, &p->ra_PrioritizationForAccessIdentity_r16);
	_serNrSysDecSQN_NR_RACH_ConfigCommon_prach_RootSequenceIndex_r16_prach_RootSequenceIndex_r16_Optional(_buffer, _size, _lidx, &p->prach_RootSequenceIndex_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SetupRelease_BWP_UplinkCommon_rach_ConfigCommon_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union SQN_NR_SetupRelease_BWP_UplinkCommon_rach_ConfigCommon_Value* p, enum SQN_NR_SetupRelease_BWP_UplinkCommon_rach_ConfigCommon_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SetupRelease_BWP_UplinkCommon_rach_ConfigCommon_release) {
		NTOH_8(p->release, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SetupRelease_BWP_UplinkCommon_rach_ConfigCommon_setup) {
		_serNrSysDecSQN_NR_RACH_ConfigCommon(_buffer, _size, _lidx, &p->setup);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecSQN_NR_SetupRelease_BWP_UplinkCommon_rach_ConfigCommon(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SetupRelease_BWP_UplinkCommon_rach_ConfigCommon* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SQN_NR_SetupRelease_BWP_UplinkCommon_rach_ConfigCommon_Sel)_tmp;
	}
	_serNrSysDecSQN_NR_SetupRelease_BWP_UplinkCommon_rach_ConfigCommon_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SetupRelease_BWP_UplinkCommon_rach_ConfigCommon_SQN_NR_BWP_UplinkCommon_rach_ConfigCommon_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SetupRelease_BWP_UplinkCommon_rach_ConfigCommon_SQN_NR_BWP_UplinkCommon_rach_ConfigCommon_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_SetupRelease_BWP_UplinkCommon_rach_ConfigCommon(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PUSCH_ConfigCommon_groupHoppingEnabledTransformPrecoding_e_groupHoppingEnabledTransformPrecoding_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_PUSCH_ConfigCommon_groupHoppingEnabledTransformPrecoding_e_groupHoppingEnabledTransformPrecoding_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_PUSCH_ConfigCommon_groupHoppingEnabledTransformPrecoding_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecUint8_t_SQN_NR_PUSCH_TimeDomainResourceAllocation_k2_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct uint8_t_SQN_NR_PUSCH_TimeDomainResourceAllocation_k2_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PUSCH_TimeDomainResourceAllocation(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_PUSCH_TimeDomainResourceAllocation* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecUint8_t_SQN_NR_PUSCH_TimeDomainResourceAllocation_k2_Optional(_buffer, _size, _lidx, &p->k2);
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->mappingType = (SQN_NR_PUSCH_TimeDomainResourceAllocation_mappingType_e)_tmp;
	}
	NTOH_8(p->startSymbolAndLength, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PUSCH_TimeDomainResourceAllocationList_SQN_NR_PUSCH_ConfigCommon_pusch_TimeDomainAllocationList_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_PUSCH_TimeDomainResourceAllocationList_SQN_NR_PUSCH_ConfigCommon_pusch_TimeDomainAllocationList_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = (struct SQN_NR_PUSCH_TimeDomainResourceAllocation*)serMalloc(_mem, p->v.d * sizeof(struct SQN_NR_PUSCH_TimeDomainResourceAllocation));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serNrSysDecSQN_NR_PUSCH_TimeDomainResourceAllocation(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecInt8_t_SQN_NR_PUSCH_ConfigCommon_msg3_DeltaPreamble_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct int8_t_SQN_NR_PUSCH_ConfigCommon_msg3_DeltaPreamble_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecInt16_t_SQN_NR_PUSCH_ConfigCommon_p0_NominalWithGrant_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct int16_t_SQN_NR_PUSCH_ConfigCommon_p0_NominalWithGrant_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_16(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PUSCH_ConfigCommon(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_PUSCH_ConfigCommon* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecSQN_NR_PUSCH_ConfigCommon_groupHoppingEnabledTransformPrecoding_e_groupHoppingEnabledTransformPrecoding_Optional(_buffer, _size, _lidx, &p->groupHoppingEnabledTransformPrecoding);
	_serNrSysDecSQN_NR_PUSCH_TimeDomainResourceAllocationList_SQN_NR_PUSCH_ConfigCommon_pusch_TimeDomainAllocationList_Optional(_buffer, _size, _lidx, _mem, &p->pusch_TimeDomainAllocationList);
	_serNrSysDecInt8_t_SQN_NR_PUSCH_ConfigCommon_msg3_DeltaPreamble_Optional(_buffer, _size, _lidx, &p->msg3_DeltaPreamble);
	_serNrSysDecInt16_t_SQN_NR_PUSCH_ConfigCommon_p0_NominalWithGrant_Optional(_buffer, _size, _lidx, &p->p0_NominalWithGrant);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SetupRelease_BWP_UplinkCommon_pusch_ConfigCommon_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union SQN_NR_SetupRelease_BWP_UplinkCommon_pusch_ConfigCommon_Value* p, enum SQN_NR_SetupRelease_BWP_UplinkCommon_pusch_ConfigCommon_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SetupRelease_BWP_UplinkCommon_pusch_ConfigCommon_release) {
		NTOH_8(p->release, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SetupRelease_BWP_UplinkCommon_pusch_ConfigCommon_setup) {
		_serNrSysDecSQN_NR_PUSCH_ConfigCommon(_buffer, _size, _lidx, _mem, &p->setup);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecSQN_NR_SetupRelease_BWP_UplinkCommon_pusch_ConfigCommon(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_SetupRelease_BWP_UplinkCommon_pusch_ConfigCommon* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SQN_NR_SetupRelease_BWP_UplinkCommon_pusch_ConfigCommon_Sel)_tmp;
	}
	_serNrSysDecSQN_NR_SetupRelease_BWP_UplinkCommon_pusch_ConfigCommon_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SetupRelease_BWP_UplinkCommon_pusch_ConfigCommon_SQN_NR_BWP_UplinkCommon_pusch_ConfigCommon_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_SetupRelease_BWP_UplinkCommon_pusch_ConfigCommon_SQN_NR_BWP_UplinkCommon_pusch_ConfigCommon_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_SetupRelease_BWP_UplinkCommon_pusch_ConfigCommon(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecUint8_t_SQN_NR_PUCCH_ConfigCommon_pucch_ResourceCommon_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct uint8_t_SQN_NR_PUCCH_ConfigCommon_pucch_ResourceCommon_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecUint16_t_SQN_NR_PUCCH_ConfigCommon_hoppingId_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct uint16_t_SQN_NR_PUCCH_ConfigCommon_hoppingId_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_16(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecInt16_t_SQN_NR_PUCCH_ConfigCommon_p0_nominal_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct int16_t_SQN_NR_PUCCH_ConfigCommon_p0_nominal_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_16(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PUCCH_ConfigCommon(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_PUCCH_ConfigCommon* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecUint8_t_SQN_NR_PUCCH_ConfigCommon_pucch_ResourceCommon_Optional(_buffer, _size, _lidx, &p->pucch_ResourceCommon);
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->pucch_GroupHopping = (SQN_NR_PUCCH_ConfigCommon_pucch_GroupHopping_e)_tmp;
	}
	_serNrSysDecUint16_t_SQN_NR_PUCCH_ConfigCommon_hoppingId_Optional(_buffer, _size, _lidx, &p->hoppingId);
	_serNrSysDecInt16_t_SQN_NR_PUCCH_ConfigCommon_p0_nominal_Optional(_buffer, _size, _lidx, &p->p0_nominal);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SetupRelease_BWP_UplinkCommon_pucch_ConfigCommon_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union SQN_NR_SetupRelease_BWP_UplinkCommon_pucch_ConfigCommon_Value* p, enum SQN_NR_SetupRelease_BWP_UplinkCommon_pucch_ConfigCommon_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SetupRelease_BWP_UplinkCommon_pucch_ConfigCommon_release) {
		NTOH_8(p->release, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SetupRelease_BWP_UplinkCommon_pucch_ConfigCommon_setup) {
		_serNrSysDecSQN_NR_PUCCH_ConfigCommon(_buffer, _size, _lidx, &p->setup);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecSQN_NR_SetupRelease_BWP_UplinkCommon_pucch_ConfigCommon(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SetupRelease_BWP_UplinkCommon_pucch_ConfigCommon* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SQN_NR_SetupRelease_BWP_UplinkCommon_pucch_ConfigCommon_Sel)_tmp;
	}
	_serNrSysDecSQN_NR_SetupRelease_BWP_UplinkCommon_pucch_ConfigCommon_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SetupRelease_BWP_UplinkCommon_pucch_ConfigCommon_SQN_NR_BWP_UplinkCommon_pucch_ConfigCommon_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SetupRelease_BWP_UplinkCommon_pucch_ConfigCommon_SQN_NR_BWP_UplinkCommon_pucch_ConfigCommon_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_SetupRelease_BWP_UplinkCommon_pucch_ConfigCommon(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SetupRelease_BWP_UplinkCommon_rach_ConfigCommonIAB_r16_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union SQN_NR_SetupRelease_BWP_UplinkCommon_rach_ConfigCommonIAB_r16_Value* p, enum SQN_NR_SetupRelease_BWP_UplinkCommon_rach_ConfigCommonIAB_r16_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SetupRelease_BWP_UplinkCommon_rach_ConfigCommonIAB_r16_release) {
		NTOH_8(p->release, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SetupRelease_BWP_UplinkCommon_rach_ConfigCommonIAB_r16_setup) {
		_serNrSysDecSQN_NR_RACH_ConfigCommon(_buffer, _size, _lidx, &p->setup);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecSQN_NR_SetupRelease_BWP_UplinkCommon_rach_ConfigCommonIAB_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SetupRelease_BWP_UplinkCommon_rach_ConfigCommonIAB_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SQN_NR_SetupRelease_BWP_UplinkCommon_rach_ConfigCommonIAB_r16_Sel)_tmp;
	}
	_serNrSysDecSQN_NR_SetupRelease_BWP_UplinkCommon_rach_ConfigCommonIAB_r16_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SetupRelease_BWP_UplinkCommon_rach_ConfigCommonIAB_r16_SQN_NR_BWP_UplinkCommon_rach_ConfigCommonIAB_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SetupRelease_BWP_UplinkCommon_rach_ConfigCommonIAB_r16_SQN_NR_BWP_UplinkCommon_rach_ConfigCommonIAB_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_SetupRelease_BWP_UplinkCommon_rach_ConfigCommonIAB_r16(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_BWP_UplinkCommon_useInterlacePUCCH_PUSCH_r16_e_useInterlacePUCCH_PUSCH_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_BWP_UplinkCommon_useInterlacePUCCH_PUSCH_r16_e_useInterlacePUCCH_PUSCH_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_BWP_UplinkCommon_useInterlacePUCCH_PUSCH_r16_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecUint16_t_SQN_NR_RACH_ConfigGenericTwoStepRA_r16_msgA_PRACH_ConfigurationIndex_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct uint16_t_SQN_NR_RACH_ConfigGenericTwoStepRA_r16_msgA_PRACH_ConfigurationIndex_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_16(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_RACH_ConfigGenericTwoStepRA_r16_msgA_RO_FDM_r16_e_msgA_RO_FDM_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_RACH_ConfigGenericTwoStepRA_r16_msgA_RO_FDM_r16_e_msgA_RO_FDM_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_RACH_ConfigGenericTwoStepRA_r16_msgA_RO_FDM_r16_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecUint16_t_SQN_NR_RACH_ConfigGenericTwoStepRA_r16_msgA_RO_FrequencyStart_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct uint16_t_SQN_NR_RACH_ConfigGenericTwoStepRA_r16_msgA_RO_FrequencyStart_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_16(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecUint8_t_SQN_NR_RACH_ConfigGenericTwoStepRA_r16_msgA_ZeroCorrelationZoneConfig_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct uint8_t_SQN_NR_RACH_ConfigGenericTwoStepRA_r16_msgA_ZeroCorrelationZoneConfig_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_RACH_ConfigGenericTwoStepRA_r16_msgA_PreamblePowerRampingStep_r16_e_msgA_PreamblePowerRampingStep_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_RACH_ConfigGenericTwoStepRA_r16_msgA_PreamblePowerRampingStep_r16_e_msgA_PreamblePowerRampingStep_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_RACH_ConfigGenericTwoStepRA_r16_msgA_PreamblePowerRampingStep_r16_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecInt16_t_SQN_NR_RACH_ConfigGenericTwoStepRA_r16_msgA_PreambleReceivedTargetPower_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct int16_t_SQN_NR_RACH_ConfigGenericTwoStepRA_r16_msgA_PreambleReceivedTargetPower_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_16(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_RACH_ConfigGenericTwoStepRA_r16_msgB_ResponseWindow_r16_e_msgB_ResponseWindow_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_RACH_ConfigGenericTwoStepRA_r16_msgB_ResponseWindow_r16_e_msgB_ResponseWindow_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_RACH_ConfigGenericTwoStepRA_r16_msgB_ResponseWindow_r16_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_RACH_ConfigGenericTwoStepRA_r16_preambleTransMax_r16_e_preambleTransMax_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_RACH_ConfigGenericTwoStepRA_r16_preambleTransMax_r16_e_preambleTransMax_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_RACH_ConfigGenericTwoStepRA_r16_preambleTransMax_r16_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_RACH_ConfigGenericTwoStepRA_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_RACH_ConfigGenericTwoStepRA_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecUint16_t_SQN_NR_RACH_ConfigGenericTwoStepRA_r16_msgA_PRACH_ConfigurationIndex_r16_Optional(_buffer, _size, _lidx, &p->msgA_PRACH_ConfigurationIndex_r16);
	_serNrSysDecSQN_NR_RACH_ConfigGenericTwoStepRA_r16_msgA_RO_FDM_r16_e_msgA_RO_FDM_r16_Optional(_buffer, _size, _lidx, &p->msgA_RO_FDM_r16);
	_serNrSysDecUint16_t_SQN_NR_RACH_ConfigGenericTwoStepRA_r16_msgA_RO_FrequencyStart_r16_Optional(_buffer, _size, _lidx, &p->msgA_RO_FrequencyStart_r16);
	_serNrSysDecUint8_t_SQN_NR_RACH_ConfigGenericTwoStepRA_r16_msgA_ZeroCorrelationZoneConfig_r16_Optional(_buffer, _size, _lidx, &p->msgA_ZeroCorrelationZoneConfig_r16);
	_serNrSysDecSQN_NR_RACH_ConfigGenericTwoStepRA_r16_msgA_PreamblePowerRampingStep_r16_e_msgA_PreamblePowerRampingStep_r16_Optional(_buffer, _size, _lidx, &p->msgA_PreamblePowerRampingStep_r16);
	_serNrSysDecInt16_t_SQN_NR_RACH_ConfigGenericTwoStepRA_r16_msgA_PreambleReceivedTargetPower_r16_Optional(_buffer, _size, _lidx, &p->msgA_PreambleReceivedTargetPower_r16);
	_serNrSysDecSQN_NR_RACH_ConfigGenericTwoStepRA_r16_msgB_ResponseWindow_r16_e_msgB_ResponseWindow_r16_Optional(_buffer, _size, _lidx, &p->msgB_ResponseWindow_r16);
	_serNrSysDecSQN_NR_RACH_ConfigGenericTwoStepRA_r16_preambleTransMax_r16_e_preambleTransMax_r16_Optional(_buffer, _size, _lidx, &p->preambleTransMax_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecUint8_t_SQN_NR_RACH_ConfigCommonTwoStepRA_r16_msgA_TotalNumberOfRA_Preambles_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct uint8_t_SQN_NR_RACH_ConfigCommonTwoStepRA_r16_msgA_TotalNumberOfRA_Preambles_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_RACH_ConfigCommonTwoStepRA_r16_msgA_SSB_PerRACH_OccasionAndCB_PreamblesPerSSB_r16_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union SQN_NR_RACH_ConfigCommonTwoStepRA_r16_msgA_SSB_PerRACH_OccasionAndCB_PreamblesPerSSB_r16_Value* p, enum SQN_NR_RACH_ConfigCommonTwoStepRA_r16_msgA_SSB_PerRACH_OccasionAndCB_PreamblesPerSSB_r16_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_RACH_ConfigCommonTwoStepRA_r16_msgA_SSB_PerRACH_OccasionAndCB_PreamblesPerSSB_r16_oneEighth) {
		{
			size_t _tmp;
			NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
			p->oneEighth = (SQN_NR_RACH_ConfigCommonTwoStepRA_r16_msgA_SSB_PerRACH_OccasionAndCB_PreamblesPerSSB_r16_oneEighth_e)_tmp;
		}
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_RACH_ConfigCommonTwoStepRA_r16_msgA_SSB_PerRACH_OccasionAndCB_PreamblesPerSSB_r16_oneFourth) {
		{
			size_t _tmp;
			NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
			p->oneFourth = (SQN_NR_RACH_ConfigCommonTwoStepRA_r16_msgA_SSB_PerRACH_OccasionAndCB_PreamblesPerSSB_r16_oneFourth_e)_tmp;
		}
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_RACH_ConfigCommonTwoStepRA_r16_msgA_SSB_PerRACH_OccasionAndCB_PreamblesPerSSB_r16_oneHalf) {
		{
			size_t _tmp;
			NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
			p->oneHalf = (SQN_NR_RACH_ConfigCommonTwoStepRA_r16_msgA_SSB_PerRACH_OccasionAndCB_PreamblesPerSSB_r16_oneHalf_e)_tmp;
		}
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_RACH_ConfigCommonTwoStepRA_r16_msgA_SSB_PerRACH_OccasionAndCB_PreamblesPerSSB_r16_one) {
		{
			size_t _tmp;
			NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
			p->one = (SQN_NR_RACH_ConfigCommonTwoStepRA_r16_msgA_SSB_PerRACH_OccasionAndCB_PreamblesPerSSB_r16_one_e)_tmp;
		}
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_RACH_ConfigCommonTwoStepRA_r16_msgA_SSB_PerRACH_OccasionAndCB_PreamblesPerSSB_r16_two) {
		{
			size_t _tmp;
			NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
			p->two = (SQN_NR_RACH_ConfigCommonTwoStepRA_r16_msgA_SSB_PerRACH_OccasionAndCB_PreamblesPerSSB_r16_two_e)_tmp;
		}
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_RACH_ConfigCommonTwoStepRA_r16_msgA_SSB_PerRACH_OccasionAndCB_PreamblesPerSSB_r16_four) {
		NTOH_8(p->four, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_RACH_ConfigCommonTwoStepRA_r16_msgA_SSB_PerRACH_OccasionAndCB_PreamblesPerSSB_r16_eight) {
		NTOH_8(p->eight, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_RACH_ConfigCommonTwoStepRA_r16_msgA_SSB_PerRACH_OccasionAndCB_PreamblesPerSSB_r16_sixteen) {
		NTOH_8(p->sixteen, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecSQN_NR_RACH_ConfigCommonTwoStepRA_r16_msgA_SSB_PerRACH_OccasionAndCB_PreamblesPerSSB_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_RACH_ConfigCommonTwoStepRA_r16_msgA_SSB_PerRACH_OccasionAndCB_PreamblesPerSSB_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SQN_NR_RACH_ConfigCommonTwoStepRA_r16_msgA_SSB_PerRACH_OccasionAndCB_PreamblesPerSSB_r16_Sel)_tmp;
	}
	_serNrSysDecSQN_NR_RACH_ConfigCommonTwoStepRA_r16_msgA_SSB_PerRACH_OccasionAndCB_PreamblesPerSSB_r16_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_RACH_ConfigCommonTwoStepRA_r16_msgA_SSB_PerRACH_OccasionAndCB_PreamblesPerSSB_r16_msgA_SSB_PerRACH_OccasionAndCB_PreamblesPerSSB_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_RACH_ConfigCommonTwoStepRA_r16_msgA_SSB_PerRACH_OccasionAndCB_PreamblesPerSSB_r16_msgA_SSB_PerRACH_OccasionAndCB_PreamblesPerSSB_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_RACH_ConfigCommonTwoStepRA_r16_msgA_SSB_PerRACH_OccasionAndCB_PreamblesPerSSB_r16(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecUint8_t_SQN_NR_RACH_ConfigCommonTwoStepRA_r16_msgA_CB_PreamblesPerSSB_PerSharedRO_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct uint8_t_SQN_NR_RACH_ConfigCommonTwoStepRA_r16_msgA_CB_PreamblesPerSSB_PerSharedRO_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecUint8_t_SQN_NR_RACH_ConfigCommonTwoStepRA_r16_msgA_SSB_SharedRO_MaskIndex_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct uint8_t_SQN_NR_RACH_ConfigCommonTwoStepRA_r16_msgA_SSB_SharedRO_MaskIndex_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_GroupB_ConfiguredTwoStepRA_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_GroupB_ConfiguredTwoStepRA_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->ra_MsgA_SizeGroupA = (SQN_NR_GroupB_ConfiguredTwoStepRA_r16_ra_MsgA_SizeGroupA_e)_tmp;
	}
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->messagePowerOffsetGroupB = (SQN_NR_GroupB_ConfiguredTwoStepRA_r16_messagePowerOffsetGroupB_e)_tmp;
	}
	NTOH_8(p->numberofRA_PreamblesGroupA, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_GroupB_ConfiguredTwoStepRA_r16_SQN_NR_RACH_ConfigCommonTwoStepRA_r16_groupB_ConfiguredTwoStepRA_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_GroupB_ConfiguredTwoStepRA_r16_SQN_NR_RACH_ConfigCommonTwoStepRA_r16_groupB_ConfiguredTwoStepRA_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_GroupB_ConfiguredTwoStepRA_r16(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_RACH_ConfigCommonTwoStepRA_r16_msgA_PRACH_RootSequenceIndex_r16_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union SQN_NR_RACH_ConfigCommonTwoStepRA_r16_msgA_PRACH_RootSequenceIndex_r16_Value* p, enum SQN_NR_RACH_ConfigCommonTwoStepRA_r16_msgA_PRACH_RootSequenceIndex_r16_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_RACH_ConfigCommonTwoStepRA_r16_msgA_PRACH_RootSequenceIndex_r16_l839) {
		NTOH_16(p->l839, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_RACH_ConfigCommonTwoStepRA_r16_msgA_PRACH_RootSequenceIndex_r16_l139) {
		NTOH_8(p->l139, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_RACH_ConfigCommonTwoStepRA_r16_msgA_PRACH_RootSequenceIndex_r16_l571) {
		NTOH_16(p->l571, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_RACH_ConfigCommonTwoStepRA_r16_msgA_PRACH_RootSequenceIndex_r16_l1151) {
		NTOH_16(p->l1151, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecSQN_NR_RACH_ConfigCommonTwoStepRA_r16_msgA_PRACH_RootSequenceIndex_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_RACH_ConfigCommonTwoStepRA_r16_msgA_PRACH_RootSequenceIndex_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SQN_NR_RACH_ConfigCommonTwoStepRA_r16_msgA_PRACH_RootSequenceIndex_r16_Sel)_tmp;
	}
	_serNrSysDecSQN_NR_RACH_ConfigCommonTwoStepRA_r16_msgA_PRACH_RootSequenceIndex_r16_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_RACH_ConfigCommonTwoStepRA_r16_msgA_PRACH_RootSequenceIndex_r16_msgA_PRACH_RootSequenceIndex_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_RACH_ConfigCommonTwoStepRA_r16_msgA_PRACH_RootSequenceIndex_r16_msgA_PRACH_RootSequenceIndex_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_RACH_ConfigCommonTwoStepRA_r16_msgA_PRACH_RootSequenceIndex_r16(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_RACH_ConfigCommonTwoStepRA_r16_msgA_TransMax_r16_e_msgA_TransMax_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_RACH_ConfigCommonTwoStepRA_r16_msgA_TransMax_r16_e_msgA_TransMax_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_RACH_ConfigCommonTwoStepRA_r16_msgA_TransMax_r16_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_RSRP_Range_SQN_NR_RACH_ConfigCommonTwoStepRA_r16_msgA_RSRP_Threshold_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_RSRP_Range_SQN_NR_RACH_ConfigCommonTwoStepRA_r16_msgA_RSRP_Threshold_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_RSRP_Range_SQN_NR_RACH_ConfigCommonTwoStepRA_r16_msgA_RSRP_ThresholdSSB_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_RSRP_Range_SQN_NR_RACH_ConfigCommonTwoStepRA_r16_msgA_RSRP_ThresholdSSB_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SubcarrierSpacing_e_SQN_NR_RACH_ConfigCommonTwoStepRA_r16_msgA_SubcarrierSpacing_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SubcarrierSpacing_e_SQN_NR_RACH_ConfigCommonTwoStepRA_r16_msgA_SubcarrierSpacing_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_SubcarrierSpacing_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_RACH_ConfigCommonTwoStepRA_r16_msgA_RestrictedSetConfig_r16_e_msgA_RestrictedSetConfig_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_RACH_ConfigCommonTwoStepRA_r16_msgA_RestrictedSetConfig_r16_e_msgA_RestrictedSetConfig_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_RACH_ConfigCommonTwoStepRA_r16_msgA_RestrictedSetConfig_r16_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_RACH_ConfigCommonTwoStepRA_r16_ra_PrioritizationForAccessIdentityTwoStep_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_RACH_ConfigCommonTwoStepRA_r16_ra_PrioritizationForAccessIdentityTwoStep_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecSQN_NR_RA_Prioritization(_buffer, _size, _lidx, &p->ra_Prioritization_r16);
	for (size_t i2 = 0; i2 < 2; i2++) {
		NTOH_8(p->ra_PrioritizationForAI_r16[i2], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_RACH_ConfigCommonTwoStepRA_r16_ra_PrioritizationForAccessIdentityTwoStep_r16_ra_PrioritizationForAccessIdentityTwoStep_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_RACH_ConfigCommonTwoStepRA_r16_ra_PrioritizationForAccessIdentityTwoStep_r16_ra_PrioritizationForAccessIdentityTwoStep_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_RACH_ConfigCommonTwoStepRA_r16_ra_PrioritizationForAccessIdentityTwoStep_r16(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_RACH_ConfigCommonTwoStepRA_r16_ra_ContentionResolutionTimer_r16_e_ra_ContentionResolutionTimer_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_RACH_ConfigCommonTwoStepRA_r16_ra_ContentionResolutionTimer_r16_e_ra_ContentionResolutionTimer_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_RACH_ConfigCommonTwoStepRA_r16_ra_ContentionResolutionTimer_r16_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_RACH_ConfigCommonTwoStepRA_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_RACH_ConfigCommonTwoStepRA_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecSQN_NR_RACH_ConfigGenericTwoStepRA_r16(_buffer, _size, _lidx, &p->rach_ConfigGenericTwoStepRA_r16);
	_serNrSysDecUint8_t_SQN_NR_RACH_ConfigCommonTwoStepRA_r16_msgA_TotalNumberOfRA_Preambles_r16_Optional(_buffer, _size, _lidx, &p->msgA_TotalNumberOfRA_Preambles_r16);
	_serNrSysDecSQN_NR_RACH_ConfigCommonTwoStepRA_r16_msgA_SSB_PerRACH_OccasionAndCB_PreamblesPerSSB_r16_msgA_SSB_PerRACH_OccasionAndCB_PreamblesPerSSB_r16_Optional(_buffer, _size, _lidx, &p->msgA_SSB_PerRACH_OccasionAndCB_PreamblesPerSSB_r16);
	_serNrSysDecUint8_t_SQN_NR_RACH_ConfigCommonTwoStepRA_r16_msgA_CB_PreamblesPerSSB_PerSharedRO_r16_Optional(_buffer, _size, _lidx, &p->msgA_CB_PreamblesPerSSB_PerSharedRO_r16);
	_serNrSysDecUint8_t_SQN_NR_RACH_ConfigCommonTwoStepRA_r16_msgA_SSB_SharedRO_MaskIndex_r16_Optional(_buffer, _size, _lidx, &p->msgA_SSB_SharedRO_MaskIndex_r16);
	_serNrSysDecSQN_NR_GroupB_ConfiguredTwoStepRA_r16_SQN_NR_RACH_ConfigCommonTwoStepRA_r16_groupB_ConfiguredTwoStepRA_r16_Optional(_buffer, _size, _lidx, &p->groupB_ConfiguredTwoStepRA_r16);
	_serNrSysDecSQN_NR_RACH_ConfigCommonTwoStepRA_r16_msgA_PRACH_RootSequenceIndex_r16_msgA_PRACH_RootSequenceIndex_r16_Optional(_buffer, _size, _lidx, &p->msgA_PRACH_RootSequenceIndex_r16);
	_serNrSysDecSQN_NR_RACH_ConfigCommonTwoStepRA_r16_msgA_TransMax_r16_e_msgA_TransMax_r16_Optional(_buffer, _size, _lidx, &p->msgA_TransMax_r16);
	_serNrSysDecSQN_NR_RSRP_Range_SQN_NR_RACH_ConfigCommonTwoStepRA_r16_msgA_RSRP_Threshold_r16_Optional(_buffer, _size, _lidx, &p->msgA_RSRP_Threshold_r16);
	_serNrSysDecSQN_NR_RSRP_Range_SQN_NR_RACH_ConfigCommonTwoStepRA_r16_msgA_RSRP_ThresholdSSB_r16_Optional(_buffer, _size, _lidx, &p->msgA_RSRP_ThresholdSSB_r16);
	_serNrSysDecSQN_NR_SubcarrierSpacing_e_SQN_NR_RACH_ConfigCommonTwoStepRA_r16_msgA_SubcarrierSpacing_r16_Optional(_buffer, _size, _lidx, &p->msgA_SubcarrierSpacing_r16);
	_serNrSysDecSQN_NR_RACH_ConfigCommonTwoStepRA_r16_msgA_RestrictedSetConfig_r16_e_msgA_RestrictedSetConfig_r16_Optional(_buffer, _size, _lidx, &p->msgA_RestrictedSetConfig_r16);
	_serNrSysDecSQN_NR_RACH_ConfigCommonTwoStepRA_r16_ra_PrioritizationForAccessIdentityTwoStep_r16_ra_PrioritizationForAccessIdentityTwoStep_r16_Optional(_buffer, _size, _lidx, &p->ra_PrioritizationForAccessIdentityTwoStep_r16);
	_serNrSysDecSQN_NR_RACH_ConfigCommonTwoStepRA_r16_ra_ContentionResolutionTimer_r16_e_ra_ContentionResolutionTimer_r16_Optional(_buffer, _size, _lidx, &p->ra_ContentionResolutionTimer_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecUint8_t_SQN_NR_MsgA_PUSCH_Resource_r16_msgA_PUSCH_TimeDomainAllocation_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct uint8_t_SQN_NR_MsgA_PUSCH_Resource_r16_msgA_PUSCH_TimeDomainAllocation_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecUint8_t_SQN_NR_MsgA_PUSCH_Resource_r16_startSymbolAndLengthMsgA_PO_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct uint8_t_SQN_NR_MsgA_PUSCH_Resource_r16_startSymbolAndLengthMsgA_PO_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_MsgA_PUSCH_Resource_r16_mappingTypeMsgA_PUSCH_r16_e_mappingTypeMsgA_PUSCH_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_MsgA_PUSCH_Resource_r16_mappingTypeMsgA_PUSCH_r16_e_mappingTypeMsgA_PUSCH_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_MsgA_PUSCH_Resource_r16_mappingTypeMsgA_PUSCH_r16_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecUint8_t_SQN_NR_MsgA_PUSCH_Resource_r16_guardPeriodMsgA_PUSCH_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct uint8_t_SQN_NR_MsgA_PUSCH_Resource_r16_guardPeriodMsgA_PUSCH_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_MsgA_PUSCH_Resource_r16_msgA_IntraSlotFrequencyHopping_r16_e_msgA_IntraSlotFrequencyHopping_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_MsgA_PUSCH_Resource_r16_msgA_IntraSlotFrequencyHopping_r16_e_msgA_IntraSlotFrequencyHopping_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_MsgA_PUSCH_Resource_r16_msgA_IntraSlotFrequencyHopping_r16_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecB2_SQN_NR_MsgA_PUSCH_Resource_r16_msgA_HoppingBits_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct B2_SQN_NR_MsgA_PUSCH_Resource_r16_msgA_HoppingBits_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	for (size_t i2 = 0; i2 < 2; i2++) {
		NTOH_8(p->v[i2], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_MsgA_DMRS_Config_r16_msgA_DMRS_AdditionalPosition_r16_e_msgA_DMRS_AdditionalPosition_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_MsgA_DMRS_Config_r16_msgA_DMRS_AdditionalPosition_r16_e_msgA_DMRS_AdditionalPosition_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_MsgA_DMRS_Config_r16_msgA_DMRS_AdditionalPosition_r16_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_MsgA_DMRS_Config_r16_msgA_MaxLength_r16_e_msgA_MaxLength_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_MsgA_DMRS_Config_r16_msgA_MaxLength_r16_e_msgA_MaxLength_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_MsgA_DMRS_Config_r16_msgA_MaxLength_r16_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecUint8_t_SQN_NR_MsgA_DMRS_Config_r16_msgA_PUSCH_DMRS_CDM_Group_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct uint8_t_SQN_NR_MsgA_DMRS_Config_r16_msgA_PUSCH_DMRS_CDM_Group_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecUint8_t_SQN_NR_MsgA_DMRS_Config_r16_msgA_PUSCH_NrofPorts_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct uint8_t_SQN_NR_MsgA_DMRS_Config_r16_msgA_PUSCH_NrofPorts_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecUint16_t_SQN_NR_MsgA_DMRS_Config_r16_msgA_ScramblingID0_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct uint16_t_SQN_NR_MsgA_DMRS_Config_r16_msgA_ScramblingID0_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_16(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecUint16_t_SQN_NR_MsgA_DMRS_Config_r16_msgA_ScramblingID1_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct uint16_t_SQN_NR_MsgA_DMRS_Config_r16_msgA_ScramblingID1_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_16(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_MsgA_DMRS_Config_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_MsgA_DMRS_Config_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecSQN_NR_MsgA_DMRS_Config_r16_msgA_DMRS_AdditionalPosition_r16_e_msgA_DMRS_AdditionalPosition_r16_Optional(_buffer, _size, _lidx, &p->msgA_DMRS_AdditionalPosition_r16);
	_serNrSysDecSQN_NR_MsgA_DMRS_Config_r16_msgA_MaxLength_r16_e_msgA_MaxLength_r16_Optional(_buffer, _size, _lidx, &p->msgA_MaxLength_r16);
	_serNrSysDecUint8_t_SQN_NR_MsgA_DMRS_Config_r16_msgA_PUSCH_DMRS_CDM_Group_r16_Optional(_buffer, _size, _lidx, &p->msgA_PUSCH_DMRS_CDM_Group_r16);
	_serNrSysDecUint8_t_SQN_NR_MsgA_DMRS_Config_r16_msgA_PUSCH_NrofPorts_r16_Optional(_buffer, _size, _lidx, &p->msgA_PUSCH_NrofPorts_r16);
	_serNrSysDecUint16_t_SQN_NR_MsgA_DMRS_Config_r16_msgA_ScramblingID0_r16_Optional(_buffer, _size, _lidx, &p->msgA_ScramblingID0_r16);
	_serNrSysDecUint16_t_SQN_NR_MsgA_DMRS_Config_r16_msgA_ScramblingID1_r16_Optional(_buffer, _size, _lidx, &p->msgA_ScramblingID1_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_MsgA_PUSCH_Resource_r16_msgA_Alpha_r16_e_msgA_Alpha_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_MsgA_PUSCH_Resource_r16_msgA_Alpha_r16_e_msgA_Alpha_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_MsgA_PUSCH_Resource_r16_msgA_Alpha_r16_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecUint8_t_SQN_NR_MsgA_PUSCH_Resource_r16_interlaceIndexFirstPO_MsgA_PUSCH_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct uint8_t_SQN_NR_MsgA_PUSCH_Resource_r16_interlaceIndexFirstPO_MsgA_PUSCH_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecUint8_t_SQN_NR_MsgA_PUSCH_Resource_r16_nrofInterlacesPerMsgA_PO_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct uint8_t_SQN_NR_MsgA_PUSCH_Resource_r16_nrofInterlacesPerMsgA_PO_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_MsgA_PUSCH_Resource_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_MsgA_PUSCH_Resource_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->msgA_MCS_r16, &_buffer[*_lidx], _lidx);
	NTOH_8(p->nrofSlotsMsgA_PUSCH_r16, &_buffer[*_lidx], _lidx);
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->nrofMsgA_PO_PerSlot_r16 = (SQN_NR_MsgA_PUSCH_Resource_r16_nrofMsgA_PO_PerSlot_r16_e)_tmp;
	}
	NTOH_8(p->msgA_PUSCH_TimeDomainOffset_r16, &_buffer[*_lidx], _lidx);
	_serNrSysDecUint8_t_SQN_NR_MsgA_PUSCH_Resource_r16_msgA_PUSCH_TimeDomainAllocation_r16_Optional(_buffer, _size, _lidx, &p->msgA_PUSCH_TimeDomainAllocation_r16);
	_serNrSysDecUint8_t_SQN_NR_MsgA_PUSCH_Resource_r16_startSymbolAndLengthMsgA_PO_r16_Optional(_buffer, _size, _lidx, &p->startSymbolAndLengthMsgA_PO_r16);
	_serNrSysDecSQN_NR_MsgA_PUSCH_Resource_r16_mappingTypeMsgA_PUSCH_r16_e_mappingTypeMsgA_PUSCH_r16_Optional(_buffer, _size, _lidx, &p->mappingTypeMsgA_PUSCH_r16);
	_serNrSysDecUint8_t_SQN_NR_MsgA_PUSCH_Resource_r16_guardPeriodMsgA_PUSCH_r16_Optional(_buffer, _size, _lidx, &p->guardPeriodMsgA_PUSCH_r16);
	NTOH_8(p->guardBandMsgA_PUSCH_r16, &_buffer[*_lidx], _lidx);
	NTOH_16(p->frequencyStartMsgA_PUSCH_r16, &_buffer[*_lidx], _lidx);
	NTOH_8(p->nrofPRBs_PerMsgA_PO_r16, &_buffer[*_lidx], _lidx);
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->nrofMsgA_PO_FDM_r16 = (SQN_NR_MsgA_PUSCH_Resource_r16_nrofMsgA_PO_FDM_r16_e)_tmp;
	}
	_serNrSysDecSQN_NR_MsgA_PUSCH_Resource_r16_msgA_IntraSlotFrequencyHopping_r16_e_msgA_IntraSlotFrequencyHopping_r16_Optional(_buffer, _size, _lidx, &p->msgA_IntraSlotFrequencyHopping_r16);
	_serNrSysDecB2_SQN_NR_MsgA_PUSCH_Resource_r16_msgA_HoppingBits_r16_Optional(_buffer, _size, _lidx, &p->msgA_HoppingBits_r16);
	_serNrSysDecSQN_NR_MsgA_DMRS_Config_r16(_buffer, _size, _lidx, &p->msgA_DMRS_Config_r16);
	NTOH_8(p->nrofDMRS_Sequences_r16, &_buffer[*_lidx], _lidx);
	_serNrSysDecSQN_NR_MsgA_PUSCH_Resource_r16_msgA_Alpha_r16_e_msgA_Alpha_r16_Optional(_buffer, _size, _lidx, &p->msgA_Alpha_r16);
	_serNrSysDecUint8_t_SQN_NR_MsgA_PUSCH_Resource_r16_interlaceIndexFirstPO_MsgA_PUSCH_r16_Optional(_buffer, _size, _lidx, &p->interlaceIndexFirstPO_MsgA_PUSCH_r16);
	_serNrSysDecUint8_t_SQN_NR_MsgA_PUSCH_Resource_r16_nrofInterlacesPerMsgA_PO_r16_Optional(_buffer, _size, _lidx, &p->nrofInterlacesPerMsgA_PO_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_MsgA_PUSCH_Resource_r16_SQN_NR_MsgA_PUSCH_Config_r16_msgA_PUSCH_ResourceGroupA_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_MsgA_PUSCH_Resource_r16_SQN_NR_MsgA_PUSCH_Config_r16_msgA_PUSCH_ResourceGroupA_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_MsgA_PUSCH_Resource_r16(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_MsgA_PUSCH_Resource_r16_SQN_NR_MsgA_PUSCH_Config_r16_msgA_PUSCH_ResourceGroupB_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_MsgA_PUSCH_Resource_r16_SQN_NR_MsgA_PUSCH_Config_r16_msgA_PUSCH_ResourceGroupB_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_MsgA_PUSCH_Resource_r16(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_MsgA_PUSCH_Config_r16_msgA_TransformPrecoder_r16_e_msgA_TransformPrecoder_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_MsgA_PUSCH_Config_r16_msgA_TransformPrecoder_r16_e_msgA_TransformPrecoder_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_MsgA_PUSCH_Config_r16_msgA_TransformPrecoder_r16_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecUint16_t_SQN_NR_MsgA_PUSCH_Config_r16_msgA_DataScramblingIndex_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct uint16_t_SQN_NR_MsgA_PUSCH_Config_r16_msgA_DataScramblingIndex_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_16(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecInt8_t_SQN_NR_MsgA_PUSCH_Config_r16_msgA_DeltaPreamble_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct int8_t_SQN_NR_MsgA_PUSCH_Config_r16_msgA_DeltaPreamble_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_MsgA_PUSCH_Config_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_MsgA_PUSCH_Config_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecSQN_NR_MsgA_PUSCH_Resource_r16_SQN_NR_MsgA_PUSCH_Config_r16_msgA_PUSCH_ResourceGroupA_r16_Optional(_buffer, _size, _lidx, &p->msgA_PUSCH_ResourceGroupA_r16);
	_serNrSysDecSQN_NR_MsgA_PUSCH_Resource_r16_SQN_NR_MsgA_PUSCH_Config_r16_msgA_PUSCH_ResourceGroupB_r16_Optional(_buffer, _size, _lidx, &p->msgA_PUSCH_ResourceGroupB_r16);
	_serNrSysDecSQN_NR_MsgA_PUSCH_Config_r16_msgA_TransformPrecoder_r16_e_msgA_TransformPrecoder_r16_Optional(_buffer, _size, _lidx, &p->msgA_TransformPrecoder_r16);
	_serNrSysDecUint16_t_SQN_NR_MsgA_PUSCH_Config_r16_msgA_DataScramblingIndex_r16_Optional(_buffer, _size, _lidx, &p->msgA_DataScramblingIndex_r16);
	_serNrSysDecInt8_t_SQN_NR_MsgA_PUSCH_Config_r16_msgA_DeltaPreamble_r16_Optional(_buffer, _size, _lidx, &p->msgA_DeltaPreamble_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_MsgA_PUSCH_Config_r16_SQN_NR_MsgA_ConfigCommon_r16_msgA_PUSCH_Config_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_MsgA_PUSCH_Config_r16_SQN_NR_MsgA_ConfigCommon_r16_msgA_PUSCH_Config_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_MsgA_PUSCH_Config_r16(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_MsgA_ConfigCommon_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_MsgA_ConfigCommon_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecSQN_NR_RACH_ConfigCommonTwoStepRA_r16(_buffer, _size, _lidx, &p->rach_ConfigCommonTwoStepRA_r16);
	_serNrSysDecSQN_NR_MsgA_PUSCH_Config_r16_SQN_NR_MsgA_ConfigCommon_r16_msgA_PUSCH_Config_r16_Optional(_buffer, _size, _lidx, &p->msgA_PUSCH_Config_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SetupRelease_BWP_UplinkCommon_msgA_ConfigCommon_r16_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union SQN_NR_SetupRelease_BWP_UplinkCommon_msgA_ConfigCommon_r16_Value* p, enum SQN_NR_SetupRelease_BWP_UplinkCommon_msgA_ConfigCommon_r16_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SetupRelease_BWP_UplinkCommon_msgA_ConfigCommon_r16_release) {
		NTOH_8(p->release, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SetupRelease_BWP_UplinkCommon_msgA_ConfigCommon_r16_setup) {
		_serNrSysDecSQN_NR_MsgA_ConfigCommon_r16(_buffer, _size, _lidx, &p->setup);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecSQN_NR_SetupRelease_BWP_UplinkCommon_msgA_ConfigCommon_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SetupRelease_BWP_UplinkCommon_msgA_ConfigCommon_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SQN_NR_SetupRelease_BWP_UplinkCommon_msgA_ConfigCommon_r16_Sel)_tmp;
	}
	_serNrSysDecSQN_NR_SetupRelease_BWP_UplinkCommon_msgA_ConfigCommon_r16_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SetupRelease_BWP_UplinkCommon_msgA_ConfigCommon_r16_SQN_NR_BWP_UplinkCommon_msgA_ConfigCommon_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SetupRelease_BWP_UplinkCommon_msgA_ConfigCommon_r16_SQN_NR_BWP_UplinkCommon_msgA_ConfigCommon_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_SetupRelease_BWP_UplinkCommon_msgA_ConfigCommon_r16(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_BWP_UplinkCommon(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_BWP_UplinkCommon* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecSQN_NR_BWP(_buffer, _size, _lidx, &p->genericParameters);
	_serNrSysDecSQN_NR_SetupRelease_BWP_UplinkCommon_rach_ConfigCommon_SQN_NR_BWP_UplinkCommon_rach_ConfigCommon_Optional(_buffer, _size, _lidx, &p->rach_ConfigCommon);
	_serNrSysDecSQN_NR_SetupRelease_BWP_UplinkCommon_pusch_ConfigCommon_SQN_NR_BWP_UplinkCommon_pusch_ConfigCommon_Optional(_buffer, _size, _lidx, _mem, &p->pusch_ConfigCommon);
	_serNrSysDecSQN_NR_SetupRelease_BWP_UplinkCommon_pucch_ConfigCommon_SQN_NR_BWP_UplinkCommon_pucch_ConfigCommon_Optional(_buffer, _size, _lidx, &p->pucch_ConfigCommon);
	_serNrSysDecSQN_NR_SetupRelease_BWP_UplinkCommon_rach_ConfigCommonIAB_r16_SQN_NR_BWP_UplinkCommon_rach_ConfigCommonIAB_r16_Optional(_buffer, _size, _lidx, &p->rach_ConfigCommonIAB_r16);
	_serNrSysDecSQN_NR_BWP_UplinkCommon_useInterlacePUCCH_PUSCH_r16_e_useInterlacePUCCH_PUSCH_r16_Optional(_buffer, _size, _lidx, &p->useInterlacePUCCH_PUSCH_r16);
	_serNrSysDecSQN_NR_SetupRelease_BWP_UplinkCommon_msgA_ConfigCommon_r16_SQN_NR_BWP_UplinkCommon_msgA_ConfigCommon_r16_Optional(_buffer, _size, _lidx, &p->msgA_ConfigCommon_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_ASN1_BWP_UplinkCommon_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union NR_ASN1_BWP_UplinkCommon_Type_Value* p, enum NR_ASN1_BWP_UplinkCommon_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_ASN1_BWP_UplinkCommon_Type_R15) {
		_serNrSysDecSQN_NR_BWP_UplinkCommon(_buffer, _size, _lidx, _mem, &p->R15);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecNR_ASN1_BWP_UplinkCommon_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_ASN1_BWP_UplinkCommon_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum NR_ASN1_BWP_UplinkCommon_Type_Sel)_tmp;
	}
	_serNrSysDecNR_ASN1_BWP_UplinkCommon_Type_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_ASN1_BWP_UplinkCommon_Type_Common_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_ASN1_BWP_UplinkCommon_Type_Common_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecNR_ASN1_BWP_UplinkCommon_Type(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecUint16_t_SQN_NR_PUCCH_ResourceSet_maxPayloadSize_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct uint16_t_SQN_NR_PUCCH_ResourceSet_maxPayloadSize_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_16(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PUCCH_ResourceSet(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_PUCCH_ResourceSet* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->pucch_ResourceSetId, &_buffer[*_lidx], _lidx);
	NTOH_32(p->resourceList.d, &_buffer[*_lidx], _lidx);
	p->resourceList.v = (SQN_NR_PUCCH_ResourceId*)serMalloc(_mem, p->resourceList.d * sizeof(SQN_NR_PUCCH_ResourceId));
	for (size_t i3 = 0; i3 < p->resourceList.d; i3++) {
		NTOH_8(p->resourceList.v[i3], &_buffer[*_lidx], _lidx);
	}
	_serNrSysDecUint16_t_SQN_NR_PUCCH_ResourceSet_maxPayloadSize_Optional(_buffer, _size, _lidx, &p->maxPayloadSize);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PUCCH_ResourceSet_SQN_NR_PUCCH_Config_resourceSetToAddModList_DynamicOptional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_PUCCH_ResourceSet_SQN_NR_PUCCH_Config_resourceSetToAddModList_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = (struct SQN_NR_PUCCH_ResourceSet*)serMalloc(_mem, p->v.d * sizeof(struct SQN_NR_PUCCH_ResourceSet));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serNrSysDecSQN_NR_PUCCH_ResourceSet(_buffer, _size, _lidx, _mem, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PUCCH_ResourceSetId_SQN_NR_PUCCH_Config_resourceSetToReleaseList_DynamicOptional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_PUCCH_ResourceSetId_SQN_NR_PUCCH_Config_resourceSetToReleaseList_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = (SQN_NR_PUCCH_ResourceSetId*)serMalloc(_mem, p->v.d * sizeof(SQN_NR_PUCCH_ResourceSetId));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		NTOH_8(p->v.v[i2], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PUCCH_Resource_intraSlotFrequencyHopping_e_intraSlotFrequencyHopping_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_PUCCH_Resource_intraSlotFrequencyHopping_e_intraSlotFrequencyHopping_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_PUCCH_Resource_intraSlotFrequencyHopping_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PRB_Id_SQN_NR_PUCCH_Resource_secondHopPRB_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_PRB_Id_SQN_NR_PUCCH_Resource_secondHopPRB_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_16(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PUCCH_format0(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_PUCCH_format0* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->initialCyclicShift, &_buffer[*_lidx], _lidx);
	NTOH_8(p->nrofSymbols, &_buffer[*_lidx], _lidx);
	NTOH_8(p->startingSymbolIndex, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PUCCH_format1(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_PUCCH_format1* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->initialCyclicShift, &_buffer[*_lidx], _lidx);
	NTOH_8(p->nrofSymbols, &_buffer[*_lidx], _lidx);
	NTOH_8(p->startingSymbolIndex, &_buffer[*_lidx], _lidx);
	NTOH_8(p->timeDomainOCC, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PUCCH_format2(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_PUCCH_format2* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->nrofPRBs, &_buffer[*_lidx], _lidx);
	NTOH_8(p->nrofSymbols, &_buffer[*_lidx], _lidx);
	NTOH_8(p->startingSymbolIndex, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PUCCH_format3(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_PUCCH_format3* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->nrofPRBs, &_buffer[*_lidx], _lidx);
	NTOH_8(p->nrofSymbols, &_buffer[*_lidx], _lidx);
	NTOH_8(p->startingSymbolIndex, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PUCCH_format4(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_PUCCH_format4* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->nrofSymbols, &_buffer[*_lidx], _lidx);
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->occ_Length = (SQN_NR_PUCCH_format4_occ_Length_e)_tmp;
	}
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->occ_Index = (SQN_NR_PUCCH_format4_occ_Index_e)_tmp;
	}
	NTOH_8(p->startingSymbolIndex, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PUCCH_Resource_format_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union SQN_NR_PUCCH_Resource_format_Value* p, enum SQN_NR_PUCCH_Resource_format_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_PUCCH_Resource_format_format0) {
		_serNrSysDecSQN_NR_PUCCH_format0(_buffer, _size, _lidx, &p->format0);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_PUCCH_Resource_format_format1) {
		_serNrSysDecSQN_NR_PUCCH_format1(_buffer, _size, _lidx, &p->format1);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_PUCCH_Resource_format_format2) {
		_serNrSysDecSQN_NR_PUCCH_format2(_buffer, _size, _lidx, &p->format2);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_PUCCH_Resource_format_format3) {
		_serNrSysDecSQN_NR_PUCCH_format3(_buffer, _size, _lidx, &p->format3);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_PUCCH_Resource_format_format4) {
		_serNrSysDecSQN_NR_PUCCH_format4(_buffer, _size, _lidx, &p->format4);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecSQN_NR_PUCCH_Resource_format(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_PUCCH_Resource_format* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SQN_NR_PUCCH_Resource_format_Sel)_tmp;
	}
	_serNrSysDecSQN_NR_PUCCH_Resource_format_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PUCCH_Resource(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_PUCCH_Resource* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->pucch_ResourceId, &_buffer[*_lidx], _lidx);
	NTOH_16(p->startingPRB, &_buffer[*_lidx], _lidx);
	_serNrSysDecSQN_NR_PUCCH_Resource_intraSlotFrequencyHopping_e_intraSlotFrequencyHopping_Optional(_buffer, _size, _lidx, &p->intraSlotFrequencyHopping);
	_serNrSysDecSQN_NR_PRB_Id_SQN_NR_PUCCH_Resource_secondHopPRB_Optional(_buffer, _size, _lidx, &p->secondHopPRB);
	_serNrSysDecSQN_NR_PUCCH_Resource_format(_buffer, _size, _lidx, &p->format);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PUCCH_Resource_SQN_NR_PUCCH_Config_resourceToAddModList_DynamicOptional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_PUCCH_Resource_SQN_NR_PUCCH_Config_resourceToAddModList_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = (struct SQN_NR_PUCCH_Resource*)serMalloc(_mem, p->v.d * sizeof(struct SQN_NR_PUCCH_Resource));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serNrSysDecSQN_NR_PUCCH_Resource(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PUCCH_ResourceId_SQN_NR_PUCCH_Config_resourceToReleaseList_DynamicOptional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_PUCCH_ResourceId_SQN_NR_PUCCH_Config_resourceToReleaseList_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = (SQN_NR_PUCCH_ResourceId*)serMalloc(_mem, p->v.d * sizeof(SQN_NR_PUCCH_ResourceId));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		NTOH_8(p->v.v[i2], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PUCCH_FormatConfig_interslotFrequencyHopping_e_interslotFrequencyHopping_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_PUCCH_FormatConfig_interslotFrequencyHopping_e_interslotFrequencyHopping_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_PUCCH_FormatConfig_interslotFrequencyHopping_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PUCCH_FormatConfig_additionalDMRS_e_additionalDMRS_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_PUCCH_FormatConfig_additionalDMRS_e_additionalDMRS_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_PUCCH_FormatConfig_additionalDMRS_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PUCCH_MaxCodeRate_e_SQN_NR_PUCCH_FormatConfig_maxCodeRate_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_PUCCH_MaxCodeRate_e_SQN_NR_PUCCH_FormatConfig_maxCodeRate_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_PUCCH_MaxCodeRate_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PUCCH_FormatConfig_nrofSlots_e_nrofSlots_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_PUCCH_FormatConfig_nrofSlots_e_nrofSlots_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_PUCCH_FormatConfig_nrofSlots_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PUCCH_FormatConfig_pi2BPSK_e_pi2BPSK_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_PUCCH_FormatConfig_pi2BPSK_e_pi2BPSK_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_PUCCH_FormatConfig_pi2BPSK_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PUCCH_FormatConfig_simultaneousHARQ_ACK_CSI_e_simultaneousHARQ_ACK_CSI_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_PUCCH_FormatConfig_simultaneousHARQ_ACK_CSI_e_simultaneousHARQ_ACK_CSI_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_PUCCH_FormatConfig_simultaneousHARQ_ACK_CSI_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PUCCH_FormatConfig(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_PUCCH_FormatConfig* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecSQN_NR_PUCCH_FormatConfig_interslotFrequencyHopping_e_interslotFrequencyHopping_Optional(_buffer, _size, _lidx, &p->interslotFrequencyHopping);
	_serNrSysDecSQN_NR_PUCCH_FormatConfig_additionalDMRS_e_additionalDMRS_Optional(_buffer, _size, _lidx, &p->additionalDMRS);
	_serNrSysDecSQN_NR_PUCCH_MaxCodeRate_e_SQN_NR_PUCCH_FormatConfig_maxCodeRate_Optional(_buffer, _size, _lidx, &p->maxCodeRate);
	_serNrSysDecSQN_NR_PUCCH_FormatConfig_nrofSlots_e_nrofSlots_Optional(_buffer, _size, _lidx, &p->nrofSlots);
	_serNrSysDecSQN_NR_PUCCH_FormatConfig_pi2BPSK_e_pi2BPSK_Optional(_buffer, _size, _lidx, &p->pi2BPSK);
	_serNrSysDecSQN_NR_PUCCH_FormatConfig_simultaneousHARQ_ACK_CSI_e_simultaneousHARQ_ACK_CSI_Optional(_buffer, _size, _lidx, &p->simultaneousHARQ_ACK_CSI);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SetupRelease_PUCCH_Config_format1_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union SQN_NR_SetupRelease_PUCCH_Config_format1_Value* p, enum SQN_NR_SetupRelease_PUCCH_Config_format1_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SetupRelease_PUCCH_Config_format1_release) {
		NTOH_8(p->release, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SetupRelease_PUCCH_Config_format1_setup) {
		_serNrSysDecSQN_NR_PUCCH_FormatConfig(_buffer, _size, _lidx, &p->setup);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecSQN_NR_SetupRelease_PUCCH_Config_format1(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SetupRelease_PUCCH_Config_format1* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SQN_NR_SetupRelease_PUCCH_Config_format1_Sel)_tmp;
	}
	_serNrSysDecSQN_NR_SetupRelease_PUCCH_Config_format1_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SetupRelease_PUCCH_Config_format1_SQN_NR_PUCCH_Config_format1_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SetupRelease_PUCCH_Config_format1_SQN_NR_PUCCH_Config_format1_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_SetupRelease_PUCCH_Config_format1(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SetupRelease_PUCCH_Config_format2_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union SQN_NR_SetupRelease_PUCCH_Config_format2_Value* p, enum SQN_NR_SetupRelease_PUCCH_Config_format2_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SetupRelease_PUCCH_Config_format2_release) {
		NTOH_8(p->release, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SetupRelease_PUCCH_Config_format2_setup) {
		_serNrSysDecSQN_NR_PUCCH_FormatConfig(_buffer, _size, _lidx, &p->setup);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecSQN_NR_SetupRelease_PUCCH_Config_format2(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SetupRelease_PUCCH_Config_format2* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SQN_NR_SetupRelease_PUCCH_Config_format2_Sel)_tmp;
	}
	_serNrSysDecSQN_NR_SetupRelease_PUCCH_Config_format2_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SetupRelease_PUCCH_Config_format2_SQN_NR_PUCCH_Config_format2_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SetupRelease_PUCCH_Config_format2_SQN_NR_PUCCH_Config_format2_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_SetupRelease_PUCCH_Config_format2(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SetupRelease_PUCCH_Config_format3_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union SQN_NR_SetupRelease_PUCCH_Config_format3_Value* p, enum SQN_NR_SetupRelease_PUCCH_Config_format3_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SetupRelease_PUCCH_Config_format3_release) {
		NTOH_8(p->release, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SetupRelease_PUCCH_Config_format3_setup) {
		_serNrSysDecSQN_NR_PUCCH_FormatConfig(_buffer, _size, _lidx, &p->setup);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecSQN_NR_SetupRelease_PUCCH_Config_format3(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SetupRelease_PUCCH_Config_format3* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SQN_NR_SetupRelease_PUCCH_Config_format3_Sel)_tmp;
	}
	_serNrSysDecSQN_NR_SetupRelease_PUCCH_Config_format3_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SetupRelease_PUCCH_Config_format3_SQN_NR_PUCCH_Config_format3_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SetupRelease_PUCCH_Config_format3_SQN_NR_PUCCH_Config_format3_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_SetupRelease_PUCCH_Config_format3(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SetupRelease_PUCCH_Config_format4_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union SQN_NR_SetupRelease_PUCCH_Config_format4_Value* p, enum SQN_NR_SetupRelease_PUCCH_Config_format4_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SetupRelease_PUCCH_Config_format4_release) {
		NTOH_8(p->release, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SetupRelease_PUCCH_Config_format4_setup) {
		_serNrSysDecSQN_NR_PUCCH_FormatConfig(_buffer, _size, _lidx, &p->setup);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecSQN_NR_SetupRelease_PUCCH_Config_format4(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SetupRelease_PUCCH_Config_format4* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SQN_NR_SetupRelease_PUCCH_Config_format4_Sel)_tmp;
	}
	_serNrSysDecSQN_NR_SetupRelease_PUCCH_Config_format4_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SetupRelease_PUCCH_Config_format4_SQN_NR_PUCCH_Config_format4_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SetupRelease_PUCCH_Config_format4_SQN_NR_PUCCH_Config_format4_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_SetupRelease_PUCCH_Config_format4(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SchedulingRequestResourceConfig_periodicityAndOffset_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union SQN_NR_SchedulingRequestResourceConfig_periodicityAndOffset_Value* p, enum SQN_NR_SchedulingRequestResourceConfig_periodicityAndOffset_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SchedulingRequestResourceConfig_periodicityAndOffset_sym2) {
		NTOH_8(p->sym2, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SchedulingRequestResourceConfig_periodicityAndOffset_sym6or7) {
		NTOH_8(p->sym6or7, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SchedulingRequestResourceConfig_periodicityAndOffset_sl1) {
		NTOH_8(p->sl1, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SchedulingRequestResourceConfig_periodicityAndOffset_sl2) {
		NTOH_8(p->sl2, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SchedulingRequestResourceConfig_periodicityAndOffset_sl4) {
		NTOH_8(p->sl4, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SchedulingRequestResourceConfig_periodicityAndOffset_sl5) {
		NTOH_8(p->sl5, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SchedulingRequestResourceConfig_periodicityAndOffset_sl8) {
		NTOH_8(p->sl8, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SchedulingRequestResourceConfig_periodicityAndOffset_sl10) {
		NTOH_8(p->sl10, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SchedulingRequestResourceConfig_periodicityAndOffset_sl16) {
		NTOH_8(p->sl16, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SchedulingRequestResourceConfig_periodicityAndOffset_sl20) {
		NTOH_8(p->sl20, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SchedulingRequestResourceConfig_periodicityAndOffset_sl40) {
		NTOH_8(p->sl40, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SchedulingRequestResourceConfig_periodicityAndOffset_sl80) {
		NTOH_8(p->sl80, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SchedulingRequestResourceConfig_periodicityAndOffset_sl160) {
		NTOH_8(p->sl160, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SchedulingRequestResourceConfig_periodicityAndOffset_sl320) {
		NTOH_16(p->sl320, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SchedulingRequestResourceConfig_periodicityAndOffset_sl640) {
		NTOH_16(p->sl640, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecSQN_NR_SchedulingRequestResourceConfig_periodicityAndOffset(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SchedulingRequestResourceConfig_periodicityAndOffset* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SQN_NR_SchedulingRequestResourceConfig_periodicityAndOffset_Sel)_tmp;
	}
	_serNrSysDecSQN_NR_SchedulingRequestResourceConfig_periodicityAndOffset_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SchedulingRequestResourceConfig_periodicityAndOffset_periodicityAndOffset_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SchedulingRequestResourceConfig_periodicityAndOffset_periodicityAndOffset_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_SchedulingRequestResourceConfig_periodicityAndOffset(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PUCCH_ResourceId_SQN_NR_SchedulingRequestResourceConfig_resource_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_PUCCH_ResourceId_SQN_NR_SchedulingRequestResourceConfig_resource_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SchedulingRequestResourceConfig(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SchedulingRequestResourceConfig* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->schedulingRequestResourceId, &_buffer[*_lidx], _lidx);
	NTOH_8(p->schedulingRequestID, &_buffer[*_lidx], _lidx);
	_serNrSysDecSQN_NR_SchedulingRequestResourceConfig_periodicityAndOffset_periodicityAndOffset_Optional(_buffer, _size, _lidx, &p->periodicityAndOffset);
	_serNrSysDecSQN_NR_PUCCH_ResourceId_SQN_NR_SchedulingRequestResourceConfig_resource_Optional(_buffer, _size, _lidx, &p->resource);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SchedulingRequestResourceConfig_SQN_NR_PUCCH_Config_schedulingRequestResourceToAddModList_DynamicOptional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_SchedulingRequestResourceConfig_SQN_NR_PUCCH_Config_schedulingRequestResourceToAddModList_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = (struct SQN_NR_SchedulingRequestResourceConfig*)serMalloc(_mem, p->v.d * sizeof(struct SQN_NR_SchedulingRequestResourceConfig));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serNrSysDecSQN_NR_SchedulingRequestResourceConfig(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SchedulingRequestResourceId_SQN_NR_PUCCH_Config_schedulingRequestResourceToReleaseList_DynamicOptional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_SchedulingRequestResourceId_SQN_NR_PUCCH_Config_schedulingRequestResourceToReleaseList_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = (SQN_NR_SchedulingRequestResourceId*)serMalloc(_mem, p->v.d * sizeof(SQN_NR_SchedulingRequestResourceId));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		NTOH_8(p->v.v[i2], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PUCCH_ResourceId_SQN_NR_PUCCH_Config_multi_CSI_PUCCH_ResourceList_DynamicOptional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_PUCCH_ResourceId_SQN_NR_PUCCH_Config_multi_CSI_PUCCH_ResourceList_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = (SQN_NR_PUCCH_ResourceId*)serMalloc(_mem, p->v.d * sizeof(SQN_NR_PUCCH_ResourceId));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		NTOH_8(p->v.v[i2], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecUint8_t_SQN_NR_PUCCH_Config_dl_DataToUL_ACK_DynamicOptional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct uint8_t_SQN_NR_PUCCH_Config_dl_DataToUL_ACK_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = (uint8_t*)serMalloc(_mem, p->v.d * sizeof(uint8_t));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		NTOH_8(p->v.v[i2], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_ServCellIndex_SQN_NR_PUCCH_SpatialRelationInfo_servingCellId_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_ServCellIndex_SQN_NR_PUCCH_SpatialRelationInfo_servingCellId_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PUCCH_SRS(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_PUCCH_SRS* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->resource, &_buffer[*_lidx], _lidx);
	NTOH_8(p->uplinkBWP, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PUCCH_SpatialRelationInfo_referenceSignal_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union SQN_NR_PUCCH_SpatialRelationInfo_referenceSignal_Value* p, enum SQN_NR_PUCCH_SpatialRelationInfo_referenceSignal_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_PUCCH_SpatialRelationInfo_referenceSignal_ssb_Index) {
		NTOH_8(p->ssb_Index, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_PUCCH_SpatialRelationInfo_referenceSignal_csi_RS_Index) {
		NTOH_8(p->csi_RS_Index, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_PUCCH_SpatialRelationInfo_referenceSignal_srs) {
		_serNrSysDecSQN_NR_PUCCH_SRS(_buffer, _size, _lidx, &p->srs);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecSQN_NR_PUCCH_SpatialRelationInfo_referenceSignal(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_PUCCH_SpatialRelationInfo_referenceSignal* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SQN_NR_PUCCH_SpatialRelationInfo_referenceSignal_Sel)_tmp;
	}
	_serNrSysDecSQN_NR_PUCCH_SpatialRelationInfo_referenceSignal_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PUCCH_SpatialRelationInfo(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_PUCCH_SpatialRelationInfo* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->pucch_SpatialRelationInfoId, &_buffer[*_lidx], _lidx);
	_serNrSysDecSQN_NR_ServCellIndex_SQN_NR_PUCCH_SpatialRelationInfo_servingCellId_Optional(_buffer, _size, _lidx, &p->servingCellId);
	_serNrSysDecSQN_NR_PUCCH_SpatialRelationInfo_referenceSignal(_buffer, _size, _lidx, &p->referenceSignal);
	NTOH_8(p->pucch_PathlossReferenceRS_Id, &_buffer[*_lidx], _lidx);
	NTOH_8(p->p0_PUCCH_Id, &_buffer[*_lidx], _lidx);
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->closedLoopIndex = (SQN_NR_PUCCH_SpatialRelationInfo_closedLoopIndex_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PUCCH_SpatialRelationInfo_SQN_NR_PUCCH_Config_spatialRelationInfoToAddModList_DynamicOptional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_PUCCH_SpatialRelationInfo_SQN_NR_PUCCH_Config_spatialRelationInfoToAddModList_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = (struct SQN_NR_PUCCH_SpatialRelationInfo*)serMalloc(_mem, p->v.d * sizeof(struct SQN_NR_PUCCH_SpatialRelationInfo));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serNrSysDecSQN_NR_PUCCH_SpatialRelationInfo(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PUCCH_SpatialRelationInfoId_SQN_NR_PUCCH_Config_spatialRelationInfoToReleaseList_DynamicOptional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_PUCCH_SpatialRelationInfoId_SQN_NR_PUCCH_Config_spatialRelationInfoToReleaseList_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = (SQN_NR_PUCCH_SpatialRelationInfoId*)serMalloc(_mem, p->v.d * sizeof(SQN_NR_PUCCH_SpatialRelationInfoId));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		NTOH_8(p->v.v[i2], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecInt8_t_SQN_NR_PUCCH_PowerControl_deltaF_PUCCH_f0_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct int8_t_SQN_NR_PUCCH_PowerControl_deltaF_PUCCH_f0_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecInt8_t_SQN_NR_PUCCH_PowerControl_deltaF_PUCCH_f1_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct int8_t_SQN_NR_PUCCH_PowerControl_deltaF_PUCCH_f1_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecInt8_t_SQN_NR_PUCCH_PowerControl_deltaF_PUCCH_f2_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct int8_t_SQN_NR_PUCCH_PowerControl_deltaF_PUCCH_f2_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecInt8_t_SQN_NR_PUCCH_PowerControl_deltaF_PUCCH_f3_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct int8_t_SQN_NR_PUCCH_PowerControl_deltaF_PUCCH_f3_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecInt8_t_SQN_NR_PUCCH_PowerControl_deltaF_PUCCH_f4_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct int8_t_SQN_NR_PUCCH_PowerControl_deltaF_PUCCH_f4_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_P0_PUCCH(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_P0_PUCCH* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->p0_PUCCH_Id, &_buffer[*_lidx], _lidx);
	NTOH_8(p->p0_PUCCH_Value, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_P0_PUCCH_SQN_NR_PUCCH_PowerControl_p0_Set_DynamicOptional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_P0_PUCCH_SQN_NR_PUCCH_PowerControl_p0_Set_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = (struct SQN_NR_P0_PUCCH*)serMalloc(_mem, p->v.d * sizeof(struct SQN_NR_P0_PUCCH));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serNrSysDecSQN_NR_P0_PUCCH(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PUCCH_PathlossReferenceRS_referenceSignal_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union SQN_NR_PUCCH_PathlossReferenceRS_referenceSignal_Value* p, enum SQN_NR_PUCCH_PathlossReferenceRS_referenceSignal_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_PUCCH_PathlossReferenceRS_referenceSignal_ssb_Index) {
		NTOH_8(p->ssb_Index, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_PUCCH_PathlossReferenceRS_referenceSignal_csi_RS_Index) {
		NTOH_8(p->csi_RS_Index, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecSQN_NR_PUCCH_PathlossReferenceRS_referenceSignal(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_PUCCH_PathlossReferenceRS_referenceSignal* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SQN_NR_PUCCH_PathlossReferenceRS_referenceSignal_Sel)_tmp;
	}
	_serNrSysDecSQN_NR_PUCCH_PathlossReferenceRS_referenceSignal_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PUCCH_PathlossReferenceRS(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_PUCCH_PathlossReferenceRS* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->pucch_PathlossReferenceRS_Id, &_buffer[*_lidx], _lidx);
	_serNrSysDecSQN_NR_PUCCH_PathlossReferenceRS_referenceSignal(_buffer, _size, _lidx, &p->referenceSignal);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PUCCH_PathlossReferenceRS_SQN_NR_PUCCH_PowerControl_pathlossReferenceRSs_DynamicOptional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_PUCCH_PathlossReferenceRS_SQN_NR_PUCCH_PowerControl_pathlossReferenceRSs_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = (struct SQN_NR_PUCCH_PathlossReferenceRS*)serMalloc(_mem, p->v.d * sizeof(struct SQN_NR_PUCCH_PathlossReferenceRS));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serNrSysDecSQN_NR_PUCCH_PathlossReferenceRS(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PUCCH_PowerControl_twoPUCCH_PC_AdjustmentStates_e_twoPUCCH_PC_AdjustmentStates_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_PUCCH_PowerControl_twoPUCCH_PC_AdjustmentStates_e_twoPUCCH_PC_AdjustmentStates_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_PUCCH_PowerControl_twoPUCCH_PC_AdjustmentStates_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PUCCH_PathlossReferenceRS_r16_referenceSignal_r16_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union SQN_NR_PUCCH_PathlossReferenceRS_r16_referenceSignal_r16_Value* p, enum SQN_NR_PUCCH_PathlossReferenceRS_r16_referenceSignal_r16_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_PUCCH_PathlossReferenceRS_r16_referenceSignal_r16_ssb_Index_r16) {
		NTOH_8(p->ssb_Index_r16, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_PUCCH_PathlossReferenceRS_r16_referenceSignal_r16_csi_RS_Index_r16) {
		NTOH_8(p->csi_RS_Index_r16, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecSQN_NR_PUCCH_PathlossReferenceRS_r16_referenceSignal_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_PUCCH_PathlossReferenceRS_r16_referenceSignal_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SQN_NR_PUCCH_PathlossReferenceRS_r16_referenceSignal_r16_Sel)_tmp;
	}
	_serNrSysDecSQN_NR_PUCCH_PathlossReferenceRS_r16_referenceSignal_r16_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PUCCH_PathlossReferenceRS_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_PUCCH_PathlossReferenceRS_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->pucch_PathlossReferenceRS_Id_r16, &_buffer[*_lidx], _lidx);
	_serNrSysDecSQN_NR_PUCCH_PathlossReferenceRS_r16_referenceSignal_r16(_buffer, _size, _lidx, &p->referenceSignal_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SetupRelease_PUCCH_PowerControl_pathlossReferenceRSs_v1610_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union SQN_NR_SetupRelease_PUCCH_PowerControl_pathlossReferenceRSs_v1610_Value* p, enum SQN_NR_SetupRelease_PUCCH_PowerControl_pathlossReferenceRSs_v1610_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SetupRelease_PUCCH_PowerControl_pathlossReferenceRSs_v1610_release) {
		NTOH_8(p->release, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SetupRelease_PUCCH_PowerControl_pathlossReferenceRSs_v1610_setup) {
		NTOH_32(p->setup.d, &_buffer[*_lidx], _lidx);
		p->setup.v = (struct SQN_NR_PUCCH_PathlossReferenceRS_r16*)serMalloc(_mem, p->setup.d * sizeof(struct SQN_NR_PUCCH_PathlossReferenceRS_r16));
		for (size_t i2 = 0; i2 < p->setup.d; i2++) {
			_serNrSysDecSQN_NR_PUCCH_PathlossReferenceRS_r16(_buffer, _size, _lidx, &p->setup.v[i2]);
		}
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecSQN_NR_SetupRelease_PUCCH_PowerControl_pathlossReferenceRSs_v1610(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_SetupRelease_PUCCH_PowerControl_pathlossReferenceRSs_v1610* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SQN_NR_SetupRelease_PUCCH_PowerControl_pathlossReferenceRSs_v1610_Sel)_tmp;
	}
	_serNrSysDecSQN_NR_SetupRelease_PUCCH_PowerControl_pathlossReferenceRSs_v1610_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SetupRelease_PUCCH_PowerControl_pathlossReferenceRSs_v1610_SQN_NR_PUCCH_PowerControl_pathlossReferenceRSs_v1610_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_SetupRelease_PUCCH_PowerControl_pathlossReferenceRSs_v1610_SQN_NR_PUCCH_PowerControl_pathlossReferenceRSs_v1610_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_SetupRelease_PUCCH_PowerControl_pathlossReferenceRSs_v1610(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PUCCH_PowerControl(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_PUCCH_PowerControl* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecInt8_t_SQN_NR_PUCCH_PowerControl_deltaF_PUCCH_f0_Optional(_buffer, _size, _lidx, &p->deltaF_PUCCH_f0);
	_serNrSysDecInt8_t_SQN_NR_PUCCH_PowerControl_deltaF_PUCCH_f1_Optional(_buffer, _size, _lidx, &p->deltaF_PUCCH_f1);
	_serNrSysDecInt8_t_SQN_NR_PUCCH_PowerControl_deltaF_PUCCH_f2_Optional(_buffer, _size, _lidx, &p->deltaF_PUCCH_f2);
	_serNrSysDecInt8_t_SQN_NR_PUCCH_PowerControl_deltaF_PUCCH_f3_Optional(_buffer, _size, _lidx, &p->deltaF_PUCCH_f3);
	_serNrSysDecInt8_t_SQN_NR_PUCCH_PowerControl_deltaF_PUCCH_f4_Optional(_buffer, _size, _lidx, &p->deltaF_PUCCH_f4);
	_serNrSysDecSQN_NR_P0_PUCCH_SQN_NR_PUCCH_PowerControl_p0_Set_DynamicOptional(_buffer, _size, _lidx, _mem, &p->p0_Set);
	_serNrSysDecSQN_NR_PUCCH_PathlossReferenceRS_SQN_NR_PUCCH_PowerControl_pathlossReferenceRSs_DynamicOptional(_buffer, _size, _lidx, _mem, &p->pathlossReferenceRSs);
	_serNrSysDecSQN_NR_PUCCH_PowerControl_twoPUCCH_PC_AdjustmentStates_e_twoPUCCH_PC_AdjustmentStates_Optional(_buffer, _size, _lidx, &p->twoPUCCH_PC_AdjustmentStates);
	_serNrSysDecSQN_NR_SetupRelease_PUCCH_PowerControl_pathlossReferenceRSs_v1610_SQN_NR_PUCCH_PowerControl_pathlossReferenceRSs_v1610_Optional(_buffer, _size, _lidx, _mem, &p->pathlossReferenceRSs_v1610);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PUCCH_PowerControl_SQN_NR_PUCCH_Config_pucch_PowerControl_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_PUCCH_PowerControl_SQN_NR_PUCCH_Config_pucch_PowerControl_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_PUCCH_PowerControl(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PUCCH_ResourceExt_r16_interlaceAllocation_r16_interlace0_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union SQN_NR_PUCCH_ResourceExt_r16_interlaceAllocation_r16_interlace0_Value* p, enum SQN_NR_PUCCH_ResourceExt_r16_interlaceAllocation_r16_interlace0_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_PUCCH_ResourceExt_r16_interlaceAllocation_r16_interlace0_scs15) {
		NTOH_8(p->scs15, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_PUCCH_ResourceExt_r16_interlaceAllocation_r16_interlace0_scs30) {
		NTOH_8(p->scs30, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecSQN_NR_PUCCH_ResourceExt_r16_interlaceAllocation_r16_interlace0(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_PUCCH_ResourceExt_r16_interlaceAllocation_r16_interlace0* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SQN_NR_PUCCH_ResourceExt_r16_interlaceAllocation_r16_interlace0_Sel)_tmp;
	}
	_serNrSysDecSQN_NR_PUCCH_ResourceExt_r16_interlaceAllocation_r16_interlace0_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PUCCH_ResourceExt_r16_interlaceAllocation_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_PUCCH_ResourceExt_r16_interlaceAllocation_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->rb_SetIndex, &_buffer[*_lidx], _lidx);
	_serNrSysDecSQN_NR_PUCCH_ResourceExt_r16_interlaceAllocation_r16_interlace0(_buffer, _size, _lidx, &p->interlace0);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PUCCH_ResourceExt_r16_interlaceAllocation_r16_interlaceAllocation_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_PUCCH_ResourceExt_r16_interlaceAllocation_r16_interlaceAllocation_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_PUCCH_ResourceExt_r16_interlaceAllocation_r16(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PUCCH_ResourceExt_r16_formatExt_v1610_occ_v1610_occ_Length_v1610_e_occ_Length_v1610_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_PUCCH_ResourceExt_r16_formatExt_v1610_occ_v1610_occ_Length_v1610_e_occ_Length_v1610_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_PUCCH_ResourceExt_r16_formatExt_v1610_occ_v1610_occ_Length_v1610_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PUCCH_ResourceExt_r16_formatExt_v1610_occ_v1610_occ_Index_v1610_e_occ_Index_v1610_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_PUCCH_ResourceExt_r16_formatExt_v1610_occ_v1610_occ_Index_v1610_e_occ_Index_v1610_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_PUCCH_ResourceExt_r16_formatExt_v1610_occ_v1610_occ_Index_v1610_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PUCCH_ResourceExt_r16_formatExt_v1610_occ_v1610(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_PUCCH_ResourceExt_r16_formatExt_v1610_occ_v1610* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecSQN_NR_PUCCH_ResourceExt_r16_formatExt_v1610_occ_v1610_occ_Length_v1610_e_occ_Length_v1610_Optional(_buffer, _size, _lidx, &p->occ_Length_v1610);
	_serNrSysDecSQN_NR_PUCCH_ResourceExt_r16_formatExt_v1610_occ_v1610_occ_Index_v1610_e_occ_Index_v1610_Optional(_buffer, _size, _lidx, &p->occ_Index_v1610);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PUCCH_ResourceExt_r16_formatExt_v1610_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union SQN_NR_PUCCH_ResourceExt_r16_formatExt_v1610_Value* p, enum SQN_NR_PUCCH_ResourceExt_r16_formatExt_v1610_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_PUCCH_ResourceExt_r16_formatExt_v1610_interlace1_v1610) {
		NTOH_8(p->interlace1_v1610, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_PUCCH_ResourceExt_r16_formatExt_v1610_occ_v1610) {
		_serNrSysDecSQN_NR_PUCCH_ResourceExt_r16_formatExt_v1610_occ_v1610(_buffer, _size, _lidx, &p->occ_v1610);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecSQN_NR_PUCCH_ResourceExt_r16_formatExt_v1610(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_PUCCH_ResourceExt_r16_formatExt_v1610* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SQN_NR_PUCCH_ResourceExt_r16_formatExt_v1610_Sel)_tmp;
	}
	_serNrSysDecSQN_NR_PUCCH_ResourceExt_r16_formatExt_v1610_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PUCCH_ResourceExt_r16_formatExt_v1610_formatExt_v1610_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_PUCCH_ResourceExt_r16_formatExt_v1610_formatExt_v1610_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_PUCCH_ResourceExt_r16_formatExt_v1610(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PUCCH_ResourceExt_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_PUCCH_ResourceExt_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecSQN_NR_PUCCH_ResourceExt_r16_interlaceAllocation_r16_interlaceAllocation_r16_Optional(_buffer, _size, _lidx, &p->interlaceAllocation_r16);
	_serNrSysDecSQN_NR_PUCCH_ResourceExt_r16_formatExt_v1610_formatExt_v1610_Optional(_buffer, _size, _lidx, &p->formatExt_v1610);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PUCCH_ResourceExt_r16_SQN_NR_PUCCH_Config_resourceToAddModListExt_r16_DynamicOptional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_PUCCH_ResourceExt_r16_SQN_NR_PUCCH_Config_resourceToAddModListExt_r16_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = (struct SQN_NR_PUCCH_ResourceExt_r16*)serMalloc(_mem, p->v.d * sizeof(struct SQN_NR_PUCCH_ResourceExt_r16));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serNrSysDecSQN_NR_PUCCH_ResourceExt_r16(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SetupRelease_PUCCH_Config_dl_DataToUL_ACK_r16_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union SQN_NR_SetupRelease_PUCCH_Config_dl_DataToUL_ACK_r16_Value* p, enum SQN_NR_SetupRelease_PUCCH_Config_dl_DataToUL_ACK_r16_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SetupRelease_PUCCH_Config_dl_DataToUL_ACK_r16_release) {
		NTOH_8(p->release, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SetupRelease_PUCCH_Config_dl_DataToUL_ACK_r16_setup) {
		NTOH_32(p->setup.d, &_buffer[*_lidx], _lidx);
		p->setup.v = (int8_t*)serMalloc(_mem, p->setup.d * sizeof(int8_t));
		for (size_t i2 = 0; i2 < p->setup.d; i2++) {
			NTOH_8(p->setup.v[i2], &_buffer[*_lidx], _lidx);
		}
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecSQN_NR_SetupRelease_PUCCH_Config_dl_DataToUL_ACK_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_SetupRelease_PUCCH_Config_dl_DataToUL_ACK_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SQN_NR_SetupRelease_PUCCH_Config_dl_DataToUL_ACK_r16_Sel)_tmp;
	}
	_serNrSysDecSQN_NR_SetupRelease_PUCCH_Config_dl_DataToUL_ACK_r16_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SetupRelease_PUCCH_Config_dl_DataToUL_ACK_r16_SQN_NR_PUCCH_Config_dl_DataToUL_ACK_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_SetupRelease_PUCCH_Config_dl_DataToUL_ACK_r16_SQN_NR_PUCCH_Config_dl_DataToUL_ACK_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_SetupRelease_PUCCH_Config_dl_DataToUL_ACK_r16(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SetupRelease_PUCCH_Config_ul_AccessConfigListDCI_1_1_r16_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union SQN_NR_SetupRelease_PUCCH_Config_ul_AccessConfigListDCI_1_1_r16_Value* p, enum SQN_NR_SetupRelease_PUCCH_Config_ul_AccessConfigListDCI_1_1_r16_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SetupRelease_PUCCH_Config_ul_AccessConfigListDCI_1_1_r16_release) {
		NTOH_8(p->release, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SetupRelease_PUCCH_Config_ul_AccessConfigListDCI_1_1_r16_setup) {
		NTOH_32(p->setup.d, &_buffer[*_lidx], _lidx);
		p->setup.v = (uint8_t*)serMalloc(_mem, p->setup.d * sizeof(uint8_t));
		for (size_t i2 = 0; i2 < p->setup.d; i2++) {
			NTOH_8(p->setup.v[i2], &_buffer[*_lidx], _lidx);
		}
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecSQN_NR_SetupRelease_PUCCH_Config_ul_AccessConfigListDCI_1_1_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_SetupRelease_PUCCH_Config_ul_AccessConfigListDCI_1_1_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SQN_NR_SetupRelease_PUCCH_Config_ul_AccessConfigListDCI_1_1_r16_Sel)_tmp;
	}
	_serNrSysDecSQN_NR_SetupRelease_PUCCH_Config_ul_AccessConfigListDCI_1_1_r16_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SetupRelease_PUCCH_Config_ul_AccessConfigListDCI_1_1_r16_SQN_NR_PUCCH_Config_ul_AccessConfigListDCI_1_1_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_SetupRelease_PUCCH_Config_ul_AccessConfigListDCI_1_1_r16_SQN_NR_PUCCH_Config_ul_AccessConfigListDCI_1_1_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_SetupRelease_PUCCH_Config_ul_AccessConfigListDCI_1_1_r16(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PUCCH_Config_subslotLengthForPUCCH_r16_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union SQN_NR_PUCCH_Config_subslotLengthForPUCCH_r16_Value* p, enum SQN_NR_PUCCH_Config_subslotLengthForPUCCH_r16_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_PUCCH_Config_subslotLengthForPUCCH_r16_normalCP_r16) {
		{
			size_t _tmp;
			NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
			p->normalCP_r16 = (SQN_NR_PUCCH_Config_subslotLengthForPUCCH_r16_normalCP_r16_e)_tmp;
		}
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_PUCCH_Config_subslotLengthForPUCCH_r16_extendedCP_r16) {
		{
			size_t _tmp;
			NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
			p->extendedCP_r16 = (SQN_NR_PUCCH_Config_subslotLengthForPUCCH_r16_extendedCP_r16_e)_tmp;
		}
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecSQN_NR_PUCCH_Config_subslotLengthForPUCCH_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_PUCCH_Config_subslotLengthForPUCCH_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SQN_NR_PUCCH_Config_subslotLengthForPUCCH_r16_Sel)_tmp;
	}
	_serNrSysDecSQN_NR_PUCCH_Config_subslotLengthForPUCCH_r16_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PUCCH_Config_subslotLengthForPUCCH_r16_subslotLengthForPUCCH_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_PUCCH_Config_subslotLengthForPUCCH_r16_subslotLengthForPUCCH_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_PUCCH_Config_subslotLengthForPUCCH_r16(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SetupRelease_PUCCH_Config_dl_DataToUL_ACK_DCI_1_2_r16_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union SQN_NR_SetupRelease_PUCCH_Config_dl_DataToUL_ACK_DCI_1_2_r16_Value* p, enum SQN_NR_SetupRelease_PUCCH_Config_dl_DataToUL_ACK_DCI_1_2_r16_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SetupRelease_PUCCH_Config_dl_DataToUL_ACK_DCI_1_2_r16_release) {
		NTOH_8(p->release, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SetupRelease_PUCCH_Config_dl_DataToUL_ACK_DCI_1_2_r16_setup) {
		NTOH_32(p->setup.d, &_buffer[*_lidx], _lidx);
		p->setup.v = (uint8_t*)serMalloc(_mem, p->setup.d * sizeof(uint8_t));
		for (size_t i2 = 0; i2 < p->setup.d; i2++) {
			NTOH_8(p->setup.v[i2], &_buffer[*_lidx], _lidx);
		}
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecSQN_NR_SetupRelease_PUCCH_Config_dl_DataToUL_ACK_DCI_1_2_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_SetupRelease_PUCCH_Config_dl_DataToUL_ACK_DCI_1_2_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SQN_NR_SetupRelease_PUCCH_Config_dl_DataToUL_ACK_DCI_1_2_r16_Sel)_tmp;
	}
	_serNrSysDecSQN_NR_SetupRelease_PUCCH_Config_dl_DataToUL_ACK_DCI_1_2_r16_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SetupRelease_PUCCH_Config_dl_DataToUL_ACK_DCI_1_2_r16_SQN_NR_PUCCH_Config_dl_DataToUL_ACK_DCI_1_2_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_SetupRelease_PUCCH_Config_dl_DataToUL_ACK_DCI_1_2_r16_SQN_NR_PUCCH_Config_dl_DataToUL_ACK_DCI_1_2_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_SetupRelease_PUCCH_Config_dl_DataToUL_ACK_DCI_1_2_r16(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecUint8_t_SQN_NR_PUCCH_Config_numberOfBitsForPUCCH_ResourceIndicatorDCI_1_2_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct uint8_t_SQN_NR_PUCCH_Config_numberOfBitsForPUCCH_ResourceIndicatorDCI_1_2_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PUCCH_Config_dmrs_UplinkTransformPrecodingPUCCH_r16_e_dmrs_UplinkTransformPrecodingPUCCH_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_PUCCH_Config_dmrs_UplinkTransformPrecodingPUCCH_r16_e_dmrs_UplinkTransformPrecodingPUCCH_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_PUCCH_Config_dmrs_UplinkTransformPrecodingPUCCH_r16_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PUCCH_SpatialRelationInfo_SQN_NR_PUCCH_Config_spatialRelationInfoToAddModList2_r16_DynamicOptional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_PUCCH_SpatialRelationInfo_SQN_NR_PUCCH_Config_spatialRelationInfoToAddModList2_r16_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = (struct SQN_NR_PUCCH_SpatialRelationInfo*)serMalloc(_mem, p->v.d * sizeof(struct SQN_NR_PUCCH_SpatialRelationInfo));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serNrSysDecSQN_NR_PUCCH_SpatialRelationInfo(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PUCCH_SpatialRelationInfoId_SQN_NR_PUCCH_Config_spatialRelationInfoToReleaseList2_r16_DynamicOptional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_PUCCH_SpatialRelationInfoId_SQN_NR_PUCCH_Config_spatialRelationInfoToReleaseList2_r16_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = (SQN_NR_PUCCH_SpatialRelationInfoId*)serMalloc(_mem, p->v.d * sizeof(SQN_NR_PUCCH_SpatialRelationInfoId));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		NTOH_8(p->v.v[i2], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PUCCH_SpatialRelationInfoId_v1610_SQN_NR_PUCCH_SpatialRelationInfoExt_r16_pucch_SpatialRelationInfoId_v1610_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_PUCCH_SpatialRelationInfoId_v1610_SQN_NR_PUCCH_SpatialRelationInfoExt_r16_pucch_SpatialRelationInfoId_v1610_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PUCCH_PathlossReferenceRS_Id_v1610_SQN_NR_PUCCH_SpatialRelationInfoExt_r16_pucch_PathlossReferenceRS_Id_v1610_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_PUCCH_PathlossReferenceRS_Id_v1610_SQN_NR_PUCCH_SpatialRelationInfoExt_r16_pucch_PathlossReferenceRS_Id_v1610_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PUCCH_SpatialRelationInfoExt_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_PUCCH_SpatialRelationInfoExt_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecSQN_NR_PUCCH_SpatialRelationInfoId_v1610_SQN_NR_PUCCH_SpatialRelationInfoExt_r16_pucch_SpatialRelationInfoId_v1610_Optional(_buffer, _size, _lidx, &p->pucch_SpatialRelationInfoId_v1610);
	_serNrSysDecSQN_NR_PUCCH_PathlossReferenceRS_Id_v1610_SQN_NR_PUCCH_SpatialRelationInfoExt_r16_pucch_PathlossReferenceRS_Id_v1610_Optional(_buffer, _size, _lidx, &p->pucch_PathlossReferenceRS_Id_v1610);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PUCCH_SpatialRelationInfoExt_r16_SQN_NR_PUCCH_Config_spatialRelationInfoToAddModListExt_r16_DynamicOptional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_PUCCH_SpatialRelationInfoExt_r16_SQN_NR_PUCCH_Config_spatialRelationInfoToAddModListExt_r16_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = (struct SQN_NR_PUCCH_SpatialRelationInfoExt_r16*)serMalloc(_mem, p->v.d * sizeof(struct SQN_NR_PUCCH_SpatialRelationInfoExt_r16));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serNrSysDecSQN_NR_PUCCH_SpatialRelationInfoExt_r16(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PUCCH_SpatialRelationInfoId_r16_SQN_NR_PUCCH_Config_spatialRelationInfoToReleaseList_r16_DynamicOptional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_PUCCH_SpatialRelationInfoId_r16_SQN_NR_PUCCH_Config_spatialRelationInfoToReleaseList_r16_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = (SQN_NR_PUCCH_SpatialRelationInfoId_r16*)serMalloc(_mem, p->v.d * sizeof(SQN_NR_PUCCH_SpatialRelationInfoId_r16));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		NTOH_8(p->v.v[i2], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PUCCH_ResourceGroup_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_PUCCH_ResourceGroup_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->pucch_ResourceGroupId_r16, &_buffer[*_lidx], _lidx);
	NTOH_32(p->resourcePerGroupList_r16.d, &_buffer[*_lidx], _lidx);
	p->resourcePerGroupList_r16.v = (SQN_NR_PUCCH_ResourceId*)serMalloc(_mem, p->resourcePerGroupList_r16.d * sizeof(SQN_NR_PUCCH_ResourceId));
	for (size_t i3 = 0; i3 < p->resourcePerGroupList_r16.d; i3++) {
		NTOH_8(p->resourcePerGroupList_r16.v[i3], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PUCCH_ResourceGroup_r16_SQN_NR_PUCCH_Config_resourceGroupToAddModList_r16_DynamicOptional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_PUCCH_ResourceGroup_r16_SQN_NR_PUCCH_Config_resourceGroupToAddModList_r16_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = (struct SQN_NR_PUCCH_ResourceGroup_r16*)serMalloc(_mem, p->v.d * sizeof(struct SQN_NR_PUCCH_ResourceGroup_r16));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serNrSysDecSQN_NR_PUCCH_ResourceGroup_r16(_buffer, _size, _lidx, _mem, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PUCCH_ResourceGroupId_r16_SQN_NR_PUCCH_Config_resourceGroupToReleaseList_r16_DynamicOptional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_PUCCH_ResourceGroupId_r16_SQN_NR_PUCCH_Config_resourceGroupToReleaseList_r16_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = (SQN_NR_PUCCH_ResourceGroupId_r16*)serMalloc(_mem, p->v.d * sizeof(SQN_NR_PUCCH_ResourceGroupId_r16));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		NTOH_8(p->v.v[i2], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecUint16_t_SQN_NR_SPS_PUCCH_AN_r16_maxPayloadSize_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct uint16_t_SQN_NR_SPS_PUCCH_AN_r16_maxPayloadSize_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_16(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SPS_PUCCH_AN_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SPS_PUCCH_AN_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->sps_PUCCH_AN_ResourceID_r16, &_buffer[*_lidx], _lidx);
	_serNrSysDecUint16_t_SQN_NR_SPS_PUCCH_AN_r16_maxPayloadSize_r16_Optional(_buffer, _size, _lidx, &p->maxPayloadSize_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SetupRelease_PUCCH_Config_sps_PUCCH_AN_List_r16_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union SQN_NR_SetupRelease_PUCCH_Config_sps_PUCCH_AN_List_r16_Value* p, enum SQN_NR_SetupRelease_PUCCH_Config_sps_PUCCH_AN_List_r16_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SetupRelease_PUCCH_Config_sps_PUCCH_AN_List_r16_release) {
		NTOH_8(p->release, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SetupRelease_PUCCH_Config_sps_PUCCH_AN_List_r16_setup) {
		NTOH_32(p->setup.d, &_buffer[*_lidx], _lidx);
		p->setup.v = (struct SQN_NR_SPS_PUCCH_AN_r16*)serMalloc(_mem, p->setup.d * sizeof(struct SQN_NR_SPS_PUCCH_AN_r16));
		for (size_t i2 = 0; i2 < p->setup.d; i2++) {
			_serNrSysDecSQN_NR_SPS_PUCCH_AN_r16(_buffer, _size, _lidx, &p->setup.v[i2]);
		}
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecSQN_NR_SetupRelease_PUCCH_Config_sps_PUCCH_AN_List_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_SetupRelease_PUCCH_Config_sps_PUCCH_AN_List_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SQN_NR_SetupRelease_PUCCH_Config_sps_PUCCH_AN_List_r16_Sel)_tmp;
	}
	_serNrSysDecSQN_NR_SetupRelease_PUCCH_Config_sps_PUCCH_AN_List_r16_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SetupRelease_PUCCH_Config_sps_PUCCH_AN_List_r16_SQN_NR_PUCCH_Config_sps_PUCCH_AN_List_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_SetupRelease_PUCCH_Config_sps_PUCCH_AN_List_r16_SQN_NR_PUCCH_Config_sps_PUCCH_AN_List_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_SetupRelease_PUCCH_Config_sps_PUCCH_AN_List_r16(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SchedulingRequestResourceConfig_v1610_phy_PriorityIndex_r16_e_phy_PriorityIndex_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SchedulingRequestResourceConfig_v1610_phy_PriorityIndex_r16_e_phy_PriorityIndex_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_SchedulingRequestResourceConfig_v1610_phy_PriorityIndex_r16_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SchedulingRequestResourceConfig_v1610(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SchedulingRequestResourceConfig_v1610* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecSQN_NR_SchedulingRequestResourceConfig_v1610_phy_PriorityIndex_r16_e_phy_PriorityIndex_r16_Optional(_buffer, _size, _lidx, &p->phy_PriorityIndex_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SchedulingRequestResourceConfig_v1610_SQN_NR_PUCCH_Config_schedulingRequestResourceToAddModList_v1610_DynamicOptional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_SchedulingRequestResourceConfig_v1610_SQN_NR_PUCCH_Config_schedulingRequestResourceToAddModList_v1610_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = (struct SQN_NR_SchedulingRequestResourceConfig_v1610*)serMalloc(_mem, p->v.d * sizeof(struct SQN_NR_SchedulingRequestResourceConfig_v1610));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serNrSysDecSQN_NR_SchedulingRequestResourceConfig_v1610(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PUCCH_Config(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_PUCCH_Config* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecSQN_NR_PUCCH_ResourceSet_SQN_NR_PUCCH_Config_resourceSetToAddModList_DynamicOptional(_buffer, _size, _lidx, _mem, &p->resourceSetToAddModList);
	_serNrSysDecSQN_NR_PUCCH_ResourceSetId_SQN_NR_PUCCH_Config_resourceSetToReleaseList_DynamicOptional(_buffer, _size, _lidx, _mem, &p->resourceSetToReleaseList);
	_serNrSysDecSQN_NR_PUCCH_Resource_SQN_NR_PUCCH_Config_resourceToAddModList_DynamicOptional(_buffer, _size, _lidx, _mem, &p->resourceToAddModList);
	_serNrSysDecSQN_NR_PUCCH_ResourceId_SQN_NR_PUCCH_Config_resourceToReleaseList_DynamicOptional(_buffer, _size, _lidx, _mem, &p->resourceToReleaseList);
	_serNrSysDecSQN_NR_SetupRelease_PUCCH_Config_format1_SQN_NR_PUCCH_Config_format1_Optional(_buffer, _size, _lidx, &p->format1);
	_serNrSysDecSQN_NR_SetupRelease_PUCCH_Config_format2_SQN_NR_PUCCH_Config_format2_Optional(_buffer, _size, _lidx, &p->format2);
	_serNrSysDecSQN_NR_SetupRelease_PUCCH_Config_format3_SQN_NR_PUCCH_Config_format3_Optional(_buffer, _size, _lidx, &p->format3);
	_serNrSysDecSQN_NR_SetupRelease_PUCCH_Config_format4_SQN_NR_PUCCH_Config_format4_Optional(_buffer, _size, _lidx, &p->format4);
	_serNrSysDecSQN_NR_SchedulingRequestResourceConfig_SQN_NR_PUCCH_Config_schedulingRequestResourceToAddModList_DynamicOptional(_buffer, _size, _lidx, _mem, &p->schedulingRequestResourceToAddModList);
	_serNrSysDecSQN_NR_SchedulingRequestResourceId_SQN_NR_PUCCH_Config_schedulingRequestResourceToReleaseList_DynamicOptional(_buffer, _size, _lidx, _mem, &p->schedulingRequestResourceToReleaseList);
	_serNrSysDecSQN_NR_PUCCH_ResourceId_SQN_NR_PUCCH_Config_multi_CSI_PUCCH_ResourceList_DynamicOptional(_buffer, _size, _lidx, _mem, &p->multi_CSI_PUCCH_ResourceList);
	_serNrSysDecUint8_t_SQN_NR_PUCCH_Config_dl_DataToUL_ACK_DynamicOptional(_buffer, _size, _lidx, _mem, &p->dl_DataToUL_ACK);
	_serNrSysDecSQN_NR_PUCCH_SpatialRelationInfo_SQN_NR_PUCCH_Config_spatialRelationInfoToAddModList_DynamicOptional(_buffer, _size, _lidx, _mem, &p->spatialRelationInfoToAddModList);
	_serNrSysDecSQN_NR_PUCCH_SpatialRelationInfoId_SQN_NR_PUCCH_Config_spatialRelationInfoToReleaseList_DynamicOptional(_buffer, _size, _lidx, _mem, &p->spatialRelationInfoToReleaseList);
	_serNrSysDecSQN_NR_PUCCH_PowerControl_SQN_NR_PUCCH_Config_pucch_PowerControl_Optional(_buffer, _size, _lidx, _mem, &p->pucch_PowerControl);
	_serNrSysDecSQN_NR_PUCCH_ResourceExt_r16_SQN_NR_PUCCH_Config_resourceToAddModListExt_r16_DynamicOptional(_buffer, _size, _lidx, _mem, &p->resourceToAddModListExt_r16);
	_serNrSysDecSQN_NR_SetupRelease_PUCCH_Config_dl_DataToUL_ACK_r16_SQN_NR_PUCCH_Config_dl_DataToUL_ACK_r16_Optional(_buffer, _size, _lidx, _mem, &p->dl_DataToUL_ACK_r16);
	_serNrSysDecSQN_NR_SetupRelease_PUCCH_Config_ul_AccessConfigListDCI_1_1_r16_SQN_NR_PUCCH_Config_ul_AccessConfigListDCI_1_1_r16_Optional(_buffer, _size, _lidx, _mem, &p->ul_AccessConfigListDCI_1_1_r16);
	_serNrSysDecSQN_NR_PUCCH_Config_subslotLengthForPUCCH_r16_subslotLengthForPUCCH_r16_Optional(_buffer, _size, _lidx, &p->subslotLengthForPUCCH_r16);
	_serNrSysDecSQN_NR_SetupRelease_PUCCH_Config_dl_DataToUL_ACK_DCI_1_2_r16_SQN_NR_PUCCH_Config_dl_DataToUL_ACK_DCI_1_2_r16_Optional(_buffer, _size, _lidx, _mem, &p->dl_DataToUL_ACK_DCI_1_2_r16);
	_serNrSysDecUint8_t_SQN_NR_PUCCH_Config_numberOfBitsForPUCCH_ResourceIndicatorDCI_1_2_r16_Optional(_buffer, _size, _lidx, &p->numberOfBitsForPUCCH_ResourceIndicatorDCI_1_2_r16);
	_serNrSysDecSQN_NR_PUCCH_Config_dmrs_UplinkTransformPrecodingPUCCH_r16_e_dmrs_UplinkTransformPrecodingPUCCH_r16_Optional(_buffer, _size, _lidx, &p->dmrs_UplinkTransformPrecodingPUCCH_r16);
	_serNrSysDecSQN_NR_PUCCH_SpatialRelationInfo_SQN_NR_PUCCH_Config_spatialRelationInfoToAddModList2_r16_DynamicOptional(_buffer, _size, _lidx, _mem, &p->spatialRelationInfoToAddModList2_r16);
	_serNrSysDecSQN_NR_PUCCH_SpatialRelationInfoId_SQN_NR_PUCCH_Config_spatialRelationInfoToReleaseList2_r16_DynamicOptional(_buffer, _size, _lidx, _mem, &p->spatialRelationInfoToReleaseList2_r16);
	_serNrSysDecSQN_NR_PUCCH_SpatialRelationInfoExt_r16_SQN_NR_PUCCH_Config_spatialRelationInfoToAddModListExt_r16_DynamicOptional(_buffer, _size, _lidx, _mem, &p->spatialRelationInfoToAddModListExt_r16);
	_serNrSysDecSQN_NR_PUCCH_SpatialRelationInfoId_r16_SQN_NR_PUCCH_Config_spatialRelationInfoToReleaseList_r16_DynamicOptional(_buffer, _size, _lidx, _mem, &p->spatialRelationInfoToReleaseList_r16);
	_serNrSysDecSQN_NR_PUCCH_ResourceGroup_r16_SQN_NR_PUCCH_Config_resourceGroupToAddModList_r16_DynamicOptional(_buffer, _size, _lidx, _mem, &p->resourceGroupToAddModList_r16);
	_serNrSysDecSQN_NR_PUCCH_ResourceGroupId_r16_SQN_NR_PUCCH_Config_resourceGroupToReleaseList_r16_DynamicOptional(_buffer, _size, _lidx, _mem, &p->resourceGroupToReleaseList_r16);
	_serNrSysDecSQN_NR_SetupRelease_PUCCH_Config_sps_PUCCH_AN_List_r16_SQN_NR_PUCCH_Config_sps_PUCCH_AN_List_r16_Optional(_buffer, _size, _lidx, _mem, &p->sps_PUCCH_AN_List_r16);
	_serNrSysDecSQN_NR_SchedulingRequestResourceConfig_v1610_SQN_NR_PUCCH_Config_schedulingRequestResourceToAddModList_v1610_DynamicOptional(_buffer, _size, _lidx, _mem, &p->schedulingRequestResourceToAddModList_v1610);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SetupRelease_BWP_UplinkDedicated_pucch_Config_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union SQN_NR_SetupRelease_BWP_UplinkDedicated_pucch_Config_Value* p, enum SQN_NR_SetupRelease_BWP_UplinkDedicated_pucch_Config_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SetupRelease_BWP_UplinkDedicated_pucch_Config_release) {
		NTOH_8(p->release, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SetupRelease_BWP_UplinkDedicated_pucch_Config_setup) {
		_serNrSysDecSQN_NR_PUCCH_Config(_buffer, _size, _lidx, _mem, &p->setup);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecSQN_NR_SetupRelease_BWP_UplinkDedicated_pucch_Config(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_SetupRelease_BWP_UplinkDedicated_pucch_Config* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SQN_NR_SetupRelease_BWP_UplinkDedicated_pucch_Config_Sel)_tmp;
	}
	_serNrSysDecSQN_NR_SetupRelease_BWP_UplinkDedicated_pucch_Config_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SetupRelease_BWP_UplinkDedicated_pucch_Config_SQN_NR_BWP_UplinkDedicated_pucch_Config_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_SetupRelease_BWP_UplinkDedicated_pucch_Config_SQN_NR_BWP_UplinkDedicated_pucch_Config_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_SetupRelease_BWP_UplinkDedicated_pucch_Config(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecUint16_t_SQN_NR_PUSCH_Config_dataScramblingIdentityPUSCH_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct uint16_t_SQN_NR_PUSCH_Config_dataScramblingIdentityPUSCH_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_16(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PUSCH_Config_txConfig_e_txConfig_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_PUSCH_Config_txConfig_e_txConfig_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_PUSCH_Config_txConfig_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_DMRS_UplinkConfig_dmrs_Type_e_dmrs_Type_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_DMRS_UplinkConfig_dmrs_Type_e_dmrs_Type_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_DMRS_UplinkConfig_dmrs_Type_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_DMRS_UplinkConfig_dmrs_AdditionalPosition_e_dmrs_AdditionalPosition_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_DMRS_UplinkConfig_dmrs_AdditionalPosition_e_dmrs_AdditionalPosition_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_DMRS_UplinkConfig_dmrs_AdditionalPosition_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecUint16_t_SQN_NR_PTRS_UplinkConfig_transformPrecoderDisabled_frequencyDensity_ArrayOptional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct uint16_t_SQN_NR_PTRS_UplinkConfig_transformPrecoderDisabled_frequencyDensity_ArrayOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	for (size_t i2 = 0; i2 < 2; i2++) {
		NTOH_16(p->v[i2], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecUint8_t_SQN_NR_PTRS_UplinkConfig_transformPrecoderDisabled_timeDensity_ArrayOptional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct uint8_t_SQN_NR_PTRS_UplinkConfig_transformPrecoderDisabled_timeDensity_ArrayOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	for (size_t i2 = 0; i2 < 3; i2++) {
		NTOH_8(p->v[i2], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PTRS_UplinkConfig_transformPrecoderDisabled_resourceElementOffset_e_resourceElementOffset_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_PTRS_UplinkConfig_transformPrecoderDisabled_resourceElementOffset_e_resourceElementOffset_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_PTRS_UplinkConfig_transformPrecoderDisabled_resourceElementOffset_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PTRS_UplinkConfig_transformPrecoderDisabled(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_PTRS_UplinkConfig_transformPrecoderDisabled* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecUint16_t_SQN_NR_PTRS_UplinkConfig_transformPrecoderDisabled_frequencyDensity_ArrayOptional(_buffer, _size, _lidx, &p->frequencyDensity);
	_serNrSysDecUint8_t_SQN_NR_PTRS_UplinkConfig_transformPrecoderDisabled_timeDensity_ArrayOptional(_buffer, _size, _lidx, &p->timeDensity);
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->maxNrofPorts = (SQN_NR_PTRS_UplinkConfig_transformPrecoderDisabled_maxNrofPorts_e)_tmp;
	}
	_serNrSysDecSQN_NR_PTRS_UplinkConfig_transformPrecoderDisabled_resourceElementOffset_e_resourceElementOffset_Optional(_buffer, _size, _lidx, &p->resourceElementOffset);
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->ptrs_Power = (SQN_NR_PTRS_UplinkConfig_transformPrecoderDisabled_ptrs_Power_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PTRS_UplinkConfig_transformPrecoderDisabled_transformPrecoderDisabled_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_PTRS_UplinkConfig_transformPrecoderDisabled_transformPrecoderDisabled_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_PTRS_UplinkConfig_transformPrecoderDisabled(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PTRS_UplinkConfig_transformPrecoderEnabled_timeDensityTransformPrecoding_e_timeDensityTransformPrecoding_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_PTRS_UplinkConfig_transformPrecoderEnabled_timeDensityTransformPrecoding_e_timeDensityTransformPrecoding_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_PTRS_UplinkConfig_transformPrecoderEnabled_timeDensityTransformPrecoding_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PTRS_UplinkConfig_transformPrecoderEnabled(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_PTRS_UplinkConfig_transformPrecoderEnabled* p)
{
	(void)_size; // TODO: generate boundaries checking

	for (size_t i2 = 0; i2 < 5; i2++) {
		NTOH_16(p->sampleDensity[i2], &_buffer[*_lidx], _lidx);
	}
	_serNrSysDecSQN_NR_PTRS_UplinkConfig_transformPrecoderEnabled_timeDensityTransformPrecoding_e_timeDensityTransformPrecoding_Optional(_buffer, _size, _lidx, &p->timeDensityTransformPrecoding);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PTRS_UplinkConfig_transformPrecoderEnabled_transformPrecoderEnabled_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_PTRS_UplinkConfig_transformPrecoderEnabled_transformPrecoderEnabled_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_PTRS_UplinkConfig_transformPrecoderEnabled(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PTRS_UplinkConfig(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_PTRS_UplinkConfig* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecSQN_NR_PTRS_UplinkConfig_transformPrecoderDisabled_transformPrecoderDisabled_Optional(_buffer, _size, _lidx, &p->transformPrecoderDisabled);
	_serNrSysDecSQN_NR_PTRS_UplinkConfig_transformPrecoderEnabled_transformPrecoderEnabled_Optional(_buffer, _size, _lidx, &p->transformPrecoderEnabled);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SetupRelease_DMRS_UplinkConfig_phaseTrackingRS_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union SQN_NR_SetupRelease_DMRS_UplinkConfig_phaseTrackingRS_Value* p, enum SQN_NR_SetupRelease_DMRS_UplinkConfig_phaseTrackingRS_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SetupRelease_DMRS_UplinkConfig_phaseTrackingRS_release) {
		NTOH_8(p->release, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SetupRelease_DMRS_UplinkConfig_phaseTrackingRS_setup) {
		_serNrSysDecSQN_NR_PTRS_UplinkConfig(_buffer, _size, _lidx, &p->setup);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecSQN_NR_SetupRelease_DMRS_UplinkConfig_phaseTrackingRS(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SetupRelease_DMRS_UplinkConfig_phaseTrackingRS* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SQN_NR_SetupRelease_DMRS_UplinkConfig_phaseTrackingRS_Sel)_tmp;
	}
	_serNrSysDecSQN_NR_SetupRelease_DMRS_UplinkConfig_phaseTrackingRS_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SetupRelease_DMRS_UplinkConfig_phaseTrackingRS_SQN_NR_DMRS_UplinkConfig_phaseTrackingRS_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SetupRelease_DMRS_UplinkConfig_phaseTrackingRS_SQN_NR_DMRS_UplinkConfig_phaseTrackingRS_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_SetupRelease_DMRS_UplinkConfig_phaseTrackingRS(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_DMRS_UplinkConfig_maxLength_e_maxLength_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_DMRS_UplinkConfig_maxLength_e_maxLength_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_DMRS_UplinkConfig_maxLength_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecUint16_t_SQN_NR_DMRS_UplinkConfig_transformPrecodingDisabled_scramblingID0_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct uint16_t_SQN_NR_DMRS_UplinkConfig_transformPrecodingDisabled_scramblingID0_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_16(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecUint16_t_SQN_NR_DMRS_UplinkConfig_transformPrecodingDisabled_scramblingID1_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct uint16_t_SQN_NR_DMRS_UplinkConfig_transformPrecodingDisabled_scramblingID1_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_16(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_DMRS_UplinkConfig_transformPrecodingDisabled_dmrs_Uplink_r16_e_dmrs_Uplink_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_DMRS_UplinkConfig_transformPrecodingDisabled_dmrs_Uplink_r16_e_dmrs_Uplink_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_DMRS_UplinkConfig_transformPrecodingDisabled_dmrs_Uplink_r16_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_DMRS_UplinkConfig_transformPrecodingDisabled(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_DMRS_UplinkConfig_transformPrecodingDisabled* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecUint16_t_SQN_NR_DMRS_UplinkConfig_transformPrecodingDisabled_scramblingID0_Optional(_buffer, _size, _lidx, &p->scramblingID0);
	_serNrSysDecUint16_t_SQN_NR_DMRS_UplinkConfig_transformPrecodingDisabled_scramblingID1_Optional(_buffer, _size, _lidx, &p->scramblingID1);
	_serNrSysDecSQN_NR_DMRS_UplinkConfig_transformPrecodingDisabled_dmrs_Uplink_r16_e_dmrs_Uplink_r16_Optional(_buffer, _size, _lidx, &p->dmrs_Uplink_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_DMRS_UplinkConfig_transformPrecodingDisabled_transformPrecodingDisabled_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_DMRS_UplinkConfig_transformPrecodingDisabled_transformPrecodingDisabled_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_DMRS_UplinkConfig_transformPrecodingDisabled(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecUint16_t_SQN_NR_DMRS_UplinkConfig_transformPrecodingEnabled_nPUSCH_Identity_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct uint16_t_SQN_NR_DMRS_UplinkConfig_transformPrecodingEnabled_nPUSCH_Identity_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_16(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_DMRS_UplinkConfig_transformPrecodingEnabled_sequenceGroupHopping_e_sequenceGroupHopping_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_DMRS_UplinkConfig_transformPrecodingEnabled_sequenceGroupHopping_e_sequenceGroupHopping_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_DMRS_UplinkConfig_transformPrecodingEnabled_sequenceGroupHopping_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_DMRS_UplinkConfig_transformPrecodingEnabled_sequenceHopping_e_sequenceHopping_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_DMRS_UplinkConfig_transformPrecodingEnabled_sequenceHopping_e_sequenceHopping_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_DMRS_UplinkConfig_transformPrecodingEnabled_sequenceHopping_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecUint16_t_SQN_NR_DMRS_UplinkTransformPrecoding_r16_pi2BPSK_ScramblingID0_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct uint16_t_SQN_NR_DMRS_UplinkTransformPrecoding_r16_pi2BPSK_ScramblingID0_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_16(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecUint16_t_SQN_NR_DMRS_UplinkTransformPrecoding_r16_pi2BPSK_ScramblingID1_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct uint16_t_SQN_NR_DMRS_UplinkTransformPrecoding_r16_pi2BPSK_ScramblingID1_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_16(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_DMRS_UplinkTransformPrecoding_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_DMRS_UplinkTransformPrecoding_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecUint16_t_SQN_NR_DMRS_UplinkTransformPrecoding_r16_pi2BPSK_ScramblingID0_Optional(_buffer, _size, _lidx, &p->pi2BPSK_ScramblingID0);
	_serNrSysDecUint16_t_SQN_NR_DMRS_UplinkTransformPrecoding_r16_pi2BPSK_ScramblingID1_Optional(_buffer, _size, _lidx, &p->pi2BPSK_ScramblingID1);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SetupRelease_DMRS_UplinkConfig_transformPrecodingEnabled_dmrs_UplinkTransformPrecoding_r16_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union SQN_NR_SetupRelease_DMRS_UplinkConfig_transformPrecodingEnabled_dmrs_UplinkTransformPrecoding_r16_Value* p, enum SQN_NR_SetupRelease_DMRS_UplinkConfig_transformPrecodingEnabled_dmrs_UplinkTransformPrecoding_r16_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SetupRelease_DMRS_UplinkConfig_transformPrecodingEnabled_dmrs_UplinkTransformPrecoding_r16_release) {
		NTOH_8(p->release, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SetupRelease_DMRS_UplinkConfig_transformPrecodingEnabled_dmrs_UplinkTransformPrecoding_r16_setup) {
		_serNrSysDecSQN_NR_DMRS_UplinkTransformPrecoding_r16(_buffer, _size, _lidx, &p->setup);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecSQN_NR_SetupRelease_DMRS_UplinkConfig_transformPrecodingEnabled_dmrs_UplinkTransformPrecoding_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SetupRelease_DMRS_UplinkConfig_transformPrecodingEnabled_dmrs_UplinkTransformPrecoding_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SQN_NR_SetupRelease_DMRS_UplinkConfig_transformPrecodingEnabled_dmrs_UplinkTransformPrecoding_r16_Sel)_tmp;
	}
	_serNrSysDecSQN_NR_SetupRelease_DMRS_UplinkConfig_transformPrecodingEnabled_dmrs_UplinkTransformPrecoding_r16_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SetupRelease_DMRS_UplinkConfig_transformPrecodingEnabled_dmrs_UplinkTransformPrecoding_r16_SQN_NR_DMRS_UplinkConfig_transformPrecodingEnabled_dmrs_UplinkTransformPrecoding_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SetupRelease_DMRS_UplinkConfig_transformPrecodingEnabled_dmrs_UplinkTransformPrecoding_r16_SQN_NR_DMRS_UplinkConfig_transformPrecodingEnabled_dmrs_UplinkTransformPrecoding_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_SetupRelease_DMRS_UplinkConfig_transformPrecodingEnabled_dmrs_UplinkTransformPrecoding_r16(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_DMRS_UplinkConfig_transformPrecodingEnabled(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_DMRS_UplinkConfig_transformPrecodingEnabled* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecUint16_t_SQN_NR_DMRS_UplinkConfig_transformPrecodingEnabled_nPUSCH_Identity_Optional(_buffer, _size, _lidx, &p->nPUSCH_Identity);
	_serNrSysDecSQN_NR_DMRS_UplinkConfig_transformPrecodingEnabled_sequenceGroupHopping_e_sequenceGroupHopping_Optional(_buffer, _size, _lidx, &p->sequenceGroupHopping);
	_serNrSysDecSQN_NR_DMRS_UplinkConfig_transformPrecodingEnabled_sequenceHopping_e_sequenceHopping_Optional(_buffer, _size, _lidx, &p->sequenceHopping);
	_serNrSysDecSQN_NR_SetupRelease_DMRS_UplinkConfig_transformPrecodingEnabled_dmrs_UplinkTransformPrecoding_r16_SQN_NR_DMRS_UplinkConfig_transformPrecodingEnabled_dmrs_UplinkTransformPrecoding_r16_Optional(_buffer, _size, _lidx, &p->dmrs_UplinkTransformPrecoding_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_DMRS_UplinkConfig_transformPrecodingEnabled_transformPrecodingEnabled_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_DMRS_UplinkConfig_transformPrecodingEnabled_transformPrecodingEnabled_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_DMRS_UplinkConfig_transformPrecodingEnabled(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_DMRS_UplinkConfig(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_DMRS_UplinkConfig* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecSQN_NR_DMRS_UplinkConfig_dmrs_Type_e_dmrs_Type_Optional(_buffer, _size, _lidx, &p->dmrs_Type);
	_serNrSysDecSQN_NR_DMRS_UplinkConfig_dmrs_AdditionalPosition_e_dmrs_AdditionalPosition_Optional(_buffer, _size, _lidx, &p->dmrs_AdditionalPosition);
	_serNrSysDecSQN_NR_SetupRelease_DMRS_UplinkConfig_phaseTrackingRS_SQN_NR_DMRS_UplinkConfig_phaseTrackingRS_Optional(_buffer, _size, _lidx, &p->phaseTrackingRS);
	_serNrSysDecSQN_NR_DMRS_UplinkConfig_maxLength_e_maxLength_Optional(_buffer, _size, _lidx, &p->maxLength);
	_serNrSysDecSQN_NR_DMRS_UplinkConfig_transformPrecodingDisabled_transformPrecodingDisabled_Optional(_buffer, _size, _lidx, &p->transformPrecodingDisabled);
	_serNrSysDecSQN_NR_DMRS_UplinkConfig_transformPrecodingEnabled_transformPrecodingEnabled_Optional(_buffer, _size, _lidx, &p->transformPrecodingEnabled);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SetupRelease_PUSCH_Config_dmrs_UplinkForPUSCH_MappingTypeA_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union SQN_NR_SetupRelease_PUSCH_Config_dmrs_UplinkForPUSCH_MappingTypeA_Value* p, enum SQN_NR_SetupRelease_PUSCH_Config_dmrs_UplinkForPUSCH_MappingTypeA_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SetupRelease_PUSCH_Config_dmrs_UplinkForPUSCH_MappingTypeA_release) {
		NTOH_8(p->release, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SetupRelease_PUSCH_Config_dmrs_UplinkForPUSCH_MappingTypeA_setup) {
		_serNrSysDecSQN_NR_DMRS_UplinkConfig(_buffer, _size, _lidx, &p->setup);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecSQN_NR_SetupRelease_PUSCH_Config_dmrs_UplinkForPUSCH_MappingTypeA(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SetupRelease_PUSCH_Config_dmrs_UplinkForPUSCH_MappingTypeA* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SQN_NR_SetupRelease_PUSCH_Config_dmrs_UplinkForPUSCH_MappingTypeA_Sel)_tmp;
	}
	_serNrSysDecSQN_NR_SetupRelease_PUSCH_Config_dmrs_UplinkForPUSCH_MappingTypeA_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SetupRelease_PUSCH_Config_dmrs_UplinkForPUSCH_MappingTypeA_SQN_NR_PUSCH_Config_dmrs_UplinkForPUSCH_MappingTypeA_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SetupRelease_PUSCH_Config_dmrs_UplinkForPUSCH_MappingTypeA_SQN_NR_PUSCH_Config_dmrs_UplinkForPUSCH_MappingTypeA_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_SetupRelease_PUSCH_Config_dmrs_UplinkForPUSCH_MappingTypeA(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SetupRelease_PUSCH_Config_dmrs_UplinkForPUSCH_MappingTypeB_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union SQN_NR_SetupRelease_PUSCH_Config_dmrs_UplinkForPUSCH_MappingTypeB_Value* p, enum SQN_NR_SetupRelease_PUSCH_Config_dmrs_UplinkForPUSCH_MappingTypeB_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SetupRelease_PUSCH_Config_dmrs_UplinkForPUSCH_MappingTypeB_release) {
		NTOH_8(p->release, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SetupRelease_PUSCH_Config_dmrs_UplinkForPUSCH_MappingTypeB_setup) {
		_serNrSysDecSQN_NR_DMRS_UplinkConfig(_buffer, _size, _lidx, &p->setup);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecSQN_NR_SetupRelease_PUSCH_Config_dmrs_UplinkForPUSCH_MappingTypeB(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SetupRelease_PUSCH_Config_dmrs_UplinkForPUSCH_MappingTypeB* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SQN_NR_SetupRelease_PUSCH_Config_dmrs_UplinkForPUSCH_MappingTypeB_Sel)_tmp;
	}
	_serNrSysDecSQN_NR_SetupRelease_PUSCH_Config_dmrs_UplinkForPUSCH_MappingTypeB_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SetupRelease_PUSCH_Config_dmrs_UplinkForPUSCH_MappingTypeB_SQN_NR_PUSCH_Config_dmrs_UplinkForPUSCH_MappingTypeB_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SetupRelease_PUSCH_Config_dmrs_UplinkForPUSCH_MappingTypeB_SQN_NR_PUSCH_Config_dmrs_UplinkForPUSCH_MappingTypeB_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_SetupRelease_PUSCH_Config_dmrs_UplinkForPUSCH_MappingTypeB(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PUSCH_PowerControl_tpc_Accumulation_e_tpc_Accumulation_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_PUSCH_PowerControl_tpc_Accumulation_e_tpc_Accumulation_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_PUSCH_PowerControl_tpc_Accumulation_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_Alpha_e_SQN_NR_PUSCH_PowerControl_msg3_Alpha_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_Alpha_e_SQN_NR_PUSCH_PowerControl_msg3_Alpha_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_Alpha_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecInt16_t_SQN_NR_PUSCH_PowerControl_p0_NominalWithoutGrant_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct int16_t_SQN_NR_PUSCH_PowerControl_p0_NominalWithoutGrant_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_16(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecInt8_t_SQN_NR_P0_PUSCH_AlphaSet_p0_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct int8_t_SQN_NR_P0_PUSCH_AlphaSet_p0_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_Alpha_e_SQN_NR_P0_PUSCH_AlphaSet_alpha_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_Alpha_e_SQN_NR_P0_PUSCH_AlphaSet_alpha_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_Alpha_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_P0_PUSCH_AlphaSet(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_P0_PUSCH_AlphaSet* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->p0_PUSCH_AlphaSetId, &_buffer[*_lidx], _lidx);
	_serNrSysDecInt8_t_SQN_NR_P0_PUSCH_AlphaSet_p0_Optional(_buffer, _size, _lidx, &p->p0);
	_serNrSysDecSQN_NR_Alpha_e_SQN_NR_P0_PUSCH_AlphaSet_alpha_Optional(_buffer, _size, _lidx, &p->alpha);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_P0_PUSCH_AlphaSet_SQN_NR_PUSCH_PowerControl_p0_AlphaSets_DynamicOptional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_P0_PUSCH_AlphaSet_SQN_NR_PUSCH_PowerControl_p0_AlphaSets_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = (struct SQN_NR_P0_PUSCH_AlphaSet*)serMalloc(_mem, p->v.d * sizeof(struct SQN_NR_P0_PUSCH_AlphaSet));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serNrSysDecSQN_NR_P0_PUSCH_AlphaSet(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PUSCH_PathlossReferenceRS_referenceSignal_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union SQN_NR_PUSCH_PathlossReferenceRS_referenceSignal_Value* p, enum SQN_NR_PUSCH_PathlossReferenceRS_referenceSignal_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_PUSCH_PathlossReferenceRS_referenceSignal_ssb_Index) {
		NTOH_8(p->ssb_Index, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_PUSCH_PathlossReferenceRS_referenceSignal_csi_RS_Index) {
		NTOH_8(p->csi_RS_Index, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecSQN_NR_PUSCH_PathlossReferenceRS_referenceSignal(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_PUSCH_PathlossReferenceRS_referenceSignal* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SQN_NR_PUSCH_PathlossReferenceRS_referenceSignal_Sel)_tmp;
	}
	_serNrSysDecSQN_NR_PUSCH_PathlossReferenceRS_referenceSignal_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PUSCH_PathlossReferenceRS(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_PUSCH_PathlossReferenceRS* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->pusch_PathlossReferenceRS_Id, &_buffer[*_lidx], _lidx);
	_serNrSysDecSQN_NR_PUSCH_PathlossReferenceRS_referenceSignal(_buffer, _size, _lidx, &p->referenceSignal);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PUSCH_PathlossReferenceRS_SQN_NR_PUSCH_PowerControl_pathlossReferenceRSToAddModList_DynamicOptional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_PUSCH_PathlossReferenceRS_SQN_NR_PUSCH_PowerControl_pathlossReferenceRSToAddModList_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = (struct SQN_NR_PUSCH_PathlossReferenceRS*)serMalloc(_mem, p->v.d * sizeof(struct SQN_NR_PUSCH_PathlossReferenceRS));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serNrSysDecSQN_NR_PUSCH_PathlossReferenceRS(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PUSCH_PathlossReferenceRS_Id_SQN_NR_PUSCH_PowerControl_pathlossReferenceRSToReleaseList_DynamicOptional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_PUSCH_PathlossReferenceRS_Id_SQN_NR_PUSCH_PowerControl_pathlossReferenceRSToReleaseList_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = (SQN_NR_PUSCH_PathlossReferenceRS_Id*)serMalloc(_mem, p->v.d * sizeof(SQN_NR_PUSCH_PathlossReferenceRS_Id));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		NTOH_8(p->v.v[i2], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PUSCH_PowerControl_twoPUSCH_PC_AdjustmentStates_e_twoPUSCH_PC_AdjustmentStates_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_PUSCH_PowerControl_twoPUSCH_PC_AdjustmentStates_e_twoPUSCH_PC_AdjustmentStates_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_PUSCH_PowerControl_twoPUSCH_PC_AdjustmentStates_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PUSCH_PowerControl_deltaMCS_e_deltaMCS_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_PUSCH_PowerControl_deltaMCS_e_deltaMCS_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_PUSCH_PowerControl_deltaMCS_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SRI_PUSCH_PowerControl(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SRI_PUSCH_PowerControl* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->sri_PUSCH_PowerControlId, &_buffer[*_lidx], _lidx);
	NTOH_8(p->sri_PUSCH_PathlossReferenceRS_Id, &_buffer[*_lidx], _lidx);
	NTOH_8(p->sri_P0_PUSCH_AlphaSetId, &_buffer[*_lidx], _lidx);
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->sri_PUSCH_ClosedLoopIndex = (SQN_NR_SRI_PUSCH_PowerControl_sri_PUSCH_ClosedLoopIndex_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SRI_PUSCH_PowerControl_SQN_NR_PUSCH_PowerControl_sri_PUSCH_MappingToAddModList_DynamicOptional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_SRI_PUSCH_PowerControl_SQN_NR_PUSCH_PowerControl_sri_PUSCH_MappingToAddModList_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = (struct SQN_NR_SRI_PUSCH_PowerControl*)serMalloc(_mem, p->v.d * sizeof(struct SQN_NR_SRI_PUSCH_PowerControl));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serNrSysDecSQN_NR_SRI_PUSCH_PowerControl(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SRI_PUSCH_PowerControlId_SQN_NR_PUSCH_PowerControl_sri_PUSCH_MappingToReleaseList_DynamicOptional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_SRI_PUSCH_PowerControlId_SQN_NR_PUSCH_PowerControl_sri_PUSCH_MappingToReleaseList_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = (SQN_NR_SRI_PUSCH_PowerControlId*)serMalloc(_mem, p->v.d * sizeof(SQN_NR_SRI_PUSCH_PowerControlId));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		NTOH_8(p->v.v[i2], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PUSCH_PowerControl(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_PUSCH_PowerControl* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecSQN_NR_PUSCH_PowerControl_tpc_Accumulation_e_tpc_Accumulation_Optional(_buffer, _size, _lidx, &p->tpc_Accumulation);
	_serNrSysDecSQN_NR_Alpha_e_SQN_NR_PUSCH_PowerControl_msg3_Alpha_Optional(_buffer, _size, _lidx, &p->msg3_Alpha);
	_serNrSysDecInt16_t_SQN_NR_PUSCH_PowerControl_p0_NominalWithoutGrant_Optional(_buffer, _size, _lidx, &p->p0_NominalWithoutGrant);
	_serNrSysDecSQN_NR_P0_PUSCH_AlphaSet_SQN_NR_PUSCH_PowerControl_p0_AlphaSets_DynamicOptional(_buffer, _size, _lidx, _mem, &p->p0_AlphaSets);
	_serNrSysDecSQN_NR_PUSCH_PathlossReferenceRS_SQN_NR_PUSCH_PowerControl_pathlossReferenceRSToAddModList_DynamicOptional(_buffer, _size, _lidx, _mem, &p->pathlossReferenceRSToAddModList);
	_serNrSysDecSQN_NR_PUSCH_PathlossReferenceRS_Id_SQN_NR_PUSCH_PowerControl_pathlossReferenceRSToReleaseList_DynamicOptional(_buffer, _size, _lidx, _mem, &p->pathlossReferenceRSToReleaseList);
	_serNrSysDecSQN_NR_PUSCH_PowerControl_twoPUSCH_PC_AdjustmentStates_e_twoPUSCH_PC_AdjustmentStates_Optional(_buffer, _size, _lidx, &p->twoPUSCH_PC_AdjustmentStates);
	_serNrSysDecSQN_NR_PUSCH_PowerControl_deltaMCS_e_deltaMCS_Optional(_buffer, _size, _lidx, &p->deltaMCS);
	_serNrSysDecSQN_NR_SRI_PUSCH_PowerControl_SQN_NR_PUSCH_PowerControl_sri_PUSCH_MappingToAddModList_DynamicOptional(_buffer, _size, _lidx, _mem, &p->sri_PUSCH_MappingToAddModList);
	_serNrSysDecSQN_NR_SRI_PUSCH_PowerControlId_SQN_NR_PUSCH_PowerControl_sri_PUSCH_MappingToReleaseList_DynamicOptional(_buffer, _size, _lidx, _mem, &p->sri_PUSCH_MappingToReleaseList);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PUSCH_PowerControl_SQN_NR_PUSCH_Config_pusch_PowerControl_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_PUSCH_PowerControl_SQN_NR_PUSCH_Config_pusch_PowerControl_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_PUSCH_PowerControl(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PUSCH_Config_frequencyHopping_e_frequencyHopping_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_PUSCH_Config_frequencyHopping_e_frequencyHopping_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_PUSCH_Config_frequencyHopping_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecUint16_t_SQN_NR_PUSCH_Config_frequencyHoppingOffsetLists_DynamicOptional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct uint16_t_SQN_NR_PUSCH_Config_frequencyHoppingOffsetLists_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = (uint16_t*)serMalloc(_mem, p->v.d * sizeof(uint16_t));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		NTOH_16(p->v.v[i2], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SetupRelease_PUSCH_Config_pusch_TimeDomainAllocationList_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union SQN_NR_SetupRelease_PUSCH_Config_pusch_TimeDomainAllocationList_Value* p, enum SQN_NR_SetupRelease_PUSCH_Config_pusch_TimeDomainAllocationList_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SetupRelease_PUSCH_Config_pusch_TimeDomainAllocationList_release) {
		NTOH_8(p->release, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SetupRelease_PUSCH_Config_pusch_TimeDomainAllocationList_setup) {
		NTOH_32(p->setup.d, &_buffer[*_lidx], _lidx);
		p->setup.v = (struct SQN_NR_PUSCH_TimeDomainResourceAllocation*)serMalloc(_mem, p->setup.d * sizeof(struct SQN_NR_PUSCH_TimeDomainResourceAllocation));
		for (size_t i2 = 0; i2 < p->setup.d; i2++) {
			_serNrSysDecSQN_NR_PUSCH_TimeDomainResourceAllocation(_buffer, _size, _lidx, &p->setup.v[i2]);
		}
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecSQN_NR_SetupRelease_PUSCH_Config_pusch_TimeDomainAllocationList(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_SetupRelease_PUSCH_Config_pusch_TimeDomainAllocationList* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SQN_NR_SetupRelease_PUSCH_Config_pusch_TimeDomainAllocationList_Sel)_tmp;
	}
	_serNrSysDecSQN_NR_SetupRelease_PUSCH_Config_pusch_TimeDomainAllocationList_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SetupRelease_PUSCH_Config_pusch_TimeDomainAllocationList_SQN_NR_PUSCH_Config_pusch_TimeDomainAllocationList_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_SetupRelease_PUSCH_Config_pusch_TimeDomainAllocationList_SQN_NR_PUSCH_Config_pusch_TimeDomainAllocationList_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_SetupRelease_PUSCH_Config_pusch_TimeDomainAllocationList(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PUSCH_Config_pusch_AggregationFactor_e_pusch_AggregationFactor_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_PUSCH_Config_pusch_AggregationFactor_e_pusch_AggregationFactor_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_PUSCH_Config_pusch_AggregationFactor_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PUSCH_Config_mcs_Table_e_mcs_Table_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_PUSCH_Config_mcs_Table_e_mcs_Table_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_PUSCH_Config_mcs_Table_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PUSCH_Config_mcs_TableTransformPrecoder_e_mcs_TableTransformPrecoder_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_PUSCH_Config_mcs_TableTransformPrecoder_e_mcs_TableTransformPrecoder_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_PUSCH_Config_mcs_TableTransformPrecoder_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PUSCH_Config_transformPrecoder_e_transformPrecoder_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_PUSCH_Config_transformPrecoder_e_transformPrecoder_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_PUSCH_Config_transformPrecoder_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PUSCH_Config_codebookSubset_e_codebookSubset_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_PUSCH_Config_codebookSubset_e_codebookSubset_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_PUSCH_Config_codebookSubset_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecUint8_t_SQN_NR_PUSCH_Config_maxRank_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct uint8_t_SQN_NR_PUSCH_Config_maxRank_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PUSCH_Config_rbg_Size_e_rbg_Size_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_PUSCH_Config_rbg_Size_e_rbg_Size_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_PUSCH_Config_rbg_Size_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecUint8_t_SQN_NR_BetaOffsets_betaOffsetACK_Index1_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct uint8_t_SQN_NR_BetaOffsets_betaOffsetACK_Index1_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecUint8_t_SQN_NR_BetaOffsets_betaOffsetACK_Index2_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct uint8_t_SQN_NR_BetaOffsets_betaOffsetACK_Index2_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecUint8_t_SQN_NR_BetaOffsets_betaOffsetACK_Index3_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct uint8_t_SQN_NR_BetaOffsets_betaOffsetACK_Index3_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecUint8_t_SQN_NR_BetaOffsets_betaOffsetCSI_Part1_Index1_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct uint8_t_SQN_NR_BetaOffsets_betaOffsetCSI_Part1_Index1_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecUint8_t_SQN_NR_BetaOffsets_betaOffsetCSI_Part1_Index2_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct uint8_t_SQN_NR_BetaOffsets_betaOffsetCSI_Part1_Index2_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecUint8_t_SQN_NR_BetaOffsets_betaOffsetCSI_Part2_Index1_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct uint8_t_SQN_NR_BetaOffsets_betaOffsetCSI_Part2_Index1_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecUint8_t_SQN_NR_BetaOffsets_betaOffsetCSI_Part2_Index2_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct uint8_t_SQN_NR_BetaOffsets_betaOffsetCSI_Part2_Index2_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_BetaOffsets(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_BetaOffsets* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecUint8_t_SQN_NR_BetaOffsets_betaOffsetACK_Index1_Optional(_buffer, _size, _lidx, &p->betaOffsetACK_Index1);
	_serNrSysDecUint8_t_SQN_NR_BetaOffsets_betaOffsetACK_Index2_Optional(_buffer, _size, _lidx, &p->betaOffsetACK_Index2);
	_serNrSysDecUint8_t_SQN_NR_BetaOffsets_betaOffsetACK_Index3_Optional(_buffer, _size, _lidx, &p->betaOffsetACK_Index3);
	_serNrSysDecUint8_t_SQN_NR_BetaOffsets_betaOffsetCSI_Part1_Index1_Optional(_buffer, _size, _lidx, &p->betaOffsetCSI_Part1_Index1);
	_serNrSysDecUint8_t_SQN_NR_BetaOffsets_betaOffsetCSI_Part1_Index2_Optional(_buffer, _size, _lidx, &p->betaOffsetCSI_Part1_Index2);
	_serNrSysDecUint8_t_SQN_NR_BetaOffsets_betaOffsetCSI_Part2_Index1_Optional(_buffer, _size, _lidx, &p->betaOffsetCSI_Part2_Index1);
	_serNrSysDecUint8_t_SQN_NR_BetaOffsets_betaOffsetCSI_Part2_Index2_Optional(_buffer, _size, _lidx, &p->betaOffsetCSI_Part2_Index2);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_UCI_OnPUSCH_betaOffsets_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union SQN_NR_UCI_OnPUSCH_betaOffsets_Value* p, enum SQN_NR_UCI_OnPUSCH_betaOffsets_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_UCI_OnPUSCH_betaOffsets_dynamic) {
		for (size_t i2 = 0; i2 < 4; i2++) {
			_serNrSysDecSQN_NR_BetaOffsets(_buffer, _size, _lidx, &p->dynamic[i2]);
		}
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_UCI_OnPUSCH_betaOffsets_semiStatic) {
		_serNrSysDecSQN_NR_BetaOffsets(_buffer, _size, _lidx, &p->semiStatic);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecSQN_NR_UCI_OnPUSCH_betaOffsets(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_UCI_OnPUSCH_betaOffsets* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SQN_NR_UCI_OnPUSCH_betaOffsets_Sel)_tmp;
	}
	_serNrSysDecSQN_NR_UCI_OnPUSCH_betaOffsets_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_UCI_OnPUSCH_betaOffsets_betaOffsets_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_UCI_OnPUSCH_betaOffsets_betaOffsets_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_UCI_OnPUSCH_betaOffsets(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_UCI_OnPUSCH(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_UCI_OnPUSCH* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecSQN_NR_UCI_OnPUSCH_betaOffsets_betaOffsets_Optional(_buffer, _size, _lidx, &p->betaOffsets);
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->scaling = (SQN_NR_UCI_OnPUSCH_scaling_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SetupRelease_PUSCH_Config_uci_OnPUSCH_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union SQN_NR_SetupRelease_PUSCH_Config_uci_OnPUSCH_Value* p, enum SQN_NR_SetupRelease_PUSCH_Config_uci_OnPUSCH_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SetupRelease_PUSCH_Config_uci_OnPUSCH_release) {
		NTOH_8(p->release, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SetupRelease_PUSCH_Config_uci_OnPUSCH_setup) {
		_serNrSysDecSQN_NR_UCI_OnPUSCH(_buffer, _size, _lidx, &p->setup);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecSQN_NR_SetupRelease_PUSCH_Config_uci_OnPUSCH(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SetupRelease_PUSCH_Config_uci_OnPUSCH* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SQN_NR_SetupRelease_PUSCH_Config_uci_OnPUSCH_Sel)_tmp;
	}
	_serNrSysDecSQN_NR_SetupRelease_PUSCH_Config_uci_OnPUSCH_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SetupRelease_PUSCH_Config_uci_OnPUSCH_SQN_NR_PUSCH_Config_uci_OnPUSCH_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SetupRelease_PUSCH_Config_uci_OnPUSCH_SQN_NR_PUSCH_Config_uci_OnPUSCH_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_SetupRelease_PUSCH_Config_uci_OnPUSCH(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PUSCH_Config_tp_pi2BPSK_e_tp_pi2BPSK_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_PUSCH_Config_tp_pi2BPSK_e_tp_pi2BPSK_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_PUSCH_Config_tp_pi2BPSK_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SetupRelease_PUSCH_Config_minimumSchedulingOffsetK2_r16_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union SQN_NR_SetupRelease_PUSCH_Config_minimumSchedulingOffsetK2_r16_Value* p, enum SQN_NR_SetupRelease_PUSCH_Config_minimumSchedulingOffsetK2_r16_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SetupRelease_PUSCH_Config_minimumSchedulingOffsetK2_r16_release) {
		NTOH_8(p->release, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SetupRelease_PUSCH_Config_minimumSchedulingOffsetK2_r16_setup) {
		NTOH_32(p->setup.d, &_buffer[*_lidx], _lidx);
		p->setup.v = (uint8_t*)serMalloc(_mem, p->setup.d * sizeof(uint8_t));
		for (size_t i2 = 0; i2 < p->setup.d; i2++) {
			NTOH_8(p->setup.v[i2], &_buffer[*_lidx], _lidx);
		}
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecSQN_NR_SetupRelease_PUSCH_Config_minimumSchedulingOffsetK2_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_SetupRelease_PUSCH_Config_minimumSchedulingOffsetK2_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SQN_NR_SetupRelease_PUSCH_Config_minimumSchedulingOffsetK2_r16_Sel)_tmp;
	}
	_serNrSysDecSQN_NR_SetupRelease_PUSCH_Config_minimumSchedulingOffsetK2_r16_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SetupRelease_PUSCH_Config_minimumSchedulingOffsetK2_r16_SQN_NR_PUSCH_Config_minimumSchedulingOffsetK2_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_SetupRelease_PUSCH_Config_minimumSchedulingOffsetK2_r16_SQN_NR_PUSCH_Config_minimumSchedulingOffsetK2_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_SetupRelease_PUSCH_Config_minimumSchedulingOffsetK2_r16(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SetupRelease_PUSCH_Config_ul_AccessConfigListDCI_0_1_r16_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union SQN_NR_SetupRelease_PUSCH_Config_ul_AccessConfigListDCI_0_1_r16_Value* p, enum SQN_NR_SetupRelease_PUSCH_Config_ul_AccessConfigListDCI_0_1_r16_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SetupRelease_PUSCH_Config_ul_AccessConfigListDCI_0_1_r16_release) {
		NTOH_8(p->release, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SetupRelease_PUSCH_Config_ul_AccessConfigListDCI_0_1_r16_setup) {
		NTOH_32(p->setup.d, &_buffer[*_lidx], _lidx);
		p->setup.v = (uint8_t*)serMalloc(_mem, p->setup.d * sizeof(uint8_t));
		for (size_t i2 = 0; i2 < p->setup.d; i2++) {
			NTOH_8(p->setup.v[i2], &_buffer[*_lidx], _lidx);
		}
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecSQN_NR_SetupRelease_PUSCH_Config_ul_AccessConfigListDCI_0_1_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_SetupRelease_PUSCH_Config_ul_AccessConfigListDCI_0_1_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SQN_NR_SetupRelease_PUSCH_Config_ul_AccessConfigListDCI_0_1_r16_Sel)_tmp;
	}
	_serNrSysDecSQN_NR_SetupRelease_PUSCH_Config_ul_AccessConfigListDCI_0_1_r16_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SetupRelease_PUSCH_Config_ul_AccessConfigListDCI_0_1_r16_SQN_NR_PUSCH_Config_ul_AccessConfigListDCI_0_1_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_SetupRelease_PUSCH_Config_ul_AccessConfigListDCI_0_1_r16_SQN_NR_PUSCH_Config_ul_AccessConfigListDCI_0_1_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_SetupRelease_PUSCH_Config_ul_AccessConfigListDCI_0_1_r16(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecUint8_t_SQN_NR_PUSCH_Config_harq_ProcessNumberSizeDCI_0_2_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct uint8_t_SQN_NR_PUSCH_Config_harq_ProcessNumberSizeDCI_0_2_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PUSCH_Config_dmrs_SequenceInitializationDCI_0_2_r16_e_dmrs_SequenceInitializationDCI_0_2_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_PUSCH_Config_dmrs_SequenceInitializationDCI_0_2_r16_e_dmrs_SequenceInitializationDCI_0_2_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_PUSCH_Config_dmrs_SequenceInitializationDCI_0_2_r16_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecUint8_t_SQN_NR_PUSCH_Config_numberOfBitsForRV_DCI_0_2_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct uint8_t_SQN_NR_PUSCH_Config_numberOfBitsForRV_DCI_0_2_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PUSCH_Config_antennaPortsFieldPresenceDCI_0_2_r16_e_antennaPortsFieldPresenceDCI_0_2_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_PUSCH_Config_antennaPortsFieldPresenceDCI_0_2_r16_e_antennaPortsFieldPresenceDCI_0_2_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_PUSCH_Config_antennaPortsFieldPresenceDCI_0_2_r16_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SetupRelease_PUSCH_Config_dmrs_UplinkForPUSCH_MappingTypeA_DCI_0_2_r16_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union SQN_NR_SetupRelease_PUSCH_Config_dmrs_UplinkForPUSCH_MappingTypeA_DCI_0_2_r16_Value* p, enum SQN_NR_SetupRelease_PUSCH_Config_dmrs_UplinkForPUSCH_MappingTypeA_DCI_0_2_r16_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SetupRelease_PUSCH_Config_dmrs_UplinkForPUSCH_MappingTypeA_DCI_0_2_r16_release) {
		NTOH_8(p->release, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SetupRelease_PUSCH_Config_dmrs_UplinkForPUSCH_MappingTypeA_DCI_0_2_r16_setup) {
		_serNrSysDecSQN_NR_DMRS_UplinkConfig(_buffer, _size, _lidx, &p->setup);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecSQN_NR_SetupRelease_PUSCH_Config_dmrs_UplinkForPUSCH_MappingTypeA_DCI_0_2_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SetupRelease_PUSCH_Config_dmrs_UplinkForPUSCH_MappingTypeA_DCI_0_2_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SQN_NR_SetupRelease_PUSCH_Config_dmrs_UplinkForPUSCH_MappingTypeA_DCI_0_2_r16_Sel)_tmp;
	}
	_serNrSysDecSQN_NR_SetupRelease_PUSCH_Config_dmrs_UplinkForPUSCH_MappingTypeA_DCI_0_2_r16_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SetupRelease_PUSCH_Config_dmrs_UplinkForPUSCH_MappingTypeA_DCI_0_2_r16_SQN_NR_PUSCH_Config_dmrs_UplinkForPUSCH_MappingTypeA_DCI_0_2_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SetupRelease_PUSCH_Config_dmrs_UplinkForPUSCH_MappingTypeA_DCI_0_2_r16_SQN_NR_PUSCH_Config_dmrs_UplinkForPUSCH_MappingTypeA_DCI_0_2_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_SetupRelease_PUSCH_Config_dmrs_UplinkForPUSCH_MappingTypeA_DCI_0_2_r16(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SetupRelease_PUSCH_Config_dmrs_UplinkForPUSCH_MappingTypeB_DCI_0_2_r16_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union SQN_NR_SetupRelease_PUSCH_Config_dmrs_UplinkForPUSCH_MappingTypeB_DCI_0_2_r16_Value* p, enum SQN_NR_SetupRelease_PUSCH_Config_dmrs_UplinkForPUSCH_MappingTypeB_DCI_0_2_r16_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SetupRelease_PUSCH_Config_dmrs_UplinkForPUSCH_MappingTypeB_DCI_0_2_r16_release) {
		NTOH_8(p->release, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SetupRelease_PUSCH_Config_dmrs_UplinkForPUSCH_MappingTypeB_DCI_0_2_r16_setup) {
		_serNrSysDecSQN_NR_DMRS_UplinkConfig(_buffer, _size, _lidx, &p->setup);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecSQN_NR_SetupRelease_PUSCH_Config_dmrs_UplinkForPUSCH_MappingTypeB_DCI_0_2_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SetupRelease_PUSCH_Config_dmrs_UplinkForPUSCH_MappingTypeB_DCI_0_2_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SQN_NR_SetupRelease_PUSCH_Config_dmrs_UplinkForPUSCH_MappingTypeB_DCI_0_2_r16_Sel)_tmp;
	}
	_serNrSysDecSQN_NR_SetupRelease_PUSCH_Config_dmrs_UplinkForPUSCH_MappingTypeB_DCI_0_2_r16_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SetupRelease_PUSCH_Config_dmrs_UplinkForPUSCH_MappingTypeB_DCI_0_2_r16_SQN_NR_PUSCH_Config_dmrs_UplinkForPUSCH_MappingTypeB_DCI_0_2_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SetupRelease_PUSCH_Config_dmrs_UplinkForPUSCH_MappingTypeB_DCI_0_2_r16_SQN_NR_PUSCH_Config_dmrs_UplinkForPUSCH_MappingTypeB_DCI_0_2_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_SetupRelease_PUSCH_Config_dmrs_UplinkForPUSCH_MappingTypeB_DCI_0_2_r16(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PUSCH_Config_frequencyHoppingDCI_0_2_r16_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union SQN_NR_PUSCH_Config_frequencyHoppingDCI_0_2_r16_Value* p, enum SQN_NR_PUSCH_Config_frequencyHoppingDCI_0_2_r16_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_PUSCH_Config_frequencyHoppingDCI_0_2_r16_pusch_RepTypeA) {
		{
			size_t _tmp;
			NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
			p->pusch_RepTypeA = (SQN_NR_PUSCH_Config_frequencyHoppingDCI_0_2_r16_pusch_RepTypeA_e)_tmp;
		}
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_PUSCH_Config_frequencyHoppingDCI_0_2_r16_pusch_RepTypeB) {
		{
			size_t _tmp;
			NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
			p->pusch_RepTypeB = (SQN_NR_PUSCH_Config_frequencyHoppingDCI_0_2_r16_pusch_RepTypeB_e)_tmp;
		}
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecSQN_NR_PUSCH_Config_frequencyHoppingDCI_0_2_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_PUSCH_Config_frequencyHoppingDCI_0_2_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SQN_NR_PUSCH_Config_frequencyHoppingDCI_0_2_r16_Sel)_tmp;
	}
	_serNrSysDecSQN_NR_PUSCH_Config_frequencyHoppingDCI_0_2_r16_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PUSCH_Config_frequencyHoppingDCI_0_2_r16_frequencyHoppingDCI_0_2_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_PUSCH_Config_frequencyHoppingDCI_0_2_r16_frequencyHoppingDCI_0_2_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_PUSCH_Config_frequencyHoppingDCI_0_2_r16(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SetupRelease_PUSCH_Config_frequencyHoppingOffsetListsDCI_0_2_r16_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union SQN_NR_SetupRelease_PUSCH_Config_frequencyHoppingOffsetListsDCI_0_2_r16_Value* p, enum SQN_NR_SetupRelease_PUSCH_Config_frequencyHoppingOffsetListsDCI_0_2_r16_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SetupRelease_PUSCH_Config_frequencyHoppingOffsetListsDCI_0_2_r16_release) {
		NTOH_8(p->release, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SetupRelease_PUSCH_Config_frequencyHoppingOffsetListsDCI_0_2_r16_setup) {
		NTOH_32(p->setup.d, &_buffer[*_lidx], _lidx);
		p->setup.v = (uint16_t*)serMalloc(_mem, p->setup.d * sizeof(uint16_t));
		for (size_t i2 = 0; i2 < p->setup.d; i2++) {
			NTOH_16(p->setup.v[i2], &_buffer[*_lidx], _lidx);
		}
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecSQN_NR_SetupRelease_PUSCH_Config_frequencyHoppingOffsetListsDCI_0_2_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_SetupRelease_PUSCH_Config_frequencyHoppingOffsetListsDCI_0_2_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SQN_NR_SetupRelease_PUSCH_Config_frequencyHoppingOffsetListsDCI_0_2_r16_Sel)_tmp;
	}
	_serNrSysDecSQN_NR_SetupRelease_PUSCH_Config_frequencyHoppingOffsetListsDCI_0_2_r16_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SetupRelease_PUSCH_Config_frequencyHoppingOffsetListsDCI_0_2_r16_SQN_NR_PUSCH_Config_frequencyHoppingOffsetListsDCI_0_2_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_SetupRelease_PUSCH_Config_frequencyHoppingOffsetListsDCI_0_2_r16_SQN_NR_PUSCH_Config_frequencyHoppingOffsetListsDCI_0_2_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_SetupRelease_PUSCH_Config_frequencyHoppingOffsetListsDCI_0_2_r16(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PUSCH_Config_codebookSubsetDCI_0_2_r16_e_codebookSubsetDCI_0_2_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_PUSCH_Config_codebookSubsetDCI_0_2_r16_e_codebookSubsetDCI_0_2_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_PUSCH_Config_codebookSubsetDCI_0_2_r16_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PUSCH_Config_invalidSymbolPatternIndicatorDCI_0_2_r16_e_invalidSymbolPatternIndicatorDCI_0_2_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_PUSCH_Config_invalidSymbolPatternIndicatorDCI_0_2_r16_e_invalidSymbolPatternIndicatorDCI_0_2_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_PUSCH_Config_invalidSymbolPatternIndicatorDCI_0_2_r16_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecUint8_t_SQN_NR_PUSCH_Config_maxRankDCI_0_2_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct uint8_t_SQN_NR_PUSCH_Config_maxRankDCI_0_2_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PUSCH_Config_mcs_TableDCI_0_2_r16_e_mcs_TableDCI_0_2_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_PUSCH_Config_mcs_TableDCI_0_2_r16_e_mcs_TableDCI_0_2_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_PUSCH_Config_mcs_TableDCI_0_2_r16_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PUSCH_Config_mcs_TableTransformPrecoderDCI_0_2_r16_e_mcs_TableTransformPrecoderDCI_0_2_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_PUSCH_Config_mcs_TableTransformPrecoderDCI_0_2_r16_e_mcs_TableTransformPrecoderDCI_0_2_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_PUSCH_Config_mcs_TableTransformPrecoderDCI_0_2_r16_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PUSCH_Config_priorityIndicatorDCI_0_2_r16_e_priorityIndicatorDCI_0_2_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_PUSCH_Config_priorityIndicatorDCI_0_2_r16_e_priorityIndicatorDCI_0_2_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_PUSCH_Config_priorityIndicatorDCI_0_2_r16_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PUSCH_Config_pusch_RepTypeIndicatorDCI_0_2_r16_e_pusch_RepTypeIndicatorDCI_0_2_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_PUSCH_Config_pusch_RepTypeIndicatorDCI_0_2_r16_e_pusch_RepTypeIndicatorDCI_0_2_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_PUSCH_Config_pusch_RepTypeIndicatorDCI_0_2_r16_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PUSCH_Config_resourceAllocationDCI_0_2_r16_e_resourceAllocationDCI_0_2_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_PUSCH_Config_resourceAllocationDCI_0_2_r16_e_resourceAllocationDCI_0_2_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_PUSCH_Config_resourceAllocationDCI_0_2_r16_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PUSCH_Config_resourceAllocationType1GranularityDCI_0_2_r16_e_resourceAllocationType1GranularityDCI_0_2_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_PUSCH_Config_resourceAllocationType1GranularityDCI_0_2_r16_e_resourceAllocationType1GranularityDCI_0_2_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_PUSCH_Config_resourceAllocationType1GranularityDCI_0_2_r16_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_UCI_OnPUSCH_DCI_0_2_r16_betaOffsetsDCI_0_2_r16_dynamicDCI_0_2_r16_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union SQN_NR_UCI_OnPUSCH_DCI_0_2_r16_betaOffsetsDCI_0_2_r16_dynamicDCI_0_2_r16_Value* p, enum SQN_NR_UCI_OnPUSCH_DCI_0_2_r16_betaOffsetsDCI_0_2_r16_dynamicDCI_0_2_r16_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_UCI_OnPUSCH_DCI_0_2_r16_betaOffsetsDCI_0_2_r16_dynamicDCI_0_2_r16_oneBit_r16) {
		for (size_t i3 = 0; i3 < 2; i3++) {
			_serNrSysDecSQN_NR_BetaOffsets(_buffer, _size, _lidx, &p->oneBit_r16[i3]);
		}
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_UCI_OnPUSCH_DCI_0_2_r16_betaOffsetsDCI_0_2_r16_dynamicDCI_0_2_r16_twoBits_r16) {
		for (size_t i3 = 0; i3 < 4; i3++) {
			_serNrSysDecSQN_NR_BetaOffsets(_buffer, _size, _lidx, &p->twoBits_r16[i3]);
		}
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecSQN_NR_UCI_OnPUSCH_DCI_0_2_r16_betaOffsetsDCI_0_2_r16_dynamicDCI_0_2_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_UCI_OnPUSCH_DCI_0_2_r16_betaOffsetsDCI_0_2_r16_dynamicDCI_0_2_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SQN_NR_UCI_OnPUSCH_DCI_0_2_r16_betaOffsetsDCI_0_2_r16_dynamicDCI_0_2_r16_Sel)_tmp;
	}
	_serNrSysDecSQN_NR_UCI_OnPUSCH_DCI_0_2_r16_betaOffsetsDCI_0_2_r16_dynamicDCI_0_2_r16_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_UCI_OnPUSCH_DCI_0_2_r16_betaOffsetsDCI_0_2_r16_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union SQN_NR_UCI_OnPUSCH_DCI_0_2_r16_betaOffsetsDCI_0_2_r16_Value* p, enum SQN_NR_UCI_OnPUSCH_DCI_0_2_r16_betaOffsetsDCI_0_2_r16_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_UCI_OnPUSCH_DCI_0_2_r16_betaOffsetsDCI_0_2_r16_dynamicDCI_0_2_r16) {
		_serNrSysDecSQN_NR_UCI_OnPUSCH_DCI_0_2_r16_betaOffsetsDCI_0_2_r16_dynamicDCI_0_2_r16(_buffer, _size, _lidx, &p->dynamicDCI_0_2_r16);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_UCI_OnPUSCH_DCI_0_2_r16_betaOffsetsDCI_0_2_r16_semiStaticDCI_0_2_r16) {
		_serNrSysDecSQN_NR_BetaOffsets(_buffer, _size, _lidx, &p->semiStaticDCI_0_2_r16);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecSQN_NR_UCI_OnPUSCH_DCI_0_2_r16_betaOffsetsDCI_0_2_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_UCI_OnPUSCH_DCI_0_2_r16_betaOffsetsDCI_0_2_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SQN_NR_UCI_OnPUSCH_DCI_0_2_r16_betaOffsetsDCI_0_2_r16_Sel)_tmp;
	}
	_serNrSysDecSQN_NR_UCI_OnPUSCH_DCI_0_2_r16_betaOffsetsDCI_0_2_r16_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_UCI_OnPUSCH_DCI_0_2_r16_betaOffsetsDCI_0_2_r16_betaOffsetsDCI_0_2_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_UCI_OnPUSCH_DCI_0_2_r16_betaOffsetsDCI_0_2_r16_betaOffsetsDCI_0_2_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_UCI_OnPUSCH_DCI_0_2_r16_betaOffsetsDCI_0_2_r16(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_UCI_OnPUSCH_DCI_0_2_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_UCI_OnPUSCH_DCI_0_2_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecSQN_NR_UCI_OnPUSCH_DCI_0_2_r16_betaOffsetsDCI_0_2_r16_betaOffsetsDCI_0_2_r16_Optional(_buffer, _size, _lidx, &p->betaOffsetsDCI_0_2_r16);
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->scalingDCI_0_2_r16 = (SQN_NR_UCI_OnPUSCH_DCI_0_2_r16_scalingDCI_0_2_r16_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SetupRelease_PUSCH_Config_uci_OnPUSCH_ListDCI_0_2_r16_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union SQN_NR_SetupRelease_PUSCH_Config_uci_OnPUSCH_ListDCI_0_2_r16_Value* p, enum SQN_NR_SetupRelease_PUSCH_Config_uci_OnPUSCH_ListDCI_0_2_r16_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SetupRelease_PUSCH_Config_uci_OnPUSCH_ListDCI_0_2_r16_release) {
		NTOH_8(p->release, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SetupRelease_PUSCH_Config_uci_OnPUSCH_ListDCI_0_2_r16_setup) {
		NTOH_32(p->setup.d, &_buffer[*_lidx], _lidx);
		p->setup.v = (struct SQN_NR_UCI_OnPUSCH_DCI_0_2_r16*)serMalloc(_mem, p->setup.d * sizeof(struct SQN_NR_UCI_OnPUSCH_DCI_0_2_r16));
		for (size_t i2 = 0; i2 < p->setup.d; i2++) {
			_serNrSysDecSQN_NR_UCI_OnPUSCH_DCI_0_2_r16(_buffer, _size, _lidx, &p->setup.v[i2]);
		}
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecSQN_NR_SetupRelease_PUSCH_Config_uci_OnPUSCH_ListDCI_0_2_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_SetupRelease_PUSCH_Config_uci_OnPUSCH_ListDCI_0_2_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SQN_NR_SetupRelease_PUSCH_Config_uci_OnPUSCH_ListDCI_0_2_r16_Sel)_tmp;
	}
	_serNrSysDecSQN_NR_SetupRelease_PUSCH_Config_uci_OnPUSCH_ListDCI_0_2_r16_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SetupRelease_PUSCH_Config_uci_OnPUSCH_ListDCI_0_2_r16_SQN_NR_PUSCH_Config_uci_OnPUSCH_ListDCI_0_2_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_SetupRelease_PUSCH_Config_uci_OnPUSCH_ListDCI_0_2_r16_SQN_NR_PUSCH_Config_uci_OnPUSCH_ListDCI_0_2_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_SetupRelease_PUSCH_Config_uci_OnPUSCH_ListDCI_0_2_r16(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecUint8_t_SQN_NR_PUSCH_TimeDomainResourceAllocation_r16_k2_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct uint8_t_SQN_NR_PUSCH_TimeDomainResourceAllocation_r16_k2_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PUSCH_Allocation_r16_mappingType_r16_e_mappingType_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_PUSCH_Allocation_r16_mappingType_r16_e_mappingType_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_PUSCH_Allocation_r16_mappingType_r16_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecUint8_t_SQN_NR_PUSCH_Allocation_r16_startSymbolAndLength_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct uint8_t_SQN_NR_PUSCH_Allocation_r16_startSymbolAndLength_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecUint8_t_SQN_NR_PUSCH_Allocation_r16_startSymbol_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct uint8_t_SQN_NR_PUSCH_Allocation_r16_startSymbol_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecUint8_t_SQN_NR_PUSCH_Allocation_r16_length_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct uint8_t_SQN_NR_PUSCH_Allocation_r16_length_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PUSCH_Allocation_r16_numberOfRepetitions_r16_e_numberOfRepetitions_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_PUSCH_Allocation_r16_numberOfRepetitions_r16_e_numberOfRepetitions_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_PUSCH_Allocation_r16_numberOfRepetitions_r16_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PUSCH_Allocation_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_PUSCH_Allocation_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecSQN_NR_PUSCH_Allocation_r16_mappingType_r16_e_mappingType_r16_Optional(_buffer, _size, _lidx, &p->mappingType_r16);
	_serNrSysDecUint8_t_SQN_NR_PUSCH_Allocation_r16_startSymbolAndLength_r16_Optional(_buffer, _size, _lidx, &p->startSymbolAndLength_r16);
	_serNrSysDecUint8_t_SQN_NR_PUSCH_Allocation_r16_startSymbol_r16_Optional(_buffer, _size, _lidx, &p->startSymbol_r16);
	_serNrSysDecUint8_t_SQN_NR_PUSCH_Allocation_r16_length_r16_Optional(_buffer, _size, _lidx, &p->length_r16);
	_serNrSysDecSQN_NR_PUSCH_Allocation_r16_numberOfRepetitions_r16_e_numberOfRepetitions_r16_Optional(_buffer, _size, _lidx, &p->numberOfRepetitions_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PUSCH_TimeDomainResourceAllocation_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_PUSCH_TimeDomainResourceAllocation_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecUint8_t_SQN_NR_PUSCH_TimeDomainResourceAllocation_r16_k2_r16_Optional(_buffer, _size, _lidx, &p->k2_r16);
	NTOH_32(p->puschAllocationList_r16.d, &_buffer[*_lidx], _lidx);
	p->puschAllocationList_r16.v = (struct SQN_NR_PUSCH_Allocation_r16*)serMalloc(_mem, p->puschAllocationList_r16.d * sizeof(struct SQN_NR_PUSCH_Allocation_r16));
	for (size_t i3 = 0; i3 < p->puschAllocationList_r16.d; i3++) {
		_serNrSysDecSQN_NR_PUSCH_Allocation_r16(_buffer, _size, _lidx, &p->puschAllocationList_r16.v[i3]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SetupRelease_PUSCH_Config_pusch_TimeDomainAllocationListDCI_0_2_r16_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union SQN_NR_SetupRelease_PUSCH_Config_pusch_TimeDomainAllocationListDCI_0_2_r16_Value* p, enum SQN_NR_SetupRelease_PUSCH_Config_pusch_TimeDomainAllocationListDCI_0_2_r16_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SetupRelease_PUSCH_Config_pusch_TimeDomainAllocationListDCI_0_2_r16_release) {
		NTOH_8(p->release, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SetupRelease_PUSCH_Config_pusch_TimeDomainAllocationListDCI_0_2_r16_setup) {
		NTOH_32(p->setup.d, &_buffer[*_lidx], _lidx);
		p->setup.v = (struct SQN_NR_PUSCH_TimeDomainResourceAllocation_r16*)serMalloc(_mem, p->setup.d * sizeof(struct SQN_NR_PUSCH_TimeDomainResourceAllocation_r16));
		for (size_t i2 = 0; i2 < p->setup.d; i2++) {
			_serNrSysDecSQN_NR_PUSCH_TimeDomainResourceAllocation_r16(_buffer, _size, _lidx, _mem, &p->setup.v[i2]);
		}
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecSQN_NR_SetupRelease_PUSCH_Config_pusch_TimeDomainAllocationListDCI_0_2_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_SetupRelease_PUSCH_Config_pusch_TimeDomainAllocationListDCI_0_2_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SQN_NR_SetupRelease_PUSCH_Config_pusch_TimeDomainAllocationListDCI_0_2_r16_Sel)_tmp;
	}
	_serNrSysDecSQN_NR_SetupRelease_PUSCH_Config_pusch_TimeDomainAllocationListDCI_0_2_r16_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SetupRelease_PUSCH_Config_pusch_TimeDomainAllocationListDCI_0_2_r16_SQN_NR_PUSCH_Config_pusch_TimeDomainAllocationListDCI_0_2_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_SetupRelease_PUSCH_Config_pusch_TimeDomainAllocationListDCI_0_2_r16_SQN_NR_PUSCH_Config_pusch_TimeDomainAllocationListDCI_0_2_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_SetupRelease_PUSCH_Config_pusch_TimeDomainAllocationListDCI_0_2_r16(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SetupRelease_PUSCH_Config_pusch_TimeDomainAllocationListDCI_0_1_r16_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union SQN_NR_SetupRelease_PUSCH_Config_pusch_TimeDomainAllocationListDCI_0_1_r16_Value* p, enum SQN_NR_SetupRelease_PUSCH_Config_pusch_TimeDomainAllocationListDCI_0_1_r16_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SetupRelease_PUSCH_Config_pusch_TimeDomainAllocationListDCI_0_1_r16_release) {
		NTOH_8(p->release, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SetupRelease_PUSCH_Config_pusch_TimeDomainAllocationListDCI_0_1_r16_setup) {
		NTOH_32(p->setup.d, &_buffer[*_lidx], _lidx);
		p->setup.v = (struct SQN_NR_PUSCH_TimeDomainResourceAllocation_r16*)serMalloc(_mem, p->setup.d * sizeof(struct SQN_NR_PUSCH_TimeDomainResourceAllocation_r16));
		for (size_t i2 = 0; i2 < p->setup.d; i2++) {
			_serNrSysDecSQN_NR_PUSCH_TimeDomainResourceAllocation_r16(_buffer, _size, _lidx, _mem, &p->setup.v[i2]);
		}
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecSQN_NR_SetupRelease_PUSCH_Config_pusch_TimeDomainAllocationListDCI_0_1_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_SetupRelease_PUSCH_Config_pusch_TimeDomainAllocationListDCI_0_1_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SQN_NR_SetupRelease_PUSCH_Config_pusch_TimeDomainAllocationListDCI_0_1_r16_Sel)_tmp;
	}
	_serNrSysDecSQN_NR_SetupRelease_PUSCH_Config_pusch_TimeDomainAllocationListDCI_0_1_r16_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SetupRelease_PUSCH_Config_pusch_TimeDomainAllocationListDCI_0_1_r16_SQN_NR_PUSCH_Config_pusch_TimeDomainAllocationListDCI_0_1_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_SetupRelease_PUSCH_Config_pusch_TimeDomainAllocationListDCI_0_1_r16_SQN_NR_PUSCH_Config_pusch_TimeDomainAllocationListDCI_0_1_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_SetupRelease_PUSCH_Config_pusch_TimeDomainAllocationListDCI_0_1_r16(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PUSCH_Config_invalidSymbolPatternIndicatorDCI_0_1_r16_e_invalidSymbolPatternIndicatorDCI_0_1_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_PUSCH_Config_invalidSymbolPatternIndicatorDCI_0_1_r16_e_invalidSymbolPatternIndicatorDCI_0_1_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_PUSCH_Config_invalidSymbolPatternIndicatorDCI_0_1_r16_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PUSCH_Config_priorityIndicatorDCI_0_1_r16_e_priorityIndicatorDCI_0_1_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_PUSCH_Config_priorityIndicatorDCI_0_1_r16_e_priorityIndicatorDCI_0_1_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_PUSCH_Config_priorityIndicatorDCI_0_1_r16_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PUSCH_Config_pusch_RepTypeIndicatorDCI_0_1_r16_e_pusch_RepTypeIndicatorDCI_0_1_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_PUSCH_Config_pusch_RepTypeIndicatorDCI_0_1_r16_e_pusch_RepTypeIndicatorDCI_0_1_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_PUSCH_Config_pusch_RepTypeIndicatorDCI_0_1_r16_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PUSCH_Config_frequencyHoppingDCI_0_1_r16_e_frequencyHoppingDCI_0_1_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_PUSCH_Config_frequencyHoppingDCI_0_1_r16_e_frequencyHoppingDCI_0_1_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_PUSCH_Config_frequencyHoppingDCI_0_1_r16_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SetupRelease_PUSCH_Config_uci_OnPUSCH_ListDCI_0_1_r16_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union SQN_NR_SetupRelease_PUSCH_Config_uci_OnPUSCH_ListDCI_0_1_r16_Value* p, enum SQN_NR_SetupRelease_PUSCH_Config_uci_OnPUSCH_ListDCI_0_1_r16_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SetupRelease_PUSCH_Config_uci_OnPUSCH_ListDCI_0_1_r16_release) {
		NTOH_8(p->release, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SetupRelease_PUSCH_Config_uci_OnPUSCH_ListDCI_0_1_r16_setup) {
		NTOH_32(p->setup.d, &_buffer[*_lidx], _lidx);
		p->setup.v = (struct SQN_NR_UCI_OnPUSCH*)serMalloc(_mem, p->setup.d * sizeof(struct SQN_NR_UCI_OnPUSCH));
		for (size_t i2 = 0; i2 < p->setup.d; i2++) {
			_serNrSysDecSQN_NR_UCI_OnPUSCH(_buffer, _size, _lidx, &p->setup.v[i2]);
		}
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecSQN_NR_SetupRelease_PUSCH_Config_uci_OnPUSCH_ListDCI_0_1_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_SetupRelease_PUSCH_Config_uci_OnPUSCH_ListDCI_0_1_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SQN_NR_SetupRelease_PUSCH_Config_uci_OnPUSCH_ListDCI_0_1_r16_Sel)_tmp;
	}
	_serNrSysDecSQN_NR_SetupRelease_PUSCH_Config_uci_OnPUSCH_ListDCI_0_1_r16_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SetupRelease_PUSCH_Config_uci_OnPUSCH_ListDCI_0_1_r16_SQN_NR_PUSCH_Config_uci_OnPUSCH_ListDCI_0_1_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_SetupRelease_PUSCH_Config_uci_OnPUSCH_ListDCI_0_1_r16_SQN_NR_PUSCH_Config_uci_OnPUSCH_ListDCI_0_1_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_SetupRelease_PUSCH_Config_uci_OnPUSCH_ListDCI_0_1_r16(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_InvalidSymbolPattern_r16_symbols_r16_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union SQN_NR_InvalidSymbolPattern_r16_symbols_r16_Value* p, enum SQN_NR_InvalidSymbolPattern_r16_symbols_r16_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_InvalidSymbolPattern_r16_symbols_r16_oneSlot) {
		for (size_t i2 = 0; i2 < 14; i2++) {
			NTOH_8(p->oneSlot[i2], &_buffer[*_lidx], _lidx);
		}
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_InvalidSymbolPattern_r16_symbols_r16_twoSlots) {
		for (size_t i2 = 0; i2 < 28; i2++) {
			NTOH_8(p->twoSlots[i2], &_buffer[*_lidx], _lidx);
		}
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecSQN_NR_InvalidSymbolPattern_r16_symbols_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_InvalidSymbolPattern_r16_symbols_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SQN_NR_InvalidSymbolPattern_r16_symbols_r16_Sel)_tmp;
	}
	_serNrSysDecSQN_NR_InvalidSymbolPattern_r16_symbols_r16_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_InvalidSymbolPattern_r16_periodicityAndPattern_r16_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union SQN_NR_InvalidSymbolPattern_r16_periodicityAndPattern_r16_Value* p, enum SQN_NR_InvalidSymbolPattern_r16_periodicityAndPattern_r16_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_InvalidSymbolPattern_r16_periodicityAndPattern_r16_n2) {
		for (size_t i2 = 0; i2 < 2; i2++) {
			NTOH_8(p->n2[i2], &_buffer[*_lidx], _lidx);
		}
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_InvalidSymbolPattern_r16_periodicityAndPattern_r16_n4) {
		for (size_t i2 = 0; i2 < 4; i2++) {
			NTOH_8(p->n4[i2], &_buffer[*_lidx], _lidx);
		}
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_InvalidSymbolPattern_r16_periodicityAndPattern_r16_n5) {
		for (size_t i2 = 0; i2 < 5; i2++) {
			NTOH_8(p->n5[i2], &_buffer[*_lidx], _lidx);
		}
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_InvalidSymbolPattern_r16_periodicityAndPattern_r16_n8) {
		for (size_t i2 = 0; i2 < 8; i2++) {
			NTOH_8(p->n8[i2], &_buffer[*_lidx], _lidx);
		}
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_InvalidSymbolPattern_r16_periodicityAndPattern_r16_n10) {
		for (size_t i2 = 0; i2 < 10; i2++) {
			NTOH_8(p->n10[i2], &_buffer[*_lidx], _lidx);
		}
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_InvalidSymbolPattern_r16_periodicityAndPattern_r16_n20) {
		for (size_t i2 = 0; i2 < 20; i2++) {
			NTOH_8(p->n20[i2], &_buffer[*_lidx], _lidx);
		}
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_InvalidSymbolPattern_r16_periodicityAndPattern_r16_n40) {
		for (size_t i2 = 0; i2 < 40; i2++) {
			NTOH_8(p->n40[i2], &_buffer[*_lidx], _lidx);
		}
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecSQN_NR_InvalidSymbolPattern_r16_periodicityAndPattern_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_InvalidSymbolPattern_r16_periodicityAndPattern_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SQN_NR_InvalidSymbolPattern_r16_periodicityAndPattern_r16_Sel)_tmp;
	}
	_serNrSysDecSQN_NR_InvalidSymbolPattern_r16_periodicityAndPattern_r16_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_InvalidSymbolPattern_r16_periodicityAndPattern_r16_periodicityAndPattern_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_InvalidSymbolPattern_r16_periodicityAndPattern_r16_periodicityAndPattern_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_InvalidSymbolPattern_r16_periodicityAndPattern_r16(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_InvalidSymbolPattern_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_InvalidSymbolPattern_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecSQN_NR_InvalidSymbolPattern_r16_symbols_r16(_buffer, _size, _lidx, &p->symbols_r16);
	_serNrSysDecSQN_NR_InvalidSymbolPattern_r16_periodicityAndPattern_r16_periodicityAndPattern_r16_Optional(_buffer, _size, _lidx, &p->periodicityAndPattern_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_InvalidSymbolPattern_r16_SQN_NR_PUSCH_Config_invalidSymbolPattern_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_InvalidSymbolPattern_r16_SQN_NR_PUSCH_Config_invalidSymbolPattern_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_InvalidSymbolPattern_r16(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PUSCH_PathlossReferenceRS_r16_referenceSignal_r16_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union SQN_NR_PUSCH_PathlossReferenceRS_r16_referenceSignal_r16_Value* p, enum SQN_NR_PUSCH_PathlossReferenceRS_r16_referenceSignal_r16_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_PUSCH_PathlossReferenceRS_r16_referenceSignal_r16_ssb_Index_r16) {
		NTOH_8(p->ssb_Index_r16, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_PUSCH_PathlossReferenceRS_r16_referenceSignal_r16_csi_RS_Index_r16) {
		NTOH_8(p->csi_RS_Index_r16, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecSQN_NR_PUSCH_PathlossReferenceRS_r16_referenceSignal_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_PUSCH_PathlossReferenceRS_r16_referenceSignal_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SQN_NR_PUSCH_PathlossReferenceRS_r16_referenceSignal_r16_Sel)_tmp;
	}
	_serNrSysDecSQN_NR_PUSCH_PathlossReferenceRS_r16_referenceSignal_r16_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PUSCH_PathlossReferenceRS_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_PUSCH_PathlossReferenceRS_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->pusch_PathlossReferenceRS_Id_r16, &_buffer[*_lidx], _lidx);
	_serNrSysDecSQN_NR_PUSCH_PathlossReferenceRS_r16_referenceSignal_r16(_buffer, _size, _lidx, &p->referenceSignal_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PUSCH_PathlossReferenceRS_r16_SQN_NR_PUSCH_PowerControl_v1610_pathlossReferenceRSToAddModList2_r16_DynamicOptional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_PUSCH_PathlossReferenceRS_r16_SQN_NR_PUSCH_PowerControl_v1610_pathlossReferenceRSToAddModList2_r16_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = (struct SQN_NR_PUSCH_PathlossReferenceRS_r16*)serMalloc(_mem, p->v.d * sizeof(struct SQN_NR_PUSCH_PathlossReferenceRS_r16));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serNrSysDecSQN_NR_PUSCH_PathlossReferenceRS_r16(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PUSCH_PathlossReferenceRS_Id_v1610_SQN_NR_PUSCH_PowerControl_v1610_pathlossReferenceRSToReleaseList2_r16_DynamicOptional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_PUSCH_PathlossReferenceRS_Id_v1610_SQN_NR_PUSCH_PowerControl_v1610_pathlossReferenceRSToReleaseList2_r16_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = (SQN_NR_PUSCH_PathlossReferenceRS_Id_v1610*)serMalloc(_mem, p->v.d * sizeof(SQN_NR_PUSCH_PathlossReferenceRS_Id_v1610));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		NTOH_8(p->v.v[i2], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_P0_PUSCH_r16_SQN_NR_P0_PUSCH_Set_r16_p0_List_r16_DynamicOptional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_P0_PUSCH_r16_SQN_NR_P0_PUSCH_Set_r16_p0_List_r16_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = (SQN_NR_P0_PUSCH_r16*)serMalloc(_mem, p->v.d * sizeof(SQN_NR_P0_PUSCH_r16));
	for (size_t i3 = 0; i3 < p->v.d; i3++) {
		NTOH_8(p->v.v[i3], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_P0_PUSCH_Set_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_P0_PUSCH_Set_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->p0_PUSCH_SetId_r16, &_buffer[*_lidx], _lidx);
	_serNrSysDecSQN_NR_P0_PUSCH_r16_SQN_NR_P0_PUSCH_Set_r16_p0_List_r16_DynamicOptional(_buffer, _size, _lidx, _mem, &p->p0_List_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_P0_PUSCH_Set_r16_SQN_NR_PUSCH_PowerControl_v1610_p0_PUSCH_SetList_r16_DynamicOptional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_P0_PUSCH_Set_r16_SQN_NR_PUSCH_PowerControl_v1610_p0_PUSCH_SetList_r16_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = (struct SQN_NR_P0_PUSCH_Set_r16*)serMalloc(_mem, p->v.d * sizeof(struct SQN_NR_P0_PUSCH_Set_r16));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serNrSysDecSQN_NR_P0_PUSCH_Set_r16(_buffer, _size, _lidx, _mem, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecUint8_t_SQN_NR_PUSCH_PowerControl_v1610_olpc_ParameterSet_olpc_ParameterSetDCI_0_1_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct uint8_t_SQN_NR_PUSCH_PowerControl_v1610_olpc_ParameterSet_olpc_ParameterSetDCI_0_1_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecUint8_t_SQN_NR_PUSCH_PowerControl_v1610_olpc_ParameterSet_olpc_ParameterSetDCI_0_2_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct uint8_t_SQN_NR_PUSCH_PowerControl_v1610_olpc_ParameterSet_olpc_ParameterSetDCI_0_2_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PUSCH_PowerControl_v1610_olpc_ParameterSet(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_PUSCH_PowerControl_v1610_olpc_ParameterSet* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecUint8_t_SQN_NR_PUSCH_PowerControl_v1610_olpc_ParameterSet_olpc_ParameterSetDCI_0_1_r16_Optional(_buffer, _size, _lidx, &p->olpc_ParameterSetDCI_0_1_r16);
	_serNrSysDecUint8_t_SQN_NR_PUSCH_PowerControl_v1610_olpc_ParameterSet_olpc_ParameterSetDCI_0_2_r16_Optional(_buffer, _size, _lidx, &p->olpc_ParameterSetDCI_0_2_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PUSCH_PowerControl_v1610_olpc_ParameterSet_olpc_ParameterSet_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_PUSCH_PowerControl_v1610_olpc_ParameterSet_olpc_ParameterSet_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_PUSCH_PowerControl_v1610_olpc_ParameterSet(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PUSCH_PowerControl_v1610(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_PUSCH_PowerControl_v1610* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecSQN_NR_PUSCH_PathlossReferenceRS_r16_SQN_NR_PUSCH_PowerControl_v1610_pathlossReferenceRSToAddModList2_r16_DynamicOptional(_buffer, _size, _lidx, _mem, &p->pathlossReferenceRSToAddModList2_r16);
	_serNrSysDecSQN_NR_PUSCH_PathlossReferenceRS_Id_v1610_SQN_NR_PUSCH_PowerControl_v1610_pathlossReferenceRSToReleaseList2_r16_DynamicOptional(_buffer, _size, _lidx, _mem, &p->pathlossReferenceRSToReleaseList2_r16);
	_serNrSysDecSQN_NR_P0_PUSCH_Set_r16_SQN_NR_PUSCH_PowerControl_v1610_p0_PUSCH_SetList_r16_DynamicOptional(_buffer, _size, _lidx, _mem, &p->p0_PUSCH_SetList_r16);
	_serNrSysDecSQN_NR_PUSCH_PowerControl_v1610_olpc_ParameterSet_olpc_ParameterSet_Optional(_buffer, _size, _lidx, &p->olpc_ParameterSet);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SetupRelease_PUSCH_Config_pusch_PowerControl_v1610_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union SQN_NR_SetupRelease_PUSCH_Config_pusch_PowerControl_v1610_Value* p, enum SQN_NR_SetupRelease_PUSCH_Config_pusch_PowerControl_v1610_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SetupRelease_PUSCH_Config_pusch_PowerControl_v1610_release) {
		NTOH_8(p->release, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SetupRelease_PUSCH_Config_pusch_PowerControl_v1610_setup) {
		_serNrSysDecSQN_NR_PUSCH_PowerControl_v1610(_buffer, _size, _lidx, _mem, &p->setup);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecSQN_NR_SetupRelease_PUSCH_Config_pusch_PowerControl_v1610(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_SetupRelease_PUSCH_Config_pusch_PowerControl_v1610* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SQN_NR_SetupRelease_PUSCH_Config_pusch_PowerControl_v1610_Sel)_tmp;
	}
	_serNrSysDecSQN_NR_SetupRelease_PUSCH_Config_pusch_PowerControl_v1610_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SetupRelease_PUSCH_Config_pusch_PowerControl_v1610_SQN_NR_PUSCH_Config_pusch_PowerControl_v1610_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_SetupRelease_PUSCH_Config_pusch_PowerControl_v1610_SQN_NR_PUSCH_Config_pusch_PowerControl_v1610_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_SetupRelease_PUSCH_Config_pusch_PowerControl_v1610(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PUSCH_Config_ul_FullPowerTransmission_r16_e_ul_FullPowerTransmission_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_PUSCH_Config_ul_FullPowerTransmission_r16_e_ul_FullPowerTransmission_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_PUSCH_Config_ul_FullPowerTransmission_r16_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SetupRelease_PUSCH_Config_pusch_TimeDomainAllocationListForMultiPUSCH_r16_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union SQN_NR_SetupRelease_PUSCH_Config_pusch_TimeDomainAllocationListForMultiPUSCH_r16_Value* p, enum SQN_NR_SetupRelease_PUSCH_Config_pusch_TimeDomainAllocationListForMultiPUSCH_r16_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SetupRelease_PUSCH_Config_pusch_TimeDomainAllocationListForMultiPUSCH_r16_release) {
		NTOH_8(p->release, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SetupRelease_PUSCH_Config_pusch_TimeDomainAllocationListForMultiPUSCH_r16_setup) {
		NTOH_32(p->setup.d, &_buffer[*_lidx], _lidx);
		p->setup.v = (struct SQN_NR_PUSCH_TimeDomainResourceAllocation_r16*)serMalloc(_mem, p->setup.d * sizeof(struct SQN_NR_PUSCH_TimeDomainResourceAllocation_r16));
		for (size_t i2 = 0; i2 < p->setup.d; i2++) {
			_serNrSysDecSQN_NR_PUSCH_TimeDomainResourceAllocation_r16(_buffer, _size, _lidx, _mem, &p->setup.v[i2]);
		}
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecSQN_NR_SetupRelease_PUSCH_Config_pusch_TimeDomainAllocationListForMultiPUSCH_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_SetupRelease_PUSCH_Config_pusch_TimeDomainAllocationListForMultiPUSCH_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SQN_NR_SetupRelease_PUSCH_Config_pusch_TimeDomainAllocationListForMultiPUSCH_r16_Sel)_tmp;
	}
	_serNrSysDecSQN_NR_SetupRelease_PUSCH_Config_pusch_TimeDomainAllocationListForMultiPUSCH_r16_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SetupRelease_PUSCH_Config_pusch_TimeDomainAllocationListForMultiPUSCH_r16_SQN_NR_PUSCH_Config_pusch_TimeDomainAllocationListForMultiPUSCH_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_SetupRelease_PUSCH_Config_pusch_TimeDomainAllocationListForMultiPUSCH_r16_SQN_NR_PUSCH_Config_pusch_TimeDomainAllocationListForMultiPUSCH_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_SetupRelease_PUSCH_Config_pusch_TimeDomainAllocationListForMultiPUSCH_r16(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecUint8_t_SQN_NR_PUSCH_Config_numberOfInvalidSymbolsForDL_UL_Switching_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct uint8_t_SQN_NR_PUSCH_Config_numberOfInvalidSymbolsForDL_UL_Switching_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PUSCH_Config(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_PUSCH_Config* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecUint16_t_SQN_NR_PUSCH_Config_dataScramblingIdentityPUSCH_Optional(_buffer, _size, _lidx, &p->dataScramblingIdentityPUSCH);
	_serNrSysDecSQN_NR_PUSCH_Config_txConfig_e_txConfig_Optional(_buffer, _size, _lidx, &p->txConfig);
	_serNrSysDecSQN_NR_SetupRelease_PUSCH_Config_dmrs_UplinkForPUSCH_MappingTypeA_SQN_NR_PUSCH_Config_dmrs_UplinkForPUSCH_MappingTypeA_Optional(_buffer, _size, _lidx, &p->dmrs_UplinkForPUSCH_MappingTypeA);
	_serNrSysDecSQN_NR_SetupRelease_PUSCH_Config_dmrs_UplinkForPUSCH_MappingTypeB_SQN_NR_PUSCH_Config_dmrs_UplinkForPUSCH_MappingTypeB_Optional(_buffer, _size, _lidx, &p->dmrs_UplinkForPUSCH_MappingTypeB);
	_serNrSysDecSQN_NR_PUSCH_PowerControl_SQN_NR_PUSCH_Config_pusch_PowerControl_Optional(_buffer, _size, _lidx, _mem, &p->pusch_PowerControl);
	_serNrSysDecSQN_NR_PUSCH_Config_frequencyHopping_e_frequencyHopping_Optional(_buffer, _size, _lidx, &p->frequencyHopping);
	_serNrSysDecUint16_t_SQN_NR_PUSCH_Config_frequencyHoppingOffsetLists_DynamicOptional(_buffer, _size, _lidx, _mem, &p->frequencyHoppingOffsetLists);
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->resourceAllocation = (SQN_NR_PUSCH_Config_resourceAllocation_e)_tmp;
	}
	_serNrSysDecSQN_NR_SetupRelease_PUSCH_Config_pusch_TimeDomainAllocationList_SQN_NR_PUSCH_Config_pusch_TimeDomainAllocationList_Optional(_buffer, _size, _lidx, _mem, &p->pusch_TimeDomainAllocationList);
	_serNrSysDecSQN_NR_PUSCH_Config_pusch_AggregationFactor_e_pusch_AggregationFactor_Optional(_buffer, _size, _lidx, &p->pusch_AggregationFactor);
	_serNrSysDecSQN_NR_PUSCH_Config_mcs_Table_e_mcs_Table_Optional(_buffer, _size, _lidx, &p->mcs_Table);
	_serNrSysDecSQN_NR_PUSCH_Config_mcs_TableTransformPrecoder_e_mcs_TableTransformPrecoder_Optional(_buffer, _size, _lidx, &p->mcs_TableTransformPrecoder);
	_serNrSysDecSQN_NR_PUSCH_Config_transformPrecoder_e_transformPrecoder_Optional(_buffer, _size, _lidx, &p->transformPrecoder);
	_serNrSysDecSQN_NR_PUSCH_Config_codebookSubset_e_codebookSubset_Optional(_buffer, _size, _lidx, &p->codebookSubset);
	_serNrSysDecUint8_t_SQN_NR_PUSCH_Config_maxRank_Optional(_buffer, _size, _lidx, &p->maxRank);
	_serNrSysDecSQN_NR_PUSCH_Config_rbg_Size_e_rbg_Size_Optional(_buffer, _size, _lidx, &p->rbg_Size);
	_serNrSysDecSQN_NR_SetupRelease_PUSCH_Config_uci_OnPUSCH_SQN_NR_PUSCH_Config_uci_OnPUSCH_Optional(_buffer, _size, _lidx, &p->uci_OnPUSCH);
	_serNrSysDecSQN_NR_PUSCH_Config_tp_pi2BPSK_e_tp_pi2BPSK_Optional(_buffer, _size, _lidx, &p->tp_pi2BPSK);
	_serNrSysDecSQN_NR_SetupRelease_PUSCH_Config_minimumSchedulingOffsetK2_r16_SQN_NR_PUSCH_Config_minimumSchedulingOffsetK2_r16_Optional(_buffer, _size, _lidx, _mem, &p->minimumSchedulingOffsetK2_r16);
	_serNrSysDecSQN_NR_SetupRelease_PUSCH_Config_ul_AccessConfigListDCI_0_1_r16_SQN_NR_PUSCH_Config_ul_AccessConfigListDCI_0_1_r16_Optional(_buffer, _size, _lidx, _mem, &p->ul_AccessConfigListDCI_0_1_r16);
	_serNrSysDecUint8_t_SQN_NR_PUSCH_Config_harq_ProcessNumberSizeDCI_0_2_r16_Optional(_buffer, _size, _lidx, &p->harq_ProcessNumberSizeDCI_0_2_r16);
	_serNrSysDecSQN_NR_PUSCH_Config_dmrs_SequenceInitializationDCI_0_2_r16_e_dmrs_SequenceInitializationDCI_0_2_r16_Optional(_buffer, _size, _lidx, &p->dmrs_SequenceInitializationDCI_0_2_r16);
	_serNrSysDecUint8_t_SQN_NR_PUSCH_Config_numberOfBitsForRV_DCI_0_2_r16_Optional(_buffer, _size, _lidx, &p->numberOfBitsForRV_DCI_0_2_r16);
	_serNrSysDecSQN_NR_PUSCH_Config_antennaPortsFieldPresenceDCI_0_2_r16_e_antennaPortsFieldPresenceDCI_0_2_r16_Optional(_buffer, _size, _lidx, &p->antennaPortsFieldPresenceDCI_0_2_r16);
	_serNrSysDecSQN_NR_SetupRelease_PUSCH_Config_dmrs_UplinkForPUSCH_MappingTypeA_DCI_0_2_r16_SQN_NR_PUSCH_Config_dmrs_UplinkForPUSCH_MappingTypeA_DCI_0_2_r16_Optional(_buffer, _size, _lidx, &p->dmrs_UplinkForPUSCH_MappingTypeA_DCI_0_2_r16);
	_serNrSysDecSQN_NR_SetupRelease_PUSCH_Config_dmrs_UplinkForPUSCH_MappingTypeB_DCI_0_2_r16_SQN_NR_PUSCH_Config_dmrs_UplinkForPUSCH_MappingTypeB_DCI_0_2_r16_Optional(_buffer, _size, _lidx, &p->dmrs_UplinkForPUSCH_MappingTypeB_DCI_0_2_r16);
	_serNrSysDecSQN_NR_PUSCH_Config_frequencyHoppingDCI_0_2_r16_frequencyHoppingDCI_0_2_r16_Optional(_buffer, _size, _lidx, &p->frequencyHoppingDCI_0_2_r16);
	_serNrSysDecSQN_NR_SetupRelease_PUSCH_Config_frequencyHoppingOffsetListsDCI_0_2_r16_SQN_NR_PUSCH_Config_frequencyHoppingOffsetListsDCI_0_2_r16_Optional(_buffer, _size, _lidx, _mem, &p->frequencyHoppingOffsetListsDCI_0_2_r16);
	_serNrSysDecSQN_NR_PUSCH_Config_codebookSubsetDCI_0_2_r16_e_codebookSubsetDCI_0_2_r16_Optional(_buffer, _size, _lidx, &p->codebookSubsetDCI_0_2_r16);
	_serNrSysDecSQN_NR_PUSCH_Config_invalidSymbolPatternIndicatorDCI_0_2_r16_e_invalidSymbolPatternIndicatorDCI_0_2_r16_Optional(_buffer, _size, _lidx, &p->invalidSymbolPatternIndicatorDCI_0_2_r16);
	_serNrSysDecUint8_t_SQN_NR_PUSCH_Config_maxRankDCI_0_2_r16_Optional(_buffer, _size, _lidx, &p->maxRankDCI_0_2_r16);
	_serNrSysDecSQN_NR_PUSCH_Config_mcs_TableDCI_0_2_r16_e_mcs_TableDCI_0_2_r16_Optional(_buffer, _size, _lidx, &p->mcs_TableDCI_0_2_r16);
	_serNrSysDecSQN_NR_PUSCH_Config_mcs_TableTransformPrecoderDCI_0_2_r16_e_mcs_TableTransformPrecoderDCI_0_2_r16_Optional(_buffer, _size, _lidx, &p->mcs_TableTransformPrecoderDCI_0_2_r16);
	_serNrSysDecSQN_NR_PUSCH_Config_priorityIndicatorDCI_0_2_r16_e_priorityIndicatorDCI_0_2_r16_Optional(_buffer, _size, _lidx, &p->priorityIndicatorDCI_0_2_r16);
	_serNrSysDecSQN_NR_PUSCH_Config_pusch_RepTypeIndicatorDCI_0_2_r16_e_pusch_RepTypeIndicatorDCI_0_2_r16_Optional(_buffer, _size, _lidx, &p->pusch_RepTypeIndicatorDCI_0_2_r16);
	_serNrSysDecSQN_NR_PUSCH_Config_resourceAllocationDCI_0_2_r16_e_resourceAllocationDCI_0_2_r16_Optional(_buffer, _size, _lidx, &p->resourceAllocationDCI_0_2_r16);
	_serNrSysDecSQN_NR_PUSCH_Config_resourceAllocationType1GranularityDCI_0_2_r16_e_resourceAllocationType1GranularityDCI_0_2_r16_Optional(_buffer, _size, _lidx, &p->resourceAllocationType1GranularityDCI_0_2_r16);
	_serNrSysDecSQN_NR_SetupRelease_PUSCH_Config_uci_OnPUSCH_ListDCI_0_2_r16_SQN_NR_PUSCH_Config_uci_OnPUSCH_ListDCI_0_2_r16_Optional(_buffer, _size, _lidx, _mem, &p->uci_OnPUSCH_ListDCI_0_2_r16);
	_serNrSysDecSQN_NR_SetupRelease_PUSCH_Config_pusch_TimeDomainAllocationListDCI_0_2_r16_SQN_NR_PUSCH_Config_pusch_TimeDomainAllocationListDCI_0_2_r16_Optional(_buffer, _size, _lidx, _mem, &p->pusch_TimeDomainAllocationListDCI_0_2_r16);
	_serNrSysDecSQN_NR_SetupRelease_PUSCH_Config_pusch_TimeDomainAllocationListDCI_0_1_r16_SQN_NR_PUSCH_Config_pusch_TimeDomainAllocationListDCI_0_1_r16_Optional(_buffer, _size, _lidx, _mem, &p->pusch_TimeDomainAllocationListDCI_0_1_r16);
	_serNrSysDecSQN_NR_PUSCH_Config_invalidSymbolPatternIndicatorDCI_0_1_r16_e_invalidSymbolPatternIndicatorDCI_0_1_r16_Optional(_buffer, _size, _lidx, &p->invalidSymbolPatternIndicatorDCI_0_1_r16);
	_serNrSysDecSQN_NR_PUSCH_Config_priorityIndicatorDCI_0_1_r16_e_priorityIndicatorDCI_0_1_r16_Optional(_buffer, _size, _lidx, &p->priorityIndicatorDCI_0_1_r16);
	_serNrSysDecSQN_NR_PUSCH_Config_pusch_RepTypeIndicatorDCI_0_1_r16_e_pusch_RepTypeIndicatorDCI_0_1_r16_Optional(_buffer, _size, _lidx, &p->pusch_RepTypeIndicatorDCI_0_1_r16);
	_serNrSysDecSQN_NR_PUSCH_Config_frequencyHoppingDCI_0_1_r16_e_frequencyHoppingDCI_0_1_r16_Optional(_buffer, _size, _lidx, &p->frequencyHoppingDCI_0_1_r16);
	_serNrSysDecSQN_NR_SetupRelease_PUSCH_Config_uci_OnPUSCH_ListDCI_0_1_r16_SQN_NR_PUSCH_Config_uci_OnPUSCH_ListDCI_0_1_r16_Optional(_buffer, _size, _lidx, _mem, &p->uci_OnPUSCH_ListDCI_0_1_r16);
	_serNrSysDecSQN_NR_InvalidSymbolPattern_r16_SQN_NR_PUSCH_Config_invalidSymbolPattern_r16_Optional(_buffer, _size, _lidx, &p->invalidSymbolPattern_r16);
	_serNrSysDecSQN_NR_SetupRelease_PUSCH_Config_pusch_PowerControl_v1610_SQN_NR_PUSCH_Config_pusch_PowerControl_v1610_Optional(_buffer, _size, _lidx, _mem, &p->pusch_PowerControl_v1610);
	_serNrSysDecSQN_NR_PUSCH_Config_ul_FullPowerTransmission_r16_e_ul_FullPowerTransmission_r16_Optional(_buffer, _size, _lidx, &p->ul_FullPowerTransmission_r16);
	_serNrSysDecSQN_NR_SetupRelease_PUSCH_Config_pusch_TimeDomainAllocationListForMultiPUSCH_r16_SQN_NR_PUSCH_Config_pusch_TimeDomainAllocationListForMultiPUSCH_r16_Optional(_buffer, _size, _lidx, _mem, &p->pusch_TimeDomainAllocationListForMultiPUSCH_r16);
	_serNrSysDecUint8_t_SQN_NR_PUSCH_Config_numberOfInvalidSymbolsForDL_UL_Switching_r16_Optional(_buffer, _size, _lidx, &p->numberOfInvalidSymbolsForDL_UL_Switching_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SetupRelease_BWP_UplinkDedicated_pusch_Config_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union SQN_NR_SetupRelease_BWP_UplinkDedicated_pusch_Config_Value* p, enum SQN_NR_SetupRelease_BWP_UplinkDedicated_pusch_Config_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SetupRelease_BWP_UplinkDedicated_pusch_Config_release) {
		NTOH_8(p->release, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SetupRelease_BWP_UplinkDedicated_pusch_Config_setup) {
		_serNrSysDecSQN_NR_PUSCH_Config(_buffer, _size, _lidx, _mem, &p->setup);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecSQN_NR_SetupRelease_BWP_UplinkDedicated_pusch_Config(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_SetupRelease_BWP_UplinkDedicated_pusch_Config* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SQN_NR_SetupRelease_BWP_UplinkDedicated_pusch_Config_Sel)_tmp;
	}
	_serNrSysDecSQN_NR_SetupRelease_BWP_UplinkDedicated_pusch_Config_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SetupRelease_BWP_UplinkDedicated_pusch_Config_SQN_NR_BWP_UplinkDedicated_pusch_Config_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_SetupRelease_BWP_UplinkDedicated_pusch_Config_SQN_NR_BWP_UplinkDedicated_pusch_Config_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_SetupRelease_BWP_UplinkDedicated_pusch_Config(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_ConfiguredGrantConfig_frequencyHopping_e_frequencyHopping_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_ConfiguredGrantConfig_frequencyHopping_e_frequencyHopping_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_ConfiguredGrantConfig_frequencyHopping_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_ConfiguredGrantConfig_mcs_Table_e_mcs_Table_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_ConfiguredGrantConfig_mcs_Table_e_mcs_Table_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_ConfiguredGrantConfig_mcs_Table_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_ConfiguredGrantConfig_mcs_TableTransformPrecoder_e_mcs_TableTransformPrecoder_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_ConfiguredGrantConfig_mcs_TableTransformPrecoder_e_mcs_TableTransformPrecoder_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_ConfiguredGrantConfig_mcs_TableTransformPrecoder_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_CG_UCI_OnPUSCH_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union SQN_NR_CG_UCI_OnPUSCH_Value* p, enum SQN_NR_CG_UCI_OnPUSCH_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_CG_UCI_OnPUSCH_dynamic) {
		NTOH_32(p->dynamic.d, &_buffer[*_lidx], _lidx);
		p->dynamic.v = (struct SQN_NR_BetaOffsets*)serMalloc(_mem, p->dynamic.d * sizeof(struct SQN_NR_BetaOffsets));
		for (size_t i2 = 0; i2 < p->dynamic.d; i2++) {
			_serNrSysDecSQN_NR_BetaOffsets(_buffer, _size, _lidx, &p->dynamic.v[i2]);
		}
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_CG_UCI_OnPUSCH_semiStatic) {
		_serNrSysDecSQN_NR_BetaOffsets(_buffer, _size, _lidx, &p->semiStatic);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecSQN_NR_CG_UCI_OnPUSCH(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_CG_UCI_OnPUSCH* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SQN_NR_CG_UCI_OnPUSCH_Sel)_tmp;
	}
	_serNrSysDecSQN_NR_CG_UCI_OnPUSCH_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SetupRelease_ConfiguredGrantConfig_uci_OnPUSCH_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union SQN_NR_SetupRelease_ConfiguredGrantConfig_uci_OnPUSCH_Value* p, enum SQN_NR_SetupRelease_ConfiguredGrantConfig_uci_OnPUSCH_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SetupRelease_ConfiguredGrantConfig_uci_OnPUSCH_release) {
		NTOH_8(p->release, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SetupRelease_ConfiguredGrantConfig_uci_OnPUSCH_setup) {
		_serNrSysDecSQN_NR_CG_UCI_OnPUSCH(_buffer, _size, _lidx, _mem, &p->setup);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecSQN_NR_SetupRelease_ConfiguredGrantConfig_uci_OnPUSCH(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_SetupRelease_ConfiguredGrantConfig_uci_OnPUSCH* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SQN_NR_SetupRelease_ConfiguredGrantConfig_uci_OnPUSCH_Sel)_tmp;
	}
	_serNrSysDecSQN_NR_SetupRelease_ConfiguredGrantConfig_uci_OnPUSCH_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SetupRelease_ConfiguredGrantConfig_uci_OnPUSCH_SQN_NR_ConfiguredGrantConfig_uci_OnPUSCH_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_SetupRelease_ConfiguredGrantConfig_uci_OnPUSCH_SQN_NR_ConfiguredGrantConfig_uci_OnPUSCH_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_SetupRelease_ConfiguredGrantConfig_uci_OnPUSCH(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_ConfiguredGrantConfig_rbg_Size_e_rbg_Size_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_ConfiguredGrantConfig_rbg_Size_e_rbg_Size_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_ConfiguredGrantConfig_rbg_Size_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_ConfiguredGrantConfig_transformPrecoder_e_transformPrecoder_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_ConfiguredGrantConfig_transformPrecoder_e_transformPrecoder_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_ConfiguredGrantConfig_transformPrecoder_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_ConfiguredGrantConfig_repK_RV_e_repK_RV_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_ConfiguredGrantConfig_repK_RV_e_repK_RV_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_ConfiguredGrantConfig_repK_RV_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecUint8_t_SQN_NR_ConfiguredGrantConfig_configuredGrantTimer_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct uint8_t_SQN_NR_ConfiguredGrantConfig_configuredGrantTimer_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecUint8_t_SQN_NR_ConfiguredGrantConfig_rrc_ConfiguredUplinkGrant_dmrs_SeqInitialization_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct uint8_t_SQN_NR_ConfiguredGrantConfig_rrc_ConfiguredUplinkGrant_dmrs_SeqInitialization_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecUint8_t_SQN_NR_ConfiguredGrantConfig_rrc_ConfiguredUplinkGrant_srs_ResourceIndicator_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct uint8_t_SQN_NR_ConfiguredGrantConfig_rrc_ConfiguredUplinkGrant_srs_ResourceIndicator_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecUint16_t_SQN_NR_ConfiguredGrantConfig_rrc_ConfiguredUplinkGrant_frequencyHoppingOffset_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct uint16_t_SQN_NR_ConfiguredGrantConfig_rrc_ConfiguredUplinkGrant_frequencyHoppingOffset_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_16(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_ConfiguredGrantConfig_rrc_ConfiguredUplinkGrant_pusch_RepTypeIndicator_r16_e_pusch_RepTypeIndicator_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_ConfiguredGrantConfig_rrc_ConfiguredUplinkGrant_pusch_RepTypeIndicator_r16_e_pusch_RepTypeIndicator_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_ConfiguredGrantConfig_rrc_ConfiguredUplinkGrant_pusch_RepTypeIndicator_r16_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_ConfiguredGrantConfig_rrc_ConfiguredUplinkGrant_frequencyHoppingPUSCH_RepTypeB_r16_e_frequencyHoppingPUSCH_RepTypeB_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_ConfiguredGrantConfig_rrc_ConfiguredUplinkGrant_frequencyHoppingPUSCH_RepTypeB_r16_e_frequencyHoppingPUSCH_RepTypeB_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_ConfiguredGrantConfig_rrc_ConfiguredUplinkGrant_frequencyHoppingPUSCH_RepTypeB_r16_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_ConfiguredGrantConfig_rrc_ConfiguredUplinkGrant_timeReferenceSFN_r16_e_timeReferenceSFN_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_ConfiguredGrantConfig_rrc_ConfiguredUplinkGrant_timeReferenceSFN_r16_e_timeReferenceSFN_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_ConfiguredGrantConfig_rrc_ConfiguredUplinkGrant_timeReferenceSFN_r16_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_ConfiguredGrantConfig_rrc_ConfiguredUplinkGrant(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_ConfiguredGrantConfig_rrc_ConfiguredUplinkGrant* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_16(p->timeDomainOffset, &_buffer[*_lidx], _lidx);
	NTOH_8(p->timeDomainAllocation, &_buffer[*_lidx], _lidx);
	for (size_t i2 = 0; i2 < 18; i2++) {
		NTOH_8(p->frequencyDomainAllocation[i2], &_buffer[*_lidx], _lidx);
	}
	NTOH_8(p->antennaPort, &_buffer[*_lidx], _lidx);
	_serNrSysDecUint8_t_SQN_NR_ConfiguredGrantConfig_rrc_ConfiguredUplinkGrant_dmrs_SeqInitialization_Optional(_buffer, _size, _lidx, &p->dmrs_SeqInitialization);
	NTOH_8(p->precodingAndNumberOfLayers, &_buffer[*_lidx], _lidx);
	_serNrSysDecUint8_t_SQN_NR_ConfiguredGrantConfig_rrc_ConfiguredUplinkGrant_srs_ResourceIndicator_Optional(_buffer, _size, _lidx, &p->srs_ResourceIndicator);
	NTOH_8(p->mcsAndTBS, &_buffer[*_lidx], _lidx);
	_serNrSysDecUint16_t_SQN_NR_ConfiguredGrantConfig_rrc_ConfiguredUplinkGrant_frequencyHoppingOffset_Optional(_buffer, _size, _lidx, &p->frequencyHoppingOffset);
	NTOH_8(p->pathlossReferenceIndex, &_buffer[*_lidx], _lidx);
	_serNrSysDecSQN_NR_ConfiguredGrantConfig_rrc_ConfiguredUplinkGrant_pusch_RepTypeIndicator_r16_e_pusch_RepTypeIndicator_r16_Optional(_buffer, _size, _lidx, &p->pusch_RepTypeIndicator_r16);
	_serNrSysDecSQN_NR_ConfiguredGrantConfig_rrc_ConfiguredUplinkGrant_frequencyHoppingPUSCH_RepTypeB_r16_e_frequencyHoppingPUSCH_RepTypeB_r16_Optional(_buffer, _size, _lidx, &p->frequencyHoppingPUSCH_RepTypeB_r16);
	_serNrSysDecSQN_NR_ConfiguredGrantConfig_rrc_ConfiguredUplinkGrant_timeReferenceSFN_r16_e_timeReferenceSFN_r16_Optional(_buffer, _size, _lidx, &p->timeReferenceSFN_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_ConfiguredGrantConfig_rrc_ConfiguredUplinkGrant_rrc_ConfiguredUplinkGrant_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_ConfiguredGrantConfig_rrc_ConfiguredUplinkGrant_rrc_ConfiguredUplinkGrant_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_ConfiguredGrantConfig_rrc_ConfiguredUplinkGrant(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecUint8_t_SQN_NR_ConfiguredGrantConfig_cg_RetransmissionTimer_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct uint8_t_SQN_NR_ConfiguredGrantConfig_cg_RetransmissionTimer_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_ConfiguredGrantConfig_cg_minDFI_Delay_r16_e_cg_minDFI_Delay_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_ConfiguredGrantConfig_cg_minDFI_Delay_r16_e_cg_minDFI_Delay_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_ConfiguredGrantConfig_cg_minDFI_Delay_r16_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecUint8_t_SQN_NR_ConfiguredGrantConfig_cg_nrofPUSCH_InSlot_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct uint8_t_SQN_NR_ConfiguredGrantConfig_cg_nrofPUSCH_InSlot_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecUint8_t_SQN_NR_ConfiguredGrantConfig_cg_nrofSlots_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct uint8_t_SQN_NR_ConfiguredGrantConfig_cg_nrofSlots_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecUint8_t_SQN_NR_CG_StartingOffsets_r16_cg_StartingFullBW_InsideCOT_r16_DynamicOptional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct uint8_t_SQN_NR_CG_StartingOffsets_r16_cg_StartingFullBW_InsideCOT_r16_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = (uint8_t*)serMalloc(_mem, p->v.d * sizeof(uint8_t));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		NTOH_8(p->v.v[i2], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecUint8_t_SQN_NR_CG_StartingOffsets_r16_cg_StartingFullBW_OutsideCOT_r16_DynamicOptional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct uint8_t_SQN_NR_CG_StartingOffsets_r16_cg_StartingFullBW_OutsideCOT_r16_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = (uint8_t*)serMalloc(_mem, p->v.d * sizeof(uint8_t));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		NTOH_8(p->v.v[i2], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecUint8_t_SQN_NR_CG_StartingOffsets_r16_cg_StartingPartialBW_InsideCOT_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct uint8_t_SQN_NR_CG_StartingOffsets_r16_cg_StartingPartialBW_InsideCOT_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecUint8_t_SQN_NR_CG_StartingOffsets_r16_cg_StartingPartialBW_OutsideCOT_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct uint8_t_SQN_NR_CG_StartingOffsets_r16_cg_StartingPartialBW_OutsideCOT_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_CG_StartingOffsets_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_CG_StartingOffsets_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecUint8_t_SQN_NR_CG_StartingOffsets_r16_cg_StartingFullBW_InsideCOT_r16_DynamicOptional(_buffer, _size, _lidx, _mem, &p->cg_StartingFullBW_InsideCOT_r16);
	_serNrSysDecUint8_t_SQN_NR_CG_StartingOffsets_r16_cg_StartingFullBW_OutsideCOT_r16_DynamicOptional(_buffer, _size, _lidx, _mem, &p->cg_StartingFullBW_OutsideCOT_r16);
	_serNrSysDecUint8_t_SQN_NR_CG_StartingOffsets_r16_cg_StartingPartialBW_InsideCOT_r16_Optional(_buffer, _size, _lidx, &p->cg_StartingPartialBW_InsideCOT_r16);
	_serNrSysDecUint8_t_SQN_NR_CG_StartingOffsets_r16_cg_StartingPartialBW_OutsideCOT_r16_Optional(_buffer, _size, _lidx, &p->cg_StartingPartialBW_OutsideCOT_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_CG_StartingOffsets_r16_SQN_NR_ConfiguredGrantConfig_cg_StartingOffsets_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_CG_StartingOffsets_r16_SQN_NR_ConfiguredGrantConfig_cg_StartingOffsets_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_CG_StartingOffsets_r16(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_ConfiguredGrantConfig_cg_UCI_Multiplexing_e_cg_UCI_Multiplexing_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_ConfiguredGrantConfig_cg_UCI_Multiplexing_e_cg_UCI_Multiplexing_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_ConfiguredGrantConfig_cg_UCI_Multiplexing_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecUint8_t_SQN_NR_ConfiguredGrantConfig_cg_COT_SharingOffset_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct uint8_t_SQN_NR_ConfiguredGrantConfig_cg_COT_SharingOffset_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecUint8_t_SQN_NR_ConfiguredGrantConfig_betaOffsetCG_UCI_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct uint8_t_SQN_NR_ConfiguredGrantConfig_betaOffsetCG_UCI_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_CG_COT_Sharing_r16_cot_Sharing_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_CG_COT_Sharing_r16_cot_Sharing_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->duration_r16, &_buffer[*_lidx], _lidx);
	NTOH_8(p->offset_r16, &_buffer[*_lidx], _lidx);
	NTOH_8(p->channelAccessPriority_r16, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_CG_COT_Sharing_r16_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union SQN_NR_CG_COT_Sharing_r16_Value* p, enum SQN_NR_CG_COT_Sharing_r16_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_CG_COT_Sharing_r16_noCOT_Sharing_r16) {
		NTOH_8(p->noCOT_Sharing_r16, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_CG_COT_Sharing_r16_cot_Sharing_r16) {
		_serNrSysDecSQN_NR_CG_COT_Sharing_r16_cot_Sharing_r16(_buffer, _size, _lidx, &p->cot_Sharing_r16);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecSQN_NR_CG_COT_Sharing_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_CG_COT_Sharing_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SQN_NR_CG_COT_Sharing_r16_Sel)_tmp;
	}
	_serNrSysDecSQN_NR_CG_COT_Sharing_r16_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_CG_COT_Sharing_r16_SQN_NR_ConfiguredGrantConfig_cg_COT_SharingList_r16_DynamicOptional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_CG_COT_Sharing_r16_SQN_NR_ConfiguredGrantConfig_cg_COT_SharingList_r16_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = (struct SQN_NR_CG_COT_Sharing_r16*)serMalloc(_mem, p->v.d * sizeof(struct SQN_NR_CG_COT_Sharing_r16));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serNrSysDecSQN_NR_CG_COT_Sharing_r16(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecUint8_t_SQN_NR_ConfiguredGrantConfig_harq_ProcID_Offset_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct uint8_t_SQN_NR_ConfiguredGrantConfig_harq_ProcID_Offset_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecUint8_t_SQN_NR_ConfiguredGrantConfig_harq_ProcID_Offset2_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct uint8_t_SQN_NR_ConfiguredGrantConfig_harq_ProcID_Offset2_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_ConfiguredGrantConfigIndex_r16_SQN_NR_ConfiguredGrantConfig_configuredGrantConfigIndex_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_ConfiguredGrantConfigIndex_r16_SQN_NR_ConfiguredGrantConfig_configuredGrantConfigIndex_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_ConfiguredGrantConfigIndexMAC_r16_SQN_NR_ConfiguredGrantConfig_configuredGrantConfigIndexMAC_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_ConfiguredGrantConfigIndexMAC_r16_SQN_NR_ConfiguredGrantConfig_configuredGrantConfigIndexMAC_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecUint16_t_SQN_NR_ConfiguredGrantConfig_periodicityExt_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct uint16_t_SQN_NR_ConfiguredGrantConfig_periodicityExt_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_16(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_ConfiguredGrantConfig_startingFromRV0_r16_e_startingFromRV0_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_ConfiguredGrantConfig_startingFromRV0_r16_e_startingFromRV0_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_ConfiguredGrantConfig_startingFromRV0_r16_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_ConfiguredGrantConfig_phy_PriorityIndex_r16_e_phy_PriorityIndex_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_ConfiguredGrantConfig_phy_PriorityIndex_r16_e_phy_PriorityIndex_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_ConfiguredGrantConfig_phy_PriorityIndex_r16_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_ConfiguredGrantConfig_autonomousTx_r16_e_autonomousTx_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_ConfiguredGrantConfig_autonomousTx_r16_e_autonomousTx_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_ConfiguredGrantConfig_autonomousTx_r16_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_ConfiguredGrantConfig(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_ConfiguredGrantConfig* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecSQN_NR_ConfiguredGrantConfig_frequencyHopping_e_frequencyHopping_Optional(_buffer, _size, _lidx, &p->frequencyHopping);
	_serNrSysDecSQN_NR_DMRS_UplinkConfig(_buffer, _size, _lidx, &p->cg_DMRS_Configuration);
	_serNrSysDecSQN_NR_ConfiguredGrantConfig_mcs_Table_e_mcs_Table_Optional(_buffer, _size, _lidx, &p->mcs_Table);
	_serNrSysDecSQN_NR_ConfiguredGrantConfig_mcs_TableTransformPrecoder_e_mcs_TableTransformPrecoder_Optional(_buffer, _size, _lidx, &p->mcs_TableTransformPrecoder);
	_serNrSysDecSQN_NR_SetupRelease_ConfiguredGrantConfig_uci_OnPUSCH_SQN_NR_ConfiguredGrantConfig_uci_OnPUSCH_Optional(_buffer, _size, _lidx, _mem, &p->uci_OnPUSCH);
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->resourceAllocation = (SQN_NR_ConfiguredGrantConfig_resourceAllocation_e)_tmp;
	}
	_serNrSysDecSQN_NR_ConfiguredGrantConfig_rbg_Size_e_rbg_Size_Optional(_buffer, _size, _lidx, &p->rbg_Size);
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->powerControlLoopToUse = (SQN_NR_ConfiguredGrantConfig_powerControlLoopToUse_e)_tmp;
	}
	NTOH_8(p->p0_PUSCH_Alpha, &_buffer[*_lidx], _lidx);
	_serNrSysDecSQN_NR_ConfiguredGrantConfig_transformPrecoder_e_transformPrecoder_Optional(_buffer, _size, _lidx, &p->transformPrecoder);
	NTOH_8(p->nrofHARQ_Processes, &_buffer[*_lidx], _lidx);
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->repK = (SQN_NR_ConfiguredGrantConfig_repK_e)_tmp;
	}
	_serNrSysDecSQN_NR_ConfiguredGrantConfig_repK_RV_e_repK_RV_Optional(_buffer, _size, _lidx, &p->repK_RV);
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->periodicity = (SQN_NR_ConfiguredGrantConfig_periodicity_e)_tmp;
	}
	_serNrSysDecUint8_t_SQN_NR_ConfiguredGrantConfig_configuredGrantTimer_Optional(_buffer, _size, _lidx, &p->configuredGrantTimer);
	_serNrSysDecSQN_NR_ConfiguredGrantConfig_rrc_ConfiguredUplinkGrant_rrc_ConfiguredUplinkGrant_Optional(_buffer, _size, _lidx, &p->rrc_ConfiguredUplinkGrant);
	_serNrSysDecUint8_t_SQN_NR_ConfiguredGrantConfig_cg_RetransmissionTimer_r16_Optional(_buffer, _size, _lidx, &p->cg_RetransmissionTimer_r16);
	_serNrSysDecSQN_NR_ConfiguredGrantConfig_cg_minDFI_Delay_r16_e_cg_minDFI_Delay_r16_Optional(_buffer, _size, _lidx, &p->cg_minDFI_Delay_r16);
	_serNrSysDecUint8_t_SQN_NR_ConfiguredGrantConfig_cg_nrofPUSCH_InSlot_r16_Optional(_buffer, _size, _lidx, &p->cg_nrofPUSCH_InSlot_r16);
	_serNrSysDecUint8_t_SQN_NR_ConfiguredGrantConfig_cg_nrofSlots_r16_Optional(_buffer, _size, _lidx, &p->cg_nrofSlots_r16);
	_serNrSysDecSQN_NR_CG_StartingOffsets_r16_SQN_NR_ConfiguredGrantConfig_cg_StartingOffsets_r16_Optional(_buffer, _size, _lidx, _mem, &p->cg_StartingOffsets_r16);
	_serNrSysDecSQN_NR_ConfiguredGrantConfig_cg_UCI_Multiplexing_e_cg_UCI_Multiplexing_Optional(_buffer, _size, _lidx, &p->cg_UCI_Multiplexing);
	_serNrSysDecUint8_t_SQN_NR_ConfiguredGrantConfig_cg_COT_SharingOffset_r16_Optional(_buffer, _size, _lidx, &p->cg_COT_SharingOffset_r16);
	_serNrSysDecUint8_t_SQN_NR_ConfiguredGrantConfig_betaOffsetCG_UCI_r16_Optional(_buffer, _size, _lidx, &p->betaOffsetCG_UCI_r16);
	_serNrSysDecSQN_NR_CG_COT_Sharing_r16_SQN_NR_ConfiguredGrantConfig_cg_COT_SharingList_r16_DynamicOptional(_buffer, _size, _lidx, _mem, &p->cg_COT_SharingList_r16);
	_serNrSysDecUint8_t_SQN_NR_ConfiguredGrantConfig_harq_ProcID_Offset_r16_Optional(_buffer, _size, _lidx, &p->harq_ProcID_Offset_r16);
	_serNrSysDecUint8_t_SQN_NR_ConfiguredGrantConfig_harq_ProcID_Offset2_r16_Optional(_buffer, _size, _lidx, &p->harq_ProcID_Offset2_r16);
	_serNrSysDecSQN_NR_ConfiguredGrantConfigIndex_r16_SQN_NR_ConfiguredGrantConfig_configuredGrantConfigIndex_r16_Optional(_buffer, _size, _lidx, &p->configuredGrantConfigIndex_r16);
	_serNrSysDecSQN_NR_ConfiguredGrantConfigIndexMAC_r16_SQN_NR_ConfiguredGrantConfig_configuredGrantConfigIndexMAC_r16_Optional(_buffer, _size, _lidx, &p->configuredGrantConfigIndexMAC_r16);
	_serNrSysDecUint16_t_SQN_NR_ConfiguredGrantConfig_periodicityExt_r16_Optional(_buffer, _size, _lidx, &p->periodicityExt_r16);
	_serNrSysDecSQN_NR_ConfiguredGrantConfig_startingFromRV0_r16_e_startingFromRV0_r16_Optional(_buffer, _size, _lidx, &p->startingFromRV0_r16);
	_serNrSysDecSQN_NR_ConfiguredGrantConfig_phy_PriorityIndex_r16_e_phy_PriorityIndex_r16_Optional(_buffer, _size, _lidx, &p->phy_PriorityIndex_r16);
	_serNrSysDecSQN_NR_ConfiguredGrantConfig_autonomousTx_r16_e_autonomousTx_r16_Optional(_buffer, _size, _lidx, &p->autonomousTx_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SetupRelease_BWP_UplinkDedicated_configuredGrantConfig_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union SQN_NR_SetupRelease_BWP_UplinkDedicated_configuredGrantConfig_Value* p, enum SQN_NR_SetupRelease_BWP_UplinkDedicated_configuredGrantConfig_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SetupRelease_BWP_UplinkDedicated_configuredGrantConfig_release) {
		NTOH_8(p->release, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SetupRelease_BWP_UplinkDedicated_configuredGrantConfig_setup) {
		_serNrSysDecSQN_NR_ConfiguredGrantConfig(_buffer, _size, _lidx, _mem, &p->setup);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecSQN_NR_SetupRelease_BWP_UplinkDedicated_configuredGrantConfig(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_SetupRelease_BWP_UplinkDedicated_configuredGrantConfig* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SQN_NR_SetupRelease_BWP_UplinkDedicated_configuredGrantConfig_Sel)_tmp;
	}
	_serNrSysDecSQN_NR_SetupRelease_BWP_UplinkDedicated_configuredGrantConfig_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SetupRelease_BWP_UplinkDedicated_configuredGrantConfig_SQN_NR_BWP_UplinkDedicated_configuredGrantConfig_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_SetupRelease_BWP_UplinkDedicated_configuredGrantConfig_SQN_NR_BWP_UplinkDedicated_configuredGrantConfig_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_SetupRelease_BWP_UplinkDedicated_configuredGrantConfig(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SRS_ResourceSetId_SQN_NR_SRS_Config_srs_ResourceSetToReleaseList_DynamicOptional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_SRS_ResourceSetId_SQN_NR_SRS_Config_srs_ResourceSetToReleaseList_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = (SQN_NR_SRS_ResourceSetId*)serMalloc(_mem, p->v.d * sizeof(SQN_NR_SRS_ResourceSetId));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		NTOH_8(p->v.v[i2], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SRS_ResourceId_SQN_NR_SRS_ResourceSet_srs_ResourceIdList_DynamicOptional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_SRS_ResourceId_SQN_NR_SRS_ResourceSet_srs_ResourceIdList_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = (SQN_NR_SRS_ResourceId*)serMalloc(_mem, p->v.d * sizeof(SQN_NR_SRS_ResourceId));
	for (size_t i3 = 0; i3 < p->v.d; i3++) {
		NTOH_8(p->v.v[i3], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_NZP_CSI_RS_ResourceId_SQN_NR_SRS_ResourceSet_resourceType_aperiodic_csi_RS_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_NZP_CSI_RS_ResourceId_SQN_NR_SRS_ResourceSet_resourceType_aperiodic_csi_RS_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecUint8_t_SQN_NR_SRS_ResourceSet_resourceType_aperiodic_slotOffset_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct uint8_t_SQN_NR_SRS_ResourceSet_resourceType_aperiodic_slotOffset_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecUint8_t_SQN_NR_SRS_ResourceSet_resourceType_aperiodic_aperiodicSRS_ResourceTriggerList_DynamicOptional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct uint8_t_SQN_NR_SRS_ResourceSet_resourceType_aperiodic_aperiodicSRS_ResourceTriggerList_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = (uint8_t*)serMalloc(_mem, p->v.d * sizeof(uint8_t));
	for (size_t i3 = 0; i3 < p->v.d; i3++) {
		NTOH_8(p->v.v[i3], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SRS_ResourceSet_resourceType_aperiodic(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_SRS_ResourceSet_resourceType_aperiodic* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->aperiodicSRS_ResourceTrigger, &_buffer[*_lidx], _lidx);
	_serNrSysDecSQN_NR_NZP_CSI_RS_ResourceId_SQN_NR_SRS_ResourceSet_resourceType_aperiodic_csi_RS_Optional(_buffer, _size, _lidx, &p->csi_RS);
	_serNrSysDecUint8_t_SQN_NR_SRS_ResourceSet_resourceType_aperiodic_slotOffset_Optional(_buffer, _size, _lidx, &p->slotOffset);
	_serNrSysDecUint8_t_SQN_NR_SRS_ResourceSet_resourceType_aperiodic_aperiodicSRS_ResourceTriggerList_DynamicOptional(_buffer, _size, _lidx, _mem, &p->aperiodicSRS_ResourceTriggerList);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_NZP_CSI_RS_ResourceId_SQN_NR_SRS_ResourceSet_resourceType_semi_persistent_associatedCSI_RS_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_NZP_CSI_RS_ResourceId_SQN_NR_SRS_ResourceSet_resourceType_semi_persistent_associatedCSI_RS_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SRS_ResourceSet_resourceType_semi_persistent(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SRS_ResourceSet_resourceType_semi_persistent* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecSQN_NR_NZP_CSI_RS_ResourceId_SQN_NR_SRS_ResourceSet_resourceType_semi_persistent_associatedCSI_RS_Optional(_buffer, _size, _lidx, &p->associatedCSI_RS);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_NZP_CSI_RS_ResourceId_SQN_NR_SRS_ResourceSet_resourceType_periodic_associatedCSI_RS_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_NZP_CSI_RS_ResourceId_SQN_NR_SRS_ResourceSet_resourceType_periodic_associatedCSI_RS_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SRS_ResourceSet_resourceType_periodic(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SRS_ResourceSet_resourceType_periodic* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecSQN_NR_NZP_CSI_RS_ResourceId_SQN_NR_SRS_ResourceSet_resourceType_periodic_associatedCSI_RS_Optional(_buffer, _size, _lidx, &p->associatedCSI_RS);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SRS_ResourceSet_resourceType_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union SQN_NR_SRS_ResourceSet_resourceType_Value* p, enum SQN_NR_SRS_ResourceSet_resourceType_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SRS_ResourceSet_resourceType_aperiodic) {
		_serNrSysDecSQN_NR_SRS_ResourceSet_resourceType_aperiodic(_buffer, _size, _lidx, _mem, &p->aperiodic);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SRS_ResourceSet_resourceType_semi_persistent) {
		_serNrSysDecSQN_NR_SRS_ResourceSet_resourceType_semi_persistent(_buffer, _size, _lidx, &p->semi_persistent);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SRS_ResourceSet_resourceType_periodic) {
		_serNrSysDecSQN_NR_SRS_ResourceSet_resourceType_periodic(_buffer, _size, _lidx, &p->periodic);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecSQN_NR_SRS_ResourceSet_resourceType(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_SRS_ResourceSet_resourceType* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SQN_NR_SRS_ResourceSet_resourceType_Sel)_tmp;
	}
	_serNrSysDecSQN_NR_SRS_ResourceSet_resourceType_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_Alpha_e_SQN_NR_SRS_ResourceSet_alpha_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_Alpha_e_SQN_NR_SRS_ResourceSet_alpha_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_Alpha_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecInt16_t_SQN_NR_SRS_ResourceSet_p0_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct int16_t_SQN_NR_SRS_ResourceSet_p0_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_16(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PathlossReferenceRS_Config_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union SQN_NR_PathlossReferenceRS_Config_Value* p, enum SQN_NR_PathlossReferenceRS_Config_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_PathlossReferenceRS_Config_ssb_Index) {
		NTOH_8(p->ssb_Index, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_PathlossReferenceRS_Config_csi_RS_Index) {
		NTOH_8(p->csi_RS_Index, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecSQN_NR_PathlossReferenceRS_Config(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_PathlossReferenceRS_Config* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SQN_NR_PathlossReferenceRS_Config_Sel)_tmp;
	}
	_serNrSysDecSQN_NR_PathlossReferenceRS_Config_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PathlossReferenceRS_Config_SQN_NR_SRS_ResourceSet_pathlossReferenceRS_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_PathlossReferenceRS_Config_SQN_NR_SRS_ResourceSet_pathlossReferenceRS_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_PathlossReferenceRS_Config(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SRS_ResourceSet_srs_PowerControlAdjustmentStates_e_srs_PowerControlAdjustmentStates_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SRS_ResourceSet_srs_PowerControlAdjustmentStates_e_srs_PowerControlAdjustmentStates_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_SRS_ResourceSet_srs_PowerControlAdjustmentStates_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PathlossReferenceRS_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_PathlossReferenceRS_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->srs_PathlossReferenceRS_Id_r16, &_buffer[*_lidx], _lidx);
	_serNrSysDecSQN_NR_PathlossReferenceRS_Config(_buffer, _size, _lidx, &p->pathlossReferenceRS_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SetupRelease_SRS_ResourceSet_pathlossReferenceRSList_r16_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union SQN_NR_SetupRelease_SRS_ResourceSet_pathlossReferenceRSList_r16_Value* p, enum SQN_NR_SetupRelease_SRS_ResourceSet_pathlossReferenceRSList_r16_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SetupRelease_SRS_ResourceSet_pathlossReferenceRSList_r16_release) {
		NTOH_8(p->release, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SetupRelease_SRS_ResourceSet_pathlossReferenceRSList_r16_setup) {
		NTOH_32(p->setup.d, &_buffer[*_lidx], _lidx);
		p->setup.v = (struct SQN_NR_PathlossReferenceRS_r16*)serMalloc(_mem, p->setup.d * sizeof(struct SQN_NR_PathlossReferenceRS_r16));
		for (size_t i3 = 0; i3 < p->setup.d; i3++) {
			_serNrSysDecSQN_NR_PathlossReferenceRS_r16(_buffer, _size, _lidx, &p->setup.v[i3]);
		}
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecSQN_NR_SetupRelease_SRS_ResourceSet_pathlossReferenceRSList_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_SetupRelease_SRS_ResourceSet_pathlossReferenceRSList_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SQN_NR_SetupRelease_SRS_ResourceSet_pathlossReferenceRSList_r16_Sel)_tmp;
	}
	_serNrSysDecSQN_NR_SetupRelease_SRS_ResourceSet_pathlossReferenceRSList_r16_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SetupRelease_SRS_ResourceSet_pathlossReferenceRSList_r16_SQN_NR_SRS_ResourceSet_pathlossReferenceRSList_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_SetupRelease_SRS_ResourceSet_pathlossReferenceRSList_r16_SQN_NR_SRS_ResourceSet_pathlossReferenceRSList_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_SetupRelease_SRS_ResourceSet_pathlossReferenceRSList_r16(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SRS_ResourceSet(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_SRS_ResourceSet* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->srs_ResourceSetId, &_buffer[*_lidx], _lidx);
	_serNrSysDecSQN_NR_SRS_ResourceId_SQN_NR_SRS_ResourceSet_srs_ResourceIdList_DynamicOptional(_buffer, _size, _lidx, _mem, &p->srs_ResourceIdList);
	_serNrSysDecSQN_NR_SRS_ResourceSet_resourceType(_buffer, _size, _lidx, _mem, &p->resourceType);
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->usage = (SQN_NR_SRS_ResourceSet_usage_e)_tmp;
	}
	_serNrSysDecSQN_NR_Alpha_e_SQN_NR_SRS_ResourceSet_alpha_Optional(_buffer, _size, _lidx, &p->alpha);
	_serNrSysDecInt16_t_SQN_NR_SRS_ResourceSet_p0_Optional(_buffer, _size, _lidx, &p->p0);
	_serNrSysDecSQN_NR_PathlossReferenceRS_Config_SQN_NR_SRS_ResourceSet_pathlossReferenceRS_Optional(_buffer, _size, _lidx, &p->pathlossReferenceRS);
	_serNrSysDecSQN_NR_SRS_ResourceSet_srs_PowerControlAdjustmentStates_e_srs_PowerControlAdjustmentStates_Optional(_buffer, _size, _lidx, &p->srs_PowerControlAdjustmentStates);
	_serNrSysDecSQN_NR_SetupRelease_SRS_ResourceSet_pathlossReferenceRSList_r16_SQN_NR_SRS_ResourceSet_pathlossReferenceRSList_r16_Optional(_buffer, _size, _lidx, _mem, &p->pathlossReferenceRSList_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SRS_ResourceSet_SQN_NR_SRS_Config_srs_ResourceSetToAddModList_DynamicOptional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_SRS_ResourceSet_SQN_NR_SRS_Config_srs_ResourceSetToAddModList_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = (struct SQN_NR_SRS_ResourceSet*)serMalloc(_mem, p->v.d * sizeof(struct SQN_NR_SRS_ResourceSet));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serNrSysDecSQN_NR_SRS_ResourceSet(_buffer, _size, _lidx, _mem, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SRS_ResourceId_SQN_NR_SRS_Config_srs_ResourceToReleaseList_DynamicOptional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_SRS_ResourceId_SQN_NR_SRS_Config_srs_ResourceToReleaseList_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = (SQN_NR_SRS_ResourceId*)serMalloc(_mem, p->v.d * sizeof(SQN_NR_SRS_ResourceId));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		NTOH_8(p->v.v[i2], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SRS_Resource_ptrs_PortIndex_e_ptrs_PortIndex_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SRS_Resource_ptrs_PortIndex_e_ptrs_PortIndex_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_SRS_Resource_ptrs_PortIndex_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SRS_Resource_transmissionComb_n2(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SRS_Resource_transmissionComb_n2* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->combOffset_n2, &_buffer[*_lidx], _lidx);
	NTOH_8(p->cyclicShift_n2, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SRS_Resource_transmissionComb_n4(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SRS_Resource_transmissionComb_n4* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->combOffset_n4, &_buffer[*_lidx], _lidx);
	NTOH_8(p->cyclicShift_n4, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SRS_Resource_transmissionComb_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union SQN_NR_SRS_Resource_transmissionComb_Value* p, enum SQN_NR_SRS_Resource_transmissionComb_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SRS_Resource_transmissionComb_n2) {
		_serNrSysDecSQN_NR_SRS_Resource_transmissionComb_n2(_buffer, _size, _lidx, &p->n2);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SRS_Resource_transmissionComb_n4) {
		_serNrSysDecSQN_NR_SRS_Resource_transmissionComb_n4(_buffer, _size, _lidx, &p->n4);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecSQN_NR_SRS_Resource_transmissionComb(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SRS_Resource_transmissionComb* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SQN_NR_SRS_Resource_transmissionComb_Sel)_tmp;
	}
	_serNrSysDecSQN_NR_SRS_Resource_transmissionComb_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SRS_Resource_resourceMapping(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SRS_Resource_resourceMapping* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->startPosition, &_buffer[*_lidx], _lidx);
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->nrofSymbols = (SQN_NR_SRS_Resource_resourceMapping_nrofSymbols_e)_tmp;
	}
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->repetitionFactor = (SQN_NR_SRS_Resource_resourceMapping_repetitionFactor_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SRS_Resource_freqHopping(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SRS_Resource_freqHopping* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->c_SRS, &_buffer[*_lidx], _lidx);
	NTOH_8(p->b_SRS, &_buffer[*_lidx], _lidx);
	NTOH_8(p->b_hop, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SRS_Resource_resourceType_aperiodic(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SRS_Resource_resourceType_aperiodic* p)
{
	(void)_size; // TODO: generate boundaries checking

	(void)_buffer;
	(void)_size;
	(void)_lidx;
	(void)p;

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SRS_PeriodicityAndOffset_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union SQN_NR_SRS_PeriodicityAndOffset_Value* p, enum SQN_NR_SRS_PeriodicityAndOffset_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SRS_PeriodicityAndOffset_sl1) {
		NTOH_8(p->sl1, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SRS_PeriodicityAndOffset_sl2) {
		NTOH_8(p->sl2, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SRS_PeriodicityAndOffset_sl4) {
		NTOH_8(p->sl4, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SRS_PeriodicityAndOffset_sl5) {
		NTOH_8(p->sl5, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SRS_PeriodicityAndOffset_sl8) {
		NTOH_8(p->sl8, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SRS_PeriodicityAndOffset_sl10) {
		NTOH_8(p->sl10, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SRS_PeriodicityAndOffset_sl16) {
		NTOH_8(p->sl16, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SRS_PeriodicityAndOffset_sl20) {
		NTOH_8(p->sl20, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SRS_PeriodicityAndOffset_sl32) {
		NTOH_8(p->sl32, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SRS_PeriodicityAndOffset_sl40) {
		NTOH_8(p->sl40, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SRS_PeriodicityAndOffset_sl64) {
		NTOH_8(p->sl64, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SRS_PeriodicityAndOffset_sl80) {
		NTOH_8(p->sl80, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SRS_PeriodicityAndOffset_sl160) {
		NTOH_8(p->sl160, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SRS_PeriodicityAndOffset_sl320) {
		NTOH_16(p->sl320, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SRS_PeriodicityAndOffset_sl640) {
		NTOH_16(p->sl640, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SRS_PeriodicityAndOffset_sl1280) {
		NTOH_16(p->sl1280, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SRS_PeriodicityAndOffset_sl2560) {
		NTOH_16(p->sl2560, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecSQN_NR_SRS_PeriodicityAndOffset(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SRS_PeriodicityAndOffset* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SQN_NR_SRS_PeriodicityAndOffset_Sel)_tmp;
	}
	_serNrSysDecSQN_NR_SRS_PeriodicityAndOffset_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SRS_Resource_resourceType_semi_persistent(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SRS_Resource_resourceType_semi_persistent* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecSQN_NR_SRS_PeriodicityAndOffset(_buffer, _size, _lidx, &p->periodicityAndOffset_sp);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SRS_Resource_resourceType_periodic(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SRS_Resource_resourceType_periodic* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecSQN_NR_SRS_PeriodicityAndOffset(_buffer, _size, _lidx, &p->periodicityAndOffset_p);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SRS_Resource_resourceType_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union SQN_NR_SRS_Resource_resourceType_Value* p, enum SQN_NR_SRS_Resource_resourceType_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SRS_Resource_resourceType_aperiodic) {
		_serNrSysDecSQN_NR_SRS_Resource_resourceType_aperiodic(_buffer, _size, _lidx, &p->aperiodic);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SRS_Resource_resourceType_semi_persistent) {
		_serNrSysDecSQN_NR_SRS_Resource_resourceType_semi_persistent(_buffer, _size, _lidx, &p->semi_persistent);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SRS_Resource_resourceType_periodic) {
		_serNrSysDecSQN_NR_SRS_Resource_resourceType_periodic(_buffer, _size, _lidx, &p->periodic);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecSQN_NR_SRS_Resource_resourceType(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SRS_Resource_resourceType* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SQN_NR_SRS_Resource_resourceType_Sel)_tmp;
	}
	_serNrSysDecSQN_NR_SRS_Resource_resourceType_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_ServCellIndex_SQN_NR_SRS_SpatialRelationInfo_servingCellId_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_ServCellIndex_SQN_NR_SRS_SpatialRelationInfo_servingCellId_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SRS_SpatialRelationInfo_referenceSignal_srs(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SRS_SpatialRelationInfo_referenceSignal_srs* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->resourceId, &_buffer[*_lidx], _lidx);
	NTOH_8(p->uplinkBWP, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SRS_SpatialRelationInfo_referenceSignal_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union SQN_NR_SRS_SpatialRelationInfo_referenceSignal_Value* p, enum SQN_NR_SRS_SpatialRelationInfo_referenceSignal_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SRS_SpatialRelationInfo_referenceSignal_ssb_Index) {
		NTOH_8(p->ssb_Index, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SRS_SpatialRelationInfo_referenceSignal_csi_RS_Index) {
		NTOH_8(p->csi_RS_Index, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SRS_SpatialRelationInfo_referenceSignal_srs) {
		_serNrSysDecSQN_NR_SRS_SpatialRelationInfo_referenceSignal_srs(_buffer, _size, _lidx, &p->srs);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecSQN_NR_SRS_SpatialRelationInfo_referenceSignal(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SRS_SpatialRelationInfo_referenceSignal* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SQN_NR_SRS_SpatialRelationInfo_referenceSignal_Sel)_tmp;
	}
	_serNrSysDecSQN_NR_SRS_SpatialRelationInfo_referenceSignal_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SRS_SpatialRelationInfo(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SRS_SpatialRelationInfo* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecSQN_NR_ServCellIndex_SQN_NR_SRS_SpatialRelationInfo_servingCellId_Optional(_buffer, _size, _lidx, &p->servingCellId);
	_serNrSysDecSQN_NR_SRS_SpatialRelationInfo_referenceSignal(_buffer, _size, _lidx, &p->referenceSignal);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SRS_SpatialRelationInfo_SQN_NR_SRS_Resource_spatialRelationInfo_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SRS_SpatialRelationInfo_SQN_NR_SRS_Resource_spatialRelationInfo_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_SRS_SpatialRelationInfo(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SRS_Resource_resourceMapping_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SRS_Resource_resourceMapping_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->startPosition_r16, &_buffer[*_lidx], _lidx);
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->nrofSymbols_r16 = (SQN_NR_SRS_Resource_resourceMapping_r16_nrofSymbols_r16_e)_tmp;
	}
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->repetitionFactor_r16 = (SQN_NR_SRS_Resource_resourceMapping_r16_repetitionFactor_r16_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SRS_Resource_resourceMapping_r16_resourceMapping_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SRS_Resource_resourceMapping_r16_resourceMapping_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_SRS_Resource_resourceMapping_r16(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SRS_Resource(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SRS_Resource* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->srs_ResourceId, &_buffer[*_lidx], _lidx);
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->nrofSRS_Ports = (SQN_NR_SRS_Resource_nrofSRS_Ports_e)_tmp;
	}
	_serNrSysDecSQN_NR_SRS_Resource_ptrs_PortIndex_e_ptrs_PortIndex_Optional(_buffer, _size, _lidx, &p->ptrs_PortIndex);
	_serNrSysDecSQN_NR_SRS_Resource_transmissionComb(_buffer, _size, _lidx, &p->transmissionComb);
	_serNrSysDecSQN_NR_SRS_Resource_resourceMapping(_buffer, _size, _lidx, &p->resourceMapping);
	NTOH_8(p->freqDomainPosition, &_buffer[*_lidx], _lidx);
	NTOH_16(p->freqDomainShift, &_buffer[*_lidx], _lidx);
	_serNrSysDecSQN_NR_SRS_Resource_freqHopping(_buffer, _size, _lidx, &p->freqHopping);
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->groupOrSequenceHopping = (SQN_NR_SRS_Resource_groupOrSequenceHopping_e)_tmp;
	}
	_serNrSysDecSQN_NR_SRS_Resource_resourceType(_buffer, _size, _lidx, &p->resourceType);
	NTOH_16(p->sequenceId, &_buffer[*_lidx], _lidx);
	_serNrSysDecSQN_NR_SRS_SpatialRelationInfo_SQN_NR_SRS_Resource_spatialRelationInfo_Optional(_buffer, _size, _lidx, &p->spatialRelationInfo);
	_serNrSysDecSQN_NR_SRS_Resource_resourceMapping_r16_resourceMapping_r16_Optional(_buffer, _size, _lidx, &p->resourceMapping_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SRS_Resource_SQN_NR_SRS_Config_srs_ResourceToAddModList_DynamicOptional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_SRS_Resource_SQN_NR_SRS_Config_srs_ResourceToAddModList_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = (struct SQN_NR_SRS_Resource*)serMalloc(_mem, p->v.d * sizeof(struct SQN_NR_SRS_Resource));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serNrSysDecSQN_NR_SRS_Resource(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SRS_Config_tpc_Accumulation_e_tpc_Accumulation_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SRS_Config_tpc_Accumulation_e_tpc_Accumulation_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_SRS_Config_tpc_Accumulation_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecUint8_t_SQN_NR_SRS_Config_srs_RequestDCI_1_2_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct uint8_t_SQN_NR_SRS_Config_srs_RequestDCI_1_2_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecUint8_t_SQN_NR_SRS_Config_srs_RequestDCI_0_2_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct uint8_t_SQN_NR_SRS_Config_srs_RequestDCI_0_2_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SRS_ResourceSet_SQN_NR_SRS_Config_srs_ResourceSetToAddModListDCI_0_2_r16_DynamicOptional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_SRS_ResourceSet_SQN_NR_SRS_Config_srs_ResourceSetToAddModListDCI_0_2_r16_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = (struct SQN_NR_SRS_ResourceSet*)serMalloc(_mem, p->v.d * sizeof(struct SQN_NR_SRS_ResourceSet));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serNrSysDecSQN_NR_SRS_ResourceSet(_buffer, _size, _lidx, _mem, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SRS_ResourceSetId_SQN_NR_SRS_Config_srs_ResourceSetToReleaseListDCI_0_2_r16_DynamicOptional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_SRS_ResourceSetId_SQN_NR_SRS_Config_srs_ResourceSetToReleaseListDCI_0_2_r16_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = (SQN_NR_SRS_ResourceSetId*)serMalloc(_mem, p->v.d * sizeof(SQN_NR_SRS_ResourceSetId));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		NTOH_8(p->v.v[i2], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SRS_PosResourceSetId_r16_SQN_NR_SRS_Config_srs_PosResourceSetToReleaseList_r16_DynamicOptional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_SRS_PosResourceSetId_r16_SQN_NR_SRS_Config_srs_PosResourceSetToReleaseList_r16_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = (SQN_NR_SRS_PosResourceSetId_r16*)serMalloc(_mem, p->v.d * sizeof(SQN_NR_SRS_PosResourceSetId_r16));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		NTOH_8(p->v.v[i2], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SRS_PosResourceId_r16_SQN_NR_SRS_PosResourceSet_r16_srs_PosResourceIdList_r16_DynamicOptional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_SRS_PosResourceId_r16_SQN_NR_SRS_PosResourceSet_r16_srs_PosResourceIdList_r16_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = (SQN_NR_SRS_PosResourceId_r16*)serMalloc(_mem, p->v.d * sizeof(SQN_NR_SRS_PosResourceId_r16));
	for (size_t i3 = 0; i3 < p->v.d; i3++) {
		NTOH_8(p->v.v[i3], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecUint8_t_SQN_NR_SRS_PosResourceSet_r16_resourceType_r16_aperiodic_r16_aperiodicSRS_ResourceTriggerList_r16_DynamicOptional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct uint8_t_SQN_NR_SRS_PosResourceSet_r16_resourceType_r16_aperiodic_r16_aperiodicSRS_ResourceTriggerList_r16_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = (uint8_t*)serMalloc(_mem, p->v.d * sizeof(uint8_t));
	for (size_t i3 = 0; i3 < p->v.d; i3++) {
		NTOH_8(p->v.v[i3], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SRS_PosResourceSet_r16_resourceType_r16_aperiodic_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_SRS_PosResourceSet_r16_resourceType_r16_aperiodic_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecUint8_t_SQN_NR_SRS_PosResourceSet_r16_resourceType_r16_aperiodic_r16_aperiodicSRS_ResourceTriggerList_r16_DynamicOptional(_buffer, _size, _lidx, _mem, &p->aperiodicSRS_ResourceTriggerList_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SRS_PosResourceSet_r16_resourceType_r16_semi_persistent_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SRS_PosResourceSet_r16_resourceType_r16_semi_persistent_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	(void)_buffer;
	(void)_size;
	(void)_lidx;
	(void)p;

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SRS_PosResourceSet_r16_resourceType_r16_periodic_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SRS_PosResourceSet_r16_resourceType_r16_periodic_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	(void)_buffer;
	(void)_size;
	(void)_lidx;
	(void)p;

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SRS_PosResourceSet_r16_resourceType_r16_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union SQN_NR_SRS_PosResourceSet_r16_resourceType_r16_Value* p, enum SQN_NR_SRS_PosResourceSet_r16_resourceType_r16_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SRS_PosResourceSet_r16_resourceType_r16_aperiodic_r16) {
		_serNrSysDecSQN_NR_SRS_PosResourceSet_r16_resourceType_r16_aperiodic_r16(_buffer, _size, _lidx, _mem, &p->aperiodic_r16);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SRS_PosResourceSet_r16_resourceType_r16_semi_persistent_r16) {
		_serNrSysDecSQN_NR_SRS_PosResourceSet_r16_resourceType_r16_semi_persistent_r16(_buffer, _size, _lidx, &p->semi_persistent_r16);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SRS_PosResourceSet_r16_resourceType_r16_periodic_r16) {
		_serNrSysDecSQN_NR_SRS_PosResourceSet_r16_resourceType_r16_periodic_r16(_buffer, _size, _lidx, &p->periodic_r16);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecSQN_NR_SRS_PosResourceSet_r16_resourceType_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_SRS_PosResourceSet_r16_resourceType_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SQN_NR_SRS_PosResourceSet_r16_resourceType_r16_Sel)_tmp;
	}
	_serNrSysDecSQN_NR_SRS_PosResourceSet_r16_resourceType_r16_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_Alpha_e_SQN_NR_SRS_PosResourceSet_r16_alpha_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_Alpha_e_SQN_NR_SRS_PosResourceSet_r16_alpha_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_Alpha_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecInt16_t_SQN_NR_SRS_PosResourceSet_r16_p0_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct int16_t_SQN_NR_SRS_PosResourceSet_r16_p0_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_16(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SSB_Index_SQN_NR_SSB_InfoNcell_r16_ssb_IndexNcell_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SSB_Index_SQN_NR_SSB_InfoNcell_r16_ssb_IndexNcell_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SSB_Configuration_r16_ssb_Periodicity_r16_e_ssb_Periodicity_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SSB_Configuration_r16_ssb_Periodicity_r16_e_ssb_Periodicity_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_SSB_Configuration_r16_ssb_Periodicity_r16_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecUint8_t_SQN_NR_SSB_Configuration_r16_sfn0_Offset_r16_integerSubframeOffset_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct uint8_t_SQN_NR_SSB_Configuration_r16_sfn0_Offset_r16_integerSubframeOffset_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SSB_Configuration_r16_sfn0_Offset_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SSB_Configuration_r16_sfn0_Offset_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_16(p->sfn_Offset_r16, &_buffer[*_lidx], _lidx);
	_serNrSysDecUint8_t_SQN_NR_SSB_Configuration_r16_sfn0_Offset_r16_integerSubframeOffset_r16_Optional(_buffer, _size, _lidx, &p->integerSubframeOffset_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SSB_Configuration_r16_sfn0_Offset_r16_sfn0_Offset_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SSB_Configuration_r16_sfn0_Offset_r16_sfn0_Offset_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_SSB_Configuration_r16_sfn0_Offset_r16(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecInt8_t_SQN_NR_SSB_Configuration_r16_ss_PBCH_BlockPower_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct int8_t_SQN_NR_SSB_Configuration_r16_ss_PBCH_BlockPower_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SSB_Configuration_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SSB_Configuration_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_32(p->ssb_Freq_r16, &_buffer[*_lidx], _lidx);
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->halfFrameIndex_r16 = (SQN_NR_SSB_Configuration_r16_halfFrameIndex_r16_e)_tmp;
	}
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->ssbSubcarrierSpacing_r16 = (SQN_NR_SubcarrierSpacing_e)_tmp;
	}
	_serNrSysDecSQN_NR_SSB_Configuration_r16_ssb_Periodicity_r16_e_ssb_Periodicity_r16_Optional(_buffer, _size, _lidx, &p->ssb_Periodicity_r16);
	_serNrSysDecSQN_NR_SSB_Configuration_r16_sfn0_Offset_r16_sfn0_Offset_r16_Optional(_buffer, _size, _lidx, &p->sfn0_Offset_r16);
	NTOH_8(p->sfn_SSB_Offset_r16, &_buffer[*_lidx], _lidx);
	_serNrSysDecInt8_t_SQN_NR_SSB_Configuration_r16_ss_PBCH_BlockPower_r16_Optional(_buffer, _size, _lidx, &p->ss_PBCH_BlockPower_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SSB_Configuration_r16_SQN_NR_SSB_InfoNcell_r16_ssb_Configuration_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SSB_Configuration_r16_SQN_NR_SSB_InfoNcell_r16_ssb_Configuration_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_SSB_Configuration_r16(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SSB_InfoNcell_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SSB_InfoNcell_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_16(p->physicalCellId_r16, &_buffer[*_lidx], _lidx);
	_serNrSysDecSQN_NR_SSB_Index_SQN_NR_SSB_InfoNcell_r16_ssb_IndexNcell_r16_Optional(_buffer, _size, _lidx, &p->ssb_IndexNcell_r16);
	_serNrSysDecSQN_NR_SSB_Configuration_r16_SQN_NR_SSB_InfoNcell_r16_ssb_Configuration_r16_Optional(_buffer, _size, _lidx, &p->ssb_Configuration_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecUint8_t_SQN_NR_DL_PRS_Info_r16_dl_PRS_ResourceId_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct uint8_t_SQN_NR_DL_PRS_Info_r16_dl_PRS_ResourceId_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_DL_PRS_Info_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_DL_PRS_Info_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->dl_PRS_ID_r16, &_buffer[*_lidx], _lidx);
	NTOH_8(p->dl_PRS_ResourceSetId_r16, &_buffer[*_lidx], _lidx);
	_serNrSysDecUint8_t_SQN_NR_DL_PRS_Info_r16_dl_PRS_ResourceId_r16_Optional(_buffer, _size, _lidx, &p->dl_PRS_ResourceId_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SRS_PosResourceSet_r16_pathlossReferenceRS_Pos_r16_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union SQN_NR_SRS_PosResourceSet_r16_pathlossReferenceRS_Pos_r16_Value* p, enum SQN_NR_SRS_PosResourceSet_r16_pathlossReferenceRS_Pos_r16_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SRS_PosResourceSet_r16_pathlossReferenceRS_Pos_r16_ssb_IndexServing_r16) {
		NTOH_8(p->ssb_IndexServing_r16, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SRS_PosResourceSet_r16_pathlossReferenceRS_Pos_r16_ssb_Ncell_r16) {
		_serNrSysDecSQN_NR_SSB_InfoNcell_r16(_buffer, _size, _lidx, &p->ssb_Ncell_r16);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SRS_PosResourceSet_r16_pathlossReferenceRS_Pos_r16_dl_PRS_r16) {
		_serNrSysDecSQN_NR_DL_PRS_Info_r16(_buffer, _size, _lidx, &p->dl_PRS_r16);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecSQN_NR_SRS_PosResourceSet_r16_pathlossReferenceRS_Pos_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SRS_PosResourceSet_r16_pathlossReferenceRS_Pos_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SQN_NR_SRS_PosResourceSet_r16_pathlossReferenceRS_Pos_r16_Sel)_tmp;
	}
	_serNrSysDecSQN_NR_SRS_PosResourceSet_r16_pathlossReferenceRS_Pos_r16_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SRS_PosResourceSet_r16_pathlossReferenceRS_Pos_r16_pathlossReferenceRS_Pos_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SRS_PosResourceSet_r16_pathlossReferenceRS_Pos_r16_pathlossReferenceRS_Pos_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_SRS_PosResourceSet_r16_pathlossReferenceRS_Pos_r16(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SRS_PosResourceSet_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_SRS_PosResourceSet_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->srs_PosResourceSetId_r16, &_buffer[*_lidx], _lidx);
	_serNrSysDecSQN_NR_SRS_PosResourceId_r16_SQN_NR_SRS_PosResourceSet_r16_srs_PosResourceIdList_r16_DynamicOptional(_buffer, _size, _lidx, _mem, &p->srs_PosResourceIdList_r16);
	_serNrSysDecSQN_NR_SRS_PosResourceSet_r16_resourceType_r16(_buffer, _size, _lidx, _mem, &p->resourceType_r16);
	_serNrSysDecSQN_NR_Alpha_e_SQN_NR_SRS_PosResourceSet_r16_alpha_r16_Optional(_buffer, _size, _lidx, &p->alpha_r16);
	_serNrSysDecInt16_t_SQN_NR_SRS_PosResourceSet_r16_p0_r16_Optional(_buffer, _size, _lidx, &p->p0_r16);
	_serNrSysDecSQN_NR_SRS_PosResourceSet_r16_pathlossReferenceRS_Pos_r16_pathlossReferenceRS_Pos_r16_Optional(_buffer, _size, _lidx, &p->pathlossReferenceRS_Pos_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SRS_PosResourceSet_r16_SQN_NR_SRS_Config_srs_PosResourceSetToAddModList_r16_DynamicOptional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_SRS_PosResourceSet_r16_SQN_NR_SRS_Config_srs_PosResourceSetToAddModList_r16_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = (struct SQN_NR_SRS_PosResourceSet_r16*)serMalloc(_mem, p->v.d * sizeof(struct SQN_NR_SRS_PosResourceSet_r16));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serNrSysDecSQN_NR_SRS_PosResourceSet_r16(_buffer, _size, _lidx, _mem, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SRS_PosResourceId_r16_SQN_NR_SRS_Config_srs_PosResourceToReleaseList_r16_DynamicOptional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_SRS_PosResourceId_r16_SQN_NR_SRS_Config_srs_PosResourceToReleaseList_r16_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = (SQN_NR_SRS_PosResourceId_r16*)serMalloc(_mem, p->v.d * sizeof(SQN_NR_SRS_PosResourceId_r16));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		NTOH_8(p->v.v[i2], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SRS_PosResource_r16_transmissionComb_r16_n2_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SRS_PosResource_r16_transmissionComb_r16_n2_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->combOffset_n2_r16, &_buffer[*_lidx], _lidx);
	NTOH_8(p->cyclicShift_n2_r16, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SRS_PosResource_r16_transmissionComb_r16_n4_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SRS_PosResource_r16_transmissionComb_r16_n4_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->combOffset_n4_16, &_buffer[*_lidx], _lidx);
	NTOH_8(p->cyclicShift_n4_r16, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SRS_PosResource_r16_transmissionComb_r16_n8_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SRS_PosResource_r16_transmissionComb_r16_n8_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->combOffset_n8_r16, &_buffer[*_lidx], _lidx);
	NTOH_8(p->cyclicShift_n8_r16, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SRS_PosResource_r16_transmissionComb_r16_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union SQN_NR_SRS_PosResource_r16_transmissionComb_r16_Value* p, enum SQN_NR_SRS_PosResource_r16_transmissionComb_r16_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SRS_PosResource_r16_transmissionComb_r16_n2_r16) {
		_serNrSysDecSQN_NR_SRS_PosResource_r16_transmissionComb_r16_n2_r16(_buffer, _size, _lidx, &p->n2_r16);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SRS_PosResource_r16_transmissionComb_r16_n4_r16) {
		_serNrSysDecSQN_NR_SRS_PosResource_r16_transmissionComb_r16_n4_r16(_buffer, _size, _lidx, &p->n4_r16);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SRS_PosResource_r16_transmissionComb_r16_n8_r16) {
		_serNrSysDecSQN_NR_SRS_PosResource_r16_transmissionComb_r16_n8_r16(_buffer, _size, _lidx, &p->n8_r16);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecSQN_NR_SRS_PosResource_r16_transmissionComb_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SRS_PosResource_r16_transmissionComb_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SQN_NR_SRS_PosResource_r16_transmissionComb_r16_Sel)_tmp;
	}
	_serNrSysDecSQN_NR_SRS_PosResource_r16_transmissionComb_r16_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SRS_PosResource_r16_resourceMapping_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SRS_PosResource_r16_resourceMapping_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->startPosition_r16, &_buffer[*_lidx], _lidx);
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->nrofSymbols_r16 = (SQN_NR_SRS_PosResource_r16_resourceMapping_r16_nrofSymbols_r16_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SRS_PosResource_r16_freqHopping_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SRS_PosResource_r16_freqHopping_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->c_SRS_r16, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecUint8_t_SQN_NR_SRS_PosResource_r16_resourceType_r16_aperiodic_r16_slotOffset_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct uint8_t_SQN_NR_SRS_PosResource_r16_resourceType_r16_aperiodic_r16_slotOffset_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SRS_PosResource_r16_resourceType_r16_aperiodic_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SRS_PosResource_r16_resourceType_r16_aperiodic_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecUint8_t_SQN_NR_SRS_PosResource_r16_resourceType_r16_aperiodic_r16_slotOffset_r16_Optional(_buffer, _size, _lidx, &p->slotOffset_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SRS_PeriodicityAndOffset_r16_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union SQN_NR_SRS_PeriodicityAndOffset_r16_Value* p, enum SQN_NR_SRS_PeriodicityAndOffset_r16_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SRS_PeriodicityAndOffset_r16_sl1) {
		NTOH_8(p->sl1, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SRS_PeriodicityAndOffset_r16_sl2) {
		NTOH_8(p->sl2, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SRS_PeriodicityAndOffset_r16_sl4) {
		NTOH_8(p->sl4, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SRS_PeriodicityAndOffset_r16_sl5) {
		NTOH_8(p->sl5, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SRS_PeriodicityAndOffset_r16_sl8) {
		NTOH_8(p->sl8, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SRS_PeriodicityAndOffset_r16_sl10) {
		NTOH_8(p->sl10, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SRS_PeriodicityAndOffset_r16_sl16) {
		NTOH_8(p->sl16, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SRS_PeriodicityAndOffset_r16_sl20) {
		NTOH_8(p->sl20, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SRS_PeriodicityAndOffset_r16_sl32) {
		NTOH_8(p->sl32, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SRS_PeriodicityAndOffset_r16_sl40) {
		NTOH_8(p->sl40, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SRS_PeriodicityAndOffset_r16_sl64) {
		NTOH_8(p->sl64, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SRS_PeriodicityAndOffset_r16_sl80) {
		NTOH_8(p->sl80, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SRS_PeriodicityAndOffset_r16_sl160) {
		NTOH_8(p->sl160, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SRS_PeriodicityAndOffset_r16_sl320) {
		NTOH_16(p->sl320, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SRS_PeriodicityAndOffset_r16_sl640) {
		NTOH_16(p->sl640, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SRS_PeriodicityAndOffset_r16_sl1280) {
		NTOH_16(p->sl1280, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SRS_PeriodicityAndOffset_r16_sl2560) {
		NTOH_16(p->sl2560, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SRS_PeriodicityAndOffset_r16_sl5120) {
		NTOH_16(p->sl5120, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SRS_PeriodicityAndOffset_r16_sl10240) {
		NTOH_16(p->sl10240, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SRS_PeriodicityAndOffset_r16_sl40960) {
		NTOH_16(p->sl40960, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SRS_PeriodicityAndOffset_r16_sl81920) {
		NTOH_32(p->sl81920, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecSQN_NR_SRS_PeriodicityAndOffset_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SRS_PeriodicityAndOffset_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SQN_NR_SRS_PeriodicityAndOffset_r16_Sel)_tmp;
	}
	_serNrSysDecSQN_NR_SRS_PeriodicityAndOffset_r16_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SRS_PosResource_r16_resourceType_r16_semi_persistent_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SRS_PosResource_r16_resourceType_r16_semi_persistent_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecSQN_NR_SRS_PeriodicityAndOffset_r16(_buffer, _size, _lidx, &p->periodicityAndOffset_sp_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SRS_PosResource_r16_resourceType_r16_periodic_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SRS_PosResource_r16_resourceType_r16_periodic_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecSQN_NR_SRS_PeriodicityAndOffset_r16(_buffer, _size, _lidx, &p->periodicityAndOffset_p_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SRS_PosResource_r16_resourceType_r16_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union SQN_NR_SRS_PosResource_r16_resourceType_r16_Value* p, enum SQN_NR_SRS_PosResource_r16_resourceType_r16_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SRS_PosResource_r16_resourceType_r16_aperiodic_r16) {
		_serNrSysDecSQN_NR_SRS_PosResource_r16_resourceType_r16_aperiodic_r16(_buffer, _size, _lidx, &p->aperiodic_r16);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SRS_PosResource_r16_resourceType_r16_semi_persistent_r16) {
		_serNrSysDecSQN_NR_SRS_PosResource_r16_resourceType_r16_semi_persistent_r16(_buffer, _size, _lidx, &p->semi_persistent_r16);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SRS_PosResource_r16_resourceType_r16_periodic_r16) {
		_serNrSysDecSQN_NR_SRS_PosResource_r16_resourceType_r16_periodic_r16(_buffer, _size, _lidx, &p->periodic_r16);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecSQN_NR_SRS_PosResource_r16_resourceType_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SRS_PosResource_r16_resourceType_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SQN_NR_SRS_PosResource_r16_resourceType_r16_Sel)_tmp;
	}
	_serNrSysDecSQN_NR_SRS_PosResource_r16_resourceType_r16_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_ServCellIndex_SQN_NR_SRS_SpatialRelationInfoPos_r16_servingRS_r16_servingCellId_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_ServCellIndex_SQN_NR_SRS_SpatialRelationInfoPos_r16_servingRS_r16_servingCellId_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SRS_SpatialRelationInfoPos_r16_servingRS_r16_referenceSignal_r16_srs_SpatialRelation_r16resourceSelection_r16_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union SQN_NR_SRS_SpatialRelationInfoPos_r16_servingRS_r16_referenceSignal_r16_srs_SpatialRelation_r16resourceSelection_r16_Value* p, enum SQN_NR_SRS_SpatialRelationInfoPos_r16_servingRS_r16_referenceSignal_r16_srs_SpatialRelation_r16resourceSelection_r16_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SRS_SpatialRelationInfoPos_r16_servingRS_r16_referenceSignal_r16_srs_SpatialRelation_r16resourceSelection_r16_srs_ResourceId_r16) {
		NTOH_8(p->srs_ResourceId_r16, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SRS_SpatialRelationInfoPos_r16_servingRS_r16_referenceSignal_r16_srs_SpatialRelation_r16resourceSelection_r16_srs_PosResourceId_r16) {
		NTOH_8(p->srs_PosResourceId_r16, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecSQN_NR_SRS_SpatialRelationInfoPos_r16_servingRS_r16_referenceSignal_r16_srs_SpatialRelation_r16resourceSelection_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SRS_SpatialRelationInfoPos_r16_servingRS_r16_referenceSignal_r16_srs_SpatialRelation_r16resourceSelection_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SQN_NR_SRS_SpatialRelationInfoPos_r16_servingRS_r16_referenceSignal_r16_srs_SpatialRelation_r16resourceSelection_r16_Sel)_tmp;
	}
	_serNrSysDecSQN_NR_SRS_SpatialRelationInfoPos_r16_servingRS_r16_referenceSignal_r16_srs_SpatialRelation_r16resourceSelection_r16_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SRS_SpatialRelationInfoPos_r16_servingRS_r16_referenceSignal_r16_srs_SpatialRelation_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SRS_SpatialRelationInfoPos_r16_servingRS_r16_referenceSignal_r16_srs_SpatialRelation_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecSQN_NR_SRS_SpatialRelationInfoPos_r16_servingRS_r16_referenceSignal_r16_srs_SpatialRelation_r16resourceSelection_r16(_buffer, _size, _lidx, &p->resourceSelection_r16);
	NTOH_8(p->uplinkBWP_r16, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SRS_SpatialRelationInfoPos_r16_servingRS_r16_referenceSignal_r16_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union SQN_NR_SRS_SpatialRelationInfoPos_r16_servingRS_r16_referenceSignal_r16_Value* p, enum SQN_NR_SRS_SpatialRelationInfoPos_r16_servingRS_r16_referenceSignal_r16_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SRS_SpatialRelationInfoPos_r16_servingRS_r16_referenceSignal_r16_ssb_IndexServing_r16) {
		NTOH_8(p->ssb_IndexServing_r16, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SRS_SpatialRelationInfoPos_r16_servingRS_r16_referenceSignal_r16_csi_RS_IndexServing_r16) {
		NTOH_8(p->csi_RS_IndexServing_r16, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SRS_SpatialRelationInfoPos_r16_servingRS_r16_referenceSignal_r16_srs_SpatialRelation_r16) {
		_serNrSysDecSQN_NR_SRS_SpatialRelationInfoPos_r16_servingRS_r16_referenceSignal_r16_srs_SpatialRelation_r16(_buffer, _size, _lidx, &p->srs_SpatialRelation_r16);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecSQN_NR_SRS_SpatialRelationInfoPos_r16_servingRS_r16_referenceSignal_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SRS_SpatialRelationInfoPos_r16_servingRS_r16_referenceSignal_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SQN_NR_SRS_SpatialRelationInfoPos_r16_servingRS_r16_referenceSignal_r16_Sel)_tmp;
	}
	_serNrSysDecSQN_NR_SRS_SpatialRelationInfoPos_r16_servingRS_r16_referenceSignal_r16_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SRS_SpatialRelationInfoPos_r16_servingRS_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SRS_SpatialRelationInfoPos_r16_servingRS_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecSQN_NR_ServCellIndex_SQN_NR_SRS_SpatialRelationInfoPos_r16_servingRS_r16_servingCellId_Optional(_buffer, _size, _lidx, &p->servingCellId);
	_serNrSysDecSQN_NR_SRS_SpatialRelationInfoPos_r16_servingRS_r16_referenceSignal_r16(_buffer, _size, _lidx, &p->referenceSignal_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SRS_SpatialRelationInfoPos_r16_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union SQN_NR_SRS_SpatialRelationInfoPos_r16_Value* p, enum SQN_NR_SRS_SpatialRelationInfoPos_r16_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SRS_SpatialRelationInfoPos_r16_servingRS_r16) {
		_serNrSysDecSQN_NR_SRS_SpatialRelationInfoPos_r16_servingRS_r16(_buffer, _size, _lidx, &p->servingRS_r16);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SRS_SpatialRelationInfoPos_r16_ssb_Ncell_r16) {
		_serNrSysDecSQN_NR_SSB_InfoNcell_r16(_buffer, _size, _lidx, &p->ssb_Ncell_r16);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SRS_SpatialRelationInfoPos_r16_dl_PRS_r16) {
		_serNrSysDecSQN_NR_DL_PRS_Info_r16(_buffer, _size, _lidx, &p->dl_PRS_r16);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecSQN_NR_SRS_SpatialRelationInfoPos_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SRS_SpatialRelationInfoPos_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SQN_NR_SRS_SpatialRelationInfoPos_r16_Sel)_tmp;
	}
	_serNrSysDecSQN_NR_SRS_SpatialRelationInfoPos_r16_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SRS_SpatialRelationInfoPos_r16_SQN_NR_SRS_PosResource_r16_spatialRelationInfoPos_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SRS_SpatialRelationInfoPos_r16_SQN_NR_SRS_PosResource_r16_spatialRelationInfoPos_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_SRS_SpatialRelationInfoPos_r16(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SRS_PosResource_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SRS_PosResource_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->srs_PosResourceId_r16, &_buffer[*_lidx], _lidx);
	_serNrSysDecSQN_NR_SRS_PosResource_r16_transmissionComb_r16(_buffer, _size, _lidx, &p->transmissionComb_r16);
	_serNrSysDecSQN_NR_SRS_PosResource_r16_resourceMapping_r16(_buffer, _size, _lidx, &p->resourceMapping_r16);
	NTOH_16(p->freqDomainShift_r16, &_buffer[*_lidx], _lidx);
	_serNrSysDecSQN_NR_SRS_PosResource_r16_freqHopping_r16(_buffer, _size, _lidx, &p->freqHopping_r16);
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->groupOrSequenceHopping_r16 = (SQN_NR_SRS_PosResource_r16_groupOrSequenceHopping_r16_e)_tmp;
	}
	_serNrSysDecSQN_NR_SRS_PosResource_r16_resourceType_r16(_buffer, _size, _lidx, &p->resourceType_r16);
	NTOH_16(p->sequenceId_r16, &_buffer[*_lidx], _lidx);
	_serNrSysDecSQN_NR_SRS_SpatialRelationInfoPos_r16_SQN_NR_SRS_PosResource_r16_spatialRelationInfoPos_r16_Optional(_buffer, _size, _lidx, &p->spatialRelationInfoPos_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SRS_PosResource_r16_SQN_NR_SRS_Config_srs_PosResourceToAddModList_r16_DynamicOptional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_SRS_PosResource_r16_SQN_NR_SRS_Config_srs_PosResourceToAddModList_r16_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = (struct SQN_NR_SRS_PosResource_r16*)serMalloc(_mem, p->v.d * sizeof(struct SQN_NR_SRS_PosResource_r16));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serNrSysDecSQN_NR_SRS_PosResource_r16(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SRS_Config(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_SRS_Config* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecSQN_NR_SRS_ResourceSetId_SQN_NR_SRS_Config_srs_ResourceSetToReleaseList_DynamicOptional(_buffer, _size, _lidx, _mem, &p->srs_ResourceSetToReleaseList);
	_serNrSysDecSQN_NR_SRS_ResourceSet_SQN_NR_SRS_Config_srs_ResourceSetToAddModList_DynamicOptional(_buffer, _size, _lidx, _mem, &p->srs_ResourceSetToAddModList);
	_serNrSysDecSQN_NR_SRS_ResourceId_SQN_NR_SRS_Config_srs_ResourceToReleaseList_DynamicOptional(_buffer, _size, _lidx, _mem, &p->srs_ResourceToReleaseList);
	_serNrSysDecSQN_NR_SRS_Resource_SQN_NR_SRS_Config_srs_ResourceToAddModList_DynamicOptional(_buffer, _size, _lidx, _mem, &p->srs_ResourceToAddModList);
	_serNrSysDecSQN_NR_SRS_Config_tpc_Accumulation_e_tpc_Accumulation_Optional(_buffer, _size, _lidx, &p->tpc_Accumulation);
	_serNrSysDecUint8_t_SQN_NR_SRS_Config_srs_RequestDCI_1_2_r16_Optional(_buffer, _size, _lidx, &p->srs_RequestDCI_1_2_r16);
	_serNrSysDecUint8_t_SQN_NR_SRS_Config_srs_RequestDCI_0_2_r16_Optional(_buffer, _size, _lidx, &p->srs_RequestDCI_0_2_r16);
	_serNrSysDecSQN_NR_SRS_ResourceSet_SQN_NR_SRS_Config_srs_ResourceSetToAddModListDCI_0_2_r16_DynamicOptional(_buffer, _size, _lidx, _mem, &p->srs_ResourceSetToAddModListDCI_0_2_r16);
	_serNrSysDecSQN_NR_SRS_ResourceSetId_SQN_NR_SRS_Config_srs_ResourceSetToReleaseListDCI_0_2_r16_DynamicOptional(_buffer, _size, _lidx, _mem, &p->srs_ResourceSetToReleaseListDCI_0_2_r16);
	_serNrSysDecSQN_NR_SRS_PosResourceSetId_r16_SQN_NR_SRS_Config_srs_PosResourceSetToReleaseList_r16_DynamicOptional(_buffer, _size, _lidx, _mem, &p->srs_PosResourceSetToReleaseList_r16);
	_serNrSysDecSQN_NR_SRS_PosResourceSet_r16_SQN_NR_SRS_Config_srs_PosResourceSetToAddModList_r16_DynamicOptional(_buffer, _size, _lidx, _mem, &p->srs_PosResourceSetToAddModList_r16);
	_serNrSysDecSQN_NR_SRS_PosResourceId_r16_SQN_NR_SRS_Config_srs_PosResourceToReleaseList_r16_DynamicOptional(_buffer, _size, _lidx, _mem, &p->srs_PosResourceToReleaseList_r16);
	_serNrSysDecSQN_NR_SRS_PosResource_r16_SQN_NR_SRS_Config_srs_PosResourceToAddModList_r16_DynamicOptional(_buffer, _size, _lidx, _mem, &p->srs_PosResourceToAddModList_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SetupRelease_BWP_UplinkDedicated_srs_Config_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union SQN_NR_SetupRelease_BWP_UplinkDedicated_srs_Config_Value* p, enum SQN_NR_SetupRelease_BWP_UplinkDedicated_srs_Config_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SetupRelease_BWP_UplinkDedicated_srs_Config_release) {
		NTOH_8(p->release, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SetupRelease_BWP_UplinkDedicated_srs_Config_setup) {
		_serNrSysDecSQN_NR_SRS_Config(_buffer, _size, _lidx, _mem, &p->setup);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecSQN_NR_SetupRelease_BWP_UplinkDedicated_srs_Config(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_SetupRelease_BWP_UplinkDedicated_srs_Config* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SQN_NR_SetupRelease_BWP_UplinkDedicated_srs_Config_Sel)_tmp;
	}
	_serNrSysDecSQN_NR_SetupRelease_BWP_UplinkDedicated_srs_Config_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SetupRelease_BWP_UplinkDedicated_srs_Config_SQN_NR_BWP_UplinkDedicated_srs_Config_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_SetupRelease_BWP_UplinkDedicated_srs_Config_SQN_NR_BWP_UplinkDedicated_srs_Config_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_SetupRelease_BWP_UplinkDedicated_srs_Config(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecUint8_t_SQN_NR_BeamFailureRecoveryConfig_rootSequenceIndex_BFR_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct uint8_t_SQN_NR_BeamFailureRecoveryConfig_rootSequenceIndex_BFR_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_RACH_ConfigGeneric_SQN_NR_BeamFailureRecoveryConfig_rach_ConfigBFR_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_RACH_ConfigGeneric_SQN_NR_BeamFailureRecoveryConfig_rach_ConfigBFR_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_RACH_ConfigGeneric(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_RSRP_Range_SQN_NR_BeamFailureRecoveryConfig_rsrp_ThresholdSSB_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_RSRP_Range_SQN_NR_BeamFailureRecoveryConfig_rsrp_ThresholdSSB_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_BFR_SSB_Resource(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_BFR_SSB_Resource* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->ssb, &_buffer[*_lidx], _lidx);
	NTOH_8(p->ra_PreambleIndex, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecUint16_t_SQN_NR_BFR_CSIRS_Resource_ra_OccasionList_DynamicOptional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct uint16_t_SQN_NR_BFR_CSIRS_Resource_ra_OccasionList_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = (uint16_t*)serMalloc(_mem, p->v.d * sizeof(uint16_t));
	for (size_t i3 = 0; i3 < p->v.d; i3++) {
		NTOH_16(p->v.v[i3], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecUint8_t_SQN_NR_BFR_CSIRS_Resource_ra_PreambleIndex_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct uint8_t_SQN_NR_BFR_CSIRS_Resource_ra_PreambleIndex_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_BFR_CSIRS_Resource(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_BFR_CSIRS_Resource* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->csi_RS, &_buffer[*_lidx], _lidx);
	_serNrSysDecUint16_t_SQN_NR_BFR_CSIRS_Resource_ra_OccasionList_DynamicOptional(_buffer, _size, _lidx, _mem, &p->ra_OccasionList);
	_serNrSysDecUint8_t_SQN_NR_BFR_CSIRS_Resource_ra_PreambleIndex_Optional(_buffer, _size, _lidx, &p->ra_PreambleIndex);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PRACH_ResourceDedicatedBFR_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union SQN_NR_PRACH_ResourceDedicatedBFR_Value* p, enum SQN_NR_PRACH_ResourceDedicatedBFR_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_PRACH_ResourceDedicatedBFR_ssb) {
		_serNrSysDecSQN_NR_BFR_SSB_Resource(_buffer, _size, _lidx, &p->ssb);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_PRACH_ResourceDedicatedBFR_csi_RS) {
		_serNrSysDecSQN_NR_BFR_CSIRS_Resource(_buffer, _size, _lidx, _mem, &p->csi_RS);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecSQN_NR_PRACH_ResourceDedicatedBFR(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_PRACH_ResourceDedicatedBFR* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SQN_NR_PRACH_ResourceDedicatedBFR_Sel)_tmp;
	}
	_serNrSysDecSQN_NR_PRACH_ResourceDedicatedBFR_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PRACH_ResourceDedicatedBFR_SQN_NR_BeamFailureRecoveryConfig_candidateBeamRSList_DynamicOptional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_PRACH_ResourceDedicatedBFR_SQN_NR_BeamFailureRecoveryConfig_candidateBeamRSList_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = (struct SQN_NR_PRACH_ResourceDedicatedBFR*)serMalloc(_mem, p->v.d * sizeof(struct SQN_NR_PRACH_ResourceDedicatedBFR));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serNrSysDecSQN_NR_PRACH_ResourceDedicatedBFR(_buffer, _size, _lidx, _mem, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_BeamFailureRecoveryConfig_ssb_perRACH_Occasion_e_ssb_perRACH_Occasion_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_BeamFailureRecoveryConfig_ssb_perRACH_Occasion_e_ssb_perRACH_Occasion_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_BeamFailureRecoveryConfig_ssb_perRACH_Occasion_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecUint8_t_SQN_NR_BeamFailureRecoveryConfig_ra_ssb_OccasionMaskIndex_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct uint8_t_SQN_NR_BeamFailureRecoveryConfig_ra_ssb_OccasionMaskIndex_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SearchSpaceId_SQN_NR_BeamFailureRecoveryConfig_recoverySearchSpaceId_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SearchSpaceId_SQN_NR_BeamFailureRecoveryConfig_recoverySearchSpaceId_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_RA_Prioritization_SQN_NR_BeamFailureRecoveryConfig_ra_Prioritization_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_RA_Prioritization_SQN_NR_BeamFailureRecoveryConfig_ra_Prioritization_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_RA_Prioritization(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_BeamFailureRecoveryConfig_beamFailureRecoveryTimer_e_beamFailureRecoveryTimer_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_BeamFailureRecoveryConfig_beamFailureRecoveryTimer_e_beamFailureRecoveryTimer_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_BeamFailureRecoveryConfig_beamFailureRecoveryTimer_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SubcarrierSpacing_e_SQN_NR_BeamFailureRecoveryConfig_msg1_SubcarrierSpacing_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SubcarrierSpacing_e_SQN_NR_BeamFailureRecoveryConfig_msg1_SubcarrierSpacing_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_SubcarrierSpacing_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_RA_Prioritization_SQN_NR_BeamFailureRecoveryConfig_ra_PrioritizationTwoStep_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_RA_Prioritization_SQN_NR_BeamFailureRecoveryConfig_ra_PrioritizationTwoStep_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_RA_Prioritization(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SetupRelease_BeamFailureRecoveryConfig_candidateBeamRSListExt_v1610_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union SQN_NR_SetupRelease_BeamFailureRecoveryConfig_candidateBeamRSListExt_v1610_Value* p, enum SQN_NR_SetupRelease_BeamFailureRecoveryConfig_candidateBeamRSListExt_v1610_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SetupRelease_BeamFailureRecoveryConfig_candidateBeamRSListExt_v1610_release) {
		NTOH_8(p->release, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SetupRelease_BeamFailureRecoveryConfig_candidateBeamRSListExt_v1610_setup) {
		NTOH_32(p->setup.d, &_buffer[*_lidx], _lidx);
		p->setup.v = (struct SQN_NR_PRACH_ResourceDedicatedBFR*)serMalloc(_mem, p->setup.d * sizeof(struct SQN_NR_PRACH_ResourceDedicatedBFR));
		for (size_t i2 = 0; i2 < p->setup.d; i2++) {
			_serNrSysDecSQN_NR_PRACH_ResourceDedicatedBFR(_buffer, _size, _lidx, _mem, &p->setup.v[i2]);
		}
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecSQN_NR_SetupRelease_BeamFailureRecoveryConfig_candidateBeamRSListExt_v1610(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_SetupRelease_BeamFailureRecoveryConfig_candidateBeamRSListExt_v1610* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SQN_NR_SetupRelease_BeamFailureRecoveryConfig_candidateBeamRSListExt_v1610_Sel)_tmp;
	}
	_serNrSysDecSQN_NR_SetupRelease_BeamFailureRecoveryConfig_candidateBeamRSListExt_v1610_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SetupRelease_BeamFailureRecoveryConfig_candidateBeamRSListExt_v1610_SQN_NR_BeamFailureRecoveryConfig_candidateBeamRSListExt_v1610_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_SetupRelease_BeamFailureRecoveryConfig_candidateBeamRSListExt_v1610_SQN_NR_BeamFailureRecoveryConfig_candidateBeamRSListExt_v1610_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_SetupRelease_BeamFailureRecoveryConfig_candidateBeamRSListExt_v1610(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_BeamFailureRecoveryConfig(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_BeamFailureRecoveryConfig* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecUint8_t_SQN_NR_BeamFailureRecoveryConfig_rootSequenceIndex_BFR_Optional(_buffer, _size, _lidx, &p->rootSequenceIndex_BFR);
	_serNrSysDecSQN_NR_RACH_ConfigGeneric_SQN_NR_BeamFailureRecoveryConfig_rach_ConfigBFR_Optional(_buffer, _size, _lidx, &p->rach_ConfigBFR);
	_serNrSysDecSQN_NR_RSRP_Range_SQN_NR_BeamFailureRecoveryConfig_rsrp_ThresholdSSB_Optional(_buffer, _size, _lidx, &p->rsrp_ThresholdSSB);
	_serNrSysDecSQN_NR_PRACH_ResourceDedicatedBFR_SQN_NR_BeamFailureRecoveryConfig_candidateBeamRSList_DynamicOptional(_buffer, _size, _lidx, _mem, &p->candidateBeamRSList);
	_serNrSysDecSQN_NR_BeamFailureRecoveryConfig_ssb_perRACH_Occasion_e_ssb_perRACH_Occasion_Optional(_buffer, _size, _lidx, &p->ssb_perRACH_Occasion);
	_serNrSysDecUint8_t_SQN_NR_BeamFailureRecoveryConfig_ra_ssb_OccasionMaskIndex_Optional(_buffer, _size, _lidx, &p->ra_ssb_OccasionMaskIndex);
	_serNrSysDecSQN_NR_SearchSpaceId_SQN_NR_BeamFailureRecoveryConfig_recoverySearchSpaceId_Optional(_buffer, _size, _lidx, &p->recoverySearchSpaceId);
	_serNrSysDecSQN_NR_RA_Prioritization_SQN_NR_BeamFailureRecoveryConfig_ra_Prioritization_Optional(_buffer, _size, _lidx, &p->ra_Prioritization);
	_serNrSysDecSQN_NR_BeamFailureRecoveryConfig_beamFailureRecoveryTimer_e_beamFailureRecoveryTimer_Optional(_buffer, _size, _lidx, &p->beamFailureRecoveryTimer);
	_serNrSysDecSQN_NR_SubcarrierSpacing_e_SQN_NR_BeamFailureRecoveryConfig_msg1_SubcarrierSpacing_Optional(_buffer, _size, _lidx, &p->msg1_SubcarrierSpacing);
	_serNrSysDecSQN_NR_RA_Prioritization_SQN_NR_BeamFailureRecoveryConfig_ra_PrioritizationTwoStep_r16_Optional(_buffer, _size, _lidx, &p->ra_PrioritizationTwoStep_r16);
	_serNrSysDecSQN_NR_SetupRelease_BeamFailureRecoveryConfig_candidateBeamRSListExt_v1610_SQN_NR_BeamFailureRecoveryConfig_candidateBeamRSListExt_v1610_Optional(_buffer, _size, _lidx, _mem, &p->candidateBeamRSListExt_v1610);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SetupRelease_BWP_UplinkDedicated_beamFailureRecoveryConfig_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union SQN_NR_SetupRelease_BWP_UplinkDedicated_beamFailureRecoveryConfig_Value* p, enum SQN_NR_SetupRelease_BWP_UplinkDedicated_beamFailureRecoveryConfig_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SetupRelease_BWP_UplinkDedicated_beamFailureRecoveryConfig_release) {
		NTOH_8(p->release, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SetupRelease_BWP_UplinkDedicated_beamFailureRecoveryConfig_setup) {
		_serNrSysDecSQN_NR_BeamFailureRecoveryConfig(_buffer, _size, _lidx, _mem, &p->setup);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecSQN_NR_SetupRelease_BWP_UplinkDedicated_beamFailureRecoveryConfig(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_SetupRelease_BWP_UplinkDedicated_beamFailureRecoveryConfig* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SQN_NR_SetupRelease_BWP_UplinkDedicated_beamFailureRecoveryConfig_Sel)_tmp;
	}
	_serNrSysDecSQN_NR_SetupRelease_BWP_UplinkDedicated_beamFailureRecoveryConfig_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SetupRelease_BWP_UplinkDedicated_beamFailureRecoveryConfig_SQN_NR_BWP_UplinkDedicated_beamFailureRecoveryConfig_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_SetupRelease_BWP_UplinkDedicated_beamFailureRecoveryConfig_SQN_NR_BWP_UplinkDedicated_beamFailureRecoveryConfig_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_SetupRelease_BWP_UplinkDedicated_beamFailureRecoveryConfig(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SetupRelease_BWP_UplinkDedicated_sl_PUCCH_Config_r16_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union SQN_NR_SetupRelease_BWP_UplinkDedicated_sl_PUCCH_Config_r16_Value* p, enum SQN_NR_SetupRelease_BWP_UplinkDedicated_sl_PUCCH_Config_r16_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SetupRelease_BWP_UplinkDedicated_sl_PUCCH_Config_r16_release) {
		NTOH_8(p->release, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SetupRelease_BWP_UplinkDedicated_sl_PUCCH_Config_r16_setup) {
		_serNrSysDecSQN_NR_PUCCH_Config(_buffer, _size, _lidx, _mem, &p->setup);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecSQN_NR_SetupRelease_BWP_UplinkDedicated_sl_PUCCH_Config_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_SetupRelease_BWP_UplinkDedicated_sl_PUCCH_Config_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SQN_NR_SetupRelease_BWP_UplinkDedicated_sl_PUCCH_Config_r16_Sel)_tmp;
	}
	_serNrSysDecSQN_NR_SetupRelease_BWP_UplinkDedicated_sl_PUCCH_Config_r16_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SetupRelease_BWP_UplinkDedicated_sl_PUCCH_Config_r16_SQN_NR_BWP_UplinkDedicated_sl_PUCCH_Config_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_SetupRelease_BWP_UplinkDedicated_sl_PUCCH_Config_r16_SQN_NR_BWP_UplinkDedicated_sl_PUCCH_Config_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_SetupRelease_BWP_UplinkDedicated_sl_PUCCH_Config_r16(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecUint8_t_SQN_NR_BWP_UplinkDedicated_cp_ExtensionC2_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct uint8_t_SQN_NR_BWP_UplinkDedicated_cp_ExtensionC2_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecUint8_t_SQN_NR_BWP_UplinkDedicated_cp_ExtensionC3_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct uint8_t_SQN_NR_BWP_UplinkDedicated_cp_ExtensionC3_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_BWP_UplinkDedicated_useInterlacePUCCH_PUSCH_r16_e_useInterlacePUCCH_PUSCH_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_BWP_UplinkDedicated_useInterlacePUCCH_PUSCH_r16_e_useInterlacePUCCH_PUSCH_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_BWP_UplinkDedicated_useInterlacePUCCH_PUSCH_r16_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SetupRelease_BWP_UplinkDedicated_pucch_ConfigurationList_r16_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union SQN_NR_SetupRelease_BWP_UplinkDedicated_pucch_ConfigurationList_r16_Value* p, enum SQN_NR_SetupRelease_BWP_UplinkDedicated_pucch_ConfigurationList_r16_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SetupRelease_BWP_UplinkDedicated_pucch_ConfigurationList_r16_release) {
		NTOH_8(p->release, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SetupRelease_BWP_UplinkDedicated_pucch_ConfigurationList_r16_setup) {
		NTOH_32(p->setup.d, &_buffer[*_lidx], _lidx);
		p->setup.v = (struct SQN_NR_PUCCH_Config*)serMalloc(_mem, p->setup.d * sizeof(struct SQN_NR_PUCCH_Config));
		for (size_t i2 = 0; i2 < p->setup.d; i2++) {
			_serNrSysDecSQN_NR_PUCCH_Config(_buffer, _size, _lidx, _mem, &p->setup.v[i2]);
		}
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecSQN_NR_SetupRelease_BWP_UplinkDedicated_pucch_ConfigurationList_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_SetupRelease_BWP_UplinkDedicated_pucch_ConfigurationList_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SQN_NR_SetupRelease_BWP_UplinkDedicated_pucch_ConfigurationList_r16_Sel)_tmp;
	}
	_serNrSysDecSQN_NR_SetupRelease_BWP_UplinkDedicated_pucch_ConfigurationList_r16_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SetupRelease_BWP_UplinkDedicated_pucch_ConfigurationList_r16_SQN_NR_BWP_UplinkDedicated_pucch_ConfigurationList_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_SetupRelease_BWP_UplinkDedicated_pucch_ConfigurationList_r16_SQN_NR_BWP_UplinkDedicated_pucch_ConfigurationList_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_SetupRelease_BWP_UplinkDedicated_pucch_ConfigurationList_r16(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_LBT_FailureRecoveryConfig_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_LBT_FailureRecoveryConfig_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->lbt_FailureInstanceMaxCount_r16 = (SQN_NR_LBT_FailureRecoveryConfig_r16_lbt_FailureInstanceMaxCount_r16_e)_tmp;
	}
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->lbt_FailureDetectionTimer_r16 = (SQN_NR_LBT_FailureRecoveryConfig_r16_lbt_FailureDetectionTimer_r16_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SetupRelease_BWP_UplinkDedicated_lbt_FailureRecoveryConfig_r16_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union SQN_NR_SetupRelease_BWP_UplinkDedicated_lbt_FailureRecoveryConfig_r16_Value* p, enum SQN_NR_SetupRelease_BWP_UplinkDedicated_lbt_FailureRecoveryConfig_r16_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SetupRelease_BWP_UplinkDedicated_lbt_FailureRecoveryConfig_r16_release) {
		NTOH_8(p->release, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SetupRelease_BWP_UplinkDedicated_lbt_FailureRecoveryConfig_r16_setup) {
		_serNrSysDecSQN_NR_LBT_FailureRecoveryConfig_r16(_buffer, _size, _lidx, &p->setup);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecSQN_NR_SetupRelease_BWP_UplinkDedicated_lbt_FailureRecoveryConfig_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SetupRelease_BWP_UplinkDedicated_lbt_FailureRecoveryConfig_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SQN_NR_SetupRelease_BWP_UplinkDedicated_lbt_FailureRecoveryConfig_r16_Sel)_tmp;
	}
	_serNrSysDecSQN_NR_SetupRelease_BWP_UplinkDedicated_lbt_FailureRecoveryConfig_r16_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SetupRelease_BWP_UplinkDedicated_lbt_FailureRecoveryConfig_r16_SQN_NR_BWP_UplinkDedicated_lbt_FailureRecoveryConfig_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SetupRelease_BWP_UplinkDedicated_lbt_FailureRecoveryConfig_r16_SQN_NR_BWP_UplinkDedicated_lbt_FailureRecoveryConfig_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_SetupRelease_BWP_UplinkDedicated_lbt_FailureRecoveryConfig_r16(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_ConfiguredGrantConfigToAddModList_r16_SQN_NR_BWP_UplinkDedicated_configuredGrantConfigToAddModList_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_ConfiguredGrantConfigToAddModList_r16_SQN_NR_BWP_UplinkDedicated_configuredGrantConfigToAddModList_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = (struct SQN_NR_ConfiguredGrantConfig*)serMalloc(_mem, p->v.d * sizeof(struct SQN_NR_ConfiguredGrantConfig));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serNrSysDecSQN_NR_ConfiguredGrantConfig(_buffer, _size, _lidx, _mem, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_ConfiguredGrantConfigToReleaseList_r16_SQN_NR_BWP_UplinkDedicated_configuredGrantConfigToReleaseList_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_ConfiguredGrantConfigToReleaseList_r16_SQN_NR_BWP_UplinkDedicated_configuredGrantConfigToReleaseList_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = (SQN_NR_ConfiguredGrantConfigIndex_r16*)serMalloc(_mem, p->v.d * sizeof(SQN_NR_ConfiguredGrantConfigIndex_r16));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		NTOH_8(p->v.v[i2], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_ConfiguredGrantConfigType2DeactivationStateList_r16_SQN_NR_BWP_UplinkDedicated_configuredGrantConfigType2DeactivationStateList_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_ConfiguredGrantConfigType2DeactivationStateList_r16_SQN_NR_BWP_UplinkDedicated_configuredGrantConfigType2DeactivationStateList_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = (SQN_NR_ConfiguredGrantConfigType2DeactivationState_r16*)serMalloc(_mem, p->v.d * sizeof(SQN_NR_ConfiguredGrantConfigType2DeactivationState_r16));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		NTOH_32(p->v.v[i2].d, &_buffer[*_lidx], _lidx);
		p->v.v[i2].v = (SQN_NR_ConfiguredGrantConfigIndex_r16*)serMalloc(_mem, p->v.v[i2].d * sizeof(SQN_NR_ConfiguredGrantConfigIndex_r16));
		for (size_t i3 = 0; i3 < p->v.v[i2].d; i3++) {
			NTOH_8(p->v.v[i2].v[i3], &_buffer[*_lidx], _lidx);
		}
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_BWP_UplinkDedicated(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_BWP_UplinkDedicated* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecSQN_NR_SetupRelease_BWP_UplinkDedicated_pucch_Config_SQN_NR_BWP_UplinkDedicated_pucch_Config_Optional(_buffer, _size, _lidx, _mem, &p->pucch_Config);
	_serNrSysDecSQN_NR_SetupRelease_BWP_UplinkDedicated_pusch_Config_SQN_NR_BWP_UplinkDedicated_pusch_Config_Optional(_buffer, _size, _lidx, _mem, &p->pusch_Config);
	_serNrSysDecSQN_NR_SetupRelease_BWP_UplinkDedicated_configuredGrantConfig_SQN_NR_BWP_UplinkDedicated_configuredGrantConfig_Optional(_buffer, _size, _lidx, _mem, &p->configuredGrantConfig);
	_serNrSysDecSQN_NR_SetupRelease_BWP_UplinkDedicated_srs_Config_SQN_NR_BWP_UplinkDedicated_srs_Config_Optional(_buffer, _size, _lidx, _mem, &p->srs_Config);
	_serNrSysDecSQN_NR_SetupRelease_BWP_UplinkDedicated_beamFailureRecoveryConfig_SQN_NR_BWP_UplinkDedicated_beamFailureRecoveryConfig_Optional(_buffer, _size, _lidx, _mem, &p->beamFailureRecoveryConfig);
	_serNrSysDecSQN_NR_SetupRelease_BWP_UplinkDedicated_sl_PUCCH_Config_r16_SQN_NR_BWP_UplinkDedicated_sl_PUCCH_Config_r16_Optional(_buffer, _size, _lidx, _mem, &p->sl_PUCCH_Config_r16);
	_serNrSysDecUint8_t_SQN_NR_BWP_UplinkDedicated_cp_ExtensionC2_r16_Optional(_buffer, _size, _lidx, &p->cp_ExtensionC2_r16);
	_serNrSysDecUint8_t_SQN_NR_BWP_UplinkDedicated_cp_ExtensionC3_r16_Optional(_buffer, _size, _lidx, &p->cp_ExtensionC3_r16);
	_serNrSysDecSQN_NR_BWP_UplinkDedicated_useInterlacePUCCH_PUSCH_r16_e_useInterlacePUCCH_PUSCH_r16_Optional(_buffer, _size, _lidx, &p->useInterlacePUCCH_PUSCH_r16);
	_serNrSysDecSQN_NR_SetupRelease_BWP_UplinkDedicated_pucch_ConfigurationList_r16_SQN_NR_BWP_UplinkDedicated_pucch_ConfigurationList_r16_Optional(_buffer, _size, _lidx, _mem, &p->pucch_ConfigurationList_r16);
	_serNrSysDecSQN_NR_SetupRelease_BWP_UplinkDedicated_lbt_FailureRecoveryConfig_r16_SQN_NR_BWP_UplinkDedicated_lbt_FailureRecoveryConfig_r16_Optional(_buffer, _size, _lidx, &p->lbt_FailureRecoveryConfig_r16);
	_serNrSysDecSQN_NR_ConfiguredGrantConfigToAddModList_r16_SQN_NR_BWP_UplinkDedicated_configuredGrantConfigToAddModList_r16_Optional(_buffer, _size, _lidx, _mem, &p->configuredGrantConfigToAddModList_r16);
	_serNrSysDecSQN_NR_ConfiguredGrantConfigToReleaseList_r16_SQN_NR_BWP_UplinkDedicated_configuredGrantConfigToReleaseList_r16_Optional(_buffer, _size, _lidx, _mem, &p->configuredGrantConfigToReleaseList_r16);
	_serNrSysDecSQN_NR_ConfiguredGrantConfigType2DeactivationStateList_r16_SQN_NR_BWP_UplinkDedicated_configuredGrantConfigType2DeactivationStateList_r16_Optional(_buffer, _size, _lidx, _mem, &p->configuredGrantConfigType2DeactivationStateList_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_ASN1_BWP_UplinkDedicated_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union NR_ASN1_BWP_UplinkDedicated_Type_Value* p, enum NR_ASN1_BWP_UplinkDedicated_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_ASN1_BWP_UplinkDedicated_Type_R15) {
		_serNrSysDecSQN_NR_BWP_UplinkDedicated(_buffer, _size, _lidx, _mem, &p->R15);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecNR_ASN1_BWP_UplinkDedicated_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_ASN1_BWP_UplinkDedicated_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum NR_ASN1_BWP_UplinkDedicated_Type_Sel)_tmp;
	}
	_serNrSysDecNR_ASN1_BWP_UplinkDedicated_Type_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_ASN1_BWP_UplinkDedicated_Type_Dedicated_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_ASN1_BWP_UplinkDedicated_Type_Dedicated_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecNR_ASN1_BWP_UplinkDedicated_Type(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_UplinkBWP_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_UplinkBWP_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecSQN_NR_BWP_Id_NR_UplinkBWP_Type_Id_Optional(_buffer, _size, _lidx, &p->Id);
	_serNrSysDecNR_ASN1_BWP_UplinkCommon_Type_Common_Optional(_buffer, _size, _lidx, _mem, &p->Common);
	_serNrSysDecNR_ASN1_BWP_UplinkDedicated_Type_Dedicated_Optional(_buffer, _size, _lidx, _mem, &p->Dedicated);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_UplinkBWP_List_Type_BwpArray_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_UplinkBWP_List_Type_BwpArray_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = (struct NR_UplinkBWP_Type*)serMalloc(_mem, p->v.d * sizeof(struct NR_UplinkBWP_Type));
	for (size_t i1 = 0; i1 < p->v.d; i1++) {
		_serNrSysDecNR_UplinkBWP_Type(_buffer, _size, _lidx, _mem, &p->v.v[i1]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_UplinkBWPs_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_UplinkBWPs_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecNR_ActiveUplinkBWP_Id_Type_ActiveBWP_Optional(_buffer, _size, _lidx, &p->ActiveBWP);
	_serNrSysDecNR_UplinkBWP_List_Type_BwpArray_Optional(_buffer, _size, _lidx, _mem, &p->BwpArray);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_UplinkBWPs_Type_BWPs_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_UplinkBWPs_Type_BWPs_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecNR_UplinkBWPs_Type(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_CFRA_occasions_ssb_perRACH_Occasion_e_ssb_perRACH_Occasion_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_CFRA_occasions_ssb_perRACH_Occasion_e_ssb_perRACH_Occasion_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_CFRA_occasions_ssb_perRACH_Occasion_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_CFRA_occasions(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_CFRA_occasions* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecSQN_NR_RACH_ConfigGeneric(_buffer, _size, _lidx, &p->rach_ConfigGeneric);
	_serNrSysDecSQN_NR_CFRA_occasions_ssb_perRACH_Occasion_e_ssb_perRACH_Occasion_Optional(_buffer, _size, _lidx, &p->ssb_perRACH_Occasion);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_CFRA_occasions_occasions_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_CFRA_occasions_occasions_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_CFRA_occasions(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecUint16_t_SQN_NR_CFRA_SSB_Resource_msgA_PUSCH_resource_Index_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct uint16_t_SQN_NR_CFRA_SSB_Resource_msgA_PUSCH_resource_Index_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_16(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_CFRA_SSB_Resource(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_CFRA_SSB_Resource* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->ssb, &_buffer[*_lidx], _lidx);
	NTOH_8(p->ra_PreambleIndex, &_buffer[*_lidx], _lidx);
	_serNrSysDecUint16_t_SQN_NR_CFRA_SSB_Resource_msgA_PUSCH_resource_Index_r16_Optional(_buffer, _size, _lidx, &p->msgA_PUSCH_resource_Index_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_CFRA_resources_ssb(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_CFRA_resources_ssb* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_32(p->ssb_ResourceList.d, &_buffer[*_lidx], _lidx);
	p->ssb_ResourceList.v = (struct SQN_NR_CFRA_SSB_Resource*)serMalloc(_mem, p->ssb_ResourceList.d * sizeof(struct SQN_NR_CFRA_SSB_Resource));
	for (size_t i1 = 0; i1 < p->ssb_ResourceList.d; i1++) {
		_serNrSysDecSQN_NR_CFRA_SSB_Resource(_buffer, _size, _lidx, &p->ssb_ResourceList.v[i1]);
	}
	NTOH_8(p->ra_ssb_OccasionMaskIndex, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_CFRA_CSIRS_Resource(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_CFRA_CSIRS_Resource* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->csi_RS, &_buffer[*_lidx], _lidx);
	NTOH_32(p->ra_OccasionList.d, &_buffer[*_lidx], _lidx);
	p->ra_OccasionList.v = (uint16_t*)serMalloc(_mem, p->ra_OccasionList.d * sizeof(uint16_t));
	for (size_t i2 = 0; i2 < p->ra_OccasionList.d; i2++) {
		NTOH_16(p->ra_OccasionList.v[i2], &_buffer[*_lidx], _lidx);
	}
	NTOH_8(p->ra_PreambleIndex, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_CFRA_resources_csirs(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_CFRA_resources_csirs* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_32(p->csirs_ResourceList.d, &_buffer[*_lidx], _lidx);
	p->csirs_ResourceList.v = (struct SQN_NR_CFRA_CSIRS_Resource*)serMalloc(_mem, p->csirs_ResourceList.d * sizeof(struct SQN_NR_CFRA_CSIRS_Resource));
	for (size_t i1 = 0; i1 < p->csirs_ResourceList.d; i1++) {
		_serNrSysDecSQN_NR_CFRA_CSIRS_Resource(_buffer, _size, _lidx, _mem, &p->csirs_ResourceList.v[i1]);
	}
	NTOH_8(p->rsrp_ThresholdCSI_RS, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_CFRA_resources_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union SQN_NR_CFRA_resources_Value* p, enum SQN_NR_CFRA_resources_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_CFRA_resources_ssb) {
		_serNrSysDecSQN_NR_CFRA_resources_ssb(_buffer, _size, _lidx, _mem, &p->ssb);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_CFRA_resources_csirs) {
		_serNrSysDecSQN_NR_CFRA_resources_csirs(_buffer, _size, _lidx, _mem, &p->csirs);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecSQN_NR_CFRA_resources(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_CFRA_resources* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SQN_NR_CFRA_resources_Sel)_tmp;
	}
	_serNrSysDecSQN_NR_CFRA_resources_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecUint8_t_SQN_NR_CFRA_totalNumberOfRA_Preambles_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct uint8_t_SQN_NR_CFRA_totalNumberOfRA_Preambles_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_CFRA(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_CFRA* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecSQN_NR_CFRA_occasions_occasions_Optional(_buffer, _size, _lidx, &p->occasions);
	_serNrSysDecSQN_NR_CFRA_resources(_buffer, _size, _lidx, _mem, &p->resources);
	_serNrSysDecUint8_t_SQN_NR_CFRA_totalNumberOfRA_Preambles_Optional(_buffer, _size, _lidx, &p->totalNumberOfRA_Preambles);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_CFRA_SQN_NR_RACH_ConfigDedicated_cfra_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_CFRA_SQN_NR_RACH_ConfigDedicated_cfra_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_CFRA(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_RA_Prioritization_SQN_NR_RACH_ConfigDedicated_ra_Prioritization_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_RA_Prioritization_SQN_NR_RACH_ConfigDedicated_ra_Prioritization_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_RA_Prioritization(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_RA_Prioritization_SQN_NR_RACH_ConfigDedicated_ra_PrioritizationTwoStep_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_RA_Prioritization_SQN_NR_RACH_ConfigDedicated_ra_PrioritizationTwoStep_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_RA_Prioritization(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_CFRA_TwoStep_r16_occasionsTwoStepRA_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_CFRA_TwoStep_r16_occasionsTwoStepRA_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecSQN_NR_RACH_ConfigGenericTwoStepRA_r16(_buffer, _size, _lidx, &p->rach_ConfigGenericTwoStepRA_r16);
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->ssb_PerRACH_OccasionTwoStepRA_r16 = (SQN_NR_CFRA_TwoStep_r16_occasionsTwoStepRA_r16_ssb_PerRACH_OccasionTwoStepRA_r16_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_CFRA_TwoStep_r16_occasionsTwoStepRA_r16_occasionsTwoStepRA_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_CFRA_TwoStep_r16_occasionsTwoStepRA_r16_occasionsTwoStepRA_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_CFRA_TwoStep_r16_occasionsTwoStepRA_r16(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_CFRA_TwoStep_r16_msgA_TransMax_r16_e_msgA_TransMax_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_CFRA_TwoStep_r16_msgA_TransMax_r16_e_msgA_TransMax_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_CFRA_TwoStep_r16_msgA_TransMax_r16_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_CFRA_TwoStep_r16_resourcesTwoStep_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_CFRA_TwoStep_r16_resourcesTwoStep_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_32(p->ssb_ResourceList.d, &_buffer[*_lidx], _lidx);
	p->ssb_ResourceList.v = (struct SQN_NR_CFRA_SSB_Resource*)serMalloc(_mem, p->ssb_ResourceList.d * sizeof(struct SQN_NR_CFRA_SSB_Resource));
	for (size_t i1 = 0; i1 < p->ssb_ResourceList.d; i1++) {
		_serNrSysDecSQN_NR_CFRA_SSB_Resource(_buffer, _size, _lidx, &p->ssb_ResourceList.v[i1]);
	}
	NTOH_8(p->ra_ssb_OccasionMaskIndex, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_CFRA_TwoStep_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_CFRA_TwoStep_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecSQN_NR_CFRA_TwoStep_r16_occasionsTwoStepRA_r16_occasionsTwoStepRA_r16_Optional(_buffer, _size, _lidx, &p->occasionsTwoStepRA_r16);
	_serNrSysDecSQN_NR_MsgA_PUSCH_Resource_r16(_buffer, _size, _lidx, &p->msgA_CFRA_PUSCH_r16);
	_serNrSysDecSQN_NR_CFRA_TwoStep_r16_msgA_TransMax_r16_e_msgA_TransMax_r16_Optional(_buffer, _size, _lidx, &p->msgA_TransMax_r16);
	_serNrSysDecSQN_NR_CFRA_TwoStep_r16_resourcesTwoStep_r16(_buffer, _size, _lidx, _mem, &p->resourcesTwoStep_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_CFRA_TwoStep_r16_SQN_NR_RACH_ConfigDedicated_cfra_TwoStep_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_CFRA_TwoStep_r16_SQN_NR_RACH_ConfigDedicated_cfra_TwoStep_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_CFRA_TwoStep_r16(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_RACH_ConfigDedicated(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_RACH_ConfigDedicated* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecSQN_NR_CFRA_SQN_NR_RACH_ConfigDedicated_cfra_Optional(_buffer, _size, _lidx, _mem, &p->cfra);
	_serNrSysDecSQN_NR_RA_Prioritization_SQN_NR_RACH_ConfigDedicated_ra_Prioritization_Optional(_buffer, _size, _lidx, &p->ra_Prioritization);
	_serNrSysDecSQN_NR_RA_Prioritization_SQN_NR_RACH_ConfigDedicated_ra_PrioritizationTwoStep_r16_Optional(_buffer, _size, _lidx, &p->ra_PrioritizationTwoStep_r16);
	_serNrSysDecSQN_NR_CFRA_TwoStep_r16_SQN_NR_RACH_ConfigDedicated_cfra_TwoStep_r16_Optional(_buffer, _size, _lidx, _mem, &p->cfra_TwoStep_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_ASN1_RACH_ConfigDedicated_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union NR_ASN1_RACH_ConfigDedicated_Type_Value* p, enum NR_ASN1_RACH_ConfigDedicated_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_ASN1_RACH_ConfigDedicated_Type_R15) {
		_serNrSysDecSQN_NR_RACH_ConfigDedicated(_buffer, _size, _lidx, _mem, &p->R15);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecNR_ASN1_RACH_ConfigDedicated_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_ASN1_RACH_ConfigDedicated_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum NR_ASN1_RACH_ConfigDedicated_Type_Sel)_tmp;
	}
	_serNrSysDecNR_ASN1_RACH_ConfigDedicated_Type_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_ASN1_RACH_ConfigDedicated_Type_RACH_ConfigDedicated_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_ASN1_RACH_ConfigDedicated_Type_RACH_ConfigDedicated_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecNR_ASN1_RACH_ConfigDedicated_Type(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SI_RequestConfig_rach_OccasionsSI(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SI_RequestConfig_rach_OccasionsSI* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecSQN_NR_RACH_ConfigGeneric(_buffer, _size, _lidx, &p->rach_ConfigSI);
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->ssb_perRACH_Occasion = (SQN_NR_SI_RequestConfig_rach_OccasionsSI_ssb_perRACH_Occasion_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SI_RequestConfig_rach_OccasionsSI_rach_OccasionsSI_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SI_RequestConfig_rach_OccasionsSI_rach_OccasionsSI_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_SI_RequestConfig_rach_OccasionsSI(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SI_RequestConfig_si_RequestPeriod_e_si_RequestPeriod_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SI_RequestConfig_si_RequestPeriod_e_si_RequestPeriod_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_SI_RequestConfig_si_RequestPeriod_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecUint8_t_SQN_NR_SI_RequestResources_ra_AssociationPeriodIndex_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct uint8_t_SQN_NR_SI_RequestResources_ra_AssociationPeriodIndex_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecUint8_t_SQN_NR_SI_RequestResources_ra_ssb_OccasionMaskIndex_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct uint8_t_SQN_NR_SI_RequestResources_ra_ssb_OccasionMaskIndex_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SI_RequestResources(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SI_RequestResources* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->ra_PreambleStartIndex, &_buffer[*_lidx], _lidx);
	_serNrSysDecUint8_t_SQN_NR_SI_RequestResources_ra_AssociationPeriodIndex_Optional(_buffer, _size, _lidx, &p->ra_AssociationPeriodIndex);
	_serNrSysDecUint8_t_SQN_NR_SI_RequestResources_ra_ssb_OccasionMaskIndex_Optional(_buffer, _size, _lidx, &p->ra_ssb_OccasionMaskIndex);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SI_RequestConfig(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_SI_RequestConfig* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecSQN_NR_SI_RequestConfig_rach_OccasionsSI_rach_OccasionsSI_Optional(_buffer, _size, _lidx, &p->rach_OccasionsSI);
	_serNrSysDecSQN_NR_SI_RequestConfig_si_RequestPeriod_e_si_RequestPeriod_Optional(_buffer, _size, _lidx, &p->si_RequestPeriod);
	NTOH_32(p->si_RequestResources.d, &_buffer[*_lidx], _lidx);
	p->si_RequestResources.v = (struct SQN_NR_SI_RequestResources*)serMalloc(_mem, p->si_RequestResources.d * sizeof(struct SQN_NR_SI_RequestResources));
	for (size_t i1 = 0; i1 < p->si_RequestResources.d; i1++) {
		_serNrSysDecSQN_NR_SI_RequestResources(_buffer, _size, _lidx, &p->si_RequestResources.v[i1]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_ASN1_SI_RequestConfig_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union NR_ASN1_SI_RequestConfig_Type_Value* p, enum NR_ASN1_SI_RequestConfig_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_ASN1_SI_RequestConfig_Type_R15) {
		_serNrSysDecSQN_NR_SI_RequestConfig(_buffer, _size, _lidx, _mem, &p->R15);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecNR_ASN1_SI_RequestConfig_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_ASN1_SI_RequestConfig_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum NR_ASN1_SI_RequestConfig_Type_Sel)_tmp;
	}
	_serNrSysDecNR_ASN1_SI_RequestConfig_Type_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_ASN1_SI_RequestConfig_Type_SI_RequestConfig_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_ASN1_SI_RequestConfig_Type_SI_RequestConfig_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecNR_ASN1_SI_RequestConfig_Type(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_UplinkConfig_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_UplinkConfig_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecNR_ASN1_FrequencyInfoUL_Type_FrequencyInfoUL_Optional(_buffer, _size, _lidx, _mem, &p->FrequencyInfoUL);
	_serNrSysDecNR_UplinkBWPs_Type_BWPs_Optional(_buffer, _size, _lidx, _mem, &p->BWPs);
	_serNrSysDecNR_ASN1_RACH_ConfigDedicated_Type_RACH_ConfigDedicated_Optional(_buffer, _size, _lidx, _mem, &p->RACH_ConfigDedicated);
	_serNrSysDecNR_ASN1_SI_RequestConfig_Type_SI_RequestConfig_Optional(_buffer, _size, _lidx, _mem, &p->SI_RequestConfig);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_Uplink_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union NR_Uplink_Type_Value* p, enum NR_Uplink_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_Uplink_Type_Config) {
		_serNrSysDecNR_UplinkConfig_Type(_buffer, _size, _lidx, _mem, &p->Config);
		return SIDL_STATUS_OK;
	}
	if (d == NR_Uplink_Type_None) {
		NTOH_8(p->None, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecNR_Uplink_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_Uplink_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum NR_Uplink_Type_Sel)_tmp;
	}
	_serNrSysDecNR_Uplink_Type_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_Uplink_Type_Uplink_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_Uplink_Type_Uplink_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecNR_Uplink_Type(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_Uplink_Type_SupplementaryUplink_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_Uplink_Type_SupplementaryUplink_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecNR_Uplink_Type(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_SS_TimingAdvanceConfig_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union NR_SS_TimingAdvanceConfig_Type_Value* p, enum NR_SS_TimingAdvanceConfig_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_SS_TimingAdvanceConfig_Type_InitialValue) {
		NTOH_16(p->InitialValue, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == NR_SS_TimingAdvanceConfig_Type_Relative) {
		NTOH_8(p->Relative, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecNR_SS_TimingAdvanceConfig_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_SS_TimingAdvanceConfig_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum NR_SS_TimingAdvanceConfig_Type_Sel)_tmp;
	}
	_serNrSysDecNR_SS_TimingAdvanceConfig_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_SS_TimingAdvanceConfig_Type_TimingAdvance_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_SS_TimingAdvanceConfig_Type_TimingAdvance_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecNR_SS_TimingAdvanceConfig_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PUSCH_CodeBlockGroupTransmission(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_PUSCH_CodeBlockGroupTransmission* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->maxCodeBlockGroupsPerTransportBlock = (SQN_NR_PUSCH_CodeBlockGroupTransmission_maxCodeBlockGroupsPerTransportBlock_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SetupRelease_PUSCH_ServingCellConfig_codeBlockGroupTransmission_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union SQN_NR_SetupRelease_PUSCH_ServingCellConfig_codeBlockGroupTransmission_Value* p, enum SQN_NR_SetupRelease_PUSCH_ServingCellConfig_codeBlockGroupTransmission_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SetupRelease_PUSCH_ServingCellConfig_codeBlockGroupTransmission_release) {
		NTOH_8(p->release, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SetupRelease_PUSCH_ServingCellConfig_codeBlockGroupTransmission_setup) {
		_serNrSysDecSQN_NR_PUSCH_CodeBlockGroupTransmission(_buffer, _size, _lidx, &p->setup);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecSQN_NR_SetupRelease_PUSCH_ServingCellConfig_codeBlockGroupTransmission(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SetupRelease_PUSCH_ServingCellConfig_codeBlockGroupTransmission* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SQN_NR_SetupRelease_PUSCH_ServingCellConfig_codeBlockGroupTransmission_Sel)_tmp;
	}
	_serNrSysDecSQN_NR_SetupRelease_PUSCH_ServingCellConfig_codeBlockGroupTransmission_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SetupRelease_PUSCH_ServingCellConfig_codeBlockGroupTransmission_SQN_NR_PUSCH_ServingCellConfig_codeBlockGroupTransmission_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SetupRelease_PUSCH_ServingCellConfig_codeBlockGroupTransmission_SQN_NR_PUSCH_ServingCellConfig_codeBlockGroupTransmission_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_SetupRelease_PUSCH_ServingCellConfig_codeBlockGroupTransmission(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PUSCH_ServingCellConfig_rateMatching_e_rateMatching_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_PUSCH_ServingCellConfig_rateMatching_e_rateMatching_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_PUSCH_ServingCellConfig_rateMatching_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PUSCH_ServingCellConfig_xOverhead_e_xOverhead_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_PUSCH_ServingCellConfig_xOverhead_e_xOverhead_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_PUSCH_ServingCellConfig_xOverhead_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecUint8_t_SQN_NR_PUSCH_ServingCellConfig_maxMIMO_Layers_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct uint8_t_SQN_NR_PUSCH_ServingCellConfig_maxMIMO_Layers_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecBool_SQN_NR_PUSCH_ServingCellConfig_processingType2Enabled_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct bool_SQN_NR_PUSCH_ServingCellConfig_processingType2Enabled_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SetupRelease_PUSCH_ServingCellConfig_maxMIMO_LayersDCI_0_2_r16_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union SQN_NR_SetupRelease_PUSCH_ServingCellConfig_maxMIMO_LayersDCI_0_2_r16_Value* p, enum SQN_NR_SetupRelease_PUSCH_ServingCellConfig_maxMIMO_LayersDCI_0_2_r16_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SetupRelease_PUSCH_ServingCellConfig_maxMIMO_LayersDCI_0_2_r16_release) {
		NTOH_8(p->release, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SetupRelease_PUSCH_ServingCellConfig_maxMIMO_LayersDCI_0_2_r16_setup) {
		NTOH_8(p->setup, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecSQN_NR_SetupRelease_PUSCH_ServingCellConfig_maxMIMO_LayersDCI_0_2_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SetupRelease_PUSCH_ServingCellConfig_maxMIMO_LayersDCI_0_2_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SQN_NR_SetupRelease_PUSCH_ServingCellConfig_maxMIMO_LayersDCI_0_2_r16_Sel)_tmp;
	}
	_serNrSysDecSQN_NR_SetupRelease_PUSCH_ServingCellConfig_maxMIMO_LayersDCI_0_2_r16_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SetupRelease_PUSCH_ServingCellConfig_maxMIMO_LayersDCI_0_2_r16_SQN_NR_PUSCH_ServingCellConfig_maxMIMO_LayersDCI_0_2_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SetupRelease_PUSCH_ServingCellConfig_maxMIMO_LayersDCI_0_2_r16_SQN_NR_PUSCH_ServingCellConfig_maxMIMO_LayersDCI_0_2_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_SetupRelease_PUSCH_ServingCellConfig_maxMIMO_LayersDCI_0_2_r16(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PUSCH_ServingCellConfig(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_PUSCH_ServingCellConfig* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecSQN_NR_SetupRelease_PUSCH_ServingCellConfig_codeBlockGroupTransmission_SQN_NR_PUSCH_ServingCellConfig_codeBlockGroupTransmission_Optional(_buffer, _size, _lidx, &p->codeBlockGroupTransmission);
	_serNrSysDecSQN_NR_PUSCH_ServingCellConfig_rateMatching_e_rateMatching_Optional(_buffer, _size, _lidx, &p->rateMatching);
	_serNrSysDecSQN_NR_PUSCH_ServingCellConfig_xOverhead_e_xOverhead_Optional(_buffer, _size, _lidx, &p->xOverhead);
	_serNrSysDecUint8_t_SQN_NR_PUSCH_ServingCellConfig_maxMIMO_Layers_Optional(_buffer, _size, _lidx, &p->maxMIMO_Layers);
	_serNrSysDecBool_SQN_NR_PUSCH_ServingCellConfig_processingType2Enabled_Optional(_buffer, _size, _lidx, &p->processingType2Enabled);
	_serNrSysDecSQN_NR_SetupRelease_PUSCH_ServingCellConfig_maxMIMO_LayersDCI_0_2_r16_SQN_NR_PUSCH_ServingCellConfig_maxMIMO_LayersDCI_0_2_r16_Optional(_buffer, _size, _lidx, &p->maxMIMO_LayersDCI_0_2_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_ASN1_PUSCH_ServingCellConfig_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union NR_ASN1_PUSCH_ServingCellConfig_Type_Value* p, enum NR_ASN1_PUSCH_ServingCellConfig_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_ASN1_PUSCH_ServingCellConfig_Type_R15) {
		_serNrSysDecSQN_NR_PUSCH_ServingCellConfig(_buffer, _size, _lidx, &p->R15);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecNR_ASN1_PUSCH_ServingCellConfig_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_ASN1_PUSCH_ServingCellConfig_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum NR_ASN1_PUSCH_ServingCellConfig_Type_Sel)_tmp;
	}
	_serNrSysDecNR_ASN1_PUSCH_ServingCellConfig_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_ASN1_PUSCH_ServingCellConfig_Type_PUSCH_ServingCellConfig_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_ASN1_PUSCH_ServingCellConfig_Type_PUSCH_ServingCellConfig_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecNR_ASN1_PUSCH_ServingCellConfig_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_ASN1_PUSCH_ServingCellConfig_Type_PUSCH_ServingCellConfigSUL_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_ASN1_PUSCH_ServingCellConfig_Type_PUSCH_ServingCellConfigSUL_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecNR_ASN1_PUSCH_ServingCellConfig_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_CellConfigPhysicalLayerUplink_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_CellConfigPhysicalLayerUplink_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecNR_Uplink_Type_Uplink_Optional(_buffer, _size, _lidx, _mem, &p->Uplink);
	_serNrSysDecNR_Uplink_Type_SupplementaryUplink_Optional(_buffer, _size, _lidx, _mem, &p->SupplementaryUplink);
	_serNrSysDecNR_SS_TimingAdvanceConfig_Type_TimingAdvance_Optional(_buffer, _size, _lidx, &p->TimingAdvance);
	_serNrSysDecNR_ASN1_PUSCH_ServingCellConfig_Type_PUSCH_ServingCellConfig_Optional(_buffer, _size, _lidx, &p->PUSCH_ServingCellConfig);
	_serNrSysDecNR_ASN1_PUSCH_ServingCellConfig_Type_PUSCH_ServingCellConfigSUL_Optional(_buffer, _size, _lidx, &p->PUSCH_ServingCellConfigSUL);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_CellConfigPhysicalLayerUplink_Type_Uplink_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_CellConfigPhysicalLayerUplink_Type_Uplink_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecNR_CellConfigPhysicalLayerUplink_Type(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_CellConfigPhysicalLayer_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_CellConfigPhysicalLayer_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecNR_CellConfigPhysicalLayerCommon_Type_Common_Optional(_buffer, _size, _lidx, _mem, &p->Common);
	_serNrSysDecNR_CellConfigPhysicalLayerDownlink_Type_Downlink_Optional(_buffer, _size, _lidx, _mem, &p->Downlink);
	_serNrSysDecNR_CellConfigPhysicalLayerUplink_Type_Uplink_Optional(_buffer, _size, _lidx, _mem, &p->Uplink);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_CellConfigPhysicalLayer_Type_PhysicalLayer_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_CellConfigPhysicalLayer_Type_PhysicalLayer_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecNR_CellConfigPhysicalLayer_Type(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_BcchToPbchConfig_Type_Pbch_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_BcchToPbchConfig_Type_Pbch_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNull_Type_ActiveBWP_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct Null_Type_ActiveBWP_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNull_Type_InitialBWP_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct Null_Type_InitialBWP_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_AssignedBWPs_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_AssignedBWPs_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecNull_Type_ActiveBWP_Optional(_buffer, _size, _lidx, &p->ActiveBWP);
	_serNrSysDecNull_Type_InitialBWP_Optional(_buffer, _size, _lidx, &p->InitialBWP);
	NTOH_32(p->DedicatedBWPs.d, &_buffer[*_lidx], _lidx);
	p->DedicatedBWPs.v = (SQN_NR_BWP_Id*)serMalloc(_mem, p->DedicatedBWPs.d * sizeof(SQN_NR_BWP_Id));
	for (size_t i1 = 0; i1 < p->DedicatedBWPs.d; i1++) {
		NTOH_8(p->DedicatedBWPs.v[i1], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_AssignedBWPs_Type_NR_SearchSpaceDlDciAssignment_Type_AssignedBWPs_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_AssignedBWPs_Type_NR_SearchSpaceDlDciAssignment_Type_AssignedBWPs_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecNR_AssignedBWPs_Type(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_SearchSpaceType_Type_NR_SearchSpaceDlDciAssignment_Type_SearchSpaceType_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_SearchSpaceType_Type_NR_SearchSpaceDlDciAssignment_Type_SearchSpaceType_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (NR_SearchSpaceType_Type)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_ResourceAllocationType_Type_NR_DciFormat_1_X_ResourceAssignment_Type_ResourceAllocationType_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_ResourceAllocationType_Type_NR_DciFormat_1_X_ResourceAssignment_Type_ResourceAllocationType_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (NR_ResourceAllocationType_Type)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_FreqDomainSchedulCommonDL_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_FreqDomainSchedulCommonDL_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_32(p->FirstRbIndex, &_buffer[*_lidx], _lidx);
	NTOH_32(p->MaxRbCnt, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_FreqDomainSchedulExplicit_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_FreqDomainSchedulExplicit_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_32(p->FirstRbIndex, &_buffer[*_lidx], _lidx);
	NTOH_32(p->Nprb, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_FreqDomainResourceAssignmentDL_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union NR_FreqDomainResourceAssignmentDL_Type_Value* p, enum NR_FreqDomainResourceAssignmentDL_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_FreqDomainResourceAssignmentDL_Type_Automatic) {
		_serNrSysDecNR_FreqDomainSchedulCommonDL_Type(_buffer, _size, _lidx, &p->Automatic);
		return SIDL_STATUS_OK;
	}
	if (d == NR_FreqDomainResourceAssignmentDL_Type_Explicit) {
		_serNrSysDecNR_FreqDomainSchedulExplicit_Type(_buffer, _size, _lidx, &p->Explicit);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecNR_FreqDomainResourceAssignmentDL_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_FreqDomainResourceAssignmentDL_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum NR_FreqDomainResourceAssignmentDL_Type_Sel)_tmp;
	}
	_serNrSysDecNR_FreqDomainResourceAssignmentDL_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_FreqDomainResourceAssignmentDL_Type_FreqDomain_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_FreqDomainResourceAssignmentDL_Type_FreqDomain_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecNR_FreqDomainResourceAssignmentDL_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_DciCommon_TimeDomainResourceAssignment_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union NR_DciCommon_TimeDomainResourceAssignment_Type_Value* p, enum NR_DciCommon_TimeDomainResourceAssignment_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_DciCommon_TimeDomainResourceAssignment_Type_Index) {
		NTOH_32(p->Index.d, &_buffer[*_lidx], _lidx);
		p->Index.v = (BIT_STRING_ELEMENT*)serMalloc(_mem, p->Index.d * sizeof(BIT_STRING_ELEMENT));
		for (size_t i1 = 0; i1 < p->Index.d; i1++) {
			NTOH_8(p->Index.v[i1], &_buffer[*_lidx], _lidx);
		}
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecNR_DciCommon_TimeDomainResourceAssignment_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_DciCommon_TimeDomainResourceAssignment_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum NR_DciCommon_TimeDomainResourceAssignment_Type_Sel)_tmp;
	}
	_serNrSysDecNR_DciCommon_TimeDomainResourceAssignment_Type_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_DciCommon_TimeDomainResourceAssignment_Type_NR_DciFormat_1_X_ResourceAssignment_Type_TimeDomain_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_DciCommon_TimeDomainResourceAssignment_Type_NR_DciFormat_1_X_ResourceAssignment_Type_TimeDomain_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecNR_DciCommon_TimeDomainResourceAssignment_Type(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_ModulationSchemePDSCH_Type_TransportBlock2_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_ModulationSchemePDSCH_Type_TransportBlock2_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (NR_ModulationSchemePDSCH_Type)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_RedundancyVersionList_Type_RedundancyVersionList_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_RedundancyVersionList_Type_RedundancyVersionList_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = (NR_RedundancyVersion_Type*)serMalloc(_mem, p->v.d * sizeof(NR_RedundancyVersion_Type));
	for (size_t i1 = 0; i1 < p->v.d; i1++) {
		NTOH_8(p->v.v[i1], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_TransportBlockSchedulingDL_Automatic_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_TransportBlockSchedulingDL_Automatic_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->TransportBlock1 = (NR_ModulationSchemePDSCH_Type)_tmp;
	}
	_serNrSysDecNR_ModulationSchemePDSCH_Type_TransportBlock2_Optional(_buffer, _size, _lidx, &p->TransportBlock2);
	_serNrSysDecNR_RedundancyVersionList_Type_RedundancyVersionList_Optional(_buffer, _size, _lidx, _mem, &p->RedundancyVersionList);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecRetransmissionTiming_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union RetransmissionTiming_Type_Value* p, enum RetransmissionTiming_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == RetransmissionTiming_Type_SlotOffset) {
		NTOH_32(p->SlotOffset, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == RetransmissionTiming_Type_SubframeOffset) {
		NTOH_32(p->SubframeOffset, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == RetransmissionTiming_Type_AnyTime) {
		NTOH_8(p->AnyTime, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecRetransmissionTiming_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct RetransmissionTiming_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum RetransmissionTiming_Type_Sel)_tmp;
	}
	_serNrSysDecRetransmissionTiming_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecTransmissionTimingOffset_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union TransmissionTimingOffset_Type_Value* p, enum TransmissionTimingOffset_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == TransmissionTimingOffset_Type_None) {
		NTOH_8(p->None, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == TransmissionTimingOffset_Type_Retransmission) {
		_serNrSysDecRetransmissionTiming_Type(_buffer, _size, _lidx, &p->Retransmission);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecTransmissionTimingOffset_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct TransmissionTimingOffset_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum TransmissionTimingOffset_Type_Sel)_tmp;
	}
	_serNrSysDecTransmissionTimingOffset_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_TransportBlockSingleTransmission_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_TransportBlockSingleTransmission_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecTransmissionTimingOffset_Type(_buffer, _size, _lidx, &p->TimingOffset);
	NTOH_8(p->ImcsValue, &_buffer[*_lidx], _lidx);
	NTOH_8(p->RedundancyVersion, &_buffer[*_lidx], _lidx);
	NTOH_8(p->ToggleNDI, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_TransportBlockRetransmissionList_Type_TransportBlock2_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_TransportBlockRetransmissionList_Type_TransportBlock2_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = (struct NR_TransportBlockSingleTransmission_Type*)serMalloc(_mem, p->v.d * sizeof(struct NR_TransportBlockSingleTransmission_Type));
	for (size_t i1 = 0; i1 < p->v.d; i1++) {
		_serNrSysDecNR_TransportBlockSingleTransmission_Type(_buffer, _size, _lidx, &p->v.v[i1]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_TransportBlockSchedulingDL_Explicit_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_TransportBlockSchedulingDL_Explicit_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_32(p->TransportBlock1.d, &_buffer[*_lidx], _lidx);
	p->TransportBlock1.v = (struct NR_TransportBlockSingleTransmission_Type*)serMalloc(_mem, p->TransportBlock1.d * sizeof(struct NR_TransportBlockSingleTransmission_Type));
	for (size_t i1 = 0; i1 < p->TransportBlock1.d; i1++) {
		_serNrSysDecNR_TransportBlockSingleTransmission_Type(_buffer, _size, _lidx, &p->TransportBlock1.v[i1]);
	}
	_serNrSysDecNR_TransportBlockRetransmissionList_Type_TransportBlock2_Optional(_buffer, _size, _lidx, _mem, &p->TransportBlock2);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_TransportBlockSchedulingDL_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union NR_TransportBlockSchedulingDL_Type_Value* p, enum NR_TransportBlockSchedulingDL_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_TransportBlockSchedulingDL_Type_Automatic) {
		_serNrSysDecNR_TransportBlockSchedulingDL_Automatic_Type(_buffer, _size, _lidx, _mem, &p->Automatic);
		return SIDL_STATUS_OK;
	}
	if (d == NR_TransportBlockSchedulingDL_Type_Explicit) {
		_serNrSysDecNR_TransportBlockSchedulingDL_Explicit_Type(_buffer, _size, _lidx, _mem, &p->Explicit);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecNR_TransportBlockSchedulingDL_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_TransportBlockSchedulingDL_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum NR_TransportBlockSchedulingDL_Type_Sel)_tmp;
	}
	_serNrSysDecNR_TransportBlockSchedulingDL_Type_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_TransportBlockSchedulingDL_Type_TransportBlockScheduling_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_TransportBlockSchedulingDL_Type_TransportBlockScheduling_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecNR_TransportBlockSchedulingDL_Type(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_HarqProcessConfig_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union NR_HarqProcessConfig_Type_Value* p, enum NR_HarqProcessConfig_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_HarqProcessConfig_Type_None) {
		NTOH_8(p->None, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == NR_HarqProcessConfig_Type_Broadcast) {
		NTOH_8(p->Broadcast, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == NR_HarqProcessConfig_Type_AnyProcess) {
		NTOH_8(p->AnyProcess, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == NR_HarqProcessConfig_Type_SpecificSubset) {
		NTOH_32(p->SpecificSubset.d, &_buffer[*_lidx], _lidx);
		p->SpecificSubset.v = (NR_HarqProcessId_Type*)serMalloc(_mem, p->SpecificSubset.d * sizeof(NR_HarqProcessId_Type));
		for (size_t i1 = 0; i1 < p->SpecificSubset.d; i1++) {
			NTOH_32(p->SpecificSubset.v[i1], &_buffer[*_lidx], _lidx);
		}
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecNR_HarqProcessConfig_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_HarqProcessConfig_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum NR_HarqProcessConfig_Type_Sel)_tmp;
	}
	_serNrSysDecNR_HarqProcessConfig_Type_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_HarqProcessConfig_Type_NR_DciFormat_1_X_ResourceAssignment_Type_HarqProcessConfig_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_HarqProcessConfig_Type_NR_DciFormat_1_X_ResourceAssignment_Type_HarqProcessConfig_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecNR_HarqProcessConfig_Type(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_DciFormat_1_X_ResourceAssignment_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_DciFormat_1_X_ResourceAssignment_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecNR_ResourceAllocationType_Type_NR_DciFormat_1_X_ResourceAssignment_Type_ResourceAllocationType_Optional(_buffer, _size, _lidx, &p->ResourceAllocationType);
	_serNrSysDecNR_FreqDomainResourceAssignmentDL_Type_FreqDomain_Optional(_buffer, _size, _lidx, &p->FreqDomain);
	_serNrSysDecNR_DciCommon_TimeDomainResourceAssignment_Type_NR_DciFormat_1_X_ResourceAssignment_Type_TimeDomain_Optional(_buffer, _size, _lidx, _mem, &p->TimeDomain);
	_serNrSysDecNR_TransportBlockSchedulingDL_Type_TransportBlockScheduling_Optional(_buffer, _size, _lidx, _mem, &p->TransportBlockScheduling);
	_serNrSysDecNR_HarqProcessConfig_Type_NR_DciFormat_1_X_ResourceAssignment_Type_HarqProcessConfig_Optional(_buffer, _size, _lidx, _mem, &p->HarqProcessConfig);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_DciFormat_1_X_ResourceAssignment_Type_ResoureAssignment_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_DciFormat_1_X_ResourceAssignment_Type_ResoureAssignment_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecNR_DciFormat_1_X_ResourceAssignment_Type(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_DciCommon_VrbPrbMapping_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union NR_DciCommon_VrbPrbMapping_Type_Value* p, enum NR_DciCommon_VrbPrbMapping_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_DciCommon_VrbPrbMapping_Type_None) {
		NTOH_8(p->None, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == NR_DciCommon_VrbPrbMapping_Type_Index) {
		for (size_t i1 = 0; i1 < 1; i1++) {
			NTOH_8(p->Index[i1], &_buffer[*_lidx], _lidx);
		}
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecNR_DciCommon_VrbPrbMapping_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_DciCommon_VrbPrbMapping_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum NR_DciCommon_VrbPrbMapping_Type_Sel)_tmp;
	}
	_serNrSysDecNR_DciCommon_VrbPrbMapping_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_DciCommon_VrbPrbMapping_Type_VrbPrbMapping_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_DciCommon_VrbPrbMapping_Type_VrbPrbMapping_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecNR_DciCommon_VrbPrbMapping_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecDAI_B2_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union DAI_B2_Type_Value* p, enum DAI_B2_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == DAI_B2_Type_Index) {
		for (size_t i1 = 0; i1 < 2; i1++) {
			NTOH_8(p->Index[i1], &_buffer[*_lidx], _lidx);
		}
		return SIDL_STATUS_OK;
	}
	if (d == DAI_B2_Type_Automatic) {
		NTOH_8(p->Automatic, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecDAI_B2_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct DAI_B2_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum DAI_B2_Type_Sel)_tmp;
	}
	_serNrSysDecDAI_B2_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_DciFormat_1_0_DAI_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union NR_DciFormat_1_0_DAI_Type_Value* p, enum NR_DciFormat_1_0_DAI_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_DciFormat_1_0_DAI_Type_Index) {
		_serNrSysDecDAI_B2_Type(_buffer, _size, _lidx, &p->Index);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecNR_DciFormat_1_0_DAI_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_DciFormat_1_0_DAI_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum NR_DciFormat_1_0_DAI_Type_Sel)_tmp;
	}
	_serNrSysDecNR_DciFormat_1_0_DAI_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_DciFormat_1_0_DAI_Type_DAI_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_DciFormat_1_0_DAI_Type_DAI_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecNR_DciFormat_1_0_DAI_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_DciCommon_TpcCommand_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union NR_DciCommon_TpcCommand_Type_Value* p, enum NR_DciCommon_TpcCommand_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_DciCommon_TpcCommand_Type_Value) {
		for (size_t i1 = 0; i1 < 2; i1++) {
			NTOH_8(p->Value[i1], &_buffer[*_lidx], _lidx);
		}
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecNR_DciCommon_TpcCommand_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_DciCommon_TpcCommand_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum NR_DciCommon_TpcCommand_Type_Sel)_tmp;
	}
	_serNrSysDecNR_DciCommon_TpcCommand_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_DciCommon_TpcCommand_Type_NR_DciFormat_1_0_SpecificInfo_Type_TpcCommandPucch_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_DciCommon_TpcCommand_Type_NR_DciFormat_1_0_SpecificInfo_Type_TpcCommandPucch_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecNR_DciCommon_TpcCommand_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_DciFormat_1_X_PucchResourceIndicator_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union NR_DciFormat_1_X_PucchResourceIndicator_Type_Value* p, enum NR_DciFormat_1_X_PucchResourceIndicator_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_DciFormat_1_X_PucchResourceIndicator_Type_Value) {
		for (size_t i1 = 0; i1 < 3; i1++) {
			NTOH_8(p->Value[i1], &_buffer[*_lidx], _lidx);
		}
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecNR_DciFormat_1_X_PucchResourceIndicator_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_DciFormat_1_X_PucchResourceIndicator_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum NR_DciFormat_1_X_PucchResourceIndicator_Type_Sel)_tmp;
	}
	_serNrSysDecNR_DciFormat_1_X_PucchResourceIndicator_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_DciFormat_1_X_PucchResourceIndicator_Type_NR_DciFormat_1_0_SpecificInfo_Type_PucchResourceIndicator_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_DciFormat_1_X_PucchResourceIndicator_Type_NR_DciFormat_1_0_SpecificInfo_Type_PucchResourceIndicator_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecNR_DciFormat_1_X_PucchResourceIndicator_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_DciFormat_1_X_PdschHarqTimingIndicator_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union NR_DciFormat_1_X_PdschHarqTimingIndicator_Type_Value* p, enum NR_DciFormat_1_X_PdschHarqTimingIndicator_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_DciFormat_1_X_PdschHarqTimingIndicator_Type_Value) {
		NTOH_32(p->Value.d, &_buffer[*_lidx], _lidx);
		p->Value.v = (BIT_STRING_ELEMENT*)serMalloc(_mem, p->Value.d * sizeof(BIT_STRING_ELEMENT));
		for (size_t i1 = 0; i1 < p->Value.d; i1++) {
			NTOH_8(p->Value.v[i1], &_buffer[*_lidx], _lidx);
		}
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecNR_DciFormat_1_X_PdschHarqTimingIndicator_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_DciFormat_1_X_PdschHarqTimingIndicator_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum NR_DciFormat_1_X_PdschHarqTimingIndicator_Type_Sel)_tmp;
	}
	_serNrSysDecNR_DciFormat_1_X_PdschHarqTimingIndicator_Type_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_DciFormat_1_X_PdschHarqTimingIndicator_Type_NR_DciFormat_1_0_SpecificInfo_Type_PdschHarqTimingIndicator_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_DciFormat_1_X_PdschHarqTimingIndicator_Type_NR_DciFormat_1_0_SpecificInfo_Type_PdschHarqTimingIndicator_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecNR_DciFormat_1_X_PdschHarqTimingIndicator_Type(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_DciFormat_X_0_ChannelAccessCPext_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union NR_DciFormat_X_0_ChannelAccessCPext_Type_Value* p, enum NR_DciFormat_X_0_ChannelAccessCPext_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_DciFormat_X_0_ChannelAccessCPext_Type_None) {
		NTOH_8(p->None, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == NR_DciFormat_X_0_ChannelAccessCPext_Type_Value) {
		for (size_t i1 = 0; i1 < 2; i1++) {
			NTOH_8(p->Value[i1], &_buffer[*_lidx], _lidx);
		}
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecNR_DciFormat_X_0_ChannelAccessCPext_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_DciFormat_X_0_ChannelAccessCPext_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum NR_DciFormat_X_0_ChannelAccessCPext_Type_Sel)_tmp;
	}
	_serNrSysDecNR_DciFormat_X_0_ChannelAccessCPext_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_DciFormat_X_0_ChannelAccessCPext_Type_NR_DciFormat_1_0_SpecificInfo_Type_ChannelAccessCPext_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_DciFormat_X_0_ChannelAccessCPext_Type_NR_DciFormat_1_0_SpecificInfo_Type_ChannelAccessCPext_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecNR_DciFormat_X_0_ChannelAccessCPext_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_DciFormat_1_0_SpecificInfo_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_DciFormat_1_0_SpecificInfo_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecNR_DciFormat_1_0_DAI_Type_DAI_Optional(_buffer, _size, _lidx, &p->DAI);
	_serNrSysDecNR_DciCommon_TpcCommand_Type_NR_DciFormat_1_0_SpecificInfo_Type_TpcCommandPucch_Optional(_buffer, _size, _lidx, &p->TpcCommandPucch);
	_serNrSysDecNR_DciFormat_1_X_PucchResourceIndicator_Type_NR_DciFormat_1_0_SpecificInfo_Type_PucchResourceIndicator_Optional(_buffer, _size, _lidx, &p->PucchResourceIndicator);
	_serNrSysDecNR_DciFormat_1_X_PdschHarqTimingIndicator_Type_NR_DciFormat_1_0_SpecificInfo_Type_PdschHarqTimingIndicator_Optional(_buffer, _size, _lidx, _mem, &p->PdschHarqTimingIndicator);
	_serNrSysDecNR_DciFormat_X_0_ChannelAccessCPext_Type_NR_DciFormat_1_0_SpecificInfo_Type_ChannelAccessCPext_Optional(_buffer, _size, _lidx, &p->ChannelAccessCPext);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecB2_Type_NR_DciFormat_1_0_P_RNTI_SpecificInfo_Type_ShortMessageIndicator_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct B2_Type_NR_DciFormat_1_0_P_RNTI_SpecificInfo_Type_ShortMessageIndicator_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	for (size_t i1 = 0; i1 < 2; i1++) {
		NTOH_8(p->v[i1], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecB8_Type_NR_DciFormat_1_0_P_RNTI_SpecificInfo_Type_ShortMessages_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct B8_Type_NR_DciFormat_1_0_P_RNTI_SpecificInfo_Type_ShortMessages_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	for (size_t i1 = 0; i1 < 8; i1++) {
		NTOH_8(p->v[i1], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecB2_Type_NR_DciFormat_1_0_P_RNTI_SpecificInfo_Type_TbScaling_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct B2_Type_NR_DciFormat_1_0_P_RNTI_SpecificInfo_Type_TbScaling_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	for (size_t i1 = 0; i1 < 2; i1++) {
		NTOH_8(p->v[i1], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_DciFormat_1_0_P_RNTI_SpecificInfo_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_DciFormat_1_0_P_RNTI_SpecificInfo_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecB2_Type_NR_DciFormat_1_0_P_RNTI_SpecificInfo_Type_ShortMessageIndicator_Optional(_buffer, _size, _lidx, &p->ShortMessageIndicator);
	_serNrSysDecB8_Type_NR_DciFormat_1_0_P_RNTI_SpecificInfo_Type_ShortMessages_Optional(_buffer, _size, _lidx, &p->ShortMessages);
	_serNrSysDecB2_Type_NR_DciFormat_1_0_P_RNTI_SpecificInfo_Type_TbScaling_Optional(_buffer, _size, _lidx, &p->TbScaling);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecB1_Type_NR_DciFormat_1_0_SI_RNTI_SpecificInfo_Type_SystemInfoIndicator_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct B1_Type_NR_DciFormat_1_0_SI_RNTI_SpecificInfo_Type_SystemInfoIndicator_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	for (size_t i1 = 0; i1 < 1; i1++) {
		NTOH_8(p->v[i1], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_DciFormat_1_0_SI_RNTI_SpecificInfo_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_DciFormat_1_0_SI_RNTI_SpecificInfo_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecB1_Type_NR_DciFormat_1_0_SI_RNTI_SpecificInfo_Type_SystemInfoIndicator_Optional(_buffer, _size, _lidx, &p->SystemInfoIndicator);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecB2_Type_NR_DciFormat_1_0_RA_RNTI_SpecificInfo_Type_TbScaling_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct B2_Type_NR_DciFormat_1_0_RA_RNTI_SpecificInfo_Type_TbScaling_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	for (size_t i1 = 0; i1 < 2; i1++) {
		NTOH_8(p->v[i1], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_DciFormat_1_0_LSBsOfSFN_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union NR_DciFormat_1_0_LSBsOfSFN_Type_Value* p, enum NR_DciFormat_1_0_LSBsOfSFN_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_DciFormat_1_0_LSBsOfSFN_Type_None) {
		NTOH_8(p->None, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == NR_DciFormat_1_0_LSBsOfSFN_Type_Automatic) {
		NTOH_8(p->Automatic, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecNR_DciFormat_1_0_LSBsOfSFN_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_DciFormat_1_0_LSBsOfSFN_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum NR_DciFormat_1_0_LSBsOfSFN_Type_Sel)_tmp;
	}
	_serNrSysDecNR_DciFormat_1_0_LSBsOfSFN_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_DciFormat_1_0_LSBsOfSFN_Type_LSBsOfSFN_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_DciFormat_1_0_LSBsOfSFN_Type_LSBsOfSFN_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecNR_DciFormat_1_0_LSBsOfSFN_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_DciFormat_1_0_RA_RNTI_SpecificInfo_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_DciFormat_1_0_RA_RNTI_SpecificInfo_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecB2_Type_NR_DciFormat_1_0_RA_RNTI_SpecificInfo_Type_TbScaling_Optional(_buffer, _size, _lidx, &p->TbScaling);
	_serNrSysDecNR_DciFormat_1_0_LSBsOfSFN_Type_LSBsOfSFN_Optional(_buffer, _size, _lidx, &p->LSBsOfSFN);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_DciCommon_CarrierIndicator_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union NR_DciCommon_CarrierIndicator_Type_Value* p, enum NR_DciCommon_CarrierIndicator_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_DciCommon_CarrierIndicator_Type_None) {
		NTOH_8(p->None, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == NR_DciCommon_CarrierIndicator_Type_CellIndex) {
		for (size_t i1 = 0; i1 < 3; i1++) {
			NTOH_8(p->CellIndex[i1], &_buffer[*_lidx], _lidx);
		}
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecNR_DciCommon_CarrierIndicator_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_DciCommon_CarrierIndicator_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum NR_DciCommon_CarrierIndicator_Type_Sel)_tmp;
	}
	_serNrSysDecNR_DciCommon_CarrierIndicator_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_DciCommon_CarrierIndicator_Type_NR_DciFormat_1_1_SpecificInfo_Type_CarrierIndicator_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_DciCommon_CarrierIndicator_Type_NR_DciFormat_1_1_SpecificInfo_Type_CarrierIndicator_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecNR_DciCommon_CarrierIndicator_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_DciCommon_BWPIndicator_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union NR_DciCommon_BWPIndicator_Type_Value* p, enum NR_DciCommon_BWPIndicator_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_DciCommon_BWPIndicator_Type_Index) {
		NTOH_32(p->Index.d, &_buffer[*_lidx], _lidx);
		p->Index.v = (BIT_STRING_ELEMENT*)serMalloc(_mem, p->Index.d * sizeof(BIT_STRING_ELEMENT));
		for (size_t i1 = 0; i1 < p->Index.d; i1++) {
			NTOH_8(p->Index.v[i1], &_buffer[*_lidx], _lidx);
		}
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecNR_DciCommon_BWPIndicator_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_DciCommon_BWPIndicator_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum NR_DciCommon_BWPIndicator_Type_Sel)_tmp;
	}
	_serNrSysDecNR_DciCommon_BWPIndicator_Type_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_DciCommon_BWPIndicator_Type_NR_DciFormat_1_1_SpecificInfo_Type_BWPIndicator_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_DciCommon_BWPIndicator_Type_NR_DciFormat_1_1_SpecificInfo_Type_BWPIndicator_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecNR_DciCommon_BWPIndicator_Type(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_DciFormat_1_1_PrbBundlingSizeIndicator_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union NR_DciFormat_1_1_PrbBundlingSizeIndicator_Type_Value* p, enum NR_DciFormat_1_1_PrbBundlingSizeIndicator_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_DciFormat_1_1_PrbBundlingSizeIndicator_Type_None) {
		NTOH_8(p->None, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == NR_DciFormat_1_1_PrbBundlingSizeIndicator_Type_Dynamic) {
		for (size_t i1 = 0; i1 < 1; i1++) {
			NTOH_8(p->Dynamic[i1], &_buffer[*_lidx], _lidx);
		}
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecNR_DciFormat_1_1_PrbBundlingSizeIndicator_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_DciFormat_1_1_PrbBundlingSizeIndicator_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum NR_DciFormat_1_1_PrbBundlingSizeIndicator_Type_Sel)_tmp;
	}
	_serNrSysDecNR_DciFormat_1_1_PrbBundlingSizeIndicator_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_DciFormat_1_1_PrbBundlingSizeIndicator_Type_PrbBundlingSizeIndicator_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_DciFormat_1_1_PrbBundlingSizeIndicator_Type_PrbBundlingSizeIndicator_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecNR_DciFormat_1_1_PrbBundlingSizeIndicator_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_DciFormat_1_1_RateMatchingIndicator_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union NR_DciFormat_1_1_RateMatchingIndicator_Type_Value* p, enum NR_DciFormat_1_1_RateMatchingIndicator_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_DciFormat_1_1_RateMatchingIndicator_Type_Bitmap) {
		NTOH_32(p->Bitmap.d, &_buffer[*_lidx], _lidx);
		p->Bitmap.v = (BIT_STRING_ELEMENT*)serMalloc(_mem, p->Bitmap.d * sizeof(BIT_STRING_ELEMENT));
		for (size_t i1 = 0; i1 < p->Bitmap.d; i1++) {
			NTOH_8(p->Bitmap.v[i1], &_buffer[*_lidx], _lidx);
		}
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecNR_DciFormat_1_1_RateMatchingIndicator_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_DciFormat_1_1_RateMatchingIndicator_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum NR_DciFormat_1_1_RateMatchingIndicator_Type_Sel)_tmp;
	}
	_serNrSysDecNR_DciFormat_1_1_RateMatchingIndicator_Type_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_DciFormat_1_1_RateMatchingIndicator_Type_RateMatchingIndicator_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_DciFormat_1_1_RateMatchingIndicator_Type_RateMatchingIndicator_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecNR_DciFormat_1_1_RateMatchingIndicator_Type(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_DciFormat_1_1_ZP_CSI_RS_Trigger_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union NR_DciFormat_1_1_ZP_CSI_RS_Trigger_Type_Value* p, enum NR_DciFormat_1_1_ZP_CSI_RS_Trigger_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_DciFormat_1_1_ZP_CSI_RS_Trigger_Type_Index) {
		NTOH_32(p->Index.d, &_buffer[*_lidx], _lidx);
		p->Index.v = (BIT_STRING_ELEMENT*)serMalloc(_mem, p->Index.d * sizeof(BIT_STRING_ELEMENT));
		for (size_t i1 = 0; i1 < p->Index.d; i1++) {
			NTOH_8(p->Index.v[i1], &_buffer[*_lidx], _lidx);
		}
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecNR_DciFormat_1_1_ZP_CSI_RS_Trigger_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_DciFormat_1_1_ZP_CSI_RS_Trigger_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum NR_DciFormat_1_1_ZP_CSI_RS_Trigger_Type_Sel)_tmp;
	}
	_serNrSysDecNR_DciFormat_1_1_ZP_CSI_RS_Trigger_Type_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_DciFormat_1_1_ZP_CSI_RS_Trigger_Type_ZP_CSI_RS_Trigger_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_DciFormat_1_1_ZP_CSI_RS_Trigger_Type_ZP_CSI_RS_Trigger_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecNR_DciFormat_1_1_ZP_CSI_RS_Trigger_Type(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecDAI_B4_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union DAI_B4_Type_Value* p, enum DAI_B4_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == DAI_B4_Type_Index) {
		for (size_t i1 = 0; i1 < 4; i1++) {
			NTOH_8(p->Index[i1], &_buffer[*_lidx], _lidx);
		}
		return SIDL_STATUS_OK;
	}
	if (d == DAI_B4_Type_Automatic) {
		NTOH_8(p->Automatic, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecDAI_B4_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct DAI_B4_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum DAI_B4_Type_Sel)_tmp;
	}
	_serNrSysDecDAI_B4_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecDAI_B6_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union DAI_B6_Type_Value* p, enum DAI_B6_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == DAI_B6_Type_Index) {
		for (size_t i1 = 0; i1 < 6; i1++) {
			NTOH_8(p->Index[i1], &_buffer[*_lidx], _lidx);
		}
		return SIDL_STATUS_OK;
	}
	if (d == DAI_B6_Type_Automatic) {
		NTOH_8(p->Automatic, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecDAI_B6_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct DAI_B6_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum DAI_B6_Type_Sel)_tmp;
	}
	_serNrSysDecDAI_B6_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_DciFormat_1_1_DAI_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union NR_DciFormat_1_1_DAI_Type_Value* p, enum NR_DciFormat_1_1_DAI_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_DciFormat_1_1_DAI_Type_None) {
		NTOH_8(p->None, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == NR_DciFormat_1_1_DAI_Type_TwoBits) {
		_serNrSysDecDAI_B2_Type(_buffer, _size, _lidx, &p->TwoBits);
		return SIDL_STATUS_OK;
	}
	if (d == NR_DciFormat_1_1_DAI_Type_FourBits) {
		_serNrSysDecDAI_B4_Type(_buffer, _size, _lidx, &p->FourBits);
		return SIDL_STATUS_OK;
	}
	if (d == NR_DciFormat_1_1_DAI_Type_SixBits) {
		_serNrSysDecDAI_B6_Type(_buffer, _size, _lidx, &p->SixBits);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecNR_DciFormat_1_1_DAI_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_DciFormat_1_1_DAI_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum NR_DciFormat_1_1_DAI_Type_Sel)_tmp;
	}
	_serNrSysDecNR_DciFormat_1_1_DAI_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_DciFormat_1_1_DAI_Type_DAI_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_DciFormat_1_1_DAI_Type_DAI_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecNR_DciFormat_1_1_DAI_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_DciCommon_TpcCommand_Type_NR_DciFormat_1_1_SpecificInfo_Type_TpcCommandPucch_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_DciCommon_TpcCommand_Type_NR_DciFormat_1_1_SpecificInfo_Type_TpcCommandPucch_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecNR_DciCommon_TpcCommand_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_DciFormat_1_X_PucchResourceIndicator_Type_NR_DciFormat_1_1_SpecificInfo_Type_PucchResourceIndicator_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_DciFormat_1_X_PucchResourceIndicator_Type_NR_DciFormat_1_1_SpecificInfo_Type_PucchResourceIndicator_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecNR_DciFormat_1_X_PucchResourceIndicator_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_DciFormat_1_X_PdschHarqTimingIndicator_Type_NR_DciFormat_1_1_SpecificInfo_Type_PdschHarqTimingIndicator_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_DciFormat_1_X_PdschHarqTimingIndicator_Type_NR_DciFormat_1_1_SpecificInfo_Type_PdschHarqTimingIndicator_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecNR_DciFormat_1_X_PdschHarqTimingIndicator_Type(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_DciFormat_1_1_OneShotHarqAckRequest_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union NR_DciFormat_1_1_OneShotHarqAckRequest_Type_Value* p, enum NR_DciFormat_1_1_OneShotHarqAckRequest_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_DciFormat_1_1_OneShotHarqAckRequest_Type_None) {
		NTOH_8(p->None, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == NR_DciFormat_1_1_OneShotHarqAckRequest_Type_Value) {
		for (size_t i1 = 0; i1 < 1; i1++) {
			NTOH_8(p->Value[i1], &_buffer[*_lidx], _lidx);
		}
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecNR_DciFormat_1_1_OneShotHarqAckRequest_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_DciFormat_1_1_OneShotHarqAckRequest_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum NR_DciFormat_1_1_OneShotHarqAckRequest_Type_Sel)_tmp;
	}
	_serNrSysDecNR_DciFormat_1_1_OneShotHarqAckRequest_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_DciFormat_1_1_OneShotHarqAckRequest_Type_OneShotHarqAckRequest_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_DciFormat_1_1_OneShotHarqAckRequest_Type_OneShotHarqAckRequest_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecNR_DciFormat_1_1_OneShotHarqAckRequest_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_DciFormat_1_1_PdschGroupIndex_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union NR_DciFormat_1_1_PdschGroupIndex_Type_Value* p, enum NR_DciFormat_1_1_PdschGroupIndex_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_DciFormat_1_1_PdschGroupIndex_Type_None) {
		NTOH_8(p->None, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == NR_DciFormat_1_1_PdschGroupIndex_Type_Value) {
		for (size_t i1 = 0; i1 < 1; i1++) {
			NTOH_8(p->Value[i1], &_buffer[*_lidx], _lidx);
		}
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecNR_DciFormat_1_1_PdschGroupIndex_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_DciFormat_1_1_PdschGroupIndex_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum NR_DciFormat_1_1_PdschGroupIndex_Type_Sel)_tmp;
	}
	_serNrSysDecNR_DciFormat_1_1_PdschGroupIndex_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_DciFormat_1_1_PdschGroupIndex_Type_PdschGroupIndex_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_DciFormat_1_1_PdschGroupIndex_Type_PdschGroupIndex_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecNR_DciFormat_1_1_PdschGroupIndex_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_DciFormat_1_1_NewFeedbackIndicator_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union NR_DciFormat_1_1_NewFeedbackIndicator_Type_Value* p, enum NR_DciFormat_1_1_NewFeedbackIndicator_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_DciFormat_1_1_NewFeedbackIndicator_Type_None) {
		NTOH_8(p->None, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == NR_DciFormat_1_1_NewFeedbackIndicator_Type_Value) {
		NTOH_32(p->Value.d, &_buffer[*_lidx], _lidx);
		p->Value.v = (BIT_STRING_ELEMENT*)serMalloc(_mem, p->Value.d * sizeof(BIT_STRING_ELEMENT));
		for (size_t i1 = 0; i1 < p->Value.d; i1++) {
			NTOH_8(p->Value.v[i1], &_buffer[*_lidx], _lidx);
		}
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecNR_DciFormat_1_1_NewFeedbackIndicator_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_DciFormat_1_1_NewFeedbackIndicator_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum NR_DciFormat_1_1_NewFeedbackIndicator_Type_Sel)_tmp;
	}
	_serNrSysDecNR_DciFormat_1_1_NewFeedbackIndicator_Type_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_DciFormat_1_1_NewFeedbackIndicator_Type_NewFeedbackIndicator_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_DciFormat_1_1_NewFeedbackIndicator_Type_NewFeedbackIndicator_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecNR_DciFormat_1_1_NewFeedbackIndicator_Type(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_DciFormat_1_1_NumberRequestedPdschGroup_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union NR_DciFormat_1_1_NumberRequestedPdschGroup_Type_Value* p, enum NR_DciFormat_1_1_NumberRequestedPdschGroup_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_DciFormat_1_1_NumberRequestedPdschGroup_Type_None) {
		NTOH_8(p->None, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == NR_DciFormat_1_1_NumberRequestedPdschGroup_Type_Value) {
		for (size_t i1 = 0; i1 < 1; i1++) {
			NTOH_8(p->Value[i1], &_buffer[*_lidx], _lidx);
		}
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecNR_DciFormat_1_1_NumberRequestedPdschGroup_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_DciFormat_1_1_NumberRequestedPdschGroup_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum NR_DciFormat_1_1_NumberRequestedPdschGroup_Type_Sel)_tmp;
	}
	_serNrSysDecNR_DciFormat_1_1_NumberRequestedPdschGroup_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_DciFormat_1_1_NumberRequestedPdschGroup_Type_NumberRequestedPdschGroup_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_DciFormat_1_1_NumberRequestedPdschGroup_Type_NumberRequestedPdschGroup_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecNR_DciFormat_1_1_NumberRequestedPdschGroup_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_DciFormat_1_1_AntennaPorts_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union NR_DciFormat_1_1_AntennaPorts_Type_Value* p, enum NR_DciFormat_1_1_AntennaPorts_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_DciFormat_1_1_AntennaPorts_Type_Index) {
		NTOH_32(p->Index.d, &_buffer[*_lidx], _lidx);
		p->Index.v = (BIT_STRING_ELEMENT*)serMalloc(_mem, p->Index.d * sizeof(BIT_STRING_ELEMENT));
		for (size_t i1 = 0; i1 < p->Index.d; i1++) {
			NTOH_8(p->Index.v[i1], &_buffer[*_lidx], _lidx);
		}
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecNR_DciFormat_1_1_AntennaPorts_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_DciFormat_1_1_AntennaPorts_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum NR_DciFormat_1_1_AntennaPorts_Type_Sel)_tmp;
	}
	_serNrSysDecNR_DciFormat_1_1_AntennaPorts_Type_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_DciFormat_1_1_AntennaPorts_Type_AntennaPorts_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_DciFormat_1_1_AntennaPorts_Type_AntennaPorts_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecNR_DciFormat_1_1_AntennaPorts_Type(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_DciFormat_1_1_TCI_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union NR_DciFormat_1_1_TCI_Type_Value* p, enum NR_DciFormat_1_1_TCI_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_DciFormat_1_1_TCI_Type_None) {
		NTOH_8(p->None, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == NR_DciFormat_1_1_TCI_Type_Value) {
		for (size_t i1 = 0; i1 < 3; i1++) {
			NTOH_8(p->Value[i1], &_buffer[*_lidx], _lidx);
		}
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecNR_DciFormat_1_1_TCI_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_DciFormat_1_1_TCI_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum NR_DciFormat_1_1_TCI_Type_Sel)_tmp;
	}
	_serNrSysDecNR_DciFormat_1_1_TCI_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_DciFormat_1_1_TCI_Type_TCI_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_DciFormat_1_1_TCI_Type_TCI_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecNR_DciFormat_1_1_TCI_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_DciFormat_X_1_SrsRequest_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union NR_DciFormat_X_1_SrsRequest_Type_Value* p, enum NR_DciFormat_X_1_SrsRequest_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_DciFormat_X_1_SrsRequest_Type_SingleUL) {
		for (size_t i1 = 0; i1 < 2; i1++) {
			NTOH_8(p->SingleUL[i1], &_buffer[*_lidx], _lidx);
		}
		return SIDL_STATUS_OK;
	}
	if (d == NR_DciFormat_X_1_SrsRequest_Type_UL_SUL) {
		for (size_t i1 = 0; i1 < 3; i1++) {
			NTOH_8(p->UL_SUL[i1], &_buffer[*_lidx], _lidx);
		}
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecNR_DciFormat_X_1_SrsRequest_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_DciFormat_X_1_SrsRequest_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum NR_DciFormat_X_1_SrsRequest_Type_Sel)_tmp;
	}
	_serNrSysDecNR_DciFormat_X_1_SrsRequest_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_DciFormat_X_1_SrsRequest_Type_NR_DciFormat_1_1_SpecificInfo_Type_SrsRequest_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_DciFormat_X_1_SrsRequest_Type_NR_DciFormat_1_1_SpecificInfo_Type_SrsRequest_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecNR_DciFormat_X_1_SrsRequest_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_DciFormat_1_1_CBGTI_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union NR_DciFormat_1_1_CBGTI_Type_Value* p, enum NR_DciFormat_1_1_CBGTI_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_DciFormat_1_1_CBGTI_Type_Bitmap) {
		NTOH_32(p->Bitmap.d, &_buffer[*_lidx], _lidx);
		p->Bitmap.v = (BIT_STRING_ELEMENT*)serMalloc(_mem, p->Bitmap.d * sizeof(BIT_STRING_ELEMENT));
		for (size_t i1 = 0; i1 < p->Bitmap.d; i1++) {
			NTOH_8(p->Bitmap.v[i1], &_buffer[*_lidx], _lidx);
		}
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecNR_DciFormat_1_1_CBGTI_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_DciFormat_1_1_CBGTI_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum NR_DciFormat_1_1_CBGTI_Type_Sel)_tmp;
	}
	_serNrSysDecNR_DciFormat_1_1_CBGTI_Type_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_DciFormat_1_1_CBGTI_Type_CBGTI_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_DciFormat_1_1_CBGTI_Type_CBGTI_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecNR_DciFormat_1_1_CBGTI_Type(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_DciFormat_1_1_CBGFI_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union NR_DciFormat_1_1_CBGFI_Type_Value* p, enum NR_DciFormat_1_1_CBGFI_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_DciFormat_1_1_CBGFI_Type_None) {
		NTOH_8(p->None, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == NR_DciFormat_1_1_CBGFI_Type_Flag) {
		for (size_t i1 = 0; i1 < 1; i1++) {
			NTOH_8(p->Flag[i1], &_buffer[*_lidx], _lidx);
		}
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecNR_DciFormat_1_1_CBGFI_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_DciFormat_1_1_CBGFI_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum NR_DciFormat_1_1_CBGFI_Type_Sel)_tmp;
	}
	_serNrSysDecNR_DciFormat_1_1_CBGFI_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_DciFormat_1_1_CBGFI_Type_CBGFI_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_DciFormat_1_1_CBGFI_Type_CBGFI_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecNR_DciFormat_1_1_CBGFI_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_DciFormat_X_1_DmrsSequenceInit_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union NR_DciFormat_X_1_DmrsSequenceInit_Type_Value* p, enum NR_DciFormat_X_1_DmrsSequenceInit_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_DciFormat_X_1_DmrsSequenceInit_Type_None) {
		NTOH_8(p->None, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == NR_DciFormat_X_1_DmrsSequenceInit_Type_Value) {
		for (size_t i1 = 0; i1 < 1; i1++) {
			NTOH_8(p->Value[i1], &_buffer[*_lidx], _lidx);
		}
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecNR_DciFormat_X_1_DmrsSequenceInit_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_DciFormat_X_1_DmrsSequenceInit_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum NR_DciFormat_X_1_DmrsSequenceInit_Type_Sel)_tmp;
	}
	_serNrSysDecNR_DciFormat_X_1_DmrsSequenceInit_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_DciFormat_X_1_DmrsSequenceInit_Type_NR_DciFormat_1_1_SpecificInfo_Type_DmrsSequenceInit_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_DciFormat_X_1_DmrsSequenceInit_Type_NR_DciFormat_1_1_SpecificInfo_Type_DmrsSequenceInit_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecNR_DciFormat_X_1_DmrsSequenceInit_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_DciFormat_X_1_PriorityIndicator_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union NR_DciFormat_X_1_PriorityIndicator_Type_Value* p, enum NR_DciFormat_X_1_PriorityIndicator_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_DciFormat_X_1_PriorityIndicator_Type_None) {
		NTOH_8(p->None, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == NR_DciFormat_X_1_PriorityIndicator_Type_Value) {
		for (size_t i1 = 0; i1 < 1; i1++) {
			NTOH_8(p->Value[i1], &_buffer[*_lidx], _lidx);
		}
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecNR_DciFormat_X_1_PriorityIndicator_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_DciFormat_X_1_PriorityIndicator_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum NR_DciFormat_X_1_PriorityIndicator_Type_Sel)_tmp;
	}
	_serNrSysDecNR_DciFormat_X_1_PriorityIndicator_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_DciFormat_X_1_PriorityIndicator_Type_NR_DciFormat_1_1_SpecificInfo_Type_PriorityIndicator_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_DciFormat_X_1_PriorityIndicator_Type_NR_DciFormat_1_1_SpecificInfo_Type_PriorityIndicator_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecNR_DciFormat_X_1_PriorityIndicator_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_DciFormat_1_1_ChannelAccessCPext_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union NR_DciFormat_1_1_ChannelAccessCPext_Type_Value* p, enum NR_DciFormat_1_1_ChannelAccessCPext_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_DciFormat_1_1_ChannelAccessCPext_Type_None) {
		NTOH_8(p->None, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == NR_DciFormat_1_1_ChannelAccessCPext_Type_Value) {
		NTOH_32(p->Value.d, &_buffer[*_lidx], _lidx);
		p->Value.v = (BIT_STRING_ELEMENT*)serMalloc(_mem, p->Value.d * sizeof(BIT_STRING_ELEMENT));
		for (size_t i1 = 0; i1 < p->Value.d; i1++) {
			NTOH_8(p->Value.v[i1], &_buffer[*_lidx], _lidx);
		}
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecNR_DciFormat_1_1_ChannelAccessCPext_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_DciFormat_1_1_ChannelAccessCPext_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum NR_DciFormat_1_1_ChannelAccessCPext_Type_Sel)_tmp;
	}
	_serNrSysDecNR_DciFormat_1_1_ChannelAccessCPext_Type_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_DciFormat_1_1_ChannelAccessCPext_Type_ChannelAccessCPext_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_DciFormat_1_1_ChannelAccessCPext_Type_ChannelAccessCPext_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecNR_DciFormat_1_1_ChannelAccessCPext_Type(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_DciFormat_X_1_MinimumApplicableSchedulingOffset_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union NR_DciFormat_X_1_MinimumApplicableSchedulingOffset_Type_Value* p, enum NR_DciFormat_X_1_MinimumApplicableSchedulingOffset_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_DciFormat_X_1_MinimumApplicableSchedulingOffset_Type_None) {
		NTOH_8(p->None, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == NR_DciFormat_X_1_MinimumApplicableSchedulingOffset_Type_Value) {
		for (size_t i1 = 0; i1 < 1; i1++) {
			NTOH_8(p->Value[i1], &_buffer[*_lidx], _lidx);
		}
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecNR_DciFormat_X_1_MinimumApplicableSchedulingOffset_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_DciFormat_X_1_MinimumApplicableSchedulingOffset_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum NR_DciFormat_X_1_MinimumApplicableSchedulingOffset_Type_Sel)_tmp;
	}
	_serNrSysDecNR_DciFormat_X_1_MinimumApplicableSchedulingOffset_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_DciFormat_X_1_MinimumApplicableSchedulingOffset_Type_NR_DciFormat_1_1_SpecificInfo_Type_MinimumApplicableSchedulingOffset_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_DciFormat_X_1_MinimumApplicableSchedulingOffset_Type_NR_DciFormat_1_1_SpecificInfo_Type_MinimumApplicableSchedulingOffset_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecNR_DciFormat_X_1_MinimumApplicableSchedulingOffset_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_DciFormat_X_1_SCellDormancyIndication_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union NR_DciFormat_X_1_SCellDormancyIndication_Type_Value* p, enum NR_DciFormat_X_1_SCellDormancyIndication_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_DciFormat_X_1_SCellDormancyIndication_Type_None) {
		NTOH_8(p->None, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == NR_DciFormat_X_1_SCellDormancyIndication_Type_Value) {
		NTOH_32(p->Value.d, &_buffer[*_lidx], _lidx);
		p->Value.v = (BIT_STRING_ELEMENT*)serMalloc(_mem, p->Value.d * sizeof(BIT_STRING_ELEMENT));
		for (size_t i1 = 0; i1 < p->Value.d; i1++) {
			NTOH_8(p->Value.v[i1], &_buffer[*_lidx], _lidx);
		}
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecNR_DciFormat_X_1_SCellDormancyIndication_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_DciFormat_X_1_SCellDormancyIndication_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum NR_DciFormat_X_1_SCellDormancyIndication_Type_Sel)_tmp;
	}
	_serNrSysDecNR_DciFormat_X_1_SCellDormancyIndication_Type_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_DciFormat_X_1_SCellDormancyIndication_Type_NR_DciFormat_1_1_SpecificInfo_Type_SCellDormancyIndication_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_DciFormat_X_1_SCellDormancyIndication_Type_NR_DciFormat_1_1_SpecificInfo_Type_SCellDormancyIndication_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecNR_DciFormat_X_1_SCellDormancyIndication_Type(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_DciFormat_1_1_SpecificInfo_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_DciFormat_1_1_SpecificInfo_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecNR_DciCommon_CarrierIndicator_Type_NR_DciFormat_1_1_SpecificInfo_Type_CarrierIndicator_Optional(_buffer, _size, _lidx, &p->CarrierIndicator);
	_serNrSysDecNR_DciCommon_BWPIndicator_Type_NR_DciFormat_1_1_SpecificInfo_Type_BWPIndicator_Optional(_buffer, _size, _lidx, _mem, &p->BWPIndicator);
	_serNrSysDecNR_DciFormat_1_1_PrbBundlingSizeIndicator_Type_PrbBundlingSizeIndicator_Optional(_buffer, _size, _lidx, &p->PrbBundlingSizeIndicator);
	_serNrSysDecNR_DciFormat_1_1_RateMatchingIndicator_Type_RateMatchingIndicator_Optional(_buffer, _size, _lidx, _mem, &p->RateMatchingIndicator);
	_serNrSysDecNR_DciFormat_1_1_ZP_CSI_RS_Trigger_Type_ZP_CSI_RS_Trigger_Optional(_buffer, _size, _lidx, _mem, &p->ZP_CSI_RS_Trigger);
	_serNrSysDecNR_DciFormat_1_1_DAI_Type_DAI_Optional(_buffer, _size, _lidx, &p->DAI);
	_serNrSysDecNR_DciCommon_TpcCommand_Type_NR_DciFormat_1_1_SpecificInfo_Type_TpcCommandPucch_Optional(_buffer, _size, _lidx, &p->TpcCommandPucch);
	_serNrSysDecNR_DciFormat_1_X_PucchResourceIndicator_Type_NR_DciFormat_1_1_SpecificInfo_Type_PucchResourceIndicator_Optional(_buffer, _size, _lidx, &p->PucchResourceIndicator);
	_serNrSysDecNR_DciFormat_1_X_PdschHarqTimingIndicator_Type_NR_DciFormat_1_1_SpecificInfo_Type_PdschHarqTimingIndicator_Optional(_buffer, _size, _lidx, _mem, &p->PdschHarqTimingIndicator);
	_serNrSysDecNR_DciFormat_1_1_OneShotHarqAckRequest_Type_OneShotHarqAckRequest_Optional(_buffer, _size, _lidx, &p->OneShotHarqAckRequest);
	_serNrSysDecNR_DciFormat_1_1_PdschGroupIndex_Type_PdschGroupIndex_Optional(_buffer, _size, _lidx, &p->PdschGroupIndex);
	_serNrSysDecNR_DciFormat_1_1_NewFeedbackIndicator_Type_NewFeedbackIndicator_Optional(_buffer, _size, _lidx, _mem, &p->NewFeedbackIndicator);
	_serNrSysDecNR_DciFormat_1_1_NumberRequestedPdschGroup_Type_NumberRequestedPdschGroup_Optional(_buffer, _size, _lidx, &p->NumberRequestedPdschGroup);
	_serNrSysDecNR_DciFormat_1_1_AntennaPorts_Type_AntennaPorts_Optional(_buffer, _size, _lidx, _mem, &p->AntennaPorts);
	_serNrSysDecNR_DciFormat_1_1_TCI_Type_TCI_Optional(_buffer, _size, _lidx, &p->TCI);
	_serNrSysDecNR_DciFormat_X_1_SrsRequest_Type_NR_DciFormat_1_1_SpecificInfo_Type_SrsRequest_Optional(_buffer, _size, _lidx, &p->SrsRequest);
	_serNrSysDecNR_DciFormat_1_1_CBGTI_Type_CBGTI_Optional(_buffer, _size, _lidx, _mem, &p->CBGTI);
	_serNrSysDecNR_DciFormat_1_1_CBGFI_Type_CBGFI_Optional(_buffer, _size, _lidx, &p->CBGFI);
	_serNrSysDecNR_DciFormat_X_1_DmrsSequenceInit_Type_NR_DciFormat_1_1_SpecificInfo_Type_DmrsSequenceInit_Optional(_buffer, _size, _lidx, &p->DmrsSequenceInit);
	_serNrSysDecNR_DciFormat_X_1_PriorityIndicator_Type_NR_DciFormat_1_1_SpecificInfo_Type_PriorityIndicator_Optional(_buffer, _size, _lidx, &p->PriorityIndicator);
	_serNrSysDecNR_DciFormat_1_1_ChannelAccessCPext_Type_ChannelAccessCPext_Optional(_buffer, _size, _lidx, _mem, &p->ChannelAccessCPext);
	_serNrSysDecNR_DciFormat_X_1_MinimumApplicableSchedulingOffset_Type_NR_DciFormat_1_1_SpecificInfo_Type_MinimumApplicableSchedulingOffset_Optional(_buffer, _size, _lidx, &p->MinimumApplicableSchedulingOffset);
	_serNrSysDecNR_DciFormat_X_1_SCellDormancyIndication_Type_NR_DciFormat_1_1_SpecificInfo_Type_SCellDormancyIndication_Optional(_buffer, _size, _lidx, _mem, &p->SCellDormancyIndication);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_DciFormat_1_X_SpecificInfo_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union NR_DciFormat_1_X_SpecificInfo_Type_Value* p, enum NR_DciFormat_1_X_SpecificInfo_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_DciFormat_1_X_SpecificInfo_Type_Format_1_0) {
		_serNrSysDecNR_DciFormat_1_0_SpecificInfo_Type(_buffer, _size, _lidx, _mem, &p->Format_1_0);
		return SIDL_STATUS_OK;
	}
	if (d == NR_DciFormat_1_X_SpecificInfo_Type_Format_1_0_P_RNTI) {
		_serNrSysDecNR_DciFormat_1_0_P_RNTI_SpecificInfo_Type(_buffer, _size, _lidx, &p->Format_1_0_P_RNTI);
		return SIDL_STATUS_OK;
	}
	if (d == NR_DciFormat_1_X_SpecificInfo_Type_Format_1_0_SI_RNTI) {
		_serNrSysDecNR_DciFormat_1_0_SI_RNTI_SpecificInfo_Type(_buffer, _size, _lidx, &p->Format_1_0_SI_RNTI);
		return SIDL_STATUS_OK;
	}
	if (d == NR_DciFormat_1_X_SpecificInfo_Type_Format_1_0_RA_RNTI) {
		_serNrSysDecNR_DciFormat_1_0_RA_RNTI_SpecificInfo_Type(_buffer, _size, _lidx, &p->Format_1_0_RA_RNTI);
		return SIDL_STATUS_OK;
	}
	if (d == NR_DciFormat_1_X_SpecificInfo_Type_Format_1_1) {
		_serNrSysDecNR_DciFormat_1_1_SpecificInfo_Type(_buffer, _size, _lidx, _mem, &p->Format_1_1);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecNR_DciFormat_1_X_SpecificInfo_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_DciFormat_1_X_SpecificInfo_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum NR_DciFormat_1_X_SpecificInfo_Type_Sel)_tmp;
	}
	_serNrSysDecNR_DciFormat_1_X_SpecificInfo_Type_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_DciFormat_1_X_SpecificInfo_Type_Format_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_DciFormat_1_X_SpecificInfo_Type_Format_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecNR_DciFormat_1_X_SpecificInfo_Type(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_DciDlInfo_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_DciDlInfo_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecNR_DciFormat_1_X_ResourceAssignment_Type_ResoureAssignment_Optional(_buffer, _size, _lidx, _mem, &p->ResoureAssignment);
	_serNrSysDecNR_DciCommon_VrbPrbMapping_Type_VrbPrbMapping_Optional(_buffer, _size, _lidx, &p->VrbPrbMapping);
	_serNrSysDecNR_DciFormat_1_X_SpecificInfo_Type_Format_Optional(_buffer, _size, _lidx, _mem, &p->Format);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_DciDlInfo_Type_DciInfo_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_DciDlInfo_Type_DciInfo_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecNR_DciDlInfo_Type(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_SearchSpaceDlDciAssignment_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_SearchSpaceDlDciAssignment_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecNR_AssignedBWPs_Type_NR_SearchSpaceDlDciAssignment_Type_AssignedBWPs_Optional(_buffer, _size, _lidx, _mem, &p->AssignedBWPs);
	_serNrSysDecNR_SearchSpaceType_Type_NR_SearchSpaceDlDciAssignment_Type_SearchSpaceType_Optional(_buffer, _size, _lidx, &p->SearchSpaceType);
	_serNrSysDecNR_DciDlInfo_Type_DciInfo_Optional(_buffer, _size, _lidx, _mem, &p->DciInfo);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_SearchSpaceDlDciAssignment_Type_NR_Sib1Schedul_Type_SearchSpaceAndDci_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_SearchSpaceDlDciAssignment_Type_NR_Sib1Schedul_Type_SearchSpaceAndDci_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecNR_SearchSpaceDlDciAssignment_Type(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecInt32_t_NR_Sib1Schedul_Type_Periodicity_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct int32_t_NR_Sib1Schedul_Type_Periodicity_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecIntegerList_Type_SlotOffsetList_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct IntegerList_Type_SlotOffsetList_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = (int32_t*)serMalloc(_mem, p->v.d * sizeof(int32_t));
	for (size_t i1 = 0; i1 < p->v.d; i1++) {
		NTOH_32(p->v.v[i1], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_Sib1Schedul_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_Sib1Schedul_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecNR_SearchSpaceDlDciAssignment_Type_NR_Sib1Schedul_Type_SearchSpaceAndDci_Optional(_buffer, _size, _lidx, _mem, &p->SearchSpaceAndDci);
	_serNrSysDecInt32_t_NR_Sib1Schedul_Type_Periodicity_Optional(_buffer, _size, _lidx, &p->Periodicity);
	_serNrSysDecIntegerList_Type_SlotOffsetList_Optional(_buffer, _size, _lidx, _mem, &p->SlotOffsetList);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_Sib1Schedul_Type_Sib1Schedul_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_Sib1Schedul_Type_Sib1Schedul_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecNR_Sib1Schedul_Type(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_SiWindowLength_Type_WindowLength_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_SiWindowLength_Type_WindowLength_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (NR_SiWindowLength_Type)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_SiPeriodicity_Type_Periodicity_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_SiPeriodicity_Type_Periodicity_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (NR_SiPeriodicity_Type)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_SearchSpaceDlDciAssignment_Type_NR_SingleSiSchedul_Type_SearchSpaceAndDci_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_SearchSpaceDlDciAssignment_Type_NR_SingleSiSchedul_Type_SearchSpaceAndDci_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecNR_SearchSpaceDlDciAssignment_Type(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecInt32_t_NR_SingleSiSchedul_Type_SlotOffset_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct int32_t_NR_SingleSiSchedul_Type_SlotOffset_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_SingleSiSchedul_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_SingleSiSchedul_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecNR_SearchSpaceDlDciAssignment_Type_NR_SingleSiSchedul_Type_SearchSpaceAndDci_Optional(_buffer, _size, _lidx, _mem, &p->SearchSpaceAndDci);
	_serNrSysDecInt32_t_NR_SingleSiSchedul_Type_SlotOffset_Optional(_buffer, _size, _lidx, &p->SlotOffset);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_SingleSiSchedul_Type_Window_DynamicOptional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_SingleSiSchedul_Type_Window_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = (struct NR_SingleSiSchedul_Type*)serMalloc(_mem, p->v.d * sizeof(struct NR_SingleSiSchedul_Type));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serNrSysDecNR_SingleSiSchedul_Type(_buffer, _size, _lidx, _mem, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_OtherSiSchedul_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_OtherSiSchedul_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecNR_SiPeriodicity_Type_Periodicity_Optional(_buffer, _size, _lidx, &p->Periodicity);
	_serNrSysDecNR_SingleSiSchedul_Type_Window_DynamicOptional(_buffer, _size, _lidx, _mem, &p->Window);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_OtherSiSchedulList_Type_SiList_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_OtherSiSchedulList_Type_SiList_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = (struct NR_OtherSiSchedul_Type*)serMalloc(_mem, p->v.d * sizeof(struct NR_OtherSiSchedul_Type));
	for (size_t i1 = 0; i1 < p->v.d; i1++) {
		_serNrSysDecNR_OtherSiSchedul_Type(_buffer, _size, _lidx, _mem, &p->v.v[i1]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_OtherSiSchedulList_Type_SegmentedSiList_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_OtherSiSchedulList_Type_SegmentedSiList_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = (struct NR_OtherSiSchedul_Type*)serMalloc(_mem, p->v.d * sizeof(struct NR_OtherSiSchedul_Type));
	for (size_t i1 = 0; i1 < p->v.d; i1++) {
		_serNrSysDecNR_OtherSiSchedul_Type(_buffer, _size, _lidx, _mem, &p->v.v[i1]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_AllOtherSiSchedul_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_AllOtherSiSchedul_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecNR_SiWindowLength_Type_WindowLength_Optional(_buffer, _size, _lidx, &p->WindowLength);
	_serNrSysDecNR_OtherSiSchedulList_Type_SiList_Optional(_buffer, _size, _lidx, _mem, &p->SiList);
	_serNrSysDecNR_OtherSiSchedulList_Type_SegmentedSiList_Optional(_buffer, _size, _lidx, _mem, &p->SegmentedSiList);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_AllOtherSiSchedul_Type_SiSchedul_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_AllOtherSiSchedul_Type_SiSchedul_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecNR_AllOtherSiSchedul_Type(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_BcchToPdschConfig_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_BcchToPdschConfig_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecNR_Sib1Schedul_Type_Sib1Schedul_Optional(_buffer, _size, _lidx, _mem, &p->Sib1Schedul);
	_serNrSysDecNR_AllOtherSiSchedul_Type_SiSchedul_Optional(_buffer, _size, _lidx, _mem, &p->SiSchedul);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_BcchToPdschConfig_Type_Pdsch_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_BcchToPdschConfig_Type_Pdsch_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecNR_BcchToPdschConfig_Type(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PDCCH_ConfigSIB1(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_PDCCH_ConfigSIB1* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->controlResourceSetZero, &_buffer[*_lidx], _lidx);
	NTOH_8(p->searchSpaceZero, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_MIB(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_MIB* p)
{
	(void)_size; // TODO: generate boundaries checking

	for (size_t i1 = 0; i1 < 6; i1++) {
		NTOH_8(p->systemFrameNumber[i1], &_buffer[*_lidx], _lidx);
	}
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->subCarrierSpacingCommon = (SQN_NR_MIB_subCarrierSpacingCommon_e)_tmp;
	}
	NTOH_8(p->ssb_SubcarrierOffset, &_buffer[*_lidx], _lidx);
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->dmrs_TypeA_Position = (SQN_NR_MIB_dmrs_TypeA_Position_e)_tmp;
	}
	_serNrSysDecSQN_NR_PDCCH_ConfigSIB1(_buffer, _size, _lidx, &p->pdcch_ConfigSIB1);
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->cellBarred = (SQN_NR_MIB_cellBarred_e)_tmp;
	}
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->intraFreqReselection = (SQN_NR_MIB_intraFreqReselection_e)_tmp;
	}
	for (size_t i1 = 0; i1 < 1; i1++) {
		NTOH_8(p->spare[i1], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_BCCH_BCH_MessageType_messageClassExtension(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_BCCH_BCH_MessageType_messageClassExtension* p)
{
	(void)_size; // TODO: generate boundaries checking

	(void)_buffer;
	(void)_size;
	(void)_lidx;
	(void)p;

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_BCCH_BCH_MessageType_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union SQN_NR_BCCH_BCH_MessageType_Value* p, enum SQN_NR_BCCH_BCH_MessageType_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_BCCH_BCH_MessageType_mib) {
		_serNrSysDecSQN_NR_MIB(_buffer, _size, _lidx, &p->mib);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_BCCH_BCH_MessageType_messageClassExtension) {
		_serNrSysDecSQN_NR_BCCH_BCH_MessageType_messageClassExtension(_buffer, _size, _lidx, &p->messageClassExtension);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecSQN_NR_BCCH_BCH_MessageType(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_BCCH_BCH_MessageType* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SQN_NR_BCCH_BCH_MessageType_Sel)_tmp;
	}
	_serNrSysDecSQN_NR_BCCH_BCH_MessageType_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_BCCH_BCH_Message(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_BCCH_BCH_Message* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecSQN_NR_BCCH_BCH_MessageType(_buffer, _size, _lidx, &p->message);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_BCCH_BCH_Message_MIB_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_BCCH_BCH_Message_MIB_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_BCCH_BCH_Message(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecUint8_t_SQN_NR_SIB2_cellReselectionInfoCommon_nrofSS_BlocksToAverage_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct uint8_t_SQN_NR_SIB2_cellReselectionInfoCommon_nrofSS_BlocksToAverage_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_RSRP_Range_SQN_NR_ThresholdNR_thresholdRSRP_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_RSRP_Range_SQN_NR_ThresholdNR_thresholdRSRP_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_RSRQ_Range_SQN_NR_ThresholdNR_thresholdRSRQ_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_RSRQ_Range_SQN_NR_ThresholdNR_thresholdRSRQ_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SINR_Range_SQN_NR_ThresholdNR_thresholdSINR_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SINR_Range_SQN_NR_ThresholdNR_thresholdSINR_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_ThresholdNR(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_ThresholdNR* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecSQN_NR_RSRP_Range_SQN_NR_ThresholdNR_thresholdRSRP_Optional(_buffer, _size, _lidx, &p->thresholdRSRP);
	_serNrSysDecSQN_NR_RSRQ_Range_SQN_NR_ThresholdNR_thresholdRSRQ_Optional(_buffer, _size, _lidx, &p->thresholdRSRQ);
	_serNrSysDecSQN_NR_SINR_Range_SQN_NR_ThresholdNR_thresholdSINR_Optional(_buffer, _size, _lidx, &p->thresholdSINR);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_ThresholdNR_SQN_NR_SIB2_cellReselectionInfoCommon_absThreshSS_BlocksConsolidation_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_ThresholdNR_SQN_NR_SIB2_cellReselectionInfoCommon_absThreshSS_BlocksConsolidation_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_ThresholdNR(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_Q_OffsetRange_e_SQN_NR_SIB2_cellReselectionInfoCommon_rangeToBestCell_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_Q_OffsetRange_e_SQN_NR_SIB2_cellReselectionInfoCommon_rangeToBestCell_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_Q_OffsetRange_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_MobilityStateParameters(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_MobilityStateParameters* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->t_Evaluation = (SQN_NR_MobilityStateParameters_t_Evaluation_e)_tmp;
	}
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->t_HystNormal = (SQN_NR_MobilityStateParameters_t_HystNormal_e)_tmp;
	}
	NTOH_8(p->n_CellChangeMedium, &_buffer[*_lidx], _lidx);
	NTOH_8(p->n_CellChangeHigh, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SIB2_cellReselectionInfoCommon_speedStateReselectionPars_q_HystSF(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SIB2_cellReselectionInfoCommon_speedStateReselectionPars_q_HystSF* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->sf_Medium = (SQN_NR_SIB2_cellReselectionInfoCommon_speedStateReselectionPars_q_HystSFsf_Medium_e)_tmp;
	}
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->sf_High = (SQN_NR_SIB2_cellReselectionInfoCommon_speedStateReselectionPars_q_HystSFsf_High_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SIB2_cellReselectionInfoCommon_speedStateReselectionPars(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SIB2_cellReselectionInfoCommon_speedStateReselectionPars* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecSQN_NR_MobilityStateParameters(_buffer, _size, _lidx, &p->mobilityStateParameters);
	_serNrSysDecSQN_NR_SIB2_cellReselectionInfoCommon_speedStateReselectionPars_q_HystSF(_buffer, _size, _lidx, &p->q_HystSF);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SIB2_cellReselectionInfoCommon_speedStateReselectionPars_speedStateReselectionPars_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SIB2_cellReselectionInfoCommon_speedStateReselectionPars_speedStateReselectionPars_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_SIB2_cellReselectionInfoCommon_speedStateReselectionPars(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SIB2_cellReselectionInfoCommon(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SIB2_cellReselectionInfoCommon* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecUint8_t_SQN_NR_SIB2_cellReselectionInfoCommon_nrofSS_BlocksToAverage_Optional(_buffer, _size, _lidx, &p->nrofSS_BlocksToAverage);
	_serNrSysDecSQN_NR_ThresholdNR_SQN_NR_SIB2_cellReselectionInfoCommon_absThreshSS_BlocksConsolidation_Optional(_buffer, _size, _lidx, &p->absThreshSS_BlocksConsolidation);
	_serNrSysDecSQN_NR_Q_OffsetRange_e_SQN_NR_SIB2_cellReselectionInfoCommon_rangeToBestCell_Optional(_buffer, _size, _lidx, &p->rangeToBestCell);
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->q_Hyst = (SQN_NR_SIB2_cellReselectionInfoCommon_q_Hyst_e)_tmp;
	}
	_serNrSysDecSQN_NR_SIB2_cellReselectionInfoCommon_speedStateReselectionPars_speedStateReselectionPars_Optional(_buffer, _size, _lidx, &p->speedStateReselectionPars);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_ReselectionThreshold_SQN_NR_SIB2_cellReselectionServingFreqInfo_s_NonIntraSearchP_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_ReselectionThreshold_SQN_NR_SIB2_cellReselectionServingFreqInfo_s_NonIntraSearchP_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_ReselectionThresholdQ_SQN_NR_SIB2_cellReselectionServingFreqInfo_s_NonIntraSearchQ_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_ReselectionThresholdQ_SQN_NR_SIB2_cellReselectionServingFreqInfo_s_NonIntraSearchQ_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_ReselectionThresholdQ_SQN_NR_SIB2_cellReselectionServingFreqInfo_threshServingLowQ_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_ReselectionThresholdQ_SQN_NR_SIB2_cellReselectionServingFreqInfo_threshServingLowQ_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_CellReselectionSubPriority_e_SQN_NR_SIB2_cellReselectionServingFreqInfo_cellReselectionSubPriority_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_CellReselectionSubPriority_e_SQN_NR_SIB2_cellReselectionServingFreqInfo_cellReselectionSubPriority_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_CellReselectionSubPriority_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SIB2_cellReselectionServingFreqInfo(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SIB2_cellReselectionServingFreqInfo* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecSQN_NR_ReselectionThreshold_SQN_NR_SIB2_cellReselectionServingFreqInfo_s_NonIntraSearchP_Optional(_buffer, _size, _lidx, &p->s_NonIntraSearchP);
	_serNrSysDecSQN_NR_ReselectionThresholdQ_SQN_NR_SIB2_cellReselectionServingFreqInfo_s_NonIntraSearchQ_Optional(_buffer, _size, _lidx, &p->s_NonIntraSearchQ);
	NTOH_8(p->threshServingLowP, &_buffer[*_lidx], _lidx);
	_serNrSysDecSQN_NR_ReselectionThresholdQ_SQN_NR_SIB2_cellReselectionServingFreqInfo_threshServingLowQ_Optional(_buffer, _size, _lidx, &p->threshServingLowQ);
	NTOH_8(p->cellReselectionPriority, &_buffer[*_lidx], _lidx);
	_serNrSysDecSQN_NR_CellReselectionSubPriority_e_SQN_NR_SIB2_cellReselectionServingFreqInfo_cellReselectionSubPriority_Optional(_buffer, _size, _lidx, &p->cellReselectionSubPriority);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_Q_RxLevMin_SQN_NR_SIB2_intraFreqCellReselectionInfo_q_RxLevMinSUL_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_Q_RxLevMin_SQN_NR_SIB2_intraFreqCellReselectionInfo_q_RxLevMinSUL_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_Q_QualMin_SQN_NR_SIB2_intraFreqCellReselectionInfo_q_QualMin_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_Q_QualMin_SQN_NR_SIB2_intraFreqCellReselectionInfo_q_QualMin_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_ReselectionThresholdQ_SQN_NR_SIB2_intraFreqCellReselectionInfo_s_IntraSearchQ_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_ReselectionThresholdQ_SQN_NR_SIB2_intraFreqCellReselectionInfo_s_IntraSearchQ_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_FreqBandIndicatorNR_SQN_NR_NR_MultiBandInfo_freqBandIndicatorNR_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_FreqBandIndicatorNR_SQN_NR_NR_MultiBandInfo_freqBandIndicatorNR_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_16(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_P_Max_SQN_NR_NR_NS_PmaxValue_additionalPmax_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_P_Max_SQN_NR_NR_NS_PmaxValue_additionalPmax_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_NR_NS_PmaxValue(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_NR_NS_PmaxValue* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecSQN_NR_P_Max_SQN_NR_NR_NS_PmaxValue_additionalPmax_Optional(_buffer, _size, _lidx, &p->additionalPmax);
	NTOH_8(p->additionalSpectrumEmission, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_NR_NS_PmaxList_SQN_NR_NR_MultiBandInfo_nr_NS_PmaxList_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_NR_NS_PmaxList_SQN_NR_NR_MultiBandInfo_nr_NS_PmaxList_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = (struct SQN_NR_NR_NS_PmaxValue*)serMalloc(_mem, p->v.d * sizeof(struct SQN_NR_NR_NS_PmaxValue));
	for (size_t i3 = 0; i3 < p->v.d; i3++) {
		_serNrSysDecSQN_NR_NR_NS_PmaxValue(_buffer, _size, _lidx, &p->v.v[i3]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_NR_MultiBandInfo(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_NR_MultiBandInfo* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecSQN_NR_FreqBandIndicatorNR_SQN_NR_NR_MultiBandInfo_freqBandIndicatorNR_Optional(_buffer, _size, _lidx, &p->freqBandIndicatorNR);
	_serNrSysDecSQN_NR_NR_NS_PmaxList_SQN_NR_NR_MultiBandInfo_nr_NS_PmaxList_Optional(_buffer, _size, _lidx, _mem, &p->nr_NS_PmaxList);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_MultiFrequencyBandListNR_SIB_SQN_NR_SIB2_intraFreqCellReselectionInfo_frequencyBandList_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_MultiFrequencyBandListNR_SIB_SQN_NR_SIB2_intraFreqCellReselectionInfo_frequencyBandList_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = (struct SQN_NR_NR_MultiBandInfo*)serMalloc(_mem, p->v.d * sizeof(struct SQN_NR_NR_MultiBandInfo));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serNrSysDecSQN_NR_NR_MultiBandInfo(_buffer, _size, _lidx, _mem, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_MultiFrequencyBandListNR_SIB_SQN_NR_SIB2_intraFreqCellReselectionInfo_frequencyBandListSUL_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_MultiFrequencyBandListNR_SIB_SQN_NR_SIB2_intraFreqCellReselectionInfo_frequencyBandListSUL_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = (struct SQN_NR_NR_MultiBandInfo*)serMalloc(_mem, p->v.d * sizeof(struct SQN_NR_NR_MultiBandInfo));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serNrSysDecSQN_NR_NR_MultiBandInfo(_buffer, _size, _lidx, _mem, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_P_Max_SQN_NR_SIB2_intraFreqCellReselectionInfo_p_Max_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_P_Max_SQN_NR_SIB2_intraFreqCellReselectionInfo_p_Max_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SSB_MTC_periodicityAndOffset_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union SQN_NR_SSB_MTC_periodicityAndOffset_Value* p, enum SQN_NR_SSB_MTC_periodicityAndOffset_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SSB_MTC_periodicityAndOffset_sf5) {
		NTOH_8(p->sf5, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SSB_MTC_periodicityAndOffset_sf10) {
		NTOH_8(p->sf10, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SSB_MTC_periodicityAndOffset_sf20) {
		NTOH_8(p->sf20, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SSB_MTC_periodicityAndOffset_sf40) {
		NTOH_8(p->sf40, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SSB_MTC_periodicityAndOffset_sf80) {
		NTOH_8(p->sf80, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SSB_MTC_periodicityAndOffset_sf160) {
		NTOH_8(p->sf160, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecSQN_NR_SSB_MTC_periodicityAndOffset(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SSB_MTC_periodicityAndOffset* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SQN_NR_SSB_MTC_periodicityAndOffset_Sel)_tmp;
	}
	_serNrSysDecSQN_NR_SSB_MTC_periodicityAndOffset_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SSB_MTC(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SSB_MTC* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecSQN_NR_SSB_MTC_periodicityAndOffset(_buffer, _size, _lidx, &p->periodicityAndOffset);
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->duration = (SQN_NR_SSB_MTC_duration_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SSB_MTC_SQN_NR_SIB2_intraFreqCellReselectionInfo_smtc_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SSB_MTC_SQN_NR_SIB2_intraFreqCellReselectionInfo_smtc_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_SSB_MTC(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SS_RSSI_Measurement(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_SS_RSSI_Measurement* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_32(p->measurementSlots.d, &_buffer[*_lidx], _lidx);
	p->measurementSlots.v = (BIT_STRING_ELEMENT*)serMalloc(_mem, p->measurementSlots.d * sizeof(BIT_STRING_ELEMENT));
	for (size_t i2 = 0; i2 < p->measurementSlots.d; i2++) {
		NTOH_8(p->measurementSlots.v[i2], &_buffer[*_lidx], _lidx);
	}
	NTOH_8(p->endSymbol, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SS_RSSI_Measurement_SQN_NR_SIB2_intraFreqCellReselectionInfo_ss_RSSI_Measurement_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_SS_RSSI_Measurement_SQN_NR_SIB2_intraFreqCellReselectionInfo_ss_RSSI_Measurement_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_SS_RSSI_Measurement(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SSB_ToMeasure_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union SQN_NR_SSB_ToMeasure_Value* p, enum SQN_NR_SSB_ToMeasure_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SSB_ToMeasure_shortBitmap) {
		for (size_t i2 = 0; i2 < 4; i2++) {
			NTOH_8(p->shortBitmap[i2], &_buffer[*_lidx], _lidx);
		}
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SSB_ToMeasure_mediumBitmap) {
		for (size_t i2 = 0; i2 < 8; i2++) {
			NTOH_8(p->mediumBitmap[i2], &_buffer[*_lidx], _lidx);
		}
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SSB_ToMeasure_longBitmap) {
		for (size_t i2 = 0; i2 < 64; i2++) {
			NTOH_8(p->longBitmap[i2], &_buffer[*_lidx], _lidx);
		}
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecSQN_NR_SSB_ToMeasure(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SSB_ToMeasure* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SQN_NR_SSB_ToMeasure_Sel)_tmp;
	}
	_serNrSysDecSQN_NR_SSB_ToMeasure_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SSB_ToMeasure_SQN_NR_SIB2_intraFreqCellReselectionInfo_ssb_ToMeasure_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SSB_ToMeasure_SQN_NR_SIB2_intraFreqCellReselectionInfo_ssb_ToMeasure_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_SSB_ToMeasure(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SpeedStateScaleFactors(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SpeedStateScaleFactors* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->sf_Medium = (SQN_NR_SpeedStateScaleFactors_sf_Medium_e)_tmp;
	}
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->sf_High = (SQN_NR_SpeedStateScaleFactors_sf_High_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SpeedStateScaleFactors_SQN_NR_SIB2_intraFreqCellReselectionInfo_t_ReselectionNR_SF_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SpeedStateScaleFactors_SQN_NR_SIB2_intraFreqCellReselectionInfo_t_ReselectionNR_SF_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_SpeedStateScaleFactors(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PhysCellId_SQN_NR_SSB_MTC2_LP_r16_pci_List_DynamicOptional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_PhysCellId_SQN_NR_SSB_MTC2_LP_r16_pci_List_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = (SQN_NR_PhysCellId*)serMalloc(_mem, p->v.d * sizeof(SQN_NR_PhysCellId));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		NTOH_16(p->v.v[i2], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SSB_MTC2_LP_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_SSB_MTC2_LP_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecSQN_NR_PhysCellId_SQN_NR_SSB_MTC2_LP_r16_pci_List_DynamicOptional(_buffer, _size, _lidx, _mem, &p->pci_List);
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->periodicity = (SQN_NR_SSB_MTC2_LP_r16_periodicity_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SSB_MTC2_LP_r16_SQN_NR_SIB2_intraFreqCellReselectionInfo_smtc2_LP_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_SSB_MTC2_LP_r16_SQN_NR_SIB2_intraFreqCellReselectionInfo_smtc2_LP_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_SSB_MTC2_LP_r16(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SSB_PositionQCL_Relation_r16_e_SQN_NR_SIB2_intraFreqCellReselectionInfo_ssb_PositionQCL_Common_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SSB_PositionQCL_Relation_r16_e_SQN_NR_SIB2_intraFreqCellReselectionInfo_ssb_PositionQCL_Common_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_SSB_PositionQCL_Relation_r16_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SIB2_intraFreqCellReselectionInfo(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_SIB2_intraFreqCellReselectionInfo* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->q_RxLevMin, &_buffer[*_lidx], _lidx);
	_serNrSysDecSQN_NR_Q_RxLevMin_SQN_NR_SIB2_intraFreqCellReselectionInfo_q_RxLevMinSUL_Optional(_buffer, _size, _lidx, &p->q_RxLevMinSUL);
	_serNrSysDecSQN_NR_Q_QualMin_SQN_NR_SIB2_intraFreqCellReselectionInfo_q_QualMin_Optional(_buffer, _size, _lidx, &p->q_QualMin);
	NTOH_8(p->s_IntraSearchP, &_buffer[*_lidx], _lidx);
	_serNrSysDecSQN_NR_ReselectionThresholdQ_SQN_NR_SIB2_intraFreqCellReselectionInfo_s_IntraSearchQ_Optional(_buffer, _size, _lidx, &p->s_IntraSearchQ);
	NTOH_8(p->t_ReselectionNR, &_buffer[*_lidx], _lidx);
	_serNrSysDecSQN_NR_MultiFrequencyBandListNR_SIB_SQN_NR_SIB2_intraFreqCellReselectionInfo_frequencyBandList_Optional(_buffer, _size, _lidx, _mem, &p->frequencyBandList);
	_serNrSysDecSQN_NR_MultiFrequencyBandListNR_SIB_SQN_NR_SIB2_intraFreqCellReselectionInfo_frequencyBandListSUL_Optional(_buffer, _size, _lidx, _mem, &p->frequencyBandListSUL);
	_serNrSysDecSQN_NR_P_Max_SQN_NR_SIB2_intraFreqCellReselectionInfo_p_Max_Optional(_buffer, _size, _lidx, &p->p_Max);
	_serNrSysDecSQN_NR_SSB_MTC_SQN_NR_SIB2_intraFreqCellReselectionInfo_smtc_Optional(_buffer, _size, _lidx, &p->smtc);
	_serNrSysDecSQN_NR_SS_RSSI_Measurement_SQN_NR_SIB2_intraFreqCellReselectionInfo_ss_RSSI_Measurement_Optional(_buffer, _size, _lidx, _mem, &p->ss_RSSI_Measurement);
	_serNrSysDecSQN_NR_SSB_ToMeasure_SQN_NR_SIB2_intraFreqCellReselectionInfo_ssb_ToMeasure_Optional(_buffer, _size, _lidx, &p->ssb_ToMeasure);
	NTOH_8(p->deriveSSB_IndexFromCell, &_buffer[*_lidx], _lidx);
	_serNrSysDecSQN_NR_SpeedStateScaleFactors_SQN_NR_SIB2_intraFreqCellReselectionInfo_t_ReselectionNR_SF_Optional(_buffer, _size, _lidx, &p->t_ReselectionNR_SF);
	_serNrSysDecSQN_NR_SSB_MTC2_LP_r16_SQN_NR_SIB2_intraFreqCellReselectionInfo_smtc2_LP_r16_Optional(_buffer, _size, _lidx, _mem, &p->smtc2_LP_r16);
	_serNrSysDecSQN_NR_SSB_PositionQCL_Relation_r16_e_SQN_NR_SIB2_intraFreqCellReselectionInfo_ssb_PositionQCL_Common_r16_Optional(_buffer, _size, _lidx, &p->ssb_PositionQCL_Common_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SIB2_relaxedMeasurement_r16_lowMobilityEvaluation_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SIB2_relaxedMeasurement_r16_lowMobilityEvaluation_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->s_SearchDeltaP_r16 = (SQN_NR_SIB2_relaxedMeasurement_r16_lowMobilityEvaluation_r16_s_SearchDeltaP_r16_e)_tmp;
	}
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->t_SearchDeltaP_r16 = (SQN_NR_SIB2_relaxedMeasurement_r16_lowMobilityEvaluation_r16_t_SearchDeltaP_r16_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SIB2_relaxedMeasurement_r16_lowMobilityEvaluation_r16_lowMobilityEvaluation_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SIB2_relaxedMeasurement_r16_lowMobilityEvaluation_r16_lowMobilityEvaluation_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_SIB2_relaxedMeasurement_r16_lowMobilityEvaluation_r16(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_ReselectionThresholdQ_SQN_NR_SIB2_relaxedMeasurement_r16_cellEdgeEvaluation_r16_s_SearchThresholdQ_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_ReselectionThresholdQ_SQN_NR_SIB2_relaxedMeasurement_r16_cellEdgeEvaluation_r16_s_SearchThresholdQ_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SIB2_relaxedMeasurement_r16_cellEdgeEvaluation_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SIB2_relaxedMeasurement_r16_cellEdgeEvaluation_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->s_SearchThresholdP_r16, &_buffer[*_lidx], _lidx);
	_serNrSysDecSQN_NR_ReselectionThresholdQ_SQN_NR_SIB2_relaxedMeasurement_r16_cellEdgeEvaluation_r16_s_SearchThresholdQ_r16_Optional(_buffer, _size, _lidx, &p->s_SearchThresholdQ_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SIB2_relaxedMeasurement_r16_cellEdgeEvaluation_r16_cellEdgeEvaluation_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SIB2_relaxedMeasurement_r16_cellEdgeEvaluation_r16_cellEdgeEvaluation_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_SIB2_relaxedMeasurement_r16_cellEdgeEvaluation_r16(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SIB2_relaxedMeasurement_r16_combineRelaxedMeasCondition_r16_e_combineRelaxedMeasCondition_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SIB2_relaxedMeasurement_r16_combineRelaxedMeasCondition_r16_e_combineRelaxedMeasCondition_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_SIB2_relaxedMeasurement_r16_combineRelaxedMeasCondition_r16_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SIB2_relaxedMeasurement_r16_highPriorityMeasRelax_r16_e_highPriorityMeasRelax_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SIB2_relaxedMeasurement_r16_highPriorityMeasRelax_r16_e_highPriorityMeasRelax_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_SIB2_relaxedMeasurement_r16_highPriorityMeasRelax_r16_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SIB2_relaxedMeasurement_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SIB2_relaxedMeasurement_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecSQN_NR_SIB2_relaxedMeasurement_r16_lowMobilityEvaluation_r16_lowMobilityEvaluation_r16_Optional(_buffer, _size, _lidx, &p->lowMobilityEvaluation_r16);
	_serNrSysDecSQN_NR_SIB2_relaxedMeasurement_r16_cellEdgeEvaluation_r16_cellEdgeEvaluation_r16_Optional(_buffer, _size, _lidx, &p->cellEdgeEvaluation_r16);
	_serNrSysDecSQN_NR_SIB2_relaxedMeasurement_r16_combineRelaxedMeasCondition_r16_e_combineRelaxedMeasCondition_r16_Optional(_buffer, _size, _lidx, &p->combineRelaxedMeasCondition_r16);
	_serNrSysDecSQN_NR_SIB2_relaxedMeasurement_r16_highPriorityMeasRelax_r16_e_highPriorityMeasRelax_r16_Optional(_buffer, _size, _lidx, &p->highPriorityMeasRelax_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SIB2_relaxedMeasurement_r16_relaxedMeasurement_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SIB2_relaxedMeasurement_r16_relaxedMeasurement_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_SIB2_relaxedMeasurement_r16(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SIB2(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_SIB2* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecSQN_NR_SIB2_cellReselectionInfoCommon(_buffer, _size, _lidx, &p->cellReselectionInfoCommon);
	_serNrSysDecSQN_NR_SIB2_cellReselectionServingFreqInfo(_buffer, _size, _lidx, &p->cellReselectionServingFreqInfo);
	_serNrSysDecSQN_NR_SIB2_intraFreqCellReselectionInfo(_buffer, _size, _lidx, _mem, &p->intraFreqCellReselectionInfo);
	_serNrSysDecSQN_NR_SIB2_relaxedMeasurement_r16_relaxedMeasurement_r16_Optional(_buffer, _size, _lidx, &p->relaxedMeasurement_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecUint8_t_SQN_NR_IntraFreqNeighCellInfo_q_RxLevMinOffsetCell_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct uint8_t_SQN_NR_IntraFreqNeighCellInfo_q_RxLevMinOffsetCell_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecUint8_t_SQN_NR_IntraFreqNeighCellInfo_q_RxLevMinOffsetCellSUL_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct uint8_t_SQN_NR_IntraFreqNeighCellInfo_q_RxLevMinOffsetCellSUL_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecUint8_t_SQN_NR_IntraFreqNeighCellInfo_q_QualMinOffsetCell_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct uint8_t_SQN_NR_IntraFreqNeighCellInfo_q_QualMinOffsetCell_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_IntraFreqNeighCellInfo(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_IntraFreqNeighCellInfo* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_16(p->physCellId, &_buffer[*_lidx], _lidx);
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->q_OffsetCell = (SQN_NR_Q_OffsetRange_e)_tmp;
	}
	_serNrSysDecUint8_t_SQN_NR_IntraFreqNeighCellInfo_q_RxLevMinOffsetCell_Optional(_buffer, _size, _lidx, &p->q_RxLevMinOffsetCell);
	_serNrSysDecUint8_t_SQN_NR_IntraFreqNeighCellInfo_q_RxLevMinOffsetCellSUL_Optional(_buffer, _size, _lidx, &p->q_RxLevMinOffsetCellSUL);
	_serNrSysDecUint8_t_SQN_NR_IntraFreqNeighCellInfo_q_QualMinOffsetCell_Optional(_buffer, _size, _lidx, &p->q_QualMinOffsetCell);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_IntraFreqNeighCellList_SQN_NR_SIB3_intraFreqNeighCellList_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_IntraFreqNeighCellList_SQN_NR_SIB3_intraFreqNeighCellList_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = (struct SQN_NR_IntraFreqNeighCellInfo*)serMalloc(_mem, p->v.d * sizeof(struct SQN_NR_IntraFreqNeighCellInfo));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serNrSysDecSQN_NR_IntraFreqNeighCellInfo(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PCI_Range_range_e_range_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_PCI_Range_range_e_range_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_PCI_Range_range_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PCI_Range(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_PCI_Range* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_16(p->start, &_buffer[*_lidx], _lidx);
	_serNrSysDecSQN_NR_PCI_Range_range_e_range_Optional(_buffer, _size, _lidx, &p->range);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_IntraFreqBlackCellList_SQN_NR_SIB3_intraFreqBlackCellList_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_IntraFreqBlackCellList_SQN_NR_SIB3_intraFreqBlackCellList_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = (struct SQN_NR_PCI_Range*)serMalloc(_mem, p->v.d * sizeof(struct SQN_NR_PCI_Range));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serNrSysDecSQN_NR_PCI_Range(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecOCTET_STRING_SQN_NR_SIB3_lateNonCriticalExtension_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct OCTET_STRING_SQN_NR_SIB3_lateNonCriticalExtension_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = (OCTET_STRING_ELEMENT*)serMalloc(_mem, p->v.d * sizeof(OCTET_STRING_ELEMENT));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		NTOH_8(p->v.v[i2], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SSB_PositionQCL_Relation_r16_e_SQN_NR_IntraFreqNeighCellInfo_v1610_ssb_PositionQCL_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SSB_PositionQCL_Relation_r16_e_SQN_NR_IntraFreqNeighCellInfo_v1610_ssb_PositionQCL_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_SSB_PositionQCL_Relation_r16_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_IntraFreqNeighCellInfo_v1610(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_IntraFreqNeighCellInfo_v1610* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecSQN_NR_SSB_PositionQCL_Relation_r16_e_SQN_NR_IntraFreqNeighCellInfo_v1610_ssb_PositionQCL_r16_Optional(_buffer, _size, _lidx, &p->ssb_PositionQCL_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_IntraFreqNeighCellList_v1610_SQN_NR_SIB3_intraFreqNeighCellList_v1610_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_IntraFreqNeighCellList_v1610_SQN_NR_SIB3_intraFreqNeighCellList_v1610_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = (struct SQN_NR_IntraFreqNeighCellInfo_v1610*)serMalloc(_mem, p->v.d * sizeof(struct SQN_NR_IntraFreqNeighCellInfo_v1610));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serNrSysDecSQN_NR_IntraFreqNeighCellInfo_v1610(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_IntraFreqWhiteCellList_r16_SQN_NR_SIB3_intraFreqWhiteCellList_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_IntraFreqWhiteCellList_r16_SQN_NR_SIB3_intraFreqWhiteCellList_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = (struct SQN_NR_PCI_Range*)serMalloc(_mem, p->v.d * sizeof(struct SQN_NR_PCI_Range));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serNrSysDecSQN_NR_PCI_Range(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_IntraFreqCAG_CellListPerPLMN_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_IntraFreqCAG_CellListPerPLMN_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->plmn_IdentityIndex_r16, &_buffer[*_lidx], _lidx);
	NTOH_32(p->cag_CellList_r16.d, &_buffer[*_lidx], _lidx);
	p->cag_CellList_r16.v = (struct SQN_NR_PCI_Range*)serMalloc(_mem, p->cag_CellList_r16.d * sizeof(struct SQN_NR_PCI_Range));
	for (size_t i3 = 0; i3 < p->cag_CellList_r16.d; i3++) {
		_serNrSysDecSQN_NR_PCI_Range(_buffer, _size, _lidx, &p->cag_CellList_r16.v[i3]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_IntraFreqCAG_CellListPerPLMN_r16_SQN_NR_SIB3_intraFreqCAG_CellList_r16_DynamicOptional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_IntraFreqCAG_CellListPerPLMN_r16_SQN_NR_SIB3_intraFreqCAG_CellList_r16_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = (struct SQN_NR_IntraFreqCAG_CellListPerPLMN_r16*)serMalloc(_mem, p->v.d * sizeof(struct SQN_NR_IntraFreqCAG_CellListPerPLMN_r16));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serNrSysDecSQN_NR_IntraFreqCAG_CellListPerPLMN_r16(_buffer, _size, _lidx, _mem, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SIB3(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_SIB3* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecSQN_NR_IntraFreqNeighCellList_SQN_NR_SIB3_intraFreqNeighCellList_Optional(_buffer, _size, _lidx, _mem, &p->intraFreqNeighCellList);
	_serNrSysDecSQN_NR_IntraFreqBlackCellList_SQN_NR_SIB3_intraFreqBlackCellList_Optional(_buffer, _size, _lidx, _mem, &p->intraFreqBlackCellList);
	_serNrSysDecOCTET_STRING_SQN_NR_SIB3_lateNonCriticalExtension_Optional(_buffer, _size, _lidx, _mem, &p->lateNonCriticalExtension);
	_serNrSysDecSQN_NR_IntraFreqNeighCellList_v1610_SQN_NR_SIB3_intraFreqNeighCellList_v1610_Optional(_buffer, _size, _lidx, _mem, &p->intraFreqNeighCellList_v1610);
	_serNrSysDecSQN_NR_IntraFreqWhiteCellList_r16_SQN_NR_SIB3_intraFreqWhiteCellList_r16_Optional(_buffer, _size, _lidx, _mem, &p->intraFreqWhiteCellList_r16);
	_serNrSysDecSQN_NR_IntraFreqCAG_CellListPerPLMN_r16_SQN_NR_SIB3_intraFreqCAG_CellList_r16_DynamicOptional(_buffer, _size, _lidx, _mem, &p->intraFreqCAG_CellList_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_MultiFrequencyBandListNR_SIB_SQN_NR_InterFreqCarrierFreqInfo_frequencyBandList_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_MultiFrequencyBandListNR_SIB_SQN_NR_InterFreqCarrierFreqInfo_frequencyBandList_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = (struct SQN_NR_NR_MultiBandInfo*)serMalloc(_mem, p->v.d * sizeof(struct SQN_NR_NR_MultiBandInfo));
	for (size_t i3 = 0; i3 < p->v.d; i3++) {
		_serNrSysDecSQN_NR_NR_MultiBandInfo(_buffer, _size, _lidx, _mem, &p->v.v[i3]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_MultiFrequencyBandListNR_SIB_SQN_NR_InterFreqCarrierFreqInfo_frequencyBandListSUL_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_MultiFrequencyBandListNR_SIB_SQN_NR_InterFreqCarrierFreqInfo_frequencyBandListSUL_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = (struct SQN_NR_NR_MultiBandInfo*)serMalloc(_mem, p->v.d * sizeof(struct SQN_NR_NR_MultiBandInfo));
	for (size_t i3 = 0; i3 < p->v.d; i3++) {
		_serNrSysDecSQN_NR_NR_MultiBandInfo(_buffer, _size, _lidx, _mem, &p->v.v[i3]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecUint8_t_SQN_NR_InterFreqCarrierFreqInfo_nrofSS_BlocksToAverage_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct uint8_t_SQN_NR_InterFreqCarrierFreqInfo_nrofSS_BlocksToAverage_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_ThresholdNR_SQN_NR_InterFreqCarrierFreqInfo_absThreshSS_BlocksConsolidation_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_ThresholdNR_SQN_NR_InterFreqCarrierFreqInfo_absThreshSS_BlocksConsolidation_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_ThresholdNR(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SSB_MTC_SQN_NR_InterFreqCarrierFreqInfo_smtc_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SSB_MTC_SQN_NR_InterFreqCarrierFreqInfo_smtc_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_SSB_MTC(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SSB_ToMeasure_SQN_NR_InterFreqCarrierFreqInfo_ssb_ToMeasure_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SSB_ToMeasure_SQN_NR_InterFreqCarrierFreqInfo_ssb_ToMeasure_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_SSB_ToMeasure(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SS_RSSI_Measurement_SQN_NR_InterFreqCarrierFreqInfo_ss_RSSI_Measurement_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_SS_RSSI_Measurement_SQN_NR_InterFreqCarrierFreqInfo_ss_RSSI_Measurement_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_SS_RSSI_Measurement(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_Q_RxLevMin_SQN_NR_InterFreqCarrierFreqInfo_q_RxLevMinSUL_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_Q_RxLevMin_SQN_NR_InterFreqCarrierFreqInfo_q_RxLevMinSUL_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_Q_QualMin_SQN_NR_InterFreqCarrierFreqInfo_q_QualMin_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_Q_QualMin_SQN_NR_InterFreqCarrierFreqInfo_q_QualMin_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_P_Max_SQN_NR_InterFreqCarrierFreqInfo_p_Max_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_P_Max_SQN_NR_InterFreqCarrierFreqInfo_p_Max_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SpeedStateScaleFactors_SQN_NR_InterFreqCarrierFreqInfo_t_ReselectionNR_SF_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SpeedStateScaleFactors_SQN_NR_InterFreqCarrierFreqInfo_t_ReselectionNR_SF_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_SpeedStateScaleFactors(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_InterFreqCarrierFreqInfo_threshX_Q(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_InterFreqCarrierFreqInfo_threshX_Q* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->threshX_HighQ, &_buffer[*_lidx], _lidx);
	NTOH_8(p->threshX_LowQ, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_InterFreqCarrierFreqInfo_threshX_Q_threshX_Q_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_InterFreqCarrierFreqInfo_threshX_Q_threshX_Q_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_InterFreqCarrierFreqInfo_threshX_Q(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_CellReselectionPriority_SQN_NR_InterFreqCarrierFreqInfo_cellReselectionPriority_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_CellReselectionPriority_SQN_NR_InterFreqCarrierFreqInfo_cellReselectionPriority_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_CellReselectionSubPriority_e_SQN_NR_InterFreqCarrierFreqInfo_cellReselectionSubPriority_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_CellReselectionSubPriority_e_SQN_NR_InterFreqCarrierFreqInfo_cellReselectionSubPriority_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_CellReselectionSubPriority_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_Q_OffsetRange_e_SQN_NR_InterFreqCarrierFreqInfo_q_OffsetFreq_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_Q_OffsetRange_e_SQN_NR_InterFreqCarrierFreqInfo_q_OffsetFreq_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_Q_OffsetRange_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecUint8_t_SQN_NR_InterFreqNeighCellInfo_q_RxLevMinOffsetCell_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct uint8_t_SQN_NR_InterFreqNeighCellInfo_q_RxLevMinOffsetCell_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecUint8_t_SQN_NR_InterFreqNeighCellInfo_q_RxLevMinOffsetCellSUL_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct uint8_t_SQN_NR_InterFreqNeighCellInfo_q_RxLevMinOffsetCellSUL_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecUint8_t_SQN_NR_InterFreqNeighCellInfo_q_QualMinOffsetCell_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct uint8_t_SQN_NR_InterFreqNeighCellInfo_q_QualMinOffsetCell_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_InterFreqNeighCellInfo(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_InterFreqNeighCellInfo* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_16(p->physCellId, &_buffer[*_lidx], _lidx);
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->q_OffsetCell = (SQN_NR_Q_OffsetRange_e)_tmp;
	}
	_serNrSysDecUint8_t_SQN_NR_InterFreqNeighCellInfo_q_RxLevMinOffsetCell_Optional(_buffer, _size, _lidx, &p->q_RxLevMinOffsetCell);
	_serNrSysDecUint8_t_SQN_NR_InterFreqNeighCellInfo_q_RxLevMinOffsetCellSUL_Optional(_buffer, _size, _lidx, &p->q_RxLevMinOffsetCellSUL);
	_serNrSysDecUint8_t_SQN_NR_InterFreqNeighCellInfo_q_QualMinOffsetCell_Optional(_buffer, _size, _lidx, &p->q_QualMinOffsetCell);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_InterFreqNeighCellList_SQN_NR_InterFreqCarrierFreqInfo_interFreqNeighCellList_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_InterFreqNeighCellList_SQN_NR_InterFreqCarrierFreqInfo_interFreqNeighCellList_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = (struct SQN_NR_InterFreqNeighCellInfo*)serMalloc(_mem, p->v.d * sizeof(struct SQN_NR_InterFreqNeighCellInfo));
	for (size_t i3 = 0; i3 < p->v.d; i3++) {
		_serNrSysDecSQN_NR_InterFreqNeighCellInfo(_buffer, _size, _lidx, &p->v.v[i3]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_InterFreqBlackCellList_SQN_NR_InterFreqCarrierFreqInfo_interFreqBlackCellList_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_InterFreqBlackCellList_SQN_NR_InterFreqCarrierFreqInfo_interFreqBlackCellList_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = (struct SQN_NR_PCI_Range*)serMalloc(_mem, p->v.d * sizeof(struct SQN_NR_PCI_Range));
	for (size_t i3 = 0; i3 < p->v.d; i3++) {
		_serNrSysDecSQN_NR_PCI_Range(_buffer, _size, _lidx, &p->v.v[i3]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_InterFreqCarrierFreqInfo(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_InterFreqCarrierFreqInfo* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_32(p->dl_CarrierFreq, &_buffer[*_lidx], _lidx);
	_serNrSysDecSQN_NR_MultiFrequencyBandListNR_SIB_SQN_NR_InterFreqCarrierFreqInfo_frequencyBandList_Optional(_buffer, _size, _lidx, _mem, &p->frequencyBandList);
	_serNrSysDecSQN_NR_MultiFrequencyBandListNR_SIB_SQN_NR_InterFreqCarrierFreqInfo_frequencyBandListSUL_Optional(_buffer, _size, _lidx, _mem, &p->frequencyBandListSUL);
	_serNrSysDecUint8_t_SQN_NR_InterFreqCarrierFreqInfo_nrofSS_BlocksToAverage_Optional(_buffer, _size, _lidx, &p->nrofSS_BlocksToAverage);
	_serNrSysDecSQN_NR_ThresholdNR_SQN_NR_InterFreqCarrierFreqInfo_absThreshSS_BlocksConsolidation_Optional(_buffer, _size, _lidx, &p->absThreshSS_BlocksConsolidation);
	_serNrSysDecSQN_NR_SSB_MTC_SQN_NR_InterFreqCarrierFreqInfo_smtc_Optional(_buffer, _size, _lidx, &p->smtc);
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->ssbSubcarrierSpacing = (SQN_NR_SubcarrierSpacing_e)_tmp;
	}
	_serNrSysDecSQN_NR_SSB_ToMeasure_SQN_NR_InterFreqCarrierFreqInfo_ssb_ToMeasure_Optional(_buffer, _size, _lidx, &p->ssb_ToMeasure);
	NTOH_8(p->deriveSSB_IndexFromCell, &_buffer[*_lidx], _lidx);
	_serNrSysDecSQN_NR_SS_RSSI_Measurement_SQN_NR_InterFreqCarrierFreqInfo_ss_RSSI_Measurement_Optional(_buffer, _size, _lidx, _mem, &p->ss_RSSI_Measurement);
	NTOH_8(p->q_RxLevMin, &_buffer[*_lidx], _lidx);
	_serNrSysDecSQN_NR_Q_RxLevMin_SQN_NR_InterFreqCarrierFreqInfo_q_RxLevMinSUL_Optional(_buffer, _size, _lidx, &p->q_RxLevMinSUL);
	_serNrSysDecSQN_NR_Q_QualMin_SQN_NR_InterFreqCarrierFreqInfo_q_QualMin_Optional(_buffer, _size, _lidx, &p->q_QualMin);
	_serNrSysDecSQN_NR_P_Max_SQN_NR_InterFreqCarrierFreqInfo_p_Max_Optional(_buffer, _size, _lidx, &p->p_Max);
	NTOH_8(p->t_ReselectionNR, &_buffer[*_lidx], _lidx);
	_serNrSysDecSQN_NR_SpeedStateScaleFactors_SQN_NR_InterFreqCarrierFreqInfo_t_ReselectionNR_SF_Optional(_buffer, _size, _lidx, &p->t_ReselectionNR_SF);
	NTOH_8(p->threshX_HighP, &_buffer[*_lidx], _lidx);
	NTOH_8(p->threshX_LowP, &_buffer[*_lidx], _lidx);
	_serNrSysDecSQN_NR_InterFreqCarrierFreqInfo_threshX_Q_threshX_Q_Optional(_buffer, _size, _lidx, &p->threshX_Q);
	_serNrSysDecSQN_NR_CellReselectionPriority_SQN_NR_InterFreqCarrierFreqInfo_cellReselectionPriority_Optional(_buffer, _size, _lidx, &p->cellReselectionPriority);
	_serNrSysDecSQN_NR_CellReselectionSubPriority_e_SQN_NR_InterFreqCarrierFreqInfo_cellReselectionSubPriority_Optional(_buffer, _size, _lidx, &p->cellReselectionSubPriority);
	_serNrSysDecSQN_NR_Q_OffsetRange_e_SQN_NR_InterFreqCarrierFreqInfo_q_OffsetFreq_Optional(_buffer, _size, _lidx, &p->q_OffsetFreq);
	_serNrSysDecSQN_NR_InterFreqNeighCellList_SQN_NR_InterFreqCarrierFreqInfo_interFreqNeighCellList_Optional(_buffer, _size, _lidx, _mem, &p->interFreqNeighCellList);
	_serNrSysDecSQN_NR_InterFreqBlackCellList_SQN_NR_InterFreqCarrierFreqInfo_interFreqBlackCellList_Optional(_buffer, _size, _lidx, _mem, &p->interFreqBlackCellList);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecOCTET_STRING_SQN_NR_SIB4_lateNonCriticalExtension_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct OCTET_STRING_SQN_NR_SIB4_lateNonCriticalExtension_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = (OCTET_STRING_ELEMENT*)serMalloc(_mem, p->v.d * sizeof(OCTET_STRING_ELEMENT));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		NTOH_8(p->v.v[i2], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SSB_PositionQCL_Relation_r16_e_SQN_NR_InterFreqNeighCellInfo_v1610_ssb_PositionQCL_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SSB_PositionQCL_Relation_r16_e_SQN_NR_InterFreqNeighCellInfo_v1610_ssb_PositionQCL_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_SSB_PositionQCL_Relation_r16_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_InterFreqNeighCellInfo_v1610(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_InterFreqNeighCellInfo_v1610* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecSQN_NR_SSB_PositionQCL_Relation_r16_e_SQN_NR_InterFreqNeighCellInfo_v1610_ssb_PositionQCL_r16_Optional(_buffer, _size, _lidx, &p->ssb_PositionQCL_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_InterFreqNeighCellList_v1610_SQN_NR_InterFreqCarrierFreqInfo_v1610_interFreqNeighCellList_v1610_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_InterFreqNeighCellList_v1610_SQN_NR_InterFreqCarrierFreqInfo_v1610_interFreqNeighCellList_v1610_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = (struct SQN_NR_InterFreqNeighCellInfo_v1610*)serMalloc(_mem, p->v.d * sizeof(struct SQN_NR_InterFreqNeighCellInfo_v1610));
	for (size_t i3 = 0; i3 < p->v.d; i3++) {
		_serNrSysDecSQN_NR_InterFreqNeighCellInfo_v1610(_buffer, _size, _lidx, &p->v.v[i3]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SSB_MTC2_LP_r16_SQN_NR_InterFreqCarrierFreqInfo_v1610_smtc2_LP_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_SSB_MTC2_LP_r16_SQN_NR_InterFreqCarrierFreqInfo_v1610_smtc2_LP_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_SSB_MTC2_LP_r16(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_InterFreqWhiteCellList_r16_SQN_NR_InterFreqCarrierFreqInfo_v1610_interFreqWhiteCellList_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_InterFreqWhiteCellList_r16_SQN_NR_InterFreqCarrierFreqInfo_v1610_interFreqWhiteCellList_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = (struct SQN_NR_PCI_Range*)serMalloc(_mem, p->v.d * sizeof(struct SQN_NR_PCI_Range));
	for (size_t i3 = 0; i3 < p->v.d; i3++) {
		_serNrSysDecSQN_NR_PCI_Range(_buffer, _size, _lidx, &p->v.v[i3]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SSB_PositionQCL_Relation_r16_e_SQN_NR_InterFreqCarrierFreqInfo_v1610_ssb_PositionQCL_Common_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SSB_PositionQCL_Relation_r16_e_SQN_NR_InterFreqCarrierFreqInfo_v1610_ssb_PositionQCL_Common_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_SSB_PositionQCL_Relation_r16_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_InterFreqCAG_CellListPerPLMN_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_InterFreqCAG_CellListPerPLMN_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->plmn_IdentityIndex_r16, &_buffer[*_lidx], _lidx);
	NTOH_32(p->cag_CellList_r16.d, &_buffer[*_lidx], _lidx);
	p->cag_CellList_r16.v = (struct SQN_NR_PCI_Range*)serMalloc(_mem, p->cag_CellList_r16.d * sizeof(struct SQN_NR_PCI_Range));
	for (size_t i4 = 0; i4 < p->cag_CellList_r16.d; i4++) {
		_serNrSysDecSQN_NR_PCI_Range(_buffer, _size, _lidx, &p->cag_CellList_r16.v[i4]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_InterFreqCAG_CellListPerPLMN_r16_SQN_NR_InterFreqCarrierFreqInfo_v1610_interFreqCAG_CellList_r16_DynamicOptional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_InterFreqCAG_CellListPerPLMN_r16_SQN_NR_InterFreqCarrierFreqInfo_v1610_interFreqCAG_CellList_r16_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = (struct SQN_NR_InterFreqCAG_CellListPerPLMN_r16*)serMalloc(_mem, p->v.d * sizeof(struct SQN_NR_InterFreqCAG_CellListPerPLMN_r16));
	for (size_t i3 = 0; i3 < p->v.d; i3++) {
		_serNrSysDecSQN_NR_InterFreqCAG_CellListPerPLMN_r16(_buffer, _size, _lidx, _mem, &p->v.v[i3]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_InterFreqCarrierFreqInfo_v1610(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_InterFreqCarrierFreqInfo_v1610* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecSQN_NR_InterFreqNeighCellList_v1610_SQN_NR_InterFreqCarrierFreqInfo_v1610_interFreqNeighCellList_v1610_Optional(_buffer, _size, _lidx, _mem, &p->interFreqNeighCellList_v1610);
	_serNrSysDecSQN_NR_SSB_MTC2_LP_r16_SQN_NR_InterFreqCarrierFreqInfo_v1610_smtc2_LP_r16_Optional(_buffer, _size, _lidx, _mem, &p->smtc2_LP_r16);
	_serNrSysDecSQN_NR_InterFreqWhiteCellList_r16_SQN_NR_InterFreqCarrierFreqInfo_v1610_interFreqWhiteCellList_r16_Optional(_buffer, _size, _lidx, _mem, &p->interFreqWhiteCellList_r16);
	_serNrSysDecSQN_NR_SSB_PositionQCL_Relation_r16_e_SQN_NR_InterFreqCarrierFreqInfo_v1610_ssb_PositionQCL_Common_r16_Optional(_buffer, _size, _lidx, &p->ssb_PositionQCL_Common_r16);
	_serNrSysDecSQN_NR_InterFreqCAG_CellListPerPLMN_r16_SQN_NR_InterFreqCarrierFreqInfo_v1610_interFreqCAG_CellList_r16_DynamicOptional(_buffer, _size, _lidx, _mem, &p->interFreqCAG_CellList_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_InterFreqCarrierFreqList_v1610_SQN_NR_SIB4_interFreqCarrierFreqList_v1610_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_InterFreqCarrierFreqList_v1610_SQN_NR_SIB4_interFreqCarrierFreqList_v1610_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = (struct SQN_NR_InterFreqCarrierFreqInfo_v1610*)serMalloc(_mem, p->v.d * sizeof(struct SQN_NR_InterFreqCarrierFreqInfo_v1610));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serNrSysDecSQN_NR_InterFreqCarrierFreqInfo_v1610(_buffer, _size, _lidx, _mem, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SIB4(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_SIB4* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_32(p->interFreqCarrierFreqList.d, &_buffer[*_lidx], _lidx);
	p->interFreqCarrierFreqList.v = (struct SQN_NR_InterFreqCarrierFreqInfo*)serMalloc(_mem, p->interFreqCarrierFreqList.d * sizeof(struct SQN_NR_InterFreqCarrierFreqInfo));
	for (size_t i2 = 0; i2 < p->interFreqCarrierFreqList.d; i2++) {
		_serNrSysDecSQN_NR_InterFreqCarrierFreqInfo(_buffer, _size, _lidx, _mem, &p->interFreqCarrierFreqList.v[i2]);
	}
	_serNrSysDecOCTET_STRING_SQN_NR_SIB4_lateNonCriticalExtension_Optional(_buffer, _size, _lidx, _mem, &p->lateNonCriticalExtension);
	_serNrSysDecSQN_NR_InterFreqCarrierFreqList_v1610_SQN_NR_SIB4_interFreqCarrierFreqList_v1610_Optional(_buffer, _size, _lidx, _mem, &p->interFreqCarrierFreqList_v1610);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecInt8_t_SQN_NR_EUTRA_NS_PmaxValue_additionalPmax_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct int8_t_SQN_NR_EUTRA_NS_PmaxValue_additionalPmax_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecUint16_t_SQN_NR_EUTRA_NS_PmaxValue_additionalSpectrumEmission_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct uint16_t_SQN_NR_EUTRA_NS_PmaxValue_additionalSpectrumEmission_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_16(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_EUTRA_NS_PmaxValue(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_EUTRA_NS_PmaxValue* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecInt8_t_SQN_NR_EUTRA_NS_PmaxValue_additionalPmax_Optional(_buffer, _size, _lidx, &p->additionalPmax);
	_serNrSysDecUint16_t_SQN_NR_EUTRA_NS_PmaxValue_additionalSpectrumEmission_Optional(_buffer, _size, _lidx, &p->additionalSpectrumEmission);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_EUTRA_NS_PmaxList_SQN_NR_EUTRA_MultiBandInfo_eutra_NS_PmaxList_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_EUTRA_NS_PmaxList_SQN_NR_EUTRA_MultiBandInfo_eutra_NS_PmaxList_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = (struct SQN_NR_EUTRA_NS_PmaxValue*)serMalloc(_mem, p->v.d * sizeof(struct SQN_NR_EUTRA_NS_PmaxValue));
	for (size_t i4 = 0; i4 < p->v.d; i4++) {
		_serNrSysDecSQN_NR_EUTRA_NS_PmaxValue(_buffer, _size, _lidx, &p->v.v[i4]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_EUTRA_MultiBandInfo(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_EUTRA_MultiBandInfo* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_16(p->eutra_FreqBandIndicator, &_buffer[*_lidx], _lidx);
	_serNrSysDecSQN_NR_EUTRA_NS_PmaxList_SQN_NR_EUTRA_MultiBandInfo_eutra_NS_PmaxList_Optional(_buffer, _size, _lidx, _mem, &p->eutra_NS_PmaxList);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_EUTRA_MultiBandInfoList_SQN_NR_CarrierFreqEUTRA_eutra_multiBandInfoList_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_EUTRA_MultiBandInfoList_SQN_NR_CarrierFreqEUTRA_eutra_multiBandInfoList_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = (struct SQN_NR_EUTRA_MultiBandInfo*)serMalloc(_mem, p->v.d * sizeof(struct SQN_NR_EUTRA_MultiBandInfo));
	for (size_t i3 = 0; i3 < p->v.d; i3++) {
		_serNrSysDecSQN_NR_EUTRA_MultiBandInfo(_buffer, _size, _lidx, _mem, &p->v.v[i3]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecUint8_t_SQN_NR_EUTRA_FreqNeighCellInfo_q_RxLevMinOffsetCell_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct uint8_t_SQN_NR_EUTRA_FreqNeighCellInfo_q_RxLevMinOffsetCell_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecUint8_t_SQN_NR_EUTRA_FreqNeighCellInfo_q_QualMinOffsetCell_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct uint8_t_SQN_NR_EUTRA_FreqNeighCellInfo_q_QualMinOffsetCell_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_EUTRA_FreqNeighCellInfo(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_EUTRA_FreqNeighCellInfo* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_16(p->physCellId, &_buffer[*_lidx], _lidx);
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->dummy = (SQN_NR_EUTRA_Q_OffsetRange_e)_tmp;
	}
	_serNrSysDecUint8_t_SQN_NR_EUTRA_FreqNeighCellInfo_q_RxLevMinOffsetCell_Optional(_buffer, _size, _lidx, &p->q_RxLevMinOffsetCell);
	_serNrSysDecUint8_t_SQN_NR_EUTRA_FreqNeighCellInfo_q_QualMinOffsetCell_Optional(_buffer, _size, _lidx, &p->q_QualMinOffsetCell);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_EUTRA_FreqNeighCellList_SQN_NR_CarrierFreqEUTRA_eutra_FreqNeighCellList_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_EUTRA_FreqNeighCellList_SQN_NR_CarrierFreqEUTRA_eutra_FreqNeighCellList_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = (struct SQN_NR_EUTRA_FreqNeighCellInfo*)serMalloc(_mem, p->v.d * sizeof(struct SQN_NR_EUTRA_FreqNeighCellInfo));
	for (size_t i3 = 0; i3 < p->v.d; i3++) {
		_serNrSysDecSQN_NR_EUTRA_FreqNeighCellInfo(_buffer, _size, _lidx, &p->v.v[i3]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_EUTRA_PhysCellIdRange_range_e_range_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_EUTRA_PhysCellIdRange_range_e_range_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_EUTRA_PhysCellIdRange_range_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_EUTRA_PhysCellIdRange(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_EUTRA_PhysCellIdRange* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_16(p->start, &_buffer[*_lidx], _lidx);
	_serNrSysDecSQN_NR_EUTRA_PhysCellIdRange_range_e_range_Optional(_buffer, _size, _lidx, &p->range);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_EUTRA_FreqBlackCellList_SQN_NR_CarrierFreqEUTRA_eutra_BlackCellList_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_EUTRA_FreqBlackCellList_SQN_NR_CarrierFreqEUTRA_eutra_BlackCellList_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = (struct SQN_NR_EUTRA_PhysCellIdRange*)serMalloc(_mem, p->v.d * sizeof(struct SQN_NR_EUTRA_PhysCellIdRange));
	for (size_t i3 = 0; i3 < p->v.d; i3++) {
		_serNrSysDecSQN_NR_EUTRA_PhysCellIdRange(_buffer, _size, _lidx, &p->v.v[i3]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_CellReselectionPriority_SQN_NR_CarrierFreqEUTRA_cellReselectionPriority_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_CellReselectionPriority_SQN_NR_CarrierFreqEUTRA_cellReselectionPriority_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_CellReselectionSubPriority_e_SQN_NR_CarrierFreqEUTRA_cellReselectionSubPriority_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_CellReselectionSubPriority_e_SQN_NR_CarrierFreqEUTRA_cellReselectionSubPriority_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_CellReselectionSubPriority_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_CarrierFreqEUTRA_threshX_Q(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_CarrierFreqEUTRA_threshX_Q* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->threshX_HighQ, &_buffer[*_lidx], _lidx);
	NTOH_8(p->threshX_LowQ, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_CarrierFreqEUTRA_threshX_Q_threshX_Q_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_CarrierFreqEUTRA_threshX_Q_threshX_Q_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_CarrierFreqEUTRA_threshX_Q(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_CarrierFreqEUTRA(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_CarrierFreqEUTRA* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_32(p->carrierFreq, &_buffer[*_lidx], _lidx);
	_serNrSysDecSQN_NR_EUTRA_MultiBandInfoList_SQN_NR_CarrierFreqEUTRA_eutra_multiBandInfoList_Optional(_buffer, _size, _lidx, _mem, &p->eutra_multiBandInfoList);
	_serNrSysDecSQN_NR_EUTRA_FreqNeighCellList_SQN_NR_CarrierFreqEUTRA_eutra_FreqNeighCellList_Optional(_buffer, _size, _lidx, _mem, &p->eutra_FreqNeighCellList);
	_serNrSysDecSQN_NR_EUTRA_FreqBlackCellList_SQN_NR_CarrierFreqEUTRA_eutra_BlackCellList_Optional(_buffer, _size, _lidx, _mem, &p->eutra_BlackCellList);
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->allowedMeasBandwidth = (SQN_NR_EUTRA_AllowedMeasBandwidth_e)_tmp;
	}
	NTOH_8(p->presenceAntennaPort1, &_buffer[*_lidx], _lidx);
	_serNrSysDecSQN_NR_CellReselectionPriority_SQN_NR_CarrierFreqEUTRA_cellReselectionPriority_Optional(_buffer, _size, _lidx, &p->cellReselectionPriority);
	_serNrSysDecSQN_NR_CellReselectionSubPriority_e_SQN_NR_CarrierFreqEUTRA_cellReselectionSubPriority_Optional(_buffer, _size, _lidx, &p->cellReselectionSubPriority);
	NTOH_8(p->threshX_High, &_buffer[*_lidx], _lidx);
	NTOH_8(p->threshX_Low, &_buffer[*_lidx], _lidx);
	NTOH_8(p->q_RxLevMin, &_buffer[*_lidx], _lidx);
	NTOH_8(p->q_QualMin, &_buffer[*_lidx], _lidx);
	NTOH_8(p->p_MaxEUTRA, &_buffer[*_lidx], _lidx);
	_serNrSysDecSQN_NR_CarrierFreqEUTRA_threshX_Q_threshX_Q_Optional(_buffer, _size, _lidx, &p->threshX_Q);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_CarrierFreqListEUTRA_SQN_NR_SIB5_carrierFreqListEUTRA_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_CarrierFreqListEUTRA_SQN_NR_SIB5_carrierFreqListEUTRA_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = (struct SQN_NR_CarrierFreqEUTRA*)serMalloc(_mem, p->v.d * sizeof(struct SQN_NR_CarrierFreqEUTRA));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serNrSysDecSQN_NR_CarrierFreqEUTRA(_buffer, _size, _lidx, _mem, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SpeedStateScaleFactors_SQN_NR_SIB5_t_ReselectionEUTRA_SF_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SpeedStateScaleFactors_SQN_NR_SIB5_t_ReselectionEUTRA_SF_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_SpeedStateScaleFactors(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecOCTET_STRING_SQN_NR_SIB5_lateNonCriticalExtension_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct OCTET_STRING_SQN_NR_SIB5_lateNonCriticalExtension_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = (OCTET_STRING_ELEMENT*)serMalloc(_mem, p->v.d * sizeof(OCTET_STRING_ELEMENT));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		NTOH_8(p->v.v[i2], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_CarrierFreqEUTRA_v1610_highSpeedEUTRACarrier_r16_e_highSpeedEUTRACarrier_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_CarrierFreqEUTRA_v1610_highSpeedEUTRACarrier_r16_e_highSpeedEUTRACarrier_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_CarrierFreqEUTRA_v1610_highSpeedEUTRACarrier_r16_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_CarrierFreqEUTRA_v1610(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_CarrierFreqEUTRA_v1610* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecSQN_NR_CarrierFreqEUTRA_v1610_highSpeedEUTRACarrier_r16_e_highSpeedEUTRACarrier_r16_Optional(_buffer, _size, _lidx, &p->highSpeedEUTRACarrier_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_CarrierFreqListEUTRA_v1610_SQN_NR_SIB5_carrierFreqListEUTRA_v1610_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_CarrierFreqListEUTRA_v1610_SQN_NR_SIB5_carrierFreqListEUTRA_v1610_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = (struct SQN_NR_CarrierFreqEUTRA_v1610*)serMalloc(_mem, p->v.d * sizeof(struct SQN_NR_CarrierFreqEUTRA_v1610));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serNrSysDecSQN_NR_CarrierFreqEUTRA_v1610(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SIB5(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_SIB5* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecSQN_NR_CarrierFreqListEUTRA_SQN_NR_SIB5_carrierFreqListEUTRA_Optional(_buffer, _size, _lidx, _mem, &p->carrierFreqListEUTRA);
	NTOH_8(p->t_ReselectionEUTRA, &_buffer[*_lidx], _lidx);
	_serNrSysDecSQN_NR_SpeedStateScaleFactors_SQN_NR_SIB5_t_ReselectionEUTRA_SF_Optional(_buffer, _size, _lidx, &p->t_ReselectionEUTRA_SF);
	_serNrSysDecOCTET_STRING_SQN_NR_SIB5_lateNonCriticalExtension_Optional(_buffer, _size, _lidx, _mem, &p->lateNonCriticalExtension);
	_serNrSysDecSQN_NR_CarrierFreqListEUTRA_v1610_SQN_NR_SIB5_carrierFreqListEUTRA_v1610_Optional(_buffer, _size, _lidx, _mem, &p->carrierFreqListEUTRA_v1610);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecOCTET_STRING_SQN_NR_SIB6_lateNonCriticalExtension_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct OCTET_STRING_SQN_NR_SIB6_lateNonCriticalExtension_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = (OCTET_STRING_ELEMENT*)serMalloc(_mem, p->v.d * sizeof(OCTET_STRING_ELEMENT));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		NTOH_8(p->v.v[i2], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SIB6(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_SIB6* p)
{
	(void)_size; // TODO: generate boundaries checking

	for (size_t i2 = 0; i2 < 16; i2++) {
		NTOH_8(p->messageIdentifier[i2], &_buffer[*_lidx], _lidx);
	}
	for (size_t i2 = 0; i2 < 16; i2++) {
		NTOH_8(p->serialNumber[i2], &_buffer[*_lidx], _lidx);
	}
	for (size_t i2 = 0; i2 < 2; i2++) {
		NTOH_8(p->warningType[i2], &_buffer[*_lidx], _lidx);
	}
	_serNrSysDecOCTET_STRING_SQN_NR_SIB6_lateNonCriticalExtension_Optional(_buffer, _size, _lidx, _mem, &p->lateNonCriticalExtension);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecO1_SQN_NR_SIB7_dataCodingScheme_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct O1_SQN_NR_SIB7_dataCodingScheme_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	for (size_t i2 = 0; i2 < 1; i2++) {
		NTOH_8(p->v[i2], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecOCTET_STRING_SQN_NR_SIB7_lateNonCriticalExtension_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct OCTET_STRING_SQN_NR_SIB7_lateNonCriticalExtension_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = (OCTET_STRING_ELEMENT*)serMalloc(_mem, p->v.d * sizeof(OCTET_STRING_ELEMENT));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		NTOH_8(p->v.v[i2], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SIB7(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_SIB7* p)
{
	(void)_size; // TODO: generate boundaries checking

	for (size_t i2 = 0; i2 < 16; i2++) {
		NTOH_8(p->messageIdentifier[i2], &_buffer[*_lidx], _lidx);
	}
	for (size_t i2 = 0; i2 < 16; i2++) {
		NTOH_8(p->serialNumber[i2], &_buffer[*_lidx], _lidx);
	}
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->warningMessageSegmentType = (SQN_NR_SIB7_warningMessageSegmentType_e)_tmp;
	}
	NTOH_8(p->warningMessageSegmentNumber, &_buffer[*_lidx], _lidx);
	NTOH_32(p->warningMessageSegment.d, &_buffer[*_lidx], _lidx);
	p->warningMessageSegment.v = (OCTET_STRING_ELEMENT*)serMalloc(_mem, p->warningMessageSegment.d * sizeof(OCTET_STRING_ELEMENT));
	for (size_t i2 = 0; i2 < p->warningMessageSegment.d; i2++) {
		NTOH_8(p->warningMessageSegment.v[i2], &_buffer[*_lidx], _lidx);
	}
	_serNrSysDecO1_SQN_NR_SIB7_dataCodingScheme_Optional(_buffer, _size, _lidx, &p->dataCodingScheme);
	_serNrSysDecOCTET_STRING_SQN_NR_SIB7_lateNonCriticalExtension_Optional(_buffer, _size, _lidx, _mem, &p->lateNonCriticalExtension);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecO1_SQN_NR_SIB8_dataCodingScheme_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct O1_SQN_NR_SIB8_dataCodingScheme_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	for (size_t i2 = 0; i2 < 1; i2++) {
		NTOH_8(p->v[i2], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecOCTET_STRING_SQN_NR_SIB8_warningAreaCoordinatesSegment_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct OCTET_STRING_SQN_NR_SIB8_warningAreaCoordinatesSegment_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = (OCTET_STRING_ELEMENT*)serMalloc(_mem, p->v.d * sizeof(OCTET_STRING_ELEMENT));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		NTOH_8(p->v.v[i2], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecOCTET_STRING_SQN_NR_SIB8_lateNonCriticalExtension_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct OCTET_STRING_SQN_NR_SIB8_lateNonCriticalExtension_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = (OCTET_STRING_ELEMENT*)serMalloc(_mem, p->v.d * sizeof(OCTET_STRING_ELEMENT));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		NTOH_8(p->v.v[i2], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SIB8(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_SIB8* p)
{
	(void)_size; // TODO: generate boundaries checking

	for (size_t i2 = 0; i2 < 16; i2++) {
		NTOH_8(p->messageIdentifier[i2], &_buffer[*_lidx], _lidx);
	}
	for (size_t i2 = 0; i2 < 16; i2++) {
		NTOH_8(p->serialNumber[i2], &_buffer[*_lidx], _lidx);
	}
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->warningMessageSegmentType = (SQN_NR_SIB8_warningMessageSegmentType_e)_tmp;
	}
	NTOH_8(p->warningMessageSegmentNumber, &_buffer[*_lidx], _lidx);
	NTOH_32(p->warningMessageSegment.d, &_buffer[*_lidx], _lidx);
	p->warningMessageSegment.v = (OCTET_STRING_ELEMENT*)serMalloc(_mem, p->warningMessageSegment.d * sizeof(OCTET_STRING_ELEMENT));
	for (size_t i2 = 0; i2 < p->warningMessageSegment.d; i2++) {
		NTOH_8(p->warningMessageSegment.v[i2], &_buffer[*_lidx], _lidx);
	}
	_serNrSysDecO1_SQN_NR_SIB8_dataCodingScheme_Optional(_buffer, _size, _lidx, &p->dataCodingScheme);
	_serNrSysDecOCTET_STRING_SQN_NR_SIB8_warningAreaCoordinatesSegment_Optional(_buffer, _size, _lidx, _mem, &p->warningAreaCoordinatesSegment);
	_serNrSysDecOCTET_STRING_SQN_NR_SIB8_lateNonCriticalExtension_Optional(_buffer, _size, _lidx, _mem, &p->lateNonCriticalExtension);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecB2_SQN_NR_SIB9_timeInfo_dayLightSavingTime_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct B2_SQN_NR_SIB9_timeInfo_dayLightSavingTime_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	for (size_t i2 = 0; i2 < 2; i2++) {
		NTOH_8(p->v[i2], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecInt16_t_SQN_NR_SIB9_timeInfo_leapSeconds_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct int16_t_SQN_NR_SIB9_timeInfo_leapSeconds_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_16(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecInt8_t_SQN_NR_SIB9_timeInfo_localTimeOffset_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct int8_t_SQN_NR_SIB9_timeInfo_localTimeOffset_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SIB9_timeInfo(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SIB9_timeInfo* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_32(p->timeInfoUTC, &_buffer[*_lidx], _lidx);
	_serNrSysDecB2_SQN_NR_SIB9_timeInfo_dayLightSavingTime_Optional(_buffer, _size, _lidx, &p->dayLightSavingTime);
	_serNrSysDecInt16_t_SQN_NR_SIB9_timeInfo_leapSeconds_Optional(_buffer, _size, _lidx, &p->leapSeconds);
	_serNrSysDecInt8_t_SQN_NR_SIB9_timeInfo_localTimeOffset_Optional(_buffer, _size, _lidx, &p->localTimeOffset);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SIB9_timeInfo_timeInfo_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SIB9_timeInfo_timeInfo_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_SIB9_timeInfo(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecOCTET_STRING_SQN_NR_SIB9_lateNonCriticalExtension_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct OCTET_STRING_SQN_NR_SIB9_lateNonCriticalExtension_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = (OCTET_STRING_ELEMENT*)serMalloc(_mem, p->v.d * sizeof(OCTET_STRING_ELEMENT));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		NTOH_8(p->v.v[i2], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_ReferenceTime_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_ReferenceTime_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_32(p->refDays_r16, &_buffer[*_lidx], _lidx);
	NTOH_32(p->refSeconds_r16, &_buffer[*_lidx], _lidx);
	NTOH_16(p->refMilliSeconds_r16, &_buffer[*_lidx], _lidx);
	NTOH_32(p->refTenNanoSeconds_r16, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecUint16_t_SQN_NR_ReferenceTimeInfo_r16_uncertainty_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct uint16_t_SQN_NR_ReferenceTimeInfo_r16_uncertainty_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_16(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_ReferenceTimeInfo_r16_timeInfoType_r16_e_timeInfoType_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_ReferenceTimeInfo_r16_timeInfoType_r16_e_timeInfoType_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_ReferenceTimeInfo_r16_timeInfoType_r16_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecUint16_t_SQN_NR_ReferenceTimeInfo_r16_referenceSFN_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct uint16_t_SQN_NR_ReferenceTimeInfo_r16_referenceSFN_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_16(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_ReferenceTimeInfo_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_ReferenceTimeInfo_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecSQN_NR_ReferenceTime_r16(_buffer, _size, _lidx, &p->time_r16);
	_serNrSysDecUint16_t_SQN_NR_ReferenceTimeInfo_r16_uncertainty_r16_Optional(_buffer, _size, _lidx, &p->uncertainty_r16);
	_serNrSysDecSQN_NR_ReferenceTimeInfo_r16_timeInfoType_r16_e_timeInfoType_r16_Optional(_buffer, _size, _lidx, &p->timeInfoType_r16);
	_serNrSysDecUint16_t_SQN_NR_ReferenceTimeInfo_r16_referenceSFN_r16_Optional(_buffer, _size, _lidx, &p->referenceSFN_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_ReferenceTimeInfo_r16_SQN_NR_SIB9_referenceTimeInfo_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_ReferenceTimeInfo_r16_SQN_NR_SIB9_referenceTimeInfo_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_ReferenceTimeInfo_r16(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SIB9(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_SIB9* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecSQN_NR_SIB9_timeInfo_timeInfo_Optional(_buffer, _size, _lidx, &p->timeInfo);
	_serNrSysDecOCTET_STRING_SQN_NR_SIB9_lateNonCriticalExtension_Optional(_buffer, _size, _lidx, _mem, &p->lateNonCriticalExtension);
	_serNrSysDecSQN_NR_ReferenceTimeInfo_r16_SQN_NR_SIB9_referenceTimeInfo_r16_Optional(_buffer, _size, _lidx, &p->referenceTimeInfo_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecOCTET_STRING_SQN_NR_HRNN_r16_hrnn_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct OCTET_STRING_SQN_NR_HRNN_r16_hrnn_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = (OCTET_STRING_ELEMENT*)serMalloc(_mem, p->v.d * sizeof(OCTET_STRING_ELEMENT));
	for (size_t i3 = 0; i3 < p->v.d; i3++) {
		NTOH_8(p->v.v[i3], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_HRNN_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_HRNN_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecOCTET_STRING_SQN_NR_HRNN_r16_hrnn_r16_Optional(_buffer, _size, _lidx, _mem, &p->hrnn_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_HRNN_List_r16_SQN_NR_SIB10_r16_hrnn_List_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_HRNN_List_r16_SQN_NR_SIB10_r16_hrnn_List_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = (struct SQN_NR_HRNN_r16*)serMalloc(_mem, p->v.d * sizeof(struct SQN_NR_HRNN_r16));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serNrSysDecSQN_NR_HRNN_r16(_buffer, _size, _lidx, _mem, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecOCTET_STRING_SQN_NR_SIB10_r16_lateNonCriticalExtension_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct OCTET_STRING_SQN_NR_SIB10_r16_lateNonCriticalExtension_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = (OCTET_STRING_ELEMENT*)serMalloc(_mem, p->v.d * sizeof(OCTET_STRING_ELEMENT));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		NTOH_8(p->v.v[i2], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SIB10_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_SIB10_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecSQN_NR_HRNN_List_r16_SQN_NR_SIB10_r16_hrnn_List_r16_Optional(_buffer, _size, _lidx, _mem, &p->hrnn_List_r16);
	_serNrSysDecOCTET_STRING_SQN_NR_SIB10_r16_lateNonCriticalExtension_Optional(_buffer, _size, _lidx, _mem, &p->lateNonCriticalExtension);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_MultiFrequencyBandListNR_SQN_NR_MeasIdleCarrierNR_r16_frequencyBandList_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_MultiFrequencyBandListNR_SQN_NR_MeasIdleCarrierNR_r16_frequencyBandList_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = (SQN_NR_FreqBandIndicatorNR*)serMalloc(_mem, p->v.d * sizeof(SQN_NR_FreqBandIndicatorNR));
	for (size_t i3 = 0; i3 < p->v.d; i3++) {
		NTOH_16(p->v.v[i3], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_CellListNR_r16_SQN_NR_MeasIdleCarrierNR_r16_measCellListNR_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_CellListNR_r16_SQN_NR_MeasIdleCarrierNR_r16_measCellListNR_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = (struct SQN_NR_PCI_Range*)serMalloc(_mem, p->v.d * sizeof(struct SQN_NR_PCI_Range));
	for (size_t i3 = 0; i3 < p->v.d; i3++) {
		_serNrSysDecSQN_NR_PCI_Range(_buffer, _size, _lidx, &p->v.v[i3]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_RSRP_Range_SQN_NR_MeasIdleCarrierNR_r16_qualityThreshold_r16_idleRSRP_Threshold_NR_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_RSRP_Range_SQN_NR_MeasIdleCarrierNR_r16_qualityThreshold_r16_idleRSRP_Threshold_NR_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_RSRQ_Range_SQN_NR_MeasIdleCarrierNR_r16_qualityThreshold_r16_idleRSRQ_Threshold_NR_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_RSRQ_Range_SQN_NR_MeasIdleCarrierNR_r16_qualityThreshold_r16_idleRSRQ_Threshold_NR_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_MeasIdleCarrierNR_r16_qualityThreshold_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_MeasIdleCarrierNR_r16_qualityThreshold_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecSQN_NR_RSRP_Range_SQN_NR_MeasIdleCarrierNR_r16_qualityThreshold_r16_idleRSRP_Threshold_NR_r16_Optional(_buffer, _size, _lidx, &p->idleRSRP_Threshold_NR_r16);
	_serNrSysDecSQN_NR_RSRQ_Range_SQN_NR_MeasIdleCarrierNR_r16_qualityThreshold_r16_idleRSRQ_Threshold_NR_r16_Optional(_buffer, _size, _lidx, &p->idleRSRQ_Threshold_NR_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_MeasIdleCarrierNR_r16_qualityThreshold_r16_qualityThreshold_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_MeasIdleCarrierNR_r16_qualityThreshold_r16_qualityThreshold_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_MeasIdleCarrierNR_r16_qualityThreshold_r16(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecUint8_t_SQN_NR_MeasIdleCarrierNR_r16_ssb_MeasConfig_r16_nrofSS_BlocksToAverage_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct uint8_t_SQN_NR_MeasIdleCarrierNR_r16_ssb_MeasConfig_r16_nrofSS_BlocksToAverage_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_ThresholdNR_SQN_NR_MeasIdleCarrierNR_r16_ssb_MeasConfig_r16_absThreshSS_BlocksConsolidation_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_ThresholdNR_SQN_NR_MeasIdleCarrierNR_r16_ssb_MeasConfig_r16_absThreshSS_BlocksConsolidation_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_ThresholdNR(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SSB_MTC_SQN_NR_MeasIdleCarrierNR_r16_ssb_MeasConfig_r16_smtc_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SSB_MTC_SQN_NR_MeasIdleCarrierNR_r16_ssb_MeasConfig_r16_smtc_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_SSB_MTC(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SSB_ToMeasure_SQN_NR_MeasIdleCarrierNR_r16_ssb_MeasConfig_r16_ssb_ToMeasure_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SSB_ToMeasure_SQN_NR_MeasIdleCarrierNR_r16_ssb_MeasConfig_r16_ssb_ToMeasure_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_SSB_ToMeasure(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SS_RSSI_Measurement_SQN_NR_MeasIdleCarrierNR_r16_ssb_MeasConfig_r16_ss_RSSI_Measurement_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_SS_RSSI_Measurement_SQN_NR_MeasIdleCarrierNR_r16_ssb_MeasConfig_r16_ss_RSSI_Measurement_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_SS_RSSI_Measurement(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_MeasIdleCarrierNR_r16_ssb_MeasConfig_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_MeasIdleCarrierNR_r16_ssb_MeasConfig_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecUint8_t_SQN_NR_MeasIdleCarrierNR_r16_ssb_MeasConfig_r16_nrofSS_BlocksToAverage_r16_Optional(_buffer, _size, _lidx, &p->nrofSS_BlocksToAverage_r16);
	_serNrSysDecSQN_NR_ThresholdNR_SQN_NR_MeasIdleCarrierNR_r16_ssb_MeasConfig_r16_absThreshSS_BlocksConsolidation_r16_Optional(_buffer, _size, _lidx, &p->absThreshSS_BlocksConsolidation_r16);
	_serNrSysDecSQN_NR_SSB_MTC_SQN_NR_MeasIdleCarrierNR_r16_ssb_MeasConfig_r16_smtc_r16_Optional(_buffer, _size, _lidx, &p->smtc_r16);
	_serNrSysDecSQN_NR_SSB_ToMeasure_SQN_NR_MeasIdleCarrierNR_r16_ssb_MeasConfig_r16_ssb_ToMeasure_r16_Optional(_buffer, _size, _lidx, &p->ssb_ToMeasure_r16);
	NTOH_8(p->deriveSSB_IndexFromCell_r16, &_buffer[*_lidx], _lidx);
	_serNrSysDecSQN_NR_SS_RSSI_Measurement_SQN_NR_MeasIdleCarrierNR_r16_ssb_MeasConfig_r16_ss_RSSI_Measurement_r16_Optional(_buffer, _size, _lidx, _mem, &p->ss_RSSI_Measurement_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_MeasIdleCarrierNR_r16_ssb_MeasConfig_r16_ssb_MeasConfig_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_MeasIdleCarrierNR_r16_ssb_MeasConfig_r16_ssb_MeasConfig_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_MeasIdleCarrierNR_r16_ssb_MeasConfig_r16(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_BeamMeasConfigIdle_NR_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_BeamMeasConfigIdle_NR_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->reportQuantityRS_Indexes_r16 = (SQN_NR_BeamMeasConfigIdle_NR_r16_reportQuantityRS_Indexes_r16_e)_tmp;
	}
	NTOH_8(p->maxNrofRS_IndexesToReport_r16, &_buffer[*_lidx], _lidx);
	NTOH_8(p->includeBeamMeasurements_r16, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_BeamMeasConfigIdle_NR_r16_SQN_NR_MeasIdleCarrierNR_r16_beamMeasConfigIdle_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_BeamMeasConfigIdle_NR_r16_SQN_NR_MeasIdleCarrierNR_r16_beamMeasConfigIdle_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_BeamMeasConfigIdle_NR_r16(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_MeasIdleCarrierNR_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_MeasIdleCarrierNR_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_32(p->carrierFreq_r16, &_buffer[*_lidx], _lidx);
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->ssbSubcarrierSpacing_r16 = (SQN_NR_SubcarrierSpacing_e)_tmp;
	}
	_serNrSysDecSQN_NR_MultiFrequencyBandListNR_SQN_NR_MeasIdleCarrierNR_r16_frequencyBandList_Optional(_buffer, _size, _lidx, _mem, &p->frequencyBandList);
	_serNrSysDecSQN_NR_CellListNR_r16_SQN_NR_MeasIdleCarrierNR_r16_measCellListNR_r16_Optional(_buffer, _size, _lidx, _mem, &p->measCellListNR_r16);
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->reportQuantities_r16 = (SQN_NR_MeasIdleCarrierNR_r16_reportQuantities_r16_e)_tmp;
	}
	_serNrSysDecSQN_NR_MeasIdleCarrierNR_r16_qualityThreshold_r16_qualityThreshold_r16_Optional(_buffer, _size, _lidx, &p->qualityThreshold_r16);
	_serNrSysDecSQN_NR_MeasIdleCarrierNR_r16_ssb_MeasConfig_r16_ssb_MeasConfig_r16_Optional(_buffer, _size, _lidx, _mem, &p->ssb_MeasConfig_r16);
	_serNrSysDecSQN_NR_BeamMeasConfigIdle_NR_r16_SQN_NR_MeasIdleCarrierNR_r16_beamMeasConfigIdle_r16_Optional(_buffer, _size, _lidx, &p->beamMeasConfigIdle_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_MeasIdleCarrierNR_r16_SQN_NR_MeasIdleConfigSIB_r16_measIdleCarrierListNR_r16_DynamicOptional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_MeasIdleCarrierNR_r16_SQN_NR_MeasIdleConfigSIB_r16_measIdleCarrierListNR_r16_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = (struct SQN_NR_MeasIdleCarrierNR_r16*)serMalloc(_mem, p->v.d * sizeof(struct SQN_NR_MeasIdleCarrierNR_r16));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serNrSysDecSQN_NR_MeasIdleCarrierNR_r16(_buffer, _size, _lidx, _mem, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_CellListEUTRA_r16_SQN_NR_MeasIdleCarrierEUTRA_r16_measCellListEUTRA_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_CellListEUTRA_r16_SQN_NR_MeasIdleCarrierEUTRA_r16_measCellListEUTRA_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = (struct SQN_NR_EUTRA_PhysCellIdRange*)serMalloc(_mem, p->v.d * sizeof(struct SQN_NR_EUTRA_PhysCellIdRange));
	for (size_t i3 = 0; i3 < p->v.d; i3++) {
		_serNrSysDecSQN_NR_EUTRA_PhysCellIdRange(_buffer, _size, _lidx, &p->v.v[i3]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_RSRP_RangeEUTRA_SQN_NR_MeasIdleCarrierEUTRA_r16_qualityThresholdEUTRA_r16_idleRSRP_Threshold_EUTRA_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_RSRP_RangeEUTRA_SQN_NR_MeasIdleCarrierEUTRA_r16_qualityThresholdEUTRA_r16_idleRSRP_Threshold_EUTRA_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_RSRQ_RangeEUTRA_r16_SQN_NR_MeasIdleCarrierEUTRA_r16_qualityThresholdEUTRA_r16_idleRSRQ_Threshold_EUTRA_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_RSRQ_RangeEUTRA_r16_SQN_NR_MeasIdleCarrierEUTRA_r16_qualityThresholdEUTRA_r16_idleRSRQ_Threshold_EUTRA_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_MeasIdleCarrierEUTRA_r16_qualityThresholdEUTRA_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_MeasIdleCarrierEUTRA_r16_qualityThresholdEUTRA_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecSQN_NR_RSRP_RangeEUTRA_SQN_NR_MeasIdleCarrierEUTRA_r16_qualityThresholdEUTRA_r16_idleRSRP_Threshold_EUTRA_r16_Optional(_buffer, _size, _lidx, &p->idleRSRP_Threshold_EUTRA_r16);
	_serNrSysDecSQN_NR_RSRQ_RangeEUTRA_r16_SQN_NR_MeasIdleCarrierEUTRA_r16_qualityThresholdEUTRA_r16_idleRSRQ_Threshold_EUTRA_r16_Optional(_buffer, _size, _lidx, &p->idleRSRQ_Threshold_EUTRA_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_MeasIdleCarrierEUTRA_r16_qualityThresholdEUTRA_r16_qualityThresholdEUTRA_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_MeasIdleCarrierEUTRA_r16_qualityThresholdEUTRA_r16_qualityThresholdEUTRA_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_MeasIdleCarrierEUTRA_r16_qualityThresholdEUTRA_r16(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_MeasIdleCarrierEUTRA_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_MeasIdleCarrierEUTRA_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_32(p->carrierFreqEUTRA_r16, &_buffer[*_lidx], _lidx);
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->allowedMeasBandwidth_r16 = (SQN_NR_EUTRA_AllowedMeasBandwidth_e)_tmp;
	}
	_serNrSysDecSQN_NR_CellListEUTRA_r16_SQN_NR_MeasIdleCarrierEUTRA_r16_measCellListEUTRA_r16_Optional(_buffer, _size, _lidx, _mem, &p->measCellListEUTRA_r16);
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->reportQuantitiesEUTRA_r16 = (SQN_NR_MeasIdleCarrierEUTRA_r16_reportQuantitiesEUTRA_r16_e)_tmp;
	}
	_serNrSysDecSQN_NR_MeasIdleCarrierEUTRA_r16_qualityThresholdEUTRA_r16_qualityThresholdEUTRA_r16_Optional(_buffer, _size, _lidx, &p->qualityThresholdEUTRA_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_MeasIdleCarrierEUTRA_r16_SQN_NR_MeasIdleConfigSIB_r16_measIdleCarrierListEUTRA_r16_DynamicOptional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_MeasIdleCarrierEUTRA_r16_SQN_NR_MeasIdleConfigSIB_r16_measIdleCarrierListEUTRA_r16_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = (struct SQN_NR_MeasIdleCarrierEUTRA_r16*)serMalloc(_mem, p->v.d * sizeof(struct SQN_NR_MeasIdleCarrierEUTRA_r16));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serNrSysDecSQN_NR_MeasIdleCarrierEUTRA_r16(_buffer, _size, _lidx, _mem, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_MeasIdleConfigSIB_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_MeasIdleConfigSIB_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecSQN_NR_MeasIdleCarrierNR_r16_SQN_NR_MeasIdleConfigSIB_r16_measIdleCarrierListNR_r16_DynamicOptional(_buffer, _size, _lidx, _mem, &p->measIdleCarrierListNR_r16);
	_serNrSysDecSQN_NR_MeasIdleCarrierEUTRA_r16_SQN_NR_MeasIdleConfigSIB_r16_measIdleCarrierListEUTRA_r16_DynamicOptional(_buffer, _size, _lidx, _mem, &p->measIdleCarrierListEUTRA_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_MeasIdleConfigSIB_r16_SQN_NR_SIB11_r16_measIdleConfigSIB_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_MeasIdleConfigSIB_r16_SQN_NR_SIB11_r16_measIdleConfigSIB_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_MeasIdleConfigSIB_r16(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecOCTET_STRING_SQN_NR_SIB11_r16_lateNonCriticalExtension_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct OCTET_STRING_SQN_NR_SIB11_r16_lateNonCriticalExtension_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = (OCTET_STRING_ELEMENT*)serMalloc(_mem, p->v.d * sizeof(OCTET_STRING_ELEMENT));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		NTOH_8(p->v.v[i2], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SIB11_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_SIB11_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecSQN_NR_MeasIdleConfigSIB_r16_SQN_NR_SIB11_r16_measIdleConfigSIB_r16_Optional(_buffer, _size, _lidx, _mem, &p->measIdleConfigSIB_r16);
	_serNrSysDecOCTET_STRING_SQN_NR_SIB11_r16_lateNonCriticalExtension_Optional(_buffer, _size, _lidx, _mem, &p->lateNonCriticalExtension);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SIB12_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_SIB12_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->segmentNumber_r16, &_buffer[*_lidx], _lidx);
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->segmentType_r16 = (SQN_NR_SIB12_r16_segmentType_r16_e)_tmp;
	}
	NTOH_32(p->segmentContainer_r16.d, &_buffer[*_lidx], _lidx);
	p->segmentContainer_r16.v = (OCTET_STRING_ELEMENT*)serMalloc(_mem, p->segmentContainer_r16.d * sizeof(OCTET_STRING_ELEMENT));
	for (size_t i2 = 0; i2 < p->segmentContainer_r16.d; i2++) {
		NTOH_8(p->segmentContainer_r16.v[i2], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecOCTET_STRING_SQN_NR_SIB13_r16_lateNonCriticalExtension_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct OCTET_STRING_SQN_NR_SIB13_r16_lateNonCriticalExtension_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = (OCTET_STRING_ELEMENT*)serMalloc(_mem, p->v.d * sizeof(OCTET_STRING_ELEMENT));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		NTOH_8(p->v.v[i2], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SIB13_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_SIB13_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_32(p->sl_V2X_ConfigCommon_r16.d, &_buffer[*_lidx], _lidx);
	p->sl_V2X_ConfigCommon_r16.v = (OCTET_STRING_ELEMENT*)serMalloc(_mem, p->sl_V2X_ConfigCommon_r16.d * sizeof(OCTET_STRING_ELEMENT));
	for (size_t i2 = 0; i2 < p->sl_V2X_ConfigCommon_r16.d; i2++) {
		NTOH_8(p->sl_V2X_ConfigCommon_r16.v[i2], &_buffer[*_lidx], _lidx);
	}
	NTOH_32(p->sl_Bandwidth_r16.d, &_buffer[*_lidx], _lidx);
	p->sl_Bandwidth_r16.v = (OCTET_STRING_ELEMENT*)serMalloc(_mem, p->sl_Bandwidth_r16.d * sizeof(OCTET_STRING_ELEMENT));
	for (size_t i2 = 0; i2 < p->sl_Bandwidth_r16.d; i2++) {
		NTOH_8(p->sl_Bandwidth_r16.v[i2], &_buffer[*_lidx], _lidx);
	}
	NTOH_32(p->tdd_Config_r16.d, &_buffer[*_lidx], _lidx);
	p->tdd_Config_r16.v = (OCTET_STRING_ELEMENT*)serMalloc(_mem, p->tdd_Config_r16.d * sizeof(OCTET_STRING_ELEMENT));
	for (size_t i2 = 0; i2 < p->tdd_Config_r16.d; i2++) {
		NTOH_8(p->tdd_Config_r16.v[i2], &_buffer[*_lidx], _lidx);
	}
	_serNrSysDecOCTET_STRING_SQN_NR_SIB13_r16_lateNonCriticalExtension_Optional(_buffer, _size, _lidx, _mem, &p->lateNonCriticalExtension);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecOCTET_STRING_SQN_NR_SIB14_r16_lateNonCriticalExtension_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct OCTET_STRING_SQN_NR_SIB14_r16_lateNonCriticalExtension_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = (OCTET_STRING_ELEMENT*)serMalloc(_mem, p->v.d * sizeof(OCTET_STRING_ELEMENT));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		NTOH_8(p->v.v[i2], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SIB14_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_SIB14_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_32(p->sl_V2X_ConfigCommonExt_r16.d, &_buffer[*_lidx], _lidx);
	p->sl_V2X_ConfigCommonExt_r16.v = (OCTET_STRING_ELEMENT*)serMalloc(_mem, p->sl_V2X_ConfigCommonExt_r16.d * sizeof(OCTET_STRING_ELEMENT));
	for (size_t i2 = 0; i2 < p->sl_V2X_ConfigCommonExt_r16.d; i2++) {
		NTOH_8(p->sl_V2X_ConfigCommonExt_r16.v[i2], &_buffer[*_lidx], _lidx);
	}
	_serNrSysDecOCTET_STRING_SQN_NR_SIB14_r16_lateNonCriticalExtension_Optional(_buffer, _size, _lidx, _mem, &p->lateNonCriticalExtension);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SystemInformation_IEs_sib_TypeAndInfo_s_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union SQN_NR_SystemInformation_IEs_sib_TypeAndInfo_s_Value* p, enum SQN_NR_SystemInformation_IEs_sib_TypeAndInfo_s_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SystemInformation_IEs_sib_TypeAndInfo_s_sib2) {
		_serNrSysDecSQN_NR_SIB2(_buffer, _size, _lidx, _mem, &p->sib2);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SystemInformation_IEs_sib_TypeAndInfo_s_sib3) {
		_serNrSysDecSQN_NR_SIB3(_buffer, _size, _lidx, _mem, &p->sib3);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SystemInformation_IEs_sib_TypeAndInfo_s_sib4) {
		_serNrSysDecSQN_NR_SIB4(_buffer, _size, _lidx, _mem, &p->sib4);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SystemInformation_IEs_sib_TypeAndInfo_s_sib5) {
		_serNrSysDecSQN_NR_SIB5(_buffer, _size, _lidx, _mem, &p->sib5);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SystemInformation_IEs_sib_TypeAndInfo_s_sib6) {
		_serNrSysDecSQN_NR_SIB6(_buffer, _size, _lidx, _mem, &p->sib6);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SystemInformation_IEs_sib_TypeAndInfo_s_sib7) {
		_serNrSysDecSQN_NR_SIB7(_buffer, _size, _lidx, _mem, &p->sib7);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SystemInformation_IEs_sib_TypeAndInfo_s_sib8) {
		_serNrSysDecSQN_NR_SIB8(_buffer, _size, _lidx, _mem, &p->sib8);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SystemInformation_IEs_sib_TypeAndInfo_s_sib9) {
		_serNrSysDecSQN_NR_SIB9(_buffer, _size, _lidx, _mem, &p->sib9);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SystemInformation_IEs_sib_TypeAndInfo_s_sib10_v1610) {
		_serNrSysDecSQN_NR_SIB10_r16(_buffer, _size, _lidx, _mem, &p->sib10_v1610);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SystemInformation_IEs_sib_TypeAndInfo_s_sib11_v1610) {
		_serNrSysDecSQN_NR_SIB11_r16(_buffer, _size, _lidx, _mem, &p->sib11_v1610);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SystemInformation_IEs_sib_TypeAndInfo_s_sib12_v1610) {
		_serNrSysDecSQN_NR_SIB12_r16(_buffer, _size, _lidx, _mem, &p->sib12_v1610);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SystemInformation_IEs_sib_TypeAndInfo_s_sib13_v1610) {
		_serNrSysDecSQN_NR_SIB13_r16(_buffer, _size, _lidx, _mem, &p->sib13_v1610);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SystemInformation_IEs_sib_TypeAndInfo_s_sib14_v1610) {
		_serNrSysDecSQN_NR_SIB14_r16(_buffer, _size, _lidx, _mem, &p->sib14_v1610);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecSQN_NR_SystemInformation_IEs_sib_TypeAndInfo_s(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_SystemInformation_IEs_sib_TypeAndInfo_s* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SQN_NR_SystemInformation_IEs_sib_TypeAndInfo_s_Sel)_tmp;
	}
	_serNrSysDecSQN_NR_SystemInformation_IEs_sib_TypeAndInfo_s_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecOCTET_STRING_SQN_NR_SystemInformation_IEs_lateNonCriticalExtension_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct OCTET_STRING_SQN_NR_SystemInformation_IEs_lateNonCriticalExtension_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = (OCTET_STRING_ELEMENT*)serMalloc(_mem, p->v.d * sizeof(OCTET_STRING_ELEMENT));
	for (size_t i1 = 0; i1 < p->v.d; i1++) {
		NTOH_8(p->v.v[i1], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SystemInformation_IEs_nonCriticalExtension(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SystemInformation_IEs_nonCriticalExtension* p)
{
	(void)_size; // TODO: generate boundaries checking

	(void)_buffer;
	(void)_size;
	(void)_lidx;
	(void)p;

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SystemInformation_IEs_nonCriticalExtension_nonCriticalExtension_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SystemInformation_IEs_nonCriticalExtension_nonCriticalExtension_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_SystemInformation_IEs_nonCriticalExtension(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SystemInformation_IEs(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_SystemInformation_IEs* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_32(p->sib_TypeAndInfo.d, &_buffer[*_lidx], _lidx);
	p->sib_TypeAndInfo.v = (struct SQN_NR_SystemInformation_IEs_sib_TypeAndInfo_s*)serMalloc(_mem, p->sib_TypeAndInfo.d * sizeof(struct SQN_NR_SystemInformation_IEs_sib_TypeAndInfo_s));
	for (size_t i1 = 0; i1 < p->sib_TypeAndInfo.d; i1++) {
		_serNrSysDecSQN_NR_SystemInformation_IEs_sib_TypeAndInfo_s(_buffer, _size, _lidx, _mem, &p->sib_TypeAndInfo.v[i1]);
	}
	_serNrSysDecOCTET_STRING_SQN_NR_SystemInformation_IEs_lateNonCriticalExtension_Optional(_buffer, _size, _lidx, _mem, &p->lateNonCriticalExtension);
	_serNrSysDecSQN_NR_SystemInformation_IEs_nonCriticalExtension_nonCriticalExtension_Optional(_buffer, _size, _lidx, &p->nonCriticalExtension);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecOCTET_STRING_SQN_NR_SIBpos_r16_lateNonCriticalExtension_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct OCTET_STRING_SQN_NR_SIBpos_r16_lateNonCriticalExtension_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = (OCTET_STRING_ELEMENT*)serMalloc(_mem, p->v.d * sizeof(OCTET_STRING_ELEMENT));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		NTOH_8(p->v.v[i2], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SIBpos_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_SIBpos_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_32(p->assistanceDataSIB_Element_r16.d, &_buffer[*_lidx], _lidx);
	p->assistanceDataSIB_Element_r16.v = (OCTET_STRING_ELEMENT*)serMalloc(_mem, p->assistanceDataSIB_Element_r16.d * sizeof(OCTET_STRING_ELEMENT));
	for (size_t i2 = 0; i2 < p->assistanceDataSIB_Element_r16.d; i2++) {
		NTOH_8(p->assistanceDataSIB_Element_r16.v[i2], &_buffer[*_lidx], _lidx);
	}
	_serNrSysDecOCTET_STRING_SQN_NR_SIBpos_r16_lateNonCriticalExtension_Optional(_buffer, _size, _lidx, _mem, &p->lateNonCriticalExtension);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PosSystemInformation_r16_IEs_posSIB_TypeAndInfo_r16_s_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union SQN_NR_PosSystemInformation_r16_IEs_posSIB_TypeAndInfo_r16_s_Value* p, enum SQN_NR_PosSystemInformation_r16_IEs_posSIB_TypeAndInfo_r16_s_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_PosSystemInformation_r16_IEs_posSIB_TypeAndInfo_r16_s_posSib1_1_r16) {
		_serNrSysDecSQN_NR_SIBpos_r16(_buffer, _size, _lidx, _mem, &p->posSib1_1_r16);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_PosSystemInformation_r16_IEs_posSIB_TypeAndInfo_r16_s_posSib1_2_r16) {
		_serNrSysDecSQN_NR_SIBpos_r16(_buffer, _size, _lidx, _mem, &p->posSib1_2_r16);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_PosSystemInformation_r16_IEs_posSIB_TypeAndInfo_r16_s_posSib1_3_r16) {
		_serNrSysDecSQN_NR_SIBpos_r16(_buffer, _size, _lidx, _mem, &p->posSib1_3_r16);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_PosSystemInformation_r16_IEs_posSIB_TypeAndInfo_r16_s_posSib1_4_r16) {
		_serNrSysDecSQN_NR_SIBpos_r16(_buffer, _size, _lidx, _mem, &p->posSib1_4_r16);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_PosSystemInformation_r16_IEs_posSIB_TypeAndInfo_r16_s_posSib1_5_r16) {
		_serNrSysDecSQN_NR_SIBpos_r16(_buffer, _size, _lidx, _mem, &p->posSib1_5_r16);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_PosSystemInformation_r16_IEs_posSIB_TypeAndInfo_r16_s_posSib1_6_r16) {
		_serNrSysDecSQN_NR_SIBpos_r16(_buffer, _size, _lidx, _mem, &p->posSib1_6_r16);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_PosSystemInformation_r16_IEs_posSIB_TypeAndInfo_r16_s_posSib1_7_r16) {
		_serNrSysDecSQN_NR_SIBpos_r16(_buffer, _size, _lidx, _mem, &p->posSib1_7_r16);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_PosSystemInformation_r16_IEs_posSIB_TypeAndInfo_r16_s_posSib1_8_r16) {
		_serNrSysDecSQN_NR_SIBpos_r16(_buffer, _size, _lidx, _mem, &p->posSib1_8_r16);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_PosSystemInformation_r16_IEs_posSIB_TypeAndInfo_r16_s_posSib2_1_r16) {
		_serNrSysDecSQN_NR_SIBpos_r16(_buffer, _size, _lidx, _mem, &p->posSib2_1_r16);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_PosSystemInformation_r16_IEs_posSIB_TypeAndInfo_r16_s_posSib2_2_r16) {
		_serNrSysDecSQN_NR_SIBpos_r16(_buffer, _size, _lidx, _mem, &p->posSib2_2_r16);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_PosSystemInformation_r16_IEs_posSIB_TypeAndInfo_r16_s_posSib2_3_r16) {
		_serNrSysDecSQN_NR_SIBpos_r16(_buffer, _size, _lidx, _mem, &p->posSib2_3_r16);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_PosSystemInformation_r16_IEs_posSIB_TypeAndInfo_r16_s_posSib2_4_r16) {
		_serNrSysDecSQN_NR_SIBpos_r16(_buffer, _size, _lidx, _mem, &p->posSib2_4_r16);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_PosSystemInformation_r16_IEs_posSIB_TypeAndInfo_r16_s_posSib2_5_r16) {
		_serNrSysDecSQN_NR_SIBpos_r16(_buffer, _size, _lidx, _mem, &p->posSib2_5_r16);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_PosSystemInformation_r16_IEs_posSIB_TypeAndInfo_r16_s_posSib2_6_r16) {
		_serNrSysDecSQN_NR_SIBpos_r16(_buffer, _size, _lidx, _mem, &p->posSib2_6_r16);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_PosSystemInformation_r16_IEs_posSIB_TypeAndInfo_r16_s_posSib2_7_r16) {
		_serNrSysDecSQN_NR_SIBpos_r16(_buffer, _size, _lidx, _mem, &p->posSib2_7_r16);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_PosSystemInformation_r16_IEs_posSIB_TypeAndInfo_r16_s_posSib2_8_r16) {
		_serNrSysDecSQN_NR_SIBpos_r16(_buffer, _size, _lidx, _mem, &p->posSib2_8_r16);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_PosSystemInformation_r16_IEs_posSIB_TypeAndInfo_r16_s_posSib2_9_r16) {
		_serNrSysDecSQN_NR_SIBpos_r16(_buffer, _size, _lidx, _mem, &p->posSib2_9_r16);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_PosSystemInformation_r16_IEs_posSIB_TypeAndInfo_r16_s_posSib2_10_r16) {
		_serNrSysDecSQN_NR_SIBpos_r16(_buffer, _size, _lidx, _mem, &p->posSib2_10_r16);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_PosSystemInformation_r16_IEs_posSIB_TypeAndInfo_r16_s_posSib2_11_r16) {
		_serNrSysDecSQN_NR_SIBpos_r16(_buffer, _size, _lidx, _mem, &p->posSib2_11_r16);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_PosSystemInformation_r16_IEs_posSIB_TypeAndInfo_r16_s_posSib2_12_r16) {
		_serNrSysDecSQN_NR_SIBpos_r16(_buffer, _size, _lidx, _mem, &p->posSib2_12_r16);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_PosSystemInformation_r16_IEs_posSIB_TypeAndInfo_r16_s_posSib2_13_r16) {
		_serNrSysDecSQN_NR_SIBpos_r16(_buffer, _size, _lidx, _mem, &p->posSib2_13_r16);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_PosSystemInformation_r16_IEs_posSIB_TypeAndInfo_r16_s_posSib2_14_r16) {
		_serNrSysDecSQN_NR_SIBpos_r16(_buffer, _size, _lidx, _mem, &p->posSib2_14_r16);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_PosSystemInformation_r16_IEs_posSIB_TypeAndInfo_r16_s_posSib2_15_r16) {
		_serNrSysDecSQN_NR_SIBpos_r16(_buffer, _size, _lidx, _mem, &p->posSib2_15_r16);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_PosSystemInformation_r16_IEs_posSIB_TypeAndInfo_r16_s_posSib2_16_r16) {
		_serNrSysDecSQN_NR_SIBpos_r16(_buffer, _size, _lidx, _mem, &p->posSib2_16_r16);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_PosSystemInformation_r16_IEs_posSIB_TypeAndInfo_r16_s_posSib2_17_r16) {
		_serNrSysDecSQN_NR_SIBpos_r16(_buffer, _size, _lidx, _mem, &p->posSib2_17_r16);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_PosSystemInformation_r16_IEs_posSIB_TypeAndInfo_r16_s_posSib2_18_r16) {
		_serNrSysDecSQN_NR_SIBpos_r16(_buffer, _size, _lidx, _mem, &p->posSib2_18_r16);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_PosSystemInformation_r16_IEs_posSIB_TypeAndInfo_r16_s_posSib2_19_r16) {
		_serNrSysDecSQN_NR_SIBpos_r16(_buffer, _size, _lidx, _mem, &p->posSib2_19_r16);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_PosSystemInformation_r16_IEs_posSIB_TypeAndInfo_r16_s_posSib2_20_r16) {
		_serNrSysDecSQN_NR_SIBpos_r16(_buffer, _size, _lidx, _mem, &p->posSib2_20_r16);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_PosSystemInformation_r16_IEs_posSIB_TypeAndInfo_r16_s_posSib2_21_r16) {
		_serNrSysDecSQN_NR_SIBpos_r16(_buffer, _size, _lidx, _mem, &p->posSib2_21_r16);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_PosSystemInformation_r16_IEs_posSIB_TypeAndInfo_r16_s_posSib2_22_r16) {
		_serNrSysDecSQN_NR_SIBpos_r16(_buffer, _size, _lidx, _mem, &p->posSib2_22_r16);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_PosSystemInformation_r16_IEs_posSIB_TypeAndInfo_r16_s_posSib2_23_r16) {
		_serNrSysDecSQN_NR_SIBpos_r16(_buffer, _size, _lidx, _mem, &p->posSib2_23_r16);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_PosSystemInformation_r16_IEs_posSIB_TypeAndInfo_r16_s_posSib3_1_r16) {
		_serNrSysDecSQN_NR_SIBpos_r16(_buffer, _size, _lidx, _mem, &p->posSib3_1_r16);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_PosSystemInformation_r16_IEs_posSIB_TypeAndInfo_r16_s_posSib4_1_r16) {
		_serNrSysDecSQN_NR_SIBpos_r16(_buffer, _size, _lidx, _mem, &p->posSib4_1_r16);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_PosSystemInformation_r16_IEs_posSIB_TypeAndInfo_r16_s_posSib5_1_r16) {
		_serNrSysDecSQN_NR_SIBpos_r16(_buffer, _size, _lidx, _mem, &p->posSib5_1_r16);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_PosSystemInformation_r16_IEs_posSIB_TypeAndInfo_r16_s_posSib6_1_r16) {
		_serNrSysDecSQN_NR_SIBpos_r16(_buffer, _size, _lidx, _mem, &p->posSib6_1_r16);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_PosSystemInformation_r16_IEs_posSIB_TypeAndInfo_r16_s_posSib6_2_r16) {
		_serNrSysDecSQN_NR_SIBpos_r16(_buffer, _size, _lidx, _mem, &p->posSib6_2_r16);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_PosSystemInformation_r16_IEs_posSIB_TypeAndInfo_r16_s_posSib6_3_r16) {
		_serNrSysDecSQN_NR_SIBpos_r16(_buffer, _size, _lidx, _mem, &p->posSib6_3_r16);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecSQN_NR_PosSystemInformation_r16_IEs_posSIB_TypeAndInfo_r16_s(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_PosSystemInformation_r16_IEs_posSIB_TypeAndInfo_r16_s* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SQN_NR_PosSystemInformation_r16_IEs_posSIB_TypeAndInfo_r16_s_Sel)_tmp;
	}
	_serNrSysDecSQN_NR_PosSystemInformation_r16_IEs_posSIB_TypeAndInfo_r16_s_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecOCTET_STRING_SQN_NR_PosSystemInformation_r16_IEs_lateNonCriticalExtension_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct OCTET_STRING_SQN_NR_PosSystemInformation_r16_IEs_lateNonCriticalExtension_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = (OCTET_STRING_ELEMENT*)serMalloc(_mem, p->v.d * sizeof(OCTET_STRING_ELEMENT));
	for (size_t i1 = 0; i1 < p->v.d; i1++) {
		NTOH_8(p->v.v[i1], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PosSystemInformation_r16_IEs_nonCriticalExtension(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_PosSystemInformation_r16_IEs_nonCriticalExtension* p)
{
	(void)_size; // TODO: generate boundaries checking

	(void)_buffer;
	(void)_size;
	(void)_lidx;
	(void)p;

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PosSystemInformation_r16_IEs_nonCriticalExtension_nonCriticalExtension_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_PosSystemInformation_r16_IEs_nonCriticalExtension_nonCriticalExtension_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_PosSystemInformation_r16_IEs_nonCriticalExtension(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PosSystemInformation_r16_IEs(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_PosSystemInformation_r16_IEs* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_32(p->posSIB_TypeAndInfo_r16.d, &_buffer[*_lidx], _lidx);
	p->posSIB_TypeAndInfo_r16.v = (struct SQN_NR_PosSystemInformation_r16_IEs_posSIB_TypeAndInfo_r16_s*)serMalloc(_mem, p->posSIB_TypeAndInfo_r16.d * sizeof(struct SQN_NR_PosSystemInformation_r16_IEs_posSIB_TypeAndInfo_r16_s));
	for (size_t i1 = 0; i1 < p->posSIB_TypeAndInfo_r16.d; i1++) {
		_serNrSysDecSQN_NR_PosSystemInformation_r16_IEs_posSIB_TypeAndInfo_r16_s(_buffer, _size, _lidx, _mem, &p->posSIB_TypeAndInfo_r16.v[i1]);
	}
	_serNrSysDecOCTET_STRING_SQN_NR_PosSystemInformation_r16_IEs_lateNonCriticalExtension_Optional(_buffer, _size, _lidx, _mem, &p->lateNonCriticalExtension);
	_serNrSysDecSQN_NR_PosSystemInformation_r16_IEs_nonCriticalExtension_nonCriticalExtension_Optional(_buffer, _size, _lidx, &p->nonCriticalExtension);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SystemInformation_criticalExtensions_criticalExtensionsFuture_r16_criticalExtensionsFuture(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SystemInformation_criticalExtensions_criticalExtensionsFuture_r16_criticalExtensionsFuture* p)
{
	(void)_size; // TODO: generate boundaries checking

	(void)_buffer;
	(void)_size;
	(void)_lidx;
	(void)p;

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SystemInformation_criticalExtensions_criticalExtensionsFuture_r16_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union SQN_NR_SystemInformation_criticalExtensions_criticalExtensionsFuture_r16_Value* p, enum SQN_NR_SystemInformation_criticalExtensions_criticalExtensionsFuture_r16_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SystemInformation_criticalExtensions_criticalExtensionsFuture_r16_posSystemInformation_r16) {
		_serNrSysDecSQN_NR_PosSystemInformation_r16_IEs(_buffer, _size, _lidx, _mem, &p->posSystemInformation_r16);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SystemInformation_criticalExtensions_criticalExtensionsFuture_r16_criticalExtensionsFuture) {
		_serNrSysDecSQN_NR_SystemInformation_criticalExtensions_criticalExtensionsFuture_r16_criticalExtensionsFuture(_buffer, _size, _lidx, &p->criticalExtensionsFuture);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecSQN_NR_SystemInformation_criticalExtensions_criticalExtensionsFuture_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_SystemInformation_criticalExtensions_criticalExtensionsFuture_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SQN_NR_SystemInformation_criticalExtensions_criticalExtensionsFuture_r16_Sel)_tmp;
	}
	_serNrSysDecSQN_NR_SystemInformation_criticalExtensions_criticalExtensionsFuture_r16_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SystemInformation_criticalExtensions_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union SQN_NR_SystemInformation_criticalExtensions_Value* p, enum SQN_NR_SystemInformation_criticalExtensions_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SystemInformation_criticalExtensions_systemInformation) {
		_serNrSysDecSQN_NR_SystemInformation_IEs(_buffer, _size, _lidx, _mem, &p->systemInformation);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SystemInformation_criticalExtensions_criticalExtensionsFuture_r16) {
		_serNrSysDecSQN_NR_SystemInformation_criticalExtensions_criticalExtensionsFuture_r16(_buffer, _size, _lidx, _mem, &p->criticalExtensionsFuture_r16);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecSQN_NR_SystemInformation_criticalExtensions(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_SystemInformation_criticalExtensions* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SQN_NR_SystemInformation_criticalExtensions_Sel)_tmp;
	}
	_serNrSysDecSQN_NR_SystemInformation_criticalExtensions_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SystemInformation(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_SystemInformation* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecSQN_NR_SystemInformation_criticalExtensions(_buffer, _size, _lidx, _mem, &p->criticalExtensions);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecUint8_t_SQN_NR_SIB1_cellSelectionInfo_q_RxLevMinOffset_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct uint8_t_SQN_NR_SIB1_cellSelectionInfo_q_RxLevMinOffset_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_Q_RxLevMin_SQN_NR_SIB1_cellSelectionInfo_q_RxLevMinSUL_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_Q_RxLevMin_SQN_NR_SIB1_cellSelectionInfo_q_RxLevMinSUL_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_Q_QualMin_SQN_NR_SIB1_cellSelectionInfo_q_QualMin_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_Q_QualMin_SQN_NR_SIB1_cellSelectionInfo_q_QualMin_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecUint8_t_SQN_NR_SIB1_cellSelectionInfo_q_QualMinOffset_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct uint8_t_SQN_NR_SIB1_cellSelectionInfo_q_QualMinOffset_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SIB1_cellSelectionInfo(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SIB1_cellSelectionInfo* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->q_RxLevMin, &_buffer[*_lidx], _lidx);
	_serNrSysDecUint8_t_SQN_NR_SIB1_cellSelectionInfo_q_RxLevMinOffset_Optional(_buffer, _size, _lidx, &p->q_RxLevMinOffset);
	_serNrSysDecSQN_NR_Q_RxLevMin_SQN_NR_SIB1_cellSelectionInfo_q_RxLevMinSUL_Optional(_buffer, _size, _lidx, &p->q_RxLevMinSUL);
	_serNrSysDecSQN_NR_Q_QualMin_SQN_NR_SIB1_cellSelectionInfo_q_QualMin_Optional(_buffer, _size, _lidx, &p->q_QualMin);
	_serNrSysDecUint8_t_SQN_NR_SIB1_cellSelectionInfo_q_QualMinOffset_Optional(_buffer, _size, _lidx, &p->q_QualMinOffset);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SIB1_cellSelectionInfo_cellSelectionInfo_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SIB1_cellSelectionInfo_cellSelectionInfo_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_SIB1_cellSelectionInfo(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_MCC_SQN_NR_PLMN_Identity_mcc_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_MCC_SQN_NR_PLMN_Identity_mcc_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	for (size_t i3 = 0; i3 < 3; i3++) {
		NTOH_8(p->v[i3], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PLMN_Identity(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_PLMN_Identity* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecSQN_NR_MCC_SQN_NR_PLMN_Identity_mcc_Optional(_buffer, _size, _lidx, &p->mcc);
	NTOH_32(p->mnc.d, &_buffer[*_lidx], _lidx);
	p->mnc.v = (SQN_NR_MCC_MNC_Digit*)serMalloc(_mem, p->mnc.d * sizeof(SQN_NR_MCC_MNC_Digit));
	for (size_t i3 = 0; i3 < p->mnc.d; i3++) {
		NTOH_8(p->mnc.v[i3], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_TrackingAreaCode_SQN_NR_PLMN_IdentityInfo_trackingAreaCode_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_TrackingAreaCode_SQN_NR_PLMN_IdentityInfo_trackingAreaCode_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	for (size_t i2 = 0; i2 < 24; i2++) {
		NTOH_8(p->v[i2], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_RAN_AreaCode_SQN_NR_PLMN_IdentityInfo_ranac_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_RAN_AreaCode_SQN_NR_PLMN_IdentityInfo_ranac_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PLMN_IdentityInfo_iab_Support_r16_e_iab_Support_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_PLMN_IdentityInfo_iab_Support_r16_e_iab_Support_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_PLMN_IdentityInfo_iab_Support_r16_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PLMN_IdentityInfo(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_PLMN_IdentityInfo* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_32(p->plmn_IdentityList.d, &_buffer[*_lidx], _lidx);
	p->plmn_IdentityList.v = (struct SQN_NR_PLMN_Identity*)serMalloc(_mem, p->plmn_IdentityList.d * sizeof(struct SQN_NR_PLMN_Identity));
	for (size_t i2 = 0; i2 < p->plmn_IdentityList.d; i2++) {
		_serNrSysDecSQN_NR_PLMN_Identity(_buffer, _size, _lidx, _mem, &p->plmn_IdentityList.v[i2]);
	}
	_serNrSysDecSQN_NR_TrackingAreaCode_SQN_NR_PLMN_IdentityInfo_trackingAreaCode_Optional(_buffer, _size, _lidx, &p->trackingAreaCode);
	_serNrSysDecSQN_NR_RAN_AreaCode_SQN_NR_PLMN_IdentityInfo_ranac_Optional(_buffer, _size, _lidx, &p->ranac);
	for (size_t i2 = 0; i2 < 36; i2++) {
		NTOH_8(p->cellIdentity[i2], &_buffer[*_lidx], _lidx);
	}
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->cellReservedForOperatorUse = (SQN_NR_PLMN_IdentityInfo_cellReservedForOperatorUse_e)_tmp;
	}
	_serNrSysDecSQN_NR_PLMN_IdentityInfo_iab_Support_r16_e_iab_Support_r16_Optional(_buffer, _size, _lidx, &p->iab_Support_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_CellAccessRelatedInfo_cellReservedForOtherUse_e_cellReservedForOtherUse_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_CellAccessRelatedInfo_cellReservedForOtherUse_e_cellReservedForOtherUse_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_CellAccessRelatedInfo_cellReservedForOtherUse_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_CellAccessRelatedInfo_cellReservedForFutureUse_r16_e_cellReservedForFutureUse_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_CellAccessRelatedInfo_cellReservedForFutureUse_r16_e_cellReservedForFutureUse_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_CellAccessRelatedInfo_cellReservedForFutureUse_r16_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_CAG_IdentityInfo_r16_manualCAGselectionAllowed_r16_e_manualCAGselectionAllowed_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_CAG_IdentityInfo_r16_manualCAGselectionAllowed_r16_e_manualCAGselectionAllowed_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_CAG_IdentityInfo_r16_manualCAGselectionAllowed_r16_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_CAG_IdentityInfo_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_CAG_IdentityInfo_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	for (size_t i4 = 0; i4 < 32; i4++) {
		NTOH_8(p->cag_Identity_r16[i4], &_buffer[*_lidx], _lidx);
	}
	_serNrSysDecSQN_NR_CAG_IdentityInfo_r16_manualCAGselectionAllowed_r16_e_manualCAGselectionAllowed_r16_Optional(_buffer, _size, _lidx, &p->manualCAGselectionAllowed_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_NPN_Identity_r16_pni_npn_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_NPN_Identity_r16_pni_npn_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecSQN_NR_PLMN_Identity(_buffer, _size, _lidx, _mem, &p->plmn_Identity_r16);
	NTOH_32(p->cag_IdentityList_r16.d, &_buffer[*_lidx], _lidx);
	p->cag_IdentityList_r16.v = (struct SQN_NR_CAG_IdentityInfo_r16*)serMalloc(_mem, p->cag_IdentityList_r16.d * sizeof(struct SQN_NR_CAG_IdentityInfo_r16));
	for (size_t i3 = 0; i3 < p->cag_IdentityList_r16.d; i3++) {
		_serNrSysDecSQN_NR_CAG_IdentityInfo_r16(_buffer, _size, _lidx, &p->cag_IdentityList_r16.v[i3]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_NPN_Identity_r16_snpn_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_NPN_Identity_r16_snpn_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecSQN_NR_PLMN_Identity(_buffer, _size, _lidx, _mem, &p->plmn_Identity);
	NTOH_32(p->nid_List_r16.d, &_buffer[*_lidx], _lidx);
	p->nid_List_r16.v = (SQN_NR_NID_r16*)serMalloc(_mem, p->nid_List_r16.d * sizeof(SQN_NR_NID_r16));
	for (size_t i3 = 0; i3 < p->nid_List_r16.d; i3++) {
		for (size_t i4 = 0; i4 < 44; i4++) {
			NTOH_8(p->nid_List_r16.v[i3][i4], &_buffer[*_lidx], _lidx);
		}
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_NPN_Identity_r16_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union SQN_NR_NPN_Identity_r16_Value* p, enum SQN_NR_NPN_Identity_r16_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_NPN_Identity_r16_pni_npn_r16) {
		_serNrSysDecSQN_NR_NPN_Identity_r16_pni_npn_r16(_buffer, _size, _lidx, _mem, &p->pni_npn_r16);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_NPN_Identity_r16_snpn_r16) {
		_serNrSysDecSQN_NR_NPN_Identity_r16_snpn_r16(_buffer, _size, _lidx, _mem, &p->snpn_r16);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecSQN_NR_NPN_Identity_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_NPN_Identity_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SQN_NR_NPN_Identity_r16_Sel)_tmp;
	}
	_serNrSysDecSQN_NR_NPN_Identity_r16_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_RAN_AreaCode_SQN_NR_NPN_IdentityInfo_r16_ranac_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_RAN_AreaCode_SQN_NR_NPN_IdentityInfo_r16_ranac_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_NPN_IdentityInfo_r16_iab_Support_r16_e_iab_Support_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_NPN_IdentityInfo_r16_iab_Support_r16_e_iab_Support_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_NPN_IdentityInfo_r16_iab_Support_r16_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_NPN_IdentityInfo_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_NPN_IdentityInfo_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_32(p->npn_IdentityList_r16.d, &_buffer[*_lidx], _lidx);
	p->npn_IdentityList_r16.v = (struct SQN_NR_NPN_Identity_r16*)serMalloc(_mem, p->npn_IdentityList_r16.d * sizeof(struct SQN_NR_NPN_Identity_r16));
	for (size_t i2 = 0; i2 < p->npn_IdentityList_r16.d; i2++) {
		_serNrSysDecSQN_NR_NPN_Identity_r16(_buffer, _size, _lidx, _mem, &p->npn_IdentityList_r16.v[i2]);
	}
	for (size_t i2 = 0; i2 < 24; i2++) {
		NTOH_8(p->trackingAreaCode_r16[i2], &_buffer[*_lidx], _lidx);
	}
	_serNrSysDecSQN_NR_RAN_AreaCode_SQN_NR_NPN_IdentityInfo_r16_ranac_r16_Optional(_buffer, _size, _lidx, &p->ranac_r16);
	for (size_t i2 = 0; i2 < 36; i2++) {
		NTOH_8(p->cellIdentity_r16[i2], &_buffer[*_lidx], _lidx);
	}
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->cellReservedForOperatorUse_r16 = (SQN_NR_NPN_IdentityInfo_r16_cellReservedForOperatorUse_r16_e)_tmp;
	}
	_serNrSysDecSQN_NR_NPN_IdentityInfo_r16_iab_Support_r16_e_iab_Support_r16_Optional(_buffer, _size, _lidx, &p->iab_Support_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_NPN_IdentityInfoList_r16_SQN_NR_CellAccessRelatedInfo_npn_IdentityInfoList_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_NPN_IdentityInfoList_r16_SQN_NR_CellAccessRelatedInfo_npn_IdentityInfoList_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = (struct SQN_NR_NPN_IdentityInfo_r16*)serMalloc(_mem, p->v.d * sizeof(struct SQN_NR_NPN_IdentityInfo_r16));
	for (size_t i1 = 0; i1 < p->v.d; i1++) {
		_serNrSysDecSQN_NR_NPN_IdentityInfo_r16(_buffer, _size, _lidx, _mem, &p->v.v[i1]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_CellAccessRelatedInfo(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_CellAccessRelatedInfo* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_32(p->plmn_IdentityList.d, &_buffer[*_lidx], _lidx);
	p->plmn_IdentityList.v = (struct SQN_NR_PLMN_IdentityInfo*)serMalloc(_mem, p->plmn_IdentityList.d * sizeof(struct SQN_NR_PLMN_IdentityInfo));
	for (size_t i1 = 0; i1 < p->plmn_IdentityList.d; i1++) {
		_serNrSysDecSQN_NR_PLMN_IdentityInfo(_buffer, _size, _lidx, _mem, &p->plmn_IdentityList.v[i1]);
	}
	_serNrSysDecSQN_NR_CellAccessRelatedInfo_cellReservedForOtherUse_e_cellReservedForOtherUse_Optional(_buffer, _size, _lidx, &p->cellReservedForOtherUse);
	_serNrSysDecSQN_NR_CellAccessRelatedInfo_cellReservedForFutureUse_r16_e_cellReservedForFutureUse_r16_Optional(_buffer, _size, _lidx, &p->cellReservedForFutureUse_r16);
	_serNrSysDecSQN_NR_NPN_IdentityInfoList_r16_SQN_NR_CellAccessRelatedInfo_npn_IdentityInfoList_r16_Optional(_buffer, _size, _lidx, _mem, &p->npn_IdentityInfoList_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecUint8_t_SQN_NR_ConnEstFailureControl_connEstFailOffset_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct uint8_t_SQN_NR_ConnEstFailureControl_connEstFailOffset_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_ConnEstFailureControl(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_ConnEstFailureControl* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->connEstFailCount = (SQN_NR_ConnEstFailureControl_connEstFailCount_e)_tmp;
	}
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->connEstFailOffsetValidity = (SQN_NR_ConnEstFailureControl_connEstFailOffsetValidity_e)_tmp;
	}
	_serNrSysDecUint8_t_SQN_NR_ConnEstFailureControl_connEstFailOffset_Optional(_buffer, _size, _lidx, &p->connEstFailOffset);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_ConnEstFailureControl_SQN_NR_SIB1_connEstFailureControl_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_ConnEstFailureControl_SQN_NR_SIB1_connEstFailureControl_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_ConnEstFailureControl(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecUint8_t_SQN_NR_SIB_TypeInfo_valueTag_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct uint8_t_SQN_NR_SIB_TypeInfo_valueTag_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SIB_TypeInfo_areaScope_e_areaScope_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SIB_TypeInfo_areaScope_e_areaScope_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_SIB_TypeInfo_areaScope_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SIB_TypeInfo(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SIB_TypeInfo* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->type = (SQN_NR_SIB_TypeInfo_type_e)_tmp;
	}
	_serNrSysDecUint8_t_SQN_NR_SIB_TypeInfo_valueTag_Optional(_buffer, _size, _lidx, &p->valueTag);
	_serNrSysDecSQN_NR_SIB_TypeInfo_areaScope_e_areaScope_Optional(_buffer, _size, _lidx, &p->areaScope);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SchedulingInfo(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_SchedulingInfo* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->si_BroadcastStatus = (SQN_NR_SchedulingInfo_si_BroadcastStatus_e)_tmp;
	}
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->si_Periodicity = (SQN_NR_SchedulingInfo_si_Periodicity_e)_tmp;
	}
	NTOH_32(p->sib_MappingInfo.d, &_buffer[*_lidx], _lidx);
	p->sib_MappingInfo.v = (struct SQN_NR_SIB_TypeInfo*)serMalloc(_mem, p->sib_MappingInfo.d * sizeof(struct SQN_NR_SIB_TypeInfo));
	for (size_t i2 = 0; i2 < p->sib_MappingInfo.d; i2++) {
		_serNrSysDecSQN_NR_SIB_TypeInfo(_buffer, _size, _lidx, &p->sib_MappingInfo.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SI_RequestConfig_SQN_NR_SI_SchedulingInfo_si_RequestConfig_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_SI_RequestConfig_SQN_NR_SI_SchedulingInfo_si_RequestConfig_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_SI_RequestConfig(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SI_RequestConfig_SQN_NR_SI_SchedulingInfo_si_RequestConfigSUL_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_SI_RequestConfig_SQN_NR_SI_SchedulingInfo_si_RequestConfigSUL_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_SI_RequestConfig(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecB24_SQN_NR_SI_SchedulingInfo_systemInformationAreaID_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct B24_SQN_NR_SI_SchedulingInfo_systemInformationAreaID_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	for (size_t i1 = 0; i1 < 24; i1++) {
		NTOH_8(p->v[i1], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SI_SchedulingInfo(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_SI_SchedulingInfo* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_32(p->schedulingInfoList.d, &_buffer[*_lidx], _lidx);
	p->schedulingInfoList.v = (struct SQN_NR_SchedulingInfo*)serMalloc(_mem, p->schedulingInfoList.d * sizeof(struct SQN_NR_SchedulingInfo));
	for (size_t i1 = 0; i1 < p->schedulingInfoList.d; i1++) {
		_serNrSysDecSQN_NR_SchedulingInfo(_buffer, _size, _lidx, _mem, &p->schedulingInfoList.v[i1]);
	}
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->si_WindowLength = (SQN_NR_SI_SchedulingInfo_si_WindowLength_e)_tmp;
	}
	_serNrSysDecSQN_NR_SI_RequestConfig_SQN_NR_SI_SchedulingInfo_si_RequestConfig_Optional(_buffer, _size, _lidx, _mem, &p->si_RequestConfig);
	_serNrSysDecSQN_NR_SI_RequestConfig_SQN_NR_SI_SchedulingInfo_si_RequestConfigSUL_Optional(_buffer, _size, _lidx, _mem, &p->si_RequestConfigSUL);
	_serNrSysDecB24_SQN_NR_SI_SchedulingInfo_systemInformationAreaID_Optional(_buffer, _size, _lidx, &p->systemInformationAreaID);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SI_SchedulingInfo_SQN_NR_SIB1_si_SchedulingInfo_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_SI_SchedulingInfo_SQN_NR_SIB1_si_SchedulingInfo_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_SI_SchedulingInfo(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_FrequencyInfoDL_SIB(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_FrequencyInfoDL_SIB* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_32(p->frequencyBandList.d, &_buffer[*_lidx], _lidx);
	p->frequencyBandList.v = (struct SQN_NR_NR_MultiBandInfo*)serMalloc(_mem, p->frequencyBandList.d * sizeof(struct SQN_NR_NR_MultiBandInfo));
	for (size_t i1 = 0; i1 < p->frequencyBandList.d; i1++) {
		_serNrSysDecSQN_NR_NR_MultiBandInfo(_buffer, _size, _lidx, _mem, &p->frequencyBandList.v[i1]);
	}
	NTOH_16(p->offsetToPointA, &_buffer[*_lidx], _lidx);
	NTOH_32(p->scs_SpecificCarrierList.d, &_buffer[*_lidx], _lidx);
	p->scs_SpecificCarrierList.v = (struct SQN_NR_SCS_SpecificCarrier*)serMalloc(_mem, p->scs_SpecificCarrierList.d * sizeof(struct SQN_NR_SCS_SpecificCarrier));
	for (size_t i1 = 0; i1 < p->scs_SpecificCarrierList.d; i1++) {
		_serNrSysDecSQN_NR_SCS_SpecificCarrier(_buffer, _size, _lidx, &p->scs_SpecificCarrierList.v[i1]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_ControlResourceSetZero_SQN_NR_PDCCH_ConfigCommon_controlResourceSetZero_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_ControlResourceSetZero_SQN_NR_PDCCH_ConfigCommon_controlResourceSetZero_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_ControlResourceSet_SQN_NR_PDCCH_ConfigCommon_commonControlResourceSet_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_ControlResourceSet_SQN_NR_PDCCH_ConfigCommon_commonControlResourceSet_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_ControlResourceSet(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SearchSpaceZero_SQN_NR_PDCCH_ConfigCommon_searchSpaceZero_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SearchSpaceZero_SQN_NR_PDCCH_ConfigCommon_searchSpaceZero_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SearchSpace_SQN_NR_PDCCH_ConfigCommon_commonSearchSpaceList_DynamicOptional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_SearchSpace_SQN_NR_PDCCH_ConfigCommon_commonSearchSpaceList_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = (struct SQN_NR_SearchSpace*)serMalloc(_mem, p->v.d * sizeof(struct SQN_NR_SearchSpace));
	for (size_t i1 = 0; i1 < p->v.d; i1++) {
		_serNrSysDecSQN_NR_SearchSpace(_buffer, _size, _lidx, &p->v.v[i1]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SearchSpaceId_SQN_NR_PDCCH_ConfigCommon_searchSpaceSIB1_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SearchSpaceId_SQN_NR_PDCCH_ConfigCommon_searchSpaceSIB1_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SearchSpaceId_SQN_NR_PDCCH_ConfigCommon_searchSpaceOtherSystemInformation_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SearchSpaceId_SQN_NR_PDCCH_ConfigCommon_searchSpaceOtherSystemInformation_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SearchSpaceId_SQN_NR_PDCCH_ConfigCommon_pagingSearchSpace_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SearchSpaceId_SQN_NR_PDCCH_ConfigCommon_pagingSearchSpace_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SearchSpaceId_SQN_NR_PDCCH_ConfigCommon_ra_SearchSpace_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SearchSpaceId_SQN_NR_PDCCH_ConfigCommon_ra_SearchSpace_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PDCCH_ConfigCommon_firstPDCCH_MonitoringOccasionOfPO_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union SQN_NR_PDCCH_ConfigCommon_firstPDCCH_MonitoringOccasionOfPO_Value* p, enum SQN_NR_PDCCH_ConfigCommon_firstPDCCH_MonitoringOccasionOfPO_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_PDCCH_ConfigCommon_firstPDCCH_MonitoringOccasionOfPO_sCS15KHZoneT) {
		NTOH_32(p->sCS15KHZoneT.d, &_buffer[*_lidx], _lidx);
		p->sCS15KHZoneT.v = (uint8_t*)serMalloc(_mem, p->sCS15KHZoneT.d * sizeof(uint8_t));
		for (size_t i1 = 0; i1 < p->sCS15KHZoneT.d; i1++) {
			NTOH_8(p->sCS15KHZoneT.v[i1], &_buffer[*_lidx], _lidx);
		}
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_PDCCH_ConfigCommon_firstPDCCH_MonitoringOccasionOfPO_sCS30KHZoneT_SCS15KHZhalfT) {
		NTOH_32(p->sCS30KHZoneT_SCS15KHZhalfT.d, &_buffer[*_lidx], _lidx);
		p->sCS30KHZoneT_SCS15KHZhalfT.v = (uint16_t*)serMalloc(_mem, p->sCS30KHZoneT_SCS15KHZhalfT.d * sizeof(uint16_t));
		for (size_t i1 = 0; i1 < p->sCS30KHZoneT_SCS15KHZhalfT.d; i1++) {
			NTOH_16(p->sCS30KHZoneT_SCS15KHZhalfT.v[i1], &_buffer[*_lidx], _lidx);
		}
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_PDCCH_ConfigCommon_firstPDCCH_MonitoringOccasionOfPO_sCS60KHZoneT_SCS30KHZhalfT_SCS15KHZquarterT) {
		NTOH_32(p->sCS60KHZoneT_SCS30KHZhalfT_SCS15KHZquarterT.d, &_buffer[*_lidx], _lidx);
		p->sCS60KHZoneT_SCS30KHZhalfT_SCS15KHZquarterT.v = (uint16_t*)serMalloc(_mem, p->sCS60KHZoneT_SCS30KHZhalfT_SCS15KHZquarterT.d * sizeof(uint16_t));
		for (size_t i1 = 0; i1 < p->sCS60KHZoneT_SCS30KHZhalfT_SCS15KHZquarterT.d; i1++) {
			NTOH_16(p->sCS60KHZoneT_SCS30KHZhalfT_SCS15KHZquarterT.v[i1], &_buffer[*_lidx], _lidx);
		}
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_PDCCH_ConfigCommon_firstPDCCH_MonitoringOccasionOfPO_sCS120KHZoneT_SCS60KHZhalfT_SCS30KHZquarterT_SCS15KHZoneEighthT) {
		NTOH_32(p->sCS120KHZoneT_SCS60KHZhalfT_SCS30KHZquarterT_SCS15KHZoneEighthT.d, &_buffer[*_lidx], _lidx);
		p->sCS120KHZoneT_SCS60KHZhalfT_SCS30KHZquarterT_SCS15KHZoneEighthT.v = (uint16_t*)serMalloc(_mem, p->sCS120KHZoneT_SCS60KHZhalfT_SCS30KHZquarterT_SCS15KHZoneEighthT.d * sizeof(uint16_t));
		for (size_t i1 = 0; i1 < p->sCS120KHZoneT_SCS60KHZhalfT_SCS30KHZquarterT_SCS15KHZoneEighthT.d; i1++) {
			NTOH_16(p->sCS120KHZoneT_SCS60KHZhalfT_SCS30KHZquarterT_SCS15KHZoneEighthT.v[i1], &_buffer[*_lidx], _lidx);
		}
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_PDCCH_ConfigCommon_firstPDCCH_MonitoringOccasionOfPO_sCS120KHZhalfT_SCS60KHZquarterT_SCS30KHZoneEighthT_SCS15KHZoneSixteenthT) {
		NTOH_32(p->sCS120KHZhalfT_SCS60KHZquarterT_SCS30KHZoneEighthT_SCS15KHZoneSixteenthT.d, &_buffer[*_lidx], _lidx);
		p->sCS120KHZhalfT_SCS60KHZquarterT_SCS30KHZoneEighthT_SCS15KHZoneSixteenthT.v = (uint16_t*)serMalloc(_mem, p->sCS120KHZhalfT_SCS60KHZquarterT_SCS30KHZoneEighthT_SCS15KHZoneSixteenthT.d * sizeof(uint16_t));
		for (size_t i1 = 0; i1 < p->sCS120KHZhalfT_SCS60KHZquarterT_SCS30KHZoneEighthT_SCS15KHZoneSixteenthT.d; i1++) {
			NTOH_16(p->sCS120KHZhalfT_SCS60KHZquarterT_SCS30KHZoneEighthT_SCS15KHZoneSixteenthT.v[i1], &_buffer[*_lidx], _lidx);
		}
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_PDCCH_ConfigCommon_firstPDCCH_MonitoringOccasionOfPO_sCS120KHZquarterT_SCS60KHZoneEighthT_SCS30KHZoneSixteenthT) {
		NTOH_32(p->sCS120KHZquarterT_SCS60KHZoneEighthT_SCS30KHZoneSixteenthT.d, &_buffer[*_lidx], _lidx);
		p->sCS120KHZquarterT_SCS60KHZoneEighthT_SCS30KHZoneSixteenthT.v = (uint16_t*)serMalloc(_mem, p->sCS120KHZquarterT_SCS60KHZoneEighthT_SCS30KHZoneSixteenthT.d * sizeof(uint16_t));
		for (size_t i1 = 0; i1 < p->sCS120KHZquarterT_SCS60KHZoneEighthT_SCS30KHZoneSixteenthT.d; i1++) {
			NTOH_16(p->sCS120KHZquarterT_SCS60KHZoneEighthT_SCS30KHZoneSixteenthT.v[i1], &_buffer[*_lidx], _lidx);
		}
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_PDCCH_ConfigCommon_firstPDCCH_MonitoringOccasionOfPO_sCS120KHZoneEighthT_SCS60KHZoneSixteenthT) {
		NTOH_32(p->sCS120KHZoneEighthT_SCS60KHZoneSixteenthT.d, &_buffer[*_lidx], _lidx);
		p->sCS120KHZoneEighthT_SCS60KHZoneSixteenthT.v = (uint16_t*)serMalloc(_mem, p->sCS120KHZoneEighthT_SCS60KHZoneSixteenthT.d * sizeof(uint16_t));
		for (size_t i1 = 0; i1 < p->sCS120KHZoneEighthT_SCS60KHZoneSixteenthT.d; i1++) {
			NTOH_16(p->sCS120KHZoneEighthT_SCS60KHZoneSixteenthT.v[i1], &_buffer[*_lidx], _lidx);
		}
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_PDCCH_ConfigCommon_firstPDCCH_MonitoringOccasionOfPO_sCS120KHZoneSixteenthT) {
		NTOH_32(p->sCS120KHZoneSixteenthT.d, &_buffer[*_lidx], _lidx);
		p->sCS120KHZoneSixteenthT.v = (uint16_t*)serMalloc(_mem, p->sCS120KHZoneSixteenthT.d * sizeof(uint16_t));
		for (size_t i1 = 0; i1 < p->sCS120KHZoneSixteenthT.d; i1++) {
			NTOH_16(p->sCS120KHZoneSixteenthT.v[i1], &_buffer[*_lidx], _lidx);
		}
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecSQN_NR_PDCCH_ConfigCommon_firstPDCCH_MonitoringOccasionOfPO(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_PDCCH_ConfigCommon_firstPDCCH_MonitoringOccasionOfPO* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SQN_NR_PDCCH_ConfigCommon_firstPDCCH_MonitoringOccasionOfPO_Sel)_tmp;
	}
	_serNrSysDecSQN_NR_PDCCH_ConfigCommon_firstPDCCH_MonitoringOccasionOfPO_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PDCCH_ConfigCommon_firstPDCCH_MonitoringOccasionOfPO_firstPDCCH_MonitoringOccasionOfPO_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_PDCCH_ConfigCommon_firstPDCCH_MonitoringOccasionOfPO_firstPDCCH_MonitoringOccasionOfPO_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_PDCCH_ConfigCommon_firstPDCCH_MonitoringOccasionOfPO(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_ControlResourceSetId_r16_SQN_NR_SearchSpaceExt_r16_controlResourceSetId_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_ControlResourceSetId_r16_SQN_NR_SearchSpaceExt_r16_controlResourceSetId_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SearchSpaceExt_r16_searchSpaceType_r16_common_r16_dci_Format2_4_r16nrofCandidates_CI_r16aggregationLevel1_r16_e_aggregationLevel1_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SearchSpaceExt_r16_searchSpaceType_r16_common_r16_dci_Format2_4_r16nrofCandidates_CI_r16aggregationLevel1_r16_e_aggregationLevel1_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_SearchSpaceExt_r16_searchSpaceType_r16_common_r16_dci_Format2_4_r16nrofCandidates_CI_r16aggregationLevel1_r16_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SearchSpaceExt_r16_searchSpaceType_r16_common_r16_dci_Format2_4_r16nrofCandidates_CI_r16aggregationLevel2_r16_e_aggregationLevel2_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SearchSpaceExt_r16_searchSpaceType_r16_common_r16_dci_Format2_4_r16nrofCandidates_CI_r16aggregationLevel2_r16_e_aggregationLevel2_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_SearchSpaceExt_r16_searchSpaceType_r16_common_r16_dci_Format2_4_r16nrofCandidates_CI_r16aggregationLevel2_r16_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SearchSpaceExt_r16_searchSpaceType_r16_common_r16_dci_Format2_4_r16nrofCandidates_CI_r16aggregationLevel4_r16_e_aggregationLevel4_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SearchSpaceExt_r16_searchSpaceType_r16_common_r16_dci_Format2_4_r16nrofCandidates_CI_r16aggregationLevel4_r16_e_aggregationLevel4_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_SearchSpaceExt_r16_searchSpaceType_r16_common_r16_dci_Format2_4_r16nrofCandidates_CI_r16aggregationLevel4_r16_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SearchSpaceExt_r16_searchSpaceType_r16_common_r16_dci_Format2_4_r16nrofCandidates_CI_r16aggregationLevel8_r16_e_aggregationLevel8_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SearchSpaceExt_r16_searchSpaceType_r16_common_r16_dci_Format2_4_r16nrofCandidates_CI_r16aggregationLevel8_r16_e_aggregationLevel8_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_SearchSpaceExt_r16_searchSpaceType_r16_common_r16_dci_Format2_4_r16nrofCandidates_CI_r16aggregationLevel8_r16_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SearchSpaceExt_r16_searchSpaceType_r16_common_r16_dci_Format2_4_r16nrofCandidates_CI_r16aggregationLevel16_r16_e_aggregationLevel16_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SearchSpaceExt_r16_searchSpaceType_r16_common_r16_dci_Format2_4_r16nrofCandidates_CI_r16aggregationLevel16_r16_e_aggregationLevel16_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_SearchSpaceExt_r16_searchSpaceType_r16_common_r16_dci_Format2_4_r16nrofCandidates_CI_r16aggregationLevel16_r16_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SearchSpaceExt_r16_searchSpaceType_r16_common_r16_dci_Format2_4_r16nrofCandidates_CI_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SearchSpaceExt_r16_searchSpaceType_r16_common_r16_dci_Format2_4_r16nrofCandidates_CI_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecSQN_NR_SearchSpaceExt_r16_searchSpaceType_r16_common_r16_dci_Format2_4_r16nrofCandidates_CI_r16aggregationLevel1_r16_e_aggregationLevel1_r16_Optional(_buffer, _size, _lidx, &p->aggregationLevel1_r16);
	_serNrSysDecSQN_NR_SearchSpaceExt_r16_searchSpaceType_r16_common_r16_dci_Format2_4_r16nrofCandidates_CI_r16aggregationLevel2_r16_e_aggregationLevel2_r16_Optional(_buffer, _size, _lidx, &p->aggregationLevel2_r16);
	_serNrSysDecSQN_NR_SearchSpaceExt_r16_searchSpaceType_r16_common_r16_dci_Format2_4_r16nrofCandidates_CI_r16aggregationLevel4_r16_e_aggregationLevel4_r16_Optional(_buffer, _size, _lidx, &p->aggregationLevel4_r16);
	_serNrSysDecSQN_NR_SearchSpaceExt_r16_searchSpaceType_r16_common_r16_dci_Format2_4_r16nrofCandidates_CI_r16aggregationLevel8_r16_e_aggregationLevel8_r16_Optional(_buffer, _size, _lidx, &p->aggregationLevel8_r16);
	_serNrSysDecSQN_NR_SearchSpaceExt_r16_searchSpaceType_r16_common_r16_dci_Format2_4_r16nrofCandidates_CI_r16aggregationLevel16_r16_e_aggregationLevel16_r16_Optional(_buffer, _size, _lidx, &p->aggregationLevel16_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SearchSpaceExt_r16_searchSpaceType_r16_common_r16_dci_Format2_4_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SearchSpaceExt_r16_searchSpaceType_r16_common_r16_dci_Format2_4_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecSQN_NR_SearchSpaceExt_r16_searchSpaceType_r16_common_r16_dci_Format2_4_r16nrofCandidates_CI_r16(_buffer, _size, _lidx, &p->nrofCandidates_CI_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SearchSpaceExt_r16_searchSpaceType_r16_common_r16_dci_Format2_4_r16_dci_Format2_4_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SearchSpaceExt_r16_searchSpaceType_r16_common_r16_dci_Format2_4_r16_dci_Format2_4_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_SearchSpaceExt_r16_searchSpaceType_r16_common_r16_dci_Format2_4_r16(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SearchSpaceExt_r16_searchSpaceType_r16_common_r16_dci_Format2_5_r16nrofCandidates_IAB_r16aggregationLevel1_r16_e_aggregationLevel1_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SearchSpaceExt_r16_searchSpaceType_r16_common_r16_dci_Format2_5_r16nrofCandidates_IAB_r16aggregationLevel1_r16_e_aggregationLevel1_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_SearchSpaceExt_r16_searchSpaceType_r16_common_r16_dci_Format2_5_r16nrofCandidates_IAB_r16aggregationLevel1_r16_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SearchSpaceExt_r16_searchSpaceType_r16_common_r16_dci_Format2_5_r16nrofCandidates_IAB_r16aggregationLevel2_r16_e_aggregationLevel2_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SearchSpaceExt_r16_searchSpaceType_r16_common_r16_dci_Format2_5_r16nrofCandidates_IAB_r16aggregationLevel2_r16_e_aggregationLevel2_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_SearchSpaceExt_r16_searchSpaceType_r16_common_r16_dci_Format2_5_r16nrofCandidates_IAB_r16aggregationLevel2_r16_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SearchSpaceExt_r16_searchSpaceType_r16_common_r16_dci_Format2_5_r16nrofCandidates_IAB_r16aggregationLevel4_r16_e_aggregationLevel4_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SearchSpaceExt_r16_searchSpaceType_r16_common_r16_dci_Format2_5_r16nrofCandidates_IAB_r16aggregationLevel4_r16_e_aggregationLevel4_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_SearchSpaceExt_r16_searchSpaceType_r16_common_r16_dci_Format2_5_r16nrofCandidates_IAB_r16aggregationLevel4_r16_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SearchSpaceExt_r16_searchSpaceType_r16_common_r16_dci_Format2_5_r16nrofCandidates_IAB_r16aggregationLevel8_r16_e_aggregationLevel8_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SearchSpaceExt_r16_searchSpaceType_r16_common_r16_dci_Format2_5_r16nrofCandidates_IAB_r16aggregationLevel8_r16_e_aggregationLevel8_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_SearchSpaceExt_r16_searchSpaceType_r16_common_r16_dci_Format2_5_r16nrofCandidates_IAB_r16aggregationLevel8_r16_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SearchSpaceExt_r16_searchSpaceType_r16_common_r16_dci_Format2_5_r16nrofCandidates_IAB_r16aggregationLevel16_r16_e_aggregationLevel16_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SearchSpaceExt_r16_searchSpaceType_r16_common_r16_dci_Format2_5_r16nrofCandidates_IAB_r16aggregationLevel16_r16_e_aggregationLevel16_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_SearchSpaceExt_r16_searchSpaceType_r16_common_r16_dci_Format2_5_r16nrofCandidates_IAB_r16aggregationLevel16_r16_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SearchSpaceExt_r16_searchSpaceType_r16_common_r16_dci_Format2_5_r16nrofCandidates_IAB_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SearchSpaceExt_r16_searchSpaceType_r16_common_r16_dci_Format2_5_r16nrofCandidates_IAB_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecSQN_NR_SearchSpaceExt_r16_searchSpaceType_r16_common_r16_dci_Format2_5_r16nrofCandidates_IAB_r16aggregationLevel1_r16_e_aggregationLevel1_r16_Optional(_buffer, _size, _lidx, &p->aggregationLevel1_r16);
	_serNrSysDecSQN_NR_SearchSpaceExt_r16_searchSpaceType_r16_common_r16_dci_Format2_5_r16nrofCandidates_IAB_r16aggregationLevel2_r16_e_aggregationLevel2_r16_Optional(_buffer, _size, _lidx, &p->aggregationLevel2_r16);
	_serNrSysDecSQN_NR_SearchSpaceExt_r16_searchSpaceType_r16_common_r16_dci_Format2_5_r16nrofCandidates_IAB_r16aggregationLevel4_r16_e_aggregationLevel4_r16_Optional(_buffer, _size, _lidx, &p->aggregationLevel4_r16);
	_serNrSysDecSQN_NR_SearchSpaceExt_r16_searchSpaceType_r16_common_r16_dci_Format2_5_r16nrofCandidates_IAB_r16aggregationLevel8_r16_e_aggregationLevel8_r16_Optional(_buffer, _size, _lidx, &p->aggregationLevel8_r16);
	_serNrSysDecSQN_NR_SearchSpaceExt_r16_searchSpaceType_r16_common_r16_dci_Format2_5_r16nrofCandidates_IAB_r16aggregationLevel16_r16_e_aggregationLevel16_r16_Optional(_buffer, _size, _lidx, &p->aggregationLevel16_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SearchSpaceExt_r16_searchSpaceType_r16_common_r16_dci_Format2_5_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SearchSpaceExt_r16_searchSpaceType_r16_common_r16_dci_Format2_5_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecSQN_NR_SearchSpaceExt_r16_searchSpaceType_r16_common_r16_dci_Format2_5_r16nrofCandidates_IAB_r16(_buffer, _size, _lidx, &p->nrofCandidates_IAB_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SearchSpaceExt_r16_searchSpaceType_r16_common_r16_dci_Format2_5_r16_dci_Format2_5_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SearchSpaceExt_r16_searchSpaceType_r16_common_r16_dci_Format2_5_r16_dci_Format2_5_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_SearchSpaceExt_r16_searchSpaceType_r16_common_r16_dci_Format2_5_r16(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SearchSpaceExt_r16_searchSpaceType_r16_common_r16_dci_Format2_6_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SearchSpaceExt_r16_searchSpaceType_r16_common_r16_dci_Format2_6_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	(void)_buffer;
	(void)_size;
	(void)_lidx;
	(void)p;

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SearchSpaceExt_r16_searchSpaceType_r16_common_r16_dci_Format2_6_r16_dci_Format2_6_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SearchSpaceExt_r16_searchSpaceType_r16_common_r16_dci_Format2_6_r16_dci_Format2_6_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_SearchSpaceExt_r16_searchSpaceType_r16_common_r16_dci_Format2_6_r16(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SearchSpaceExt_r16_searchSpaceType_r16_common_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SearchSpaceExt_r16_searchSpaceType_r16_common_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecSQN_NR_SearchSpaceExt_r16_searchSpaceType_r16_common_r16_dci_Format2_4_r16_dci_Format2_4_r16_Optional(_buffer, _size, _lidx, &p->dci_Format2_4_r16);
	_serNrSysDecSQN_NR_SearchSpaceExt_r16_searchSpaceType_r16_common_r16_dci_Format2_5_r16_dci_Format2_5_r16_Optional(_buffer, _size, _lidx, &p->dci_Format2_5_r16);
	_serNrSysDecSQN_NR_SearchSpaceExt_r16_searchSpaceType_r16_common_r16_dci_Format2_6_r16_dci_Format2_6_r16_Optional(_buffer, _size, _lidx, &p->dci_Format2_6_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SearchSpaceExt_r16_searchSpaceType_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SearchSpaceExt_r16_searchSpaceType_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecSQN_NR_SearchSpaceExt_r16_searchSpaceType_r16_common_r16(_buffer, _size, _lidx, &p->common_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SearchSpaceExt_r16_searchSpaceType_r16_searchSpaceType_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SearchSpaceExt_r16_searchSpaceType_r16_searchSpaceType_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_SearchSpaceExt_r16_searchSpaceType_r16(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecUint8_t_SQN_NR_SearchSpaceExt_r16_searchSpaceGroupIdList_r16_DynamicOptional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct uint8_t_SQN_NR_SearchSpaceExt_r16_searchSpaceGroupIdList_r16_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = (uint8_t*)serMalloc(_mem, p->v.d * sizeof(uint8_t));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		NTOH_8(p->v.v[i2], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecB5_SQN_NR_SearchSpaceExt_r16_freqMonitorLocations_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct B5_SQN_NR_SearchSpaceExt_r16_freqMonitorLocations_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	for (size_t i2 = 0; i2 < 5; i2++) {
		NTOH_8(p->v[i2], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SearchSpaceExt_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_SearchSpaceExt_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecSQN_NR_ControlResourceSetId_r16_SQN_NR_SearchSpaceExt_r16_controlResourceSetId_r16_Optional(_buffer, _size, _lidx, &p->controlResourceSetId_r16);
	_serNrSysDecSQN_NR_SearchSpaceExt_r16_searchSpaceType_r16_searchSpaceType_r16_Optional(_buffer, _size, _lidx, &p->searchSpaceType_r16);
	_serNrSysDecUint8_t_SQN_NR_SearchSpaceExt_r16_searchSpaceGroupIdList_r16_DynamicOptional(_buffer, _size, _lidx, _mem, &p->searchSpaceGroupIdList_r16);
	_serNrSysDecB5_SQN_NR_SearchSpaceExt_r16_freqMonitorLocations_r16_Optional(_buffer, _size, _lidx, &p->freqMonitorLocations_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SearchSpaceExt_r16_SQN_NR_PDCCH_ConfigCommon_commonSearchSpaceListExt_r16_DynamicOptional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_SearchSpaceExt_r16_SQN_NR_PDCCH_ConfigCommon_commonSearchSpaceListExt_r16_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = (struct SQN_NR_SearchSpaceExt_r16*)serMalloc(_mem, p->v.d * sizeof(struct SQN_NR_SearchSpaceExt_r16));
	for (size_t i1 = 0; i1 < p->v.d; i1++) {
		_serNrSysDecSQN_NR_SearchSpaceExt_r16(_buffer, _size, _lidx, _mem, &p->v.v[i1]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PDCCH_ConfigCommon(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_PDCCH_ConfigCommon* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecSQN_NR_ControlResourceSetZero_SQN_NR_PDCCH_ConfigCommon_controlResourceSetZero_Optional(_buffer, _size, _lidx, &p->controlResourceSetZero);
	_serNrSysDecSQN_NR_ControlResourceSet_SQN_NR_PDCCH_ConfigCommon_commonControlResourceSet_Optional(_buffer, _size, _lidx, _mem, &p->commonControlResourceSet);
	_serNrSysDecSQN_NR_SearchSpaceZero_SQN_NR_PDCCH_ConfigCommon_searchSpaceZero_Optional(_buffer, _size, _lidx, &p->searchSpaceZero);
	_serNrSysDecSQN_NR_SearchSpace_SQN_NR_PDCCH_ConfigCommon_commonSearchSpaceList_DynamicOptional(_buffer, _size, _lidx, _mem, &p->commonSearchSpaceList);
	_serNrSysDecSQN_NR_SearchSpaceId_SQN_NR_PDCCH_ConfigCommon_searchSpaceSIB1_Optional(_buffer, _size, _lidx, &p->searchSpaceSIB1);
	_serNrSysDecSQN_NR_SearchSpaceId_SQN_NR_PDCCH_ConfigCommon_searchSpaceOtherSystemInformation_Optional(_buffer, _size, _lidx, &p->searchSpaceOtherSystemInformation);
	_serNrSysDecSQN_NR_SearchSpaceId_SQN_NR_PDCCH_ConfigCommon_pagingSearchSpace_Optional(_buffer, _size, _lidx, &p->pagingSearchSpace);
	_serNrSysDecSQN_NR_SearchSpaceId_SQN_NR_PDCCH_ConfigCommon_ra_SearchSpace_Optional(_buffer, _size, _lidx, &p->ra_SearchSpace);
	_serNrSysDecSQN_NR_PDCCH_ConfigCommon_firstPDCCH_MonitoringOccasionOfPO_firstPDCCH_MonitoringOccasionOfPO_Optional(_buffer, _size, _lidx, _mem, &p->firstPDCCH_MonitoringOccasionOfPO);
	_serNrSysDecSQN_NR_SearchSpaceExt_r16_SQN_NR_PDCCH_ConfigCommon_commonSearchSpaceListExt_r16_DynamicOptional(_buffer, _size, _lidx, _mem, &p->commonSearchSpaceListExt_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SetupRelease_BWP_DownlinkCommon_pdcch_ConfigCommon_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union SQN_NR_SetupRelease_BWP_DownlinkCommon_pdcch_ConfigCommon_Value* p, enum SQN_NR_SetupRelease_BWP_DownlinkCommon_pdcch_ConfigCommon_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SetupRelease_BWP_DownlinkCommon_pdcch_ConfigCommon_release) {
		NTOH_8(p->release, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SetupRelease_BWP_DownlinkCommon_pdcch_ConfigCommon_setup) {
		_serNrSysDecSQN_NR_PDCCH_ConfigCommon(_buffer, _size, _lidx, _mem, &p->setup);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecSQN_NR_SetupRelease_BWP_DownlinkCommon_pdcch_ConfigCommon(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_SetupRelease_BWP_DownlinkCommon_pdcch_ConfigCommon* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SQN_NR_SetupRelease_BWP_DownlinkCommon_pdcch_ConfigCommon_Sel)_tmp;
	}
	_serNrSysDecSQN_NR_SetupRelease_BWP_DownlinkCommon_pdcch_ConfigCommon_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SetupRelease_BWP_DownlinkCommon_pdcch_ConfigCommon_SQN_NR_BWP_DownlinkCommon_pdcch_ConfigCommon_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_SetupRelease_BWP_DownlinkCommon_pdcch_ConfigCommon_SQN_NR_BWP_DownlinkCommon_pdcch_ConfigCommon_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_SetupRelease_BWP_DownlinkCommon_pdcch_ConfigCommon(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SetupRelease_BWP_DownlinkCommon_pdsch_ConfigCommon_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union SQN_NR_SetupRelease_BWP_DownlinkCommon_pdsch_ConfigCommon_Value* p, enum SQN_NR_SetupRelease_BWP_DownlinkCommon_pdsch_ConfigCommon_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SetupRelease_BWP_DownlinkCommon_pdsch_ConfigCommon_release) {
		NTOH_8(p->release, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SetupRelease_BWP_DownlinkCommon_pdsch_ConfigCommon_setup) {
		_serNrSysDecSQN_NR_PDSCH_ConfigCommon(_buffer, _size, _lidx, _mem, &p->setup);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecSQN_NR_SetupRelease_BWP_DownlinkCommon_pdsch_ConfigCommon(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_SetupRelease_BWP_DownlinkCommon_pdsch_ConfigCommon* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SQN_NR_SetupRelease_BWP_DownlinkCommon_pdsch_ConfigCommon_Sel)_tmp;
	}
	_serNrSysDecSQN_NR_SetupRelease_BWP_DownlinkCommon_pdsch_ConfigCommon_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SetupRelease_BWP_DownlinkCommon_pdsch_ConfigCommon_SQN_NR_BWP_DownlinkCommon_pdsch_ConfigCommon_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_SetupRelease_BWP_DownlinkCommon_pdsch_ConfigCommon_SQN_NR_BWP_DownlinkCommon_pdsch_ConfigCommon_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_SetupRelease_BWP_DownlinkCommon_pdsch_ConfigCommon(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_BWP_DownlinkCommon(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_BWP_DownlinkCommon* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecSQN_NR_BWP(_buffer, _size, _lidx, &p->genericParameters);
	_serNrSysDecSQN_NR_SetupRelease_BWP_DownlinkCommon_pdcch_ConfigCommon_SQN_NR_BWP_DownlinkCommon_pdcch_ConfigCommon_Optional(_buffer, _size, _lidx, _mem, &p->pdcch_ConfigCommon);
	_serNrSysDecSQN_NR_SetupRelease_BWP_DownlinkCommon_pdsch_ConfigCommon_SQN_NR_BWP_DownlinkCommon_pdsch_ConfigCommon_Optional(_buffer, _size, _lidx, _mem, &p->pdsch_ConfigCommon);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_BCCH_Config(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_BCCH_Config* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->modificationPeriodCoeff = (SQN_NR_BCCH_Config_modificationPeriodCoeff_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PCCH_Config_nAndPagingFrameOffset_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union SQN_NR_PCCH_Config_nAndPagingFrameOffset_Value* p, enum SQN_NR_PCCH_Config_nAndPagingFrameOffset_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_PCCH_Config_nAndPagingFrameOffset_oneT) {
		NTOH_8(p->oneT, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_PCCH_Config_nAndPagingFrameOffset_halfT) {
		NTOH_8(p->halfT, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_PCCH_Config_nAndPagingFrameOffset_quarterT) {
		NTOH_8(p->quarterT, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_PCCH_Config_nAndPagingFrameOffset_oneEighthT) {
		NTOH_8(p->oneEighthT, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_PCCH_Config_nAndPagingFrameOffset_oneSixteenthT) {
		NTOH_8(p->oneSixteenthT, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecSQN_NR_PCCH_Config_nAndPagingFrameOffset(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_PCCH_Config_nAndPagingFrameOffset* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SQN_NR_PCCH_Config_nAndPagingFrameOffset_Sel)_tmp;
	}
	_serNrSysDecSQN_NR_PCCH_Config_nAndPagingFrameOffset_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PCCH_Config_firstPDCCH_MonitoringOccasionOfPO_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union SQN_NR_PCCH_Config_firstPDCCH_MonitoringOccasionOfPO_Value* p, enum SQN_NR_PCCH_Config_firstPDCCH_MonitoringOccasionOfPO_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_PCCH_Config_firstPDCCH_MonitoringOccasionOfPO_sCS15KHZoneT) {
		NTOH_32(p->sCS15KHZoneT.d, &_buffer[*_lidx], _lidx);
		p->sCS15KHZoneT.v = (uint8_t*)serMalloc(_mem, p->sCS15KHZoneT.d * sizeof(uint8_t));
		for (size_t i1 = 0; i1 < p->sCS15KHZoneT.d; i1++) {
			NTOH_8(p->sCS15KHZoneT.v[i1], &_buffer[*_lidx], _lidx);
		}
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_PCCH_Config_firstPDCCH_MonitoringOccasionOfPO_sCS30KHZoneT_SCS15KHZhalfT) {
		NTOH_32(p->sCS30KHZoneT_SCS15KHZhalfT.d, &_buffer[*_lidx], _lidx);
		p->sCS30KHZoneT_SCS15KHZhalfT.v = (uint16_t*)serMalloc(_mem, p->sCS30KHZoneT_SCS15KHZhalfT.d * sizeof(uint16_t));
		for (size_t i1 = 0; i1 < p->sCS30KHZoneT_SCS15KHZhalfT.d; i1++) {
			NTOH_16(p->sCS30KHZoneT_SCS15KHZhalfT.v[i1], &_buffer[*_lidx], _lidx);
		}
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_PCCH_Config_firstPDCCH_MonitoringOccasionOfPO_sCS60KHZoneT_SCS30KHZhalfT_SCS15KHZquarterT) {
		NTOH_32(p->sCS60KHZoneT_SCS30KHZhalfT_SCS15KHZquarterT.d, &_buffer[*_lidx], _lidx);
		p->sCS60KHZoneT_SCS30KHZhalfT_SCS15KHZquarterT.v = (uint16_t*)serMalloc(_mem, p->sCS60KHZoneT_SCS30KHZhalfT_SCS15KHZquarterT.d * sizeof(uint16_t));
		for (size_t i1 = 0; i1 < p->sCS60KHZoneT_SCS30KHZhalfT_SCS15KHZquarterT.d; i1++) {
			NTOH_16(p->sCS60KHZoneT_SCS30KHZhalfT_SCS15KHZquarterT.v[i1], &_buffer[*_lidx], _lidx);
		}
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_PCCH_Config_firstPDCCH_MonitoringOccasionOfPO_sCS120KHZoneT_SCS60KHZhalfT_SCS30KHZquarterT_SCS15KHZoneEighthT) {
		NTOH_32(p->sCS120KHZoneT_SCS60KHZhalfT_SCS30KHZquarterT_SCS15KHZoneEighthT.d, &_buffer[*_lidx], _lidx);
		p->sCS120KHZoneT_SCS60KHZhalfT_SCS30KHZquarterT_SCS15KHZoneEighthT.v = (uint16_t*)serMalloc(_mem, p->sCS120KHZoneT_SCS60KHZhalfT_SCS30KHZquarterT_SCS15KHZoneEighthT.d * sizeof(uint16_t));
		for (size_t i1 = 0; i1 < p->sCS120KHZoneT_SCS60KHZhalfT_SCS30KHZquarterT_SCS15KHZoneEighthT.d; i1++) {
			NTOH_16(p->sCS120KHZoneT_SCS60KHZhalfT_SCS30KHZquarterT_SCS15KHZoneEighthT.v[i1], &_buffer[*_lidx], _lidx);
		}
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_PCCH_Config_firstPDCCH_MonitoringOccasionOfPO_sCS120KHZhalfT_SCS60KHZquarterT_SCS30KHZoneEighthT_SCS15KHZoneSixteenthT) {
		NTOH_32(p->sCS120KHZhalfT_SCS60KHZquarterT_SCS30KHZoneEighthT_SCS15KHZoneSixteenthT.d, &_buffer[*_lidx], _lidx);
		p->sCS120KHZhalfT_SCS60KHZquarterT_SCS30KHZoneEighthT_SCS15KHZoneSixteenthT.v = (uint16_t*)serMalloc(_mem, p->sCS120KHZhalfT_SCS60KHZquarterT_SCS30KHZoneEighthT_SCS15KHZoneSixteenthT.d * sizeof(uint16_t));
		for (size_t i1 = 0; i1 < p->sCS120KHZhalfT_SCS60KHZquarterT_SCS30KHZoneEighthT_SCS15KHZoneSixteenthT.d; i1++) {
			NTOH_16(p->sCS120KHZhalfT_SCS60KHZquarterT_SCS30KHZoneEighthT_SCS15KHZoneSixteenthT.v[i1], &_buffer[*_lidx], _lidx);
		}
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_PCCH_Config_firstPDCCH_MonitoringOccasionOfPO_sCS120KHZquarterT_SCS60KHZoneEighthT_SCS30KHZoneSixteenthT) {
		NTOH_32(p->sCS120KHZquarterT_SCS60KHZoneEighthT_SCS30KHZoneSixteenthT.d, &_buffer[*_lidx], _lidx);
		p->sCS120KHZquarterT_SCS60KHZoneEighthT_SCS30KHZoneSixteenthT.v = (uint16_t*)serMalloc(_mem, p->sCS120KHZquarterT_SCS60KHZoneEighthT_SCS30KHZoneSixteenthT.d * sizeof(uint16_t));
		for (size_t i1 = 0; i1 < p->sCS120KHZquarterT_SCS60KHZoneEighthT_SCS30KHZoneSixteenthT.d; i1++) {
			NTOH_16(p->sCS120KHZquarterT_SCS60KHZoneEighthT_SCS30KHZoneSixteenthT.v[i1], &_buffer[*_lidx], _lidx);
		}
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_PCCH_Config_firstPDCCH_MonitoringOccasionOfPO_sCS120KHZoneEighthT_SCS60KHZoneSixteenthT) {
		NTOH_32(p->sCS120KHZoneEighthT_SCS60KHZoneSixteenthT.d, &_buffer[*_lidx], _lidx);
		p->sCS120KHZoneEighthT_SCS60KHZoneSixteenthT.v = (uint16_t*)serMalloc(_mem, p->sCS120KHZoneEighthT_SCS60KHZoneSixteenthT.d * sizeof(uint16_t));
		for (size_t i1 = 0; i1 < p->sCS120KHZoneEighthT_SCS60KHZoneSixteenthT.d; i1++) {
			NTOH_16(p->sCS120KHZoneEighthT_SCS60KHZoneSixteenthT.v[i1], &_buffer[*_lidx], _lidx);
		}
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_PCCH_Config_firstPDCCH_MonitoringOccasionOfPO_sCS120KHZoneSixteenthT) {
		NTOH_32(p->sCS120KHZoneSixteenthT.d, &_buffer[*_lidx], _lidx);
		p->sCS120KHZoneSixteenthT.v = (uint16_t*)serMalloc(_mem, p->sCS120KHZoneSixteenthT.d * sizeof(uint16_t));
		for (size_t i1 = 0; i1 < p->sCS120KHZoneSixteenthT.d; i1++) {
			NTOH_16(p->sCS120KHZoneSixteenthT.v[i1], &_buffer[*_lidx], _lidx);
		}
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecSQN_NR_PCCH_Config_firstPDCCH_MonitoringOccasionOfPO(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_PCCH_Config_firstPDCCH_MonitoringOccasionOfPO* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SQN_NR_PCCH_Config_firstPDCCH_MonitoringOccasionOfPO_Sel)_tmp;
	}
	_serNrSysDecSQN_NR_PCCH_Config_firstPDCCH_MonitoringOccasionOfPO_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PCCH_Config_firstPDCCH_MonitoringOccasionOfPO_firstPDCCH_MonitoringOccasionOfPO_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_PCCH_Config_firstPDCCH_MonitoringOccasionOfPO_firstPDCCH_MonitoringOccasionOfPO_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_PCCH_Config_firstPDCCH_MonitoringOccasionOfPO(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecUint8_t_SQN_NR_PCCH_Config_nrofPDCCH_MonitoringOccasionPerSSB_InPO_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct uint8_t_SQN_NR_PCCH_Config_nrofPDCCH_MonitoringOccasionPerSSB_InPO_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PCCH_Config(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_PCCH_Config* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->defaultPagingCycle = (SQN_NR_PagingCycle_e)_tmp;
	}
	_serNrSysDecSQN_NR_PCCH_Config_nAndPagingFrameOffset(_buffer, _size, _lidx, &p->nAndPagingFrameOffset);
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->ns = (SQN_NR_PCCH_Config_ns_e)_tmp;
	}
	_serNrSysDecSQN_NR_PCCH_Config_firstPDCCH_MonitoringOccasionOfPO_firstPDCCH_MonitoringOccasionOfPO_Optional(_buffer, _size, _lidx, _mem, &p->firstPDCCH_MonitoringOccasionOfPO);
	_serNrSysDecUint8_t_SQN_NR_PCCH_Config_nrofPDCCH_MonitoringOccasionPerSSB_InPO_r16_Optional(_buffer, _size, _lidx, &p->nrofPDCCH_MonitoringOccasionPerSSB_InPO_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_DownlinkConfigCommonSIB(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_DownlinkConfigCommonSIB* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecSQN_NR_FrequencyInfoDL_SIB(_buffer, _size, _lidx, _mem, &p->frequencyInfoDL);
	_serNrSysDecSQN_NR_BWP_DownlinkCommon(_buffer, _size, _lidx, _mem, &p->initialDownlinkBWP);
	_serNrSysDecSQN_NR_BCCH_Config(_buffer, _size, _lidx, &p->bcch_Config);
	_serNrSysDecSQN_NR_PCCH_Config(_buffer, _size, _lidx, _mem, &p->pcch_Config);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_MultiFrequencyBandListNR_SIB_SQN_NR_FrequencyInfoUL_SIB_frequencyBandList_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_MultiFrequencyBandListNR_SIB_SQN_NR_FrequencyInfoUL_SIB_frequencyBandList_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = (struct SQN_NR_NR_MultiBandInfo*)serMalloc(_mem, p->v.d * sizeof(struct SQN_NR_NR_MultiBandInfo));
	for (size_t i1 = 0; i1 < p->v.d; i1++) {
		_serNrSysDecSQN_NR_NR_MultiBandInfo(_buffer, _size, _lidx, _mem, &p->v.v[i1]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_ARFCN_ValueNR_SQN_NR_FrequencyInfoUL_SIB_absoluteFrequencyPointA_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_ARFCN_ValueNR_SQN_NR_FrequencyInfoUL_SIB_absoluteFrequencyPointA_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_P_Max_SQN_NR_FrequencyInfoUL_SIB_p_Max_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_P_Max_SQN_NR_FrequencyInfoUL_SIB_p_Max_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_FrequencyInfoUL_SIB_frequencyShift7p5khz_e_frequencyShift7p5khz_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_FrequencyInfoUL_SIB_frequencyShift7p5khz_e_frequencyShift7p5khz_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_FrequencyInfoUL_SIB_frequencyShift7p5khz_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_FrequencyInfoUL_SIB(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_FrequencyInfoUL_SIB* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecSQN_NR_MultiFrequencyBandListNR_SIB_SQN_NR_FrequencyInfoUL_SIB_frequencyBandList_Optional(_buffer, _size, _lidx, _mem, &p->frequencyBandList);
	_serNrSysDecSQN_NR_ARFCN_ValueNR_SQN_NR_FrequencyInfoUL_SIB_absoluteFrequencyPointA_Optional(_buffer, _size, _lidx, &p->absoluteFrequencyPointA);
	NTOH_32(p->scs_SpecificCarrierList.d, &_buffer[*_lidx], _lidx);
	p->scs_SpecificCarrierList.v = (struct SQN_NR_SCS_SpecificCarrier*)serMalloc(_mem, p->scs_SpecificCarrierList.d * sizeof(struct SQN_NR_SCS_SpecificCarrier));
	for (size_t i1 = 0; i1 < p->scs_SpecificCarrierList.d; i1++) {
		_serNrSysDecSQN_NR_SCS_SpecificCarrier(_buffer, _size, _lidx, &p->scs_SpecificCarrierList.v[i1]);
	}
	_serNrSysDecSQN_NR_P_Max_SQN_NR_FrequencyInfoUL_SIB_p_Max_Optional(_buffer, _size, _lidx, &p->p_Max);
	_serNrSysDecSQN_NR_FrequencyInfoUL_SIB_frequencyShift7p5khz_e_frequencyShift7p5khz_Optional(_buffer, _size, _lidx, &p->frequencyShift7p5khz);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_UplinkConfigCommonSIB(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_UplinkConfigCommonSIB* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecSQN_NR_FrequencyInfoUL_SIB(_buffer, _size, _lidx, _mem, &p->frequencyInfoUL);
	_serNrSysDecSQN_NR_BWP_UplinkCommon(_buffer, _size, _lidx, _mem, &p->initialUplinkBWP);
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->timeAlignmentTimerCommon = (SQN_NR_TimeAlignmentTimer_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_UplinkConfigCommonSIB_SQN_NR_ServingCellConfigCommonSIB_uplinkConfigCommon_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_UplinkConfigCommonSIB_SQN_NR_ServingCellConfigCommonSIB_uplinkConfigCommon_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_UplinkConfigCommonSIB(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_UplinkConfigCommonSIB_SQN_NR_ServingCellConfigCommonSIB_supplementaryUplink_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_UplinkConfigCommonSIB_SQN_NR_ServingCellConfigCommonSIB_supplementaryUplink_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_UplinkConfigCommonSIB(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_ServingCellConfigCommonSIB_n_TimingAdvanceOffset_e_n_TimingAdvanceOffset_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_ServingCellConfigCommonSIB_n_TimingAdvanceOffset_e_n_TimingAdvanceOffset_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_ServingCellConfigCommonSIB_n_TimingAdvanceOffset_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecB8_SQN_NR_ServingCellConfigCommonSIB_ssb_PositionsInBurst_groupPresence_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct B8_SQN_NR_ServingCellConfigCommonSIB_ssb_PositionsInBurst_groupPresence_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	for (size_t i1 = 0; i1 < 8; i1++) {
		NTOH_8(p->v[i1], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_ServingCellConfigCommonSIB_ssb_PositionsInBurst(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_ServingCellConfigCommonSIB_ssb_PositionsInBurst* p)
{
	(void)_size; // TODO: generate boundaries checking

	for (size_t i1 = 0; i1 < 8; i1++) {
		NTOH_8(p->inOneGroup[i1], &_buffer[*_lidx], _lidx);
	}
	_serNrSysDecB8_SQN_NR_ServingCellConfigCommonSIB_ssb_PositionsInBurst_groupPresence_Optional(_buffer, _size, _lidx, &p->groupPresence);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_TDD_UL_DL_ConfigCommon_SQN_NR_ServingCellConfigCommonSIB_tdd_UL_DL_ConfigurationCommon_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_TDD_UL_DL_ConfigCommon_SQN_NR_ServingCellConfigCommonSIB_tdd_UL_DL_ConfigurationCommon_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_TDD_UL_DL_ConfigCommon(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SemiStaticChannelAccessConfig(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SemiStaticChannelAccessConfig* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->period = (SQN_NR_SemiStaticChannelAccessConfig_period_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_ServingCellConfigCommonSIB_channelAccessMode_r16_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union SQN_NR_ServingCellConfigCommonSIB_channelAccessMode_r16_Value* p, enum SQN_NR_ServingCellConfigCommonSIB_channelAccessMode_r16_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_ServingCellConfigCommonSIB_channelAccessMode_r16_dynamic) {
		NTOH_8(p->dynamic, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_ServingCellConfigCommonSIB_channelAccessMode_r16_semiStatic) {
		_serNrSysDecSQN_NR_SemiStaticChannelAccessConfig(_buffer, _size, _lidx, &p->semiStatic);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecSQN_NR_ServingCellConfigCommonSIB_channelAccessMode_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_ServingCellConfigCommonSIB_channelAccessMode_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SQN_NR_ServingCellConfigCommonSIB_channelAccessMode_r16_Sel)_tmp;
	}
	_serNrSysDecSQN_NR_ServingCellConfigCommonSIB_channelAccessMode_r16_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_ServingCellConfigCommonSIB_channelAccessMode_r16_channelAccessMode_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_ServingCellConfigCommonSIB_channelAccessMode_r16_channelAccessMode_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_ServingCellConfigCommonSIB_channelAccessMode_r16(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_ServingCellConfigCommonSIB_discoveryBurstWindowLength_r16_e_discoveryBurstWindowLength_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_ServingCellConfigCommonSIB_discoveryBurstWindowLength_r16_e_discoveryBurstWindowLength_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_ServingCellConfigCommonSIB_discoveryBurstWindowLength_r16_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_HighSpeedConfig_r16_highSpeedMeasFlag_r16_e_highSpeedMeasFlag_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_HighSpeedConfig_r16_highSpeedMeasFlag_r16_e_highSpeedMeasFlag_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_HighSpeedConfig_r16_highSpeedMeasFlag_r16_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_HighSpeedConfig_r16_highSpeedDemodFlag_r16_e_highSpeedDemodFlag_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_HighSpeedConfig_r16_highSpeedDemodFlag_r16_e_highSpeedDemodFlag_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_HighSpeedConfig_r16_highSpeedDemodFlag_r16_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_HighSpeedConfig_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_HighSpeedConfig_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecSQN_NR_HighSpeedConfig_r16_highSpeedMeasFlag_r16_e_highSpeedMeasFlag_r16_Optional(_buffer, _size, _lidx, &p->highSpeedMeasFlag_r16);
	_serNrSysDecSQN_NR_HighSpeedConfig_r16_highSpeedDemodFlag_r16_e_highSpeedDemodFlag_r16_Optional(_buffer, _size, _lidx, &p->highSpeedDemodFlag_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_HighSpeedConfig_r16_SQN_NR_ServingCellConfigCommonSIB_highSpeedConfig_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_HighSpeedConfig_r16_SQN_NR_ServingCellConfigCommonSIB_highSpeedConfig_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_HighSpeedConfig_r16(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_ServingCellConfigCommonSIB(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_ServingCellConfigCommonSIB* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecSQN_NR_DownlinkConfigCommonSIB(_buffer, _size, _lidx, _mem, &p->downlinkConfigCommon);
	_serNrSysDecSQN_NR_UplinkConfigCommonSIB_SQN_NR_ServingCellConfigCommonSIB_uplinkConfigCommon_Optional(_buffer, _size, _lidx, _mem, &p->uplinkConfigCommon);
	_serNrSysDecSQN_NR_UplinkConfigCommonSIB_SQN_NR_ServingCellConfigCommonSIB_supplementaryUplink_Optional(_buffer, _size, _lidx, _mem, &p->supplementaryUplink);
	_serNrSysDecSQN_NR_ServingCellConfigCommonSIB_n_TimingAdvanceOffset_e_n_TimingAdvanceOffset_Optional(_buffer, _size, _lidx, &p->n_TimingAdvanceOffset);
	_serNrSysDecSQN_NR_ServingCellConfigCommonSIB_ssb_PositionsInBurst(_buffer, _size, _lidx, &p->ssb_PositionsInBurst);
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->ssb_PeriodicityServingCell = (SQN_NR_ServingCellConfigCommonSIB_ssb_PeriodicityServingCell_e)_tmp;
	}
	_serNrSysDecSQN_NR_TDD_UL_DL_ConfigCommon_SQN_NR_ServingCellConfigCommonSIB_tdd_UL_DL_ConfigurationCommon_Optional(_buffer, _size, _lidx, &p->tdd_UL_DL_ConfigurationCommon);
	NTOH_8(p->ss_PBCH_BlockPower, &_buffer[*_lidx], _lidx);
	_serNrSysDecSQN_NR_ServingCellConfigCommonSIB_channelAccessMode_r16_channelAccessMode_r16_Optional(_buffer, _size, _lidx, &p->channelAccessMode_r16);
	_serNrSysDecSQN_NR_ServingCellConfigCommonSIB_discoveryBurstWindowLength_r16_e_discoveryBurstWindowLength_r16_Optional(_buffer, _size, _lidx, &p->discoveryBurstWindowLength_r16);
	_serNrSysDecSQN_NR_HighSpeedConfig_r16_SQN_NR_ServingCellConfigCommonSIB_highSpeedConfig_r16_Optional(_buffer, _size, _lidx, &p->highSpeedConfig_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_ServingCellConfigCommonSIB_SQN_NR_SIB1_servingCellConfigCommon_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_ServingCellConfigCommonSIB_SQN_NR_SIB1_servingCellConfigCommon_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_ServingCellConfigCommonSIB(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SIB1_ims_EmergencySupport_e_ims_EmergencySupport_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SIB1_ims_EmergencySupport_e_ims_EmergencySupport_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_SIB1_ims_EmergencySupport_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SIB1_eCallOverIMS_Support_e_eCallOverIMS_Support_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SIB1_eCallOverIMS_Support_e_eCallOverIMS_Support_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_SIB1_eCallOverIMS_Support_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_UE_TimersAndConstants(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_UE_TimersAndConstants* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->t300 = (SQN_NR_UE_TimersAndConstants_t300_e)_tmp;
	}
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->t301 = (SQN_NR_UE_TimersAndConstants_t301_e)_tmp;
	}
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->t310 = (SQN_NR_UE_TimersAndConstants_t310_e)_tmp;
	}
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->n310 = (SQN_NR_UE_TimersAndConstants_n310_e)_tmp;
	}
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->t311 = (SQN_NR_UE_TimersAndConstants_t311_e)_tmp;
	}
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->n311 = (SQN_NR_UE_TimersAndConstants_n311_e)_tmp;
	}
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->t319 = (SQN_NR_UE_TimersAndConstants_t319_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_UE_TimersAndConstants_SQN_NR_SIB1_ue_TimersAndConstants_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_UE_TimersAndConstants_SQN_NR_SIB1_ue_TimersAndConstants_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_UE_TimersAndConstants(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_UAC_BarringPerCat(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_UAC_BarringPerCat* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->accessCategory, &_buffer[*_lidx], _lidx);
	NTOH_8(p->uac_barringInfoSetIndex, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_UAC_BarringPerCatList_SQN_NR_SIB1_uac_BarringInfo_uac_BarringForCommon_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_UAC_BarringPerCatList_SQN_NR_SIB1_uac_BarringInfo_uac_BarringForCommon_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = (struct SQN_NR_UAC_BarringPerCat*)serMalloc(_mem, p->v.d * sizeof(struct SQN_NR_UAC_BarringPerCat));
	for (size_t i1 = 0; i1 < p->v.d; i1++) {
		_serNrSysDecSQN_NR_UAC_BarringPerCat(_buffer, _size, _lidx, &p->v.v[i1]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_UAC_BarringPerPLMN_uac_ACBarringListType_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union SQN_NR_UAC_BarringPerPLMN_uac_ACBarringListType_Value* p, enum SQN_NR_UAC_BarringPerPLMN_uac_ACBarringListType_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_UAC_BarringPerPLMN_uac_ACBarringListType_uac_ImplicitACBarringList) {
		for (size_t i2 = 0; i2 < 63; i2++) {
			NTOH_8(p->uac_ImplicitACBarringList[i2], &_buffer[*_lidx], _lidx);
		}
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_UAC_BarringPerPLMN_uac_ACBarringListType_uac_ExplicitACBarringList) {
		NTOH_32(p->uac_ExplicitACBarringList.d, &_buffer[*_lidx], _lidx);
		p->uac_ExplicitACBarringList.v = (struct SQN_NR_UAC_BarringPerCat*)serMalloc(_mem, p->uac_ExplicitACBarringList.d * sizeof(struct SQN_NR_UAC_BarringPerCat));
		for (size_t i2 = 0; i2 < p->uac_ExplicitACBarringList.d; i2++) {
			_serNrSysDecSQN_NR_UAC_BarringPerCat(_buffer, _size, _lidx, &p->uac_ExplicitACBarringList.v[i2]);
		}
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecSQN_NR_UAC_BarringPerPLMN_uac_ACBarringListType(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_UAC_BarringPerPLMN_uac_ACBarringListType* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SQN_NR_UAC_BarringPerPLMN_uac_ACBarringListType_Sel)_tmp;
	}
	_serNrSysDecSQN_NR_UAC_BarringPerPLMN_uac_ACBarringListType_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_UAC_BarringPerPLMN_uac_ACBarringListType_uac_ACBarringListType_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_UAC_BarringPerPLMN_uac_ACBarringListType_uac_ACBarringListType_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_UAC_BarringPerPLMN_uac_ACBarringListType(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_UAC_BarringPerPLMN(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_UAC_BarringPerPLMN* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->plmn_IdentityIndex, &_buffer[*_lidx], _lidx);
	_serNrSysDecSQN_NR_UAC_BarringPerPLMN_uac_ACBarringListType_uac_ACBarringListType_Optional(_buffer, _size, _lidx, _mem, &p->uac_ACBarringListType);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_UAC_BarringPerPLMN_List_SQN_NR_SIB1_uac_BarringInfo_uac_BarringPerPLMN_List_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_UAC_BarringPerPLMN_List_SQN_NR_SIB1_uac_BarringInfo_uac_BarringPerPLMN_List_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = (struct SQN_NR_UAC_BarringPerPLMN*)serMalloc(_mem, p->v.d * sizeof(struct SQN_NR_UAC_BarringPerPLMN));
	for (size_t i1 = 0; i1 < p->v.d; i1++) {
		_serNrSysDecSQN_NR_UAC_BarringPerPLMN(_buffer, _size, _lidx, _mem, &p->v.v[i1]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_UAC_BarringInfoSet(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_UAC_BarringInfoSet* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->uac_BarringFactor = (SQN_NR_UAC_BarringInfoSet_uac_BarringFactor_e)_tmp;
	}
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->uac_BarringTime = (SQN_NR_UAC_BarringInfoSet_uac_BarringTime_e)_tmp;
	}
	for (size_t i2 = 0; i2 < 7; i2++) {
		NTOH_8(p->uac_BarringForAccessIdentity[i2], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SIB1_uac_BarringInfo_uac_AccessCategory1_SelectionAssistanceInfo_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union SQN_NR_SIB1_uac_BarringInfo_uac_AccessCategory1_SelectionAssistanceInfo_Value* p, enum SQN_NR_SIB1_uac_BarringInfo_uac_AccessCategory1_SelectionAssistanceInfo_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SIB1_uac_BarringInfo_uac_AccessCategory1_SelectionAssistanceInfo_plmnCommon) {
		{
			size_t _tmp;
			NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
			p->plmnCommon = (SQN_NR_UAC_AccessCategory1_SelectionAssistanceInfo_e)_tmp;
		}
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SIB1_uac_BarringInfo_uac_AccessCategory1_SelectionAssistanceInfo_individualPLMNList) {
		NTOH_32(p->individualPLMNList.d, &_buffer[*_lidx], _lidx);
		p->individualPLMNList.v = (SQN_NR_UAC_AccessCategory1_SelectionAssistanceInfo_e*)serMalloc(_mem, p->individualPLMNList.d * sizeof(SQN_NR_UAC_AccessCategory1_SelectionAssistanceInfo_e));
		for (size_t i1 = 0; i1 < p->individualPLMNList.d; i1++) {
			{
				size_t _tmp;
				NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
				p->individualPLMNList.v[i1] = (SQN_NR_UAC_AccessCategory1_SelectionAssistanceInfo_e)_tmp;
			}
		}
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecSQN_NR_SIB1_uac_BarringInfo_uac_AccessCategory1_SelectionAssistanceInfo(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_SIB1_uac_BarringInfo_uac_AccessCategory1_SelectionAssistanceInfo* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SQN_NR_SIB1_uac_BarringInfo_uac_AccessCategory1_SelectionAssistanceInfo_Sel)_tmp;
	}
	_serNrSysDecSQN_NR_SIB1_uac_BarringInfo_uac_AccessCategory1_SelectionAssistanceInfo_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SIB1_uac_BarringInfo_uac_AccessCategory1_SelectionAssistanceInfo_uac_AccessCategory1_SelectionAssistanceInfo_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_SIB1_uac_BarringInfo_uac_AccessCategory1_SelectionAssistanceInfo_uac_AccessCategory1_SelectionAssistanceInfo_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_SIB1_uac_BarringInfo_uac_AccessCategory1_SelectionAssistanceInfo(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SIB1_uac_BarringInfo(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_SIB1_uac_BarringInfo* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecSQN_NR_UAC_BarringPerCatList_SQN_NR_SIB1_uac_BarringInfo_uac_BarringForCommon_Optional(_buffer, _size, _lidx, _mem, &p->uac_BarringForCommon);
	_serNrSysDecSQN_NR_UAC_BarringPerPLMN_List_SQN_NR_SIB1_uac_BarringInfo_uac_BarringPerPLMN_List_Optional(_buffer, _size, _lidx, _mem, &p->uac_BarringPerPLMN_List);
	NTOH_32(p->uac_BarringInfoSetList.d, &_buffer[*_lidx], _lidx);
	p->uac_BarringInfoSetList.v = (struct SQN_NR_UAC_BarringInfoSet*)serMalloc(_mem, p->uac_BarringInfoSetList.d * sizeof(struct SQN_NR_UAC_BarringInfoSet));
	for (size_t i1 = 0; i1 < p->uac_BarringInfoSetList.d; i1++) {
		_serNrSysDecSQN_NR_UAC_BarringInfoSet(_buffer, _size, _lidx, &p->uac_BarringInfoSetList.v[i1]);
	}
	_serNrSysDecSQN_NR_SIB1_uac_BarringInfo_uac_AccessCategory1_SelectionAssistanceInfo_uac_AccessCategory1_SelectionAssistanceInfo_Optional(_buffer, _size, _lidx, _mem, &p->uac_AccessCategory1_SelectionAssistanceInfo);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SIB1_uac_BarringInfo_uac_BarringInfo_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_SIB1_uac_BarringInfo_uac_BarringInfo_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_SIB1_uac_BarringInfo(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SIB1_useFullResumeID_e_useFullResumeID_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SIB1_useFullResumeID_e_useFullResumeID_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_SIB1_useFullResumeID_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecOCTET_STRING_SQN_NR_SIB1_lateNonCriticalExtension_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct OCTET_STRING_SQN_NR_SIB1_lateNonCriticalExtension_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = (OCTET_STRING_ELEMENT*)serMalloc(_mem, p->v.d * sizeof(OCTET_STRING_ELEMENT));
	for (size_t i1 = 0; i1 < p->v.d; i1++) {
		NTOH_8(p->v.v[i1], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SIB1_v1610_IEs_idleModeMeasurementsEUTRA_r16_e_idleModeMeasurementsEUTRA_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SIB1_v1610_IEs_idleModeMeasurementsEUTRA_r16_e_idleModeMeasurementsEUTRA_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_SIB1_v1610_IEs_idleModeMeasurementsEUTRA_r16_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SIB1_v1610_IEs_idleModeMeasurementsNR_r16_e_idleModeMeasurementsNR_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SIB1_v1610_IEs_idleModeMeasurementsNR_r16_e_idleModeMeasurementsNR_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_SIB1_v1610_IEs_idleModeMeasurementsNR_r16_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PosSchedulingInfo_r16_offsetToSI_Used_r16_e_offsetToSI_Used_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_PosSchedulingInfo_r16_offsetToSI_Used_r16_e_offsetToSI_Used_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_PosSchedulingInfo_r16_offsetToSI_Used_r16_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PosSIB_Type_r16_encrypted_r16_e_encrypted_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_PosSIB_Type_r16_encrypted_r16_e_encrypted_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_PosSIB_Type_r16_encrypted_r16_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_GNSS_ID_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_GNSS_ID_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->gnss_id_r16 = (SQN_NR_GNSS_ID_r16_gnss_id_r16_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_GNSS_ID_r16_SQN_NR_PosSIB_Type_r16_gnss_id_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_GNSS_ID_r16_SQN_NR_PosSIB_Type_r16_gnss_id_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_GNSS_ID_r16(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SBAS_ID_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SBAS_ID_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->sbas_id_r16 = (SQN_NR_SBAS_ID_r16_sbas_id_r16_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SBAS_ID_r16_SQN_NR_PosSIB_Type_r16_sbas_id_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SBAS_ID_r16_SQN_NR_PosSIB_Type_r16_sbas_id_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_SBAS_ID_r16(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PosSIB_Type_r16_areaScope_r16_e_areaScope_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_PosSIB_Type_r16_areaScope_r16_e_areaScope_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_PosSIB_Type_r16_areaScope_r16_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PosSIB_Type_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_PosSIB_Type_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecSQN_NR_PosSIB_Type_r16_encrypted_r16_e_encrypted_r16_Optional(_buffer, _size, _lidx, &p->encrypted_r16);
	_serNrSysDecSQN_NR_GNSS_ID_r16_SQN_NR_PosSIB_Type_r16_gnss_id_r16_Optional(_buffer, _size, _lidx, &p->gnss_id_r16);
	_serNrSysDecSQN_NR_SBAS_ID_r16_SQN_NR_PosSIB_Type_r16_sbas_id_r16_Optional(_buffer, _size, _lidx, &p->sbas_id_r16);
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->posSibType_r16 = (SQN_NR_PosSIB_Type_r16_posSibType_r16_e)_tmp;
	}
	_serNrSysDecSQN_NR_PosSIB_Type_r16_areaScope_r16_e_areaScope_r16_Optional(_buffer, _size, _lidx, &p->areaScope_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PosSchedulingInfo_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_PosSchedulingInfo_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecSQN_NR_PosSchedulingInfo_r16_offsetToSI_Used_r16_e_offsetToSI_Used_r16_Optional(_buffer, _size, _lidx, &p->offsetToSI_Used_r16);
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->posSI_Periodicity_r16 = (SQN_NR_PosSchedulingInfo_r16_posSI_Periodicity_r16_e)_tmp;
	}
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->posSI_BroadcastStatus_r16 = (SQN_NR_PosSchedulingInfo_r16_posSI_BroadcastStatus_r16_e)_tmp;
	}
	NTOH_32(p->posSIB_MappingInfo_r16.d, &_buffer[*_lidx], _lidx);
	p->posSIB_MappingInfo_r16.v = (struct SQN_NR_PosSIB_Type_r16*)serMalloc(_mem, p->posSIB_MappingInfo_r16.d * sizeof(struct SQN_NR_PosSIB_Type_r16));
	for (size_t i2 = 0; i2 < p->posSIB_MappingInfo_r16.d; i2++) {
		_serNrSysDecSQN_NR_PosSIB_Type_r16(_buffer, _size, _lidx, &p->posSIB_MappingInfo_r16.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SI_RequestConfig_SQN_NR_PosSI_SchedulingInfo_r16_posSI_RequestConfig_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_SI_RequestConfig_SQN_NR_PosSI_SchedulingInfo_r16_posSI_RequestConfig_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_SI_RequestConfig(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SI_RequestConfig_SQN_NR_PosSI_SchedulingInfo_r16_posSI_RequestConfigSUL_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_SI_RequestConfig_SQN_NR_PosSI_SchedulingInfo_r16_posSI_RequestConfigSUL_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_SI_RequestConfig(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PosSI_SchedulingInfo_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_PosSI_SchedulingInfo_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_32(p->posSchedulingInfoList_r16.d, &_buffer[*_lidx], _lidx);
	p->posSchedulingInfoList_r16.v = (struct SQN_NR_PosSchedulingInfo_r16*)serMalloc(_mem, p->posSchedulingInfoList_r16.d * sizeof(struct SQN_NR_PosSchedulingInfo_r16));
	for (size_t i1 = 0; i1 < p->posSchedulingInfoList_r16.d; i1++) {
		_serNrSysDecSQN_NR_PosSchedulingInfo_r16(_buffer, _size, _lidx, _mem, &p->posSchedulingInfoList_r16.v[i1]);
	}
	_serNrSysDecSQN_NR_SI_RequestConfig_SQN_NR_PosSI_SchedulingInfo_r16_posSI_RequestConfig_r16_Optional(_buffer, _size, _lidx, _mem, &p->posSI_RequestConfig_r16);
	_serNrSysDecSQN_NR_SI_RequestConfig_SQN_NR_PosSI_SchedulingInfo_r16_posSI_RequestConfigSUL_r16_Optional(_buffer, _size, _lidx, _mem, &p->posSI_RequestConfigSUL_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PosSI_SchedulingInfo_r16_SQN_NR_SIB1_v1610_IEs_posSI_SchedulingInfo_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_PosSI_SchedulingInfo_r16_SQN_NR_SIB1_v1610_IEs_posSI_SchedulingInfo_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_PosSI_SchedulingInfo_r16(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SIB1_v1610_IEs_nonCriticalExtension(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SIB1_v1610_IEs_nonCriticalExtension* p)
{
	(void)_size; // TODO: generate boundaries checking

	(void)_buffer;
	(void)_size;
	(void)_lidx;
	(void)p;

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SIB1_v1610_IEs_nonCriticalExtension_nonCriticalExtension_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SIB1_v1610_IEs_nonCriticalExtension_nonCriticalExtension_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_SIB1_v1610_IEs_nonCriticalExtension(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SIB1_v1610_IEs(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_SIB1_v1610_IEs* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecSQN_NR_SIB1_v1610_IEs_idleModeMeasurementsEUTRA_r16_e_idleModeMeasurementsEUTRA_r16_Optional(_buffer, _size, _lidx, &p->idleModeMeasurementsEUTRA_r16);
	_serNrSysDecSQN_NR_SIB1_v1610_IEs_idleModeMeasurementsNR_r16_e_idleModeMeasurementsNR_r16_Optional(_buffer, _size, _lidx, &p->idleModeMeasurementsNR_r16);
	_serNrSysDecSQN_NR_PosSI_SchedulingInfo_r16_SQN_NR_SIB1_v1610_IEs_posSI_SchedulingInfo_r16_Optional(_buffer, _size, _lidx, _mem, &p->posSI_SchedulingInfo_r16);
	_serNrSysDecSQN_NR_SIB1_v1610_IEs_nonCriticalExtension_nonCriticalExtension_Optional(_buffer, _size, _lidx, &p->nonCriticalExtension);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SIB1_v1610_IEs_SQN_NR_SIB1_nonCriticalExtension_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_SIB1_v1610_IEs_SQN_NR_SIB1_nonCriticalExtension_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_SIB1_v1610_IEs(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SIB1(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_SIB1* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecSQN_NR_SIB1_cellSelectionInfo_cellSelectionInfo_Optional(_buffer, _size, _lidx, &p->cellSelectionInfo);
	_serNrSysDecSQN_NR_CellAccessRelatedInfo(_buffer, _size, _lidx, _mem, &p->cellAccessRelatedInfo);
	_serNrSysDecSQN_NR_ConnEstFailureControl_SQN_NR_SIB1_connEstFailureControl_Optional(_buffer, _size, _lidx, &p->connEstFailureControl);
	_serNrSysDecSQN_NR_SI_SchedulingInfo_SQN_NR_SIB1_si_SchedulingInfo_Optional(_buffer, _size, _lidx, _mem, &p->si_SchedulingInfo);
	_serNrSysDecSQN_NR_ServingCellConfigCommonSIB_SQN_NR_SIB1_servingCellConfigCommon_Optional(_buffer, _size, _lidx, _mem, &p->servingCellConfigCommon);
	_serNrSysDecSQN_NR_SIB1_ims_EmergencySupport_e_ims_EmergencySupport_Optional(_buffer, _size, _lidx, &p->ims_EmergencySupport);
	_serNrSysDecSQN_NR_SIB1_eCallOverIMS_Support_e_eCallOverIMS_Support_Optional(_buffer, _size, _lidx, &p->eCallOverIMS_Support);
	_serNrSysDecSQN_NR_UE_TimersAndConstants_SQN_NR_SIB1_ue_TimersAndConstants_Optional(_buffer, _size, _lidx, &p->ue_TimersAndConstants);
	_serNrSysDecSQN_NR_SIB1_uac_BarringInfo_uac_BarringInfo_Optional(_buffer, _size, _lidx, _mem, &p->uac_BarringInfo);
	_serNrSysDecSQN_NR_SIB1_useFullResumeID_e_useFullResumeID_Optional(_buffer, _size, _lidx, &p->useFullResumeID);
	_serNrSysDecOCTET_STRING_SQN_NR_SIB1_lateNonCriticalExtension_Optional(_buffer, _size, _lidx, _mem, &p->lateNonCriticalExtension);
	_serNrSysDecSQN_NR_SIB1_v1610_IEs_SQN_NR_SIB1_nonCriticalExtension_Optional(_buffer, _size, _lidx, _mem, &p->nonCriticalExtension);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_BCCH_DL_SCH_MessageType_c1_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union SQN_NR_BCCH_DL_SCH_MessageType_c1_Value* p, enum SQN_NR_BCCH_DL_SCH_MessageType_c1_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_BCCH_DL_SCH_MessageType_c1_systemInformation) {
		_serNrSysDecSQN_NR_SystemInformation(_buffer, _size, _lidx, _mem, &p->systemInformation);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_BCCH_DL_SCH_MessageType_c1_systemInformationBlockType1) {
		_serNrSysDecSQN_NR_SIB1(_buffer, _size, _lidx, _mem, &p->systemInformationBlockType1);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecSQN_NR_BCCH_DL_SCH_MessageType_c1(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_BCCH_DL_SCH_MessageType_c1* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SQN_NR_BCCH_DL_SCH_MessageType_c1_Sel)_tmp;
	}
	_serNrSysDecSQN_NR_BCCH_DL_SCH_MessageType_c1_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_BCCH_DL_SCH_MessageType_messageClassExtension(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_BCCH_DL_SCH_MessageType_messageClassExtension* p)
{
	(void)_size; // TODO: generate boundaries checking

	(void)_buffer;
	(void)_size;
	(void)_lidx;
	(void)p;

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_BCCH_DL_SCH_MessageType_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union SQN_NR_BCCH_DL_SCH_MessageType_Value* p, enum SQN_NR_BCCH_DL_SCH_MessageType_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_BCCH_DL_SCH_MessageType_c1) {
		_serNrSysDecSQN_NR_BCCH_DL_SCH_MessageType_c1(_buffer, _size, _lidx, _mem, &p->c1);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_BCCH_DL_SCH_MessageType_messageClassExtension) {
		_serNrSysDecSQN_NR_BCCH_DL_SCH_MessageType_messageClassExtension(_buffer, _size, _lidx, &p->messageClassExtension);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecSQN_NR_BCCH_DL_SCH_MessageType(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_BCCH_DL_SCH_MessageType* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SQN_NR_BCCH_DL_SCH_MessageType_Sel)_tmp;
	}
	_serNrSysDecSQN_NR_BCCH_DL_SCH_MessageType_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_BCCH_DL_SCH_Message(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_BCCH_DL_SCH_Message* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecSQN_NR_BCCH_DL_SCH_MessageType(_buffer, _size, _lidx, _mem, &p->message);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_BCCH_DL_SCH_Message_SIB1_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_BCCH_DL_SCH_Message_SIB1_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_BCCH_DL_SCH_Message(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_SI_List_Type_SIs_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_SI_List_Type_SIs_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = (struct SQN_NR_BCCH_DL_SCH_Message*)serMalloc(_mem, p->v.d * sizeof(struct SQN_NR_BCCH_DL_SCH_Message));
	for (size_t i1 = 0; i1 < p->v.d; i1++) {
		_serNrSysDecSQN_NR_BCCH_DL_SCH_Message(_buffer, _size, _lidx, _mem, &p->v.v[i1]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_SegmentedSI_List_Type_SegmentedSIs_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_SegmentedSI_List_Type_SegmentedSIs_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = (NR_SI_List_Type*)serMalloc(_mem, p->v.d * sizeof(NR_SI_List_Type));
	for (size_t i1 = 0; i1 < p->v.d; i1++) {
		NTOH_32(p->v.v[i1].d, &_buffer[*_lidx], _lidx);
		p->v.v[i1].v = (struct SQN_NR_BCCH_DL_SCH_Message*)serMalloc(_mem, p->v.v[i1].d * sizeof(struct SQN_NR_BCCH_DL_SCH_Message));
		for (size_t i2 = 0; i2 < p->v.v[i1].d; i2++) {
			_serNrSysDecSQN_NR_BCCH_DL_SCH_Message(_buffer, _size, _lidx, _mem, &p->v.v[i1].v[i2]);
		}
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_BcchInfo_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_BcchInfo_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecSQN_NR_BCCH_BCH_Message_MIB_Optional(_buffer, _size, _lidx, &p->MIB);
	_serNrSysDecSQN_NR_BCCH_DL_SCH_Message_SIB1_Optional(_buffer, _size, _lidx, _mem, &p->SIB1);
	_serNrSysDecNR_SI_List_Type_SIs_Optional(_buffer, _size, _lidx, _mem, &p->SIs);
	_serNrSysDecNR_SegmentedSI_List_Type_SegmentedSIs_Optional(_buffer, _size, _lidx, _mem, &p->SegmentedSIs);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_BcchInfo_Type_BcchInfo_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_BcchInfo_Type_BcchInfo_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecNR_BcchInfo_Type(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_BcchConfig_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_BcchConfig_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecNR_BcchToPbchConfig_Type_Pbch_Optional(_buffer, _size, _lidx, &p->Pbch);
	_serNrSysDecNR_BcchToPdschConfig_Type_Pdsch_Optional(_buffer, _size, _lidx, _mem, &p->Pdsch);
	_serNrSysDecNR_BcchInfo_Type_BcchInfo_Optional(_buffer, _size, _lidx, _mem, &p->BcchInfo);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_BcchConfig_Type_BcchConfig_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_BcchConfig_Type_BcchConfig_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecNR_BcchConfig_Type(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_SearchSpaceDlDciAssignment_Type_NR_PcchConfig_Type_SearchSpaceAndDci_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_SearchSpaceDlDciAssignment_Type_NR_PcchConfig_Type_SearchSpaceAndDci_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecNR_SearchSpaceDlDciAssignment_Type(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_PcchConfig_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_PcchConfig_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecNR_SearchSpaceDlDciAssignment_Type_NR_PcchConfig_Type_SearchSpaceAndDci_Optional(_buffer, _size, _lidx, _mem, &p->SearchSpaceAndDci);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_PcchConfig_Type_PcchConfig_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_PcchConfig_Type_PcchConfig_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecNR_PcchConfig_Type(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_SearchSpaceDlDciAssignment_Type_NR_RandomAccessResponseConfig_Type_SearchSpaceAndDci_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_SearchSpaceDlDciAssignment_Type_NR_RandomAccessResponseConfig_Type_SearchSpaceAndDci_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecNR_SearchSpaceDlDciAssignment_Type(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecRAR_RapIdCtrl_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union RAR_RapIdCtrl_Type_Value* p, enum RAR_RapIdCtrl_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == RAR_RapIdCtrl_Type_Automatic) {
		NTOH_8(p->Automatic, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == RAR_RapIdCtrl_Type_Unmatched) {
		NTOH_8(p->Unmatched, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecRAR_RapIdCtrl_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct RAR_RapIdCtrl_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum RAR_RapIdCtrl_Type_Sel)_tmp;
	}
	_serNrSysDecRAR_RapIdCtrl_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_RAR_RapIdOnly_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_RAR_RapIdOnly_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecRAR_RapIdCtrl_Type(_buffer, _size, _lidx, &p->RapId);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_RAR_UplinkGrant_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_RAR_UplinkGrant_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	for (size_t i3 = 0; i3 < 1; i3++) {
		NTOH_8(p->HoppingFlag[i3], &_buffer[*_lidx], _lidx);
	}
	for (size_t i3 = 0; i3 < 14; i3++) {
		NTOH_8(p->Msg3FrequencyResourceAllocation[i3], &_buffer[*_lidx], _lidx);
	}
	for (size_t i3 = 0; i3 < 4; i3++) {
		NTOH_8(p->Msg3TimeResourceAllocation[i3], &_buffer[*_lidx], _lidx);
	}
	for (size_t i3 = 0; i3 < 4; i3++) {
		NTOH_8(p->MCS[i3], &_buffer[*_lidx], _lidx);
	}
	for (size_t i3 = 0; i3 < 3; i3++) {
		NTOH_8(p->TPC_Command[i3], &_buffer[*_lidx], _lidx);
	}
	for (size_t i3 = 0; i3 < 1; i3++) {
		NTOH_8(p->CQI_Req[i3], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_TempC_RNTI_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union NR_TempC_RNTI_Type_Value* p, enum NR_TempC_RNTI_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_TempC_RNTI_Type_SameAsC_RNTI) {
		NTOH_8(p->SameAsC_RNTI, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == NR_TempC_RNTI_Type_Explicit) {
		NTOH_16(p->Explicit, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecNR_TempC_RNTI_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_TempC_RNTI_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum NR_TempC_RNTI_Type_Sel)_tmp;
	}
	_serNrSysDecNR_TempC_RNTI_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_RAR_Payload_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_RAR_Payload_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_16(p->TimingAdvance, &_buffer[*_lidx], _lidx);
	_serNrSysDecNR_RAR_UplinkGrant_Type(_buffer, _size, _lidx, &p->UplinkGrant);
	_serNrSysDecNR_TempC_RNTI_Type(_buffer, _size, _lidx, &p->TempC_RNTI);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_RAR_RapIdAndPayload_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_RAR_RapIdAndPayload_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecRAR_RapIdCtrl_Type(_buffer, _size, _lidx, &p->RapId);
	_serNrSysDecNR_RAR_Payload_Type(_buffer, _size, _lidx, &p->Payload);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_RAR_SubPdu_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union NR_RAR_SubPdu_Type_Value* p, enum NR_RAR_SubPdu_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_RAR_SubPdu_Type_BackoffIndicator) {
		NTOH_8(p->BackoffIndicator, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == NR_RAR_SubPdu_Type_RapIdOnly) {
		_serNrSysDecNR_RAR_RapIdOnly_Type(_buffer, _size, _lidx, &p->RapIdOnly);
		return SIDL_STATUS_OK;
	}
	if (d == NR_RAR_SubPdu_Type_RapIdAndPayload) {
		_serNrSysDecNR_RAR_RapIdAndPayload_Type(_buffer, _size, _lidx, &p->RapIdAndPayload);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecNR_RAR_SubPdu_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_RAR_SubPdu_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum NR_RAR_SubPdu_Type_Sel)_tmp;
	}
	_serNrSysDecNR_RAR_SubPdu_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_RAR_SubPduList_Type_SubPduList_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_RAR_SubPduList_Type_SubPduList_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = (struct NR_RAR_SubPdu_Type*)serMalloc(_mem, p->v.d * sizeof(struct NR_RAR_SubPdu_Type));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serNrSysDecNR_RAR_SubPdu_Type(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecBool_NR_RAR_MacPdu_Type_CrcError_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct bool_NR_RAR_MacPdu_Type_CrcError_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_RAR_MacPdu_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_RAR_MacPdu_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecNR_RAR_SubPduList_Type_SubPduList_Optional(_buffer, _size, _lidx, _mem, &p->SubPduList);
	_serNrSysDecBool_NR_RAR_MacPdu_Type_CrcError_Optional(_buffer, _size, _lidx, &p->CrcError);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_RAR_MacPdu_Type_MacPdu_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_RAR_MacPdu_Type_MacPdu_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecNR_RAR_MacPdu_Type(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_RandomAccessResponseConfig_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_RandomAccessResponseConfig_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecNR_SearchSpaceDlDciAssignment_Type_NR_RandomAccessResponseConfig_Type_SearchSpaceAndDci_Optional(_buffer, _size, _lidx, _mem, &p->SearchSpaceAndDci);
	_serNrSysDecNR_RAR_MacPdu_Type_MacPdu_Optional(_buffer, _size, _lidx, _mem, &p->MacPdu);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_RandomAccessResponseConfig_Type_RandomAccessResponse_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_RandomAccessResponseConfig_Type_RandomAccessResponse_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecNR_RandomAccessResponseConfig_Type(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_AssignedBWPs_Type_NR_SearchSpaceUlDciAssignment_Type_AssignedBWPs_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_AssignedBWPs_Type_NR_SearchSpaceUlDciAssignment_Type_AssignedBWPs_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecNR_AssignedBWPs_Type(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_SearchSpaceType_Type_NR_SearchSpaceUlDciAssignment_Type_SearchSpaceType_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_SearchSpaceType_Type_NR_SearchSpaceUlDciAssignment_Type_SearchSpaceType_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (NR_SearchSpaceType_Type)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_ResourceAllocationType_Type_NR_DciFormat_0_X_ResourceAssignment_Type_ResourceAllocationType_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_ResourceAllocationType_Type_NR_DciFormat_0_X_ResourceAssignment_Type_ResourceAllocationType_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (NR_ResourceAllocationType_Type)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_FreqDomainSchedulExplicit_Type_FreqDomain_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_FreqDomainSchedulExplicit_Type_FreqDomain_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecNR_FreqDomainSchedulExplicit_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_DciCommon_TimeDomainResourceAssignment_Type_NR_DciFormat_0_X_ResourceAssignment_Type_TimeDomain_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_DciCommon_TimeDomainResourceAssignment_Type_NR_DciFormat_0_X_ResourceAssignment_Type_TimeDomain_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecNR_DciCommon_TimeDomainResourceAssignment_Type(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_TransportBlockRetransmissionList_Type_TransportBlockScheduling_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_TransportBlockRetransmissionList_Type_TransportBlockScheduling_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = (struct NR_TransportBlockSingleTransmission_Type*)serMalloc(_mem, p->v.d * sizeof(struct NR_TransportBlockSingleTransmission_Type));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		_serNrSysDecNR_TransportBlockSingleTransmission_Type(_buffer, _size, _lidx, &p->v.v[i2]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_HarqProcessConfig_Type_NR_DciFormat_0_X_ResourceAssignment_Type_HarqProcessConfig_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_HarqProcessConfig_Type_NR_DciFormat_0_X_ResourceAssignment_Type_HarqProcessConfig_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecNR_HarqProcessConfig_Type(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_DciFormat_0_X_ResourceAssignment_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_DciFormat_0_X_ResourceAssignment_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecNR_ResourceAllocationType_Type_NR_DciFormat_0_X_ResourceAssignment_Type_ResourceAllocationType_Optional(_buffer, _size, _lidx, &p->ResourceAllocationType);
	_serNrSysDecNR_FreqDomainSchedulExplicit_Type_FreqDomain_Optional(_buffer, _size, _lidx, &p->FreqDomain);
	_serNrSysDecNR_DciCommon_TimeDomainResourceAssignment_Type_NR_DciFormat_0_X_ResourceAssignment_Type_TimeDomain_Optional(_buffer, _size, _lidx, _mem, &p->TimeDomain);
	_serNrSysDecNR_TransportBlockRetransmissionList_Type_TransportBlockScheduling_Optional(_buffer, _size, _lidx, _mem, &p->TransportBlockScheduling);
	_serNrSysDecNR_HarqProcessConfig_Type_NR_DciFormat_0_X_ResourceAssignment_Type_HarqProcessConfig_Optional(_buffer, _size, _lidx, _mem, &p->HarqProcessConfig);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_DciFormat_0_X_ResourceAssignment_Type_ResoureAssignment_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_DciFormat_0_X_ResourceAssignment_Type_ResoureAssignment_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecNR_DciFormat_0_X_ResourceAssignment_Type(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_DciFormat_0_X_PuschHoppingCtrl_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union NR_DciFormat_0_X_PuschHoppingCtrl_Type_Value* p, enum NR_DciFormat_0_X_PuschHoppingCtrl_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_DciFormat_0_X_PuschHoppingCtrl_Type_None) {
		NTOH_8(p->None, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == NR_DciFormat_0_X_PuschHoppingCtrl_Type_Flag) {
		for (size_t i2 = 0; i2 < 1; i2++) {
			NTOH_8(p->Flag[i2], &_buffer[*_lidx], _lidx);
		}
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecNR_DciFormat_0_X_PuschHoppingCtrl_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_DciFormat_0_X_PuschHoppingCtrl_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum NR_DciFormat_0_X_PuschHoppingCtrl_Type_Sel)_tmp;
	}
	_serNrSysDecNR_DciFormat_0_X_PuschHoppingCtrl_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_DciFormat_0_X_PuschHoppingCtrl_Type_PuschHoppingCtrl_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_DciFormat_0_X_PuschHoppingCtrl_Type_PuschHoppingCtrl_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecNR_DciFormat_0_X_PuschHoppingCtrl_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_DciCommon_TpcCommand_Type_TpcCommandPusch_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_DciCommon_TpcCommand_Type_TpcCommandPusch_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecNR_DciCommon_TpcCommand_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_DciCommon_UL_SUL_Indicator_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union NR_DciCommon_UL_SUL_Indicator_Type_Value* p, enum NR_DciCommon_UL_SUL_Indicator_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_DciCommon_UL_SUL_Indicator_Type_None) {
		NTOH_8(p->None, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == NR_DciCommon_UL_SUL_Indicator_Type_Value) {
		for (size_t i2 = 0; i2 < 1; i2++) {
			NTOH_8(p->Value[i2], &_buffer[*_lidx], _lidx);
		}
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecNR_DciCommon_UL_SUL_Indicator_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_DciCommon_UL_SUL_Indicator_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum NR_DciCommon_UL_SUL_Indicator_Type_Sel)_tmp;
	}
	_serNrSysDecNR_DciCommon_UL_SUL_Indicator_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_DciCommon_UL_SUL_Indicator_Type_UL_SUL_Indicator_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_DciCommon_UL_SUL_Indicator_Type_UL_SUL_Indicator_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecNR_DciCommon_UL_SUL_Indicator_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_DciFormat_X_0_ChannelAccessCPext_Type_NR_DciFormat_0_0_SpecificInfo_Type_ChannelAccessCPext_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_DciFormat_X_0_ChannelAccessCPext_Type_NR_DciFormat_0_0_SpecificInfo_Type_ChannelAccessCPext_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecNR_DciFormat_X_0_ChannelAccessCPext_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_DciFormat_0_0_SpecificInfo_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_DciFormat_0_0_SpecificInfo_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecNR_DciFormat_X_0_ChannelAccessCPext_Type_NR_DciFormat_0_0_SpecificInfo_Type_ChannelAccessCPext_Optional(_buffer, _size, _lidx, &p->ChannelAccessCPext);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_DciCommon_CarrierIndicator_Type_NR_DciFormat_0_1_SpecificInfo_Type_CarrierIndicator_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_DciCommon_CarrierIndicator_Type_NR_DciFormat_0_1_SpecificInfo_Type_CarrierIndicator_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecNR_DciCommon_CarrierIndicator_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_DciFormat_0_1_DfiFlag_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union NR_DciFormat_0_1_DfiFlag_Type_Value* p, enum NR_DciFormat_0_1_DfiFlag_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_DciFormat_0_1_DfiFlag_Type_None) {
		NTOH_8(p->None, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == NR_DciFormat_0_1_DfiFlag_Type_Flag) {
		for (size_t i2 = 0; i2 < 1; i2++) {
			NTOH_8(p->Flag[i2], &_buffer[*_lidx], _lidx);
		}
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecNR_DciFormat_0_1_DfiFlag_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_DciFormat_0_1_DfiFlag_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum NR_DciFormat_0_1_DfiFlag_Type_Sel)_tmp;
	}
	_serNrSysDecNR_DciFormat_0_1_DfiFlag_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_DciFormat_0_1_DfiFlag_Type_DfiFlag_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_DciFormat_0_1_DfiFlag_Type_DfiFlag_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecNR_DciFormat_0_1_DfiFlag_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_DciCommon_BWPIndicator_Type_NR_DciFormat_0_1_SpecificInfo_Type_BWPIndicator_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_DciCommon_BWPIndicator_Type_NR_DciFormat_0_1_SpecificInfo_Type_BWPIndicator_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecNR_DciCommon_BWPIndicator_Type(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecDAI_B1_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union DAI_B1_Type_Value* p, enum DAI_B1_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == DAI_B1_Type_Index) {
		for (size_t i2 = 0; i2 < 1; i2++) {
			NTOH_8(p->Index[i2], &_buffer[*_lidx], _lidx);
		}
		return SIDL_STATUS_OK;
	}
	if (d == DAI_B1_Type_Automatic) {
		NTOH_8(p->Automatic, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecDAI_B1_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct DAI_B1_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum DAI_B1_Type_Sel)_tmp;
	}
	_serNrSysDecDAI_B1_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_DciFormat_0_1_FirstDAI_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union NR_DciFormat_0_1_FirstDAI_Type_Value* p, enum NR_DciFormat_0_1_FirstDAI_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_DciFormat_0_1_FirstDAI_Type_SemiStaticCodebook) {
		_serNrSysDecDAI_B1_Type(_buffer, _size, _lidx, &p->SemiStaticCodebook);
		return SIDL_STATUS_OK;
	}
	if (d == NR_DciFormat_0_1_FirstDAI_Type_DynamicCodebook) {
		_serNrSysDecDAI_B2_Type(_buffer, _size, _lidx, &p->DynamicCodebook);
		return SIDL_STATUS_OK;
	}
	if (d == NR_DciFormat_0_1_FirstDAI_Type_EnhancedDynamicCodebook) {
		_serNrSysDecDAI_B4_Type(_buffer, _size, _lidx, &p->EnhancedDynamicCodebook);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecNR_DciFormat_0_1_FirstDAI_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_DciFormat_0_1_FirstDAI_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum NR_DciFormat_0_1_FirstDAI_Type_Sel)_tmp;
	}
	_serNrSysDecNR_DciFormat_0_1_FirstDAI_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_DciFormat_0_1_FirstDAI_Type_FirstDAI_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_DciFormat_0_1_FirstDAI_Type_FirstDAI_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecNR_DciFormat_0_1_FirstDAI_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_DciFormat_0_1_SecondDAI_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union NR_DciFormat_0_1_SecondDAI_Type_Value* p, enum NR_DciFormat_0_1_SecondDAI_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_DciFormat_0_1_SecondDAI_Type_None) {
		NTOH_8(p->None, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == NR_DciFormat_0_1_SecondDAI_Type_DynamicCodebook) {
		_serNrSysDecDAI_B2_Type(_buffer, _size, _lidx, &p->DynamicCodebook);
		return SIDL_STATUS_OK;
	}
	if (d == NR_DciFormat_0_1_SecondDAI_Type_EnhancedDynamicCodebook) {
		_serNrSysDecDAI_B4_Type(_buffer, _size, _lidx, &p->EnhancedDynamicCodebook);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecNR_DciFormat_0_1_SecondDAI_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_DciFormat_0_1_SecondDAI_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum NR_DciFormat_0_1_SecondDAI_Type_Sel)_tmp;
	}
	_serNrSysDecNR_DciFormat_0_1_SecondDAI_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_DciFormat_0_1_SecondDAI_Type_SecondDAI_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_DciFormat_0_1_SecondDAI_Type_SecondDAI_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecNR_DciFormat_0_1_SecondDAI_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_DciFormat_0_1_SrsResourceIndicator_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union NR_DciFormat_0_1_SrsResourceIndicator_Type_Value* p, enum NR_DciFormat_0_1_SrsResourceIndicator_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_DciFormat_0_1_SrsResourceIndicator_Type_NonCodeBook) {
		NTOH_32(p->NonCodeBook.d, &_buffer[*_lidx], _lidx);
		p->NonCodeBook.v = (BIT_STRING_ELEMENT*)serMalloc(_mem, p->NonCodeBook.d * sizeof(BIT_STRING_ELEMENT));
		for (size_t i2 = 0; i2 < p->NonCodeBook.d; i2++) {
			NTOH_8(p->NonCodeBook.v[i2], &_buffer[*_lidx], _lidx);
		}
		return SIDL_STATUS_OK;
	}
	if (d == NR_DciFormat_0_1_SrsResourceIndicator_Type_CodeBook) {
		NTOH_32(p->CodeBook.d, &_buffer[*_lidx], _lidx);
		p->CodeBook.v = (BIT_STRING_ELEMENT*)serMalloc(_mem, p->CodeBook.d * sizeof(BIT_STRING_ELEMENT));
		for (size_t i2 = 0; i2 < p->CodeBook.d; i2++) {
			NTOH_8(p->CodeBook.v[i2], &_buffer[*_lidx], _lidx);
		}
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecNR_DciFormat_0_1_SrsResourceIndicator_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_DciFormat_0_1_SrsResourceIndicator_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum NR_DciFormat_0_1_SrsResourceIndicator_Type_Sel)_tmp;
	}
	_serNrSysDecNR_DciFormat_0_1_SrsResourceIndicator_Type_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_DciFormat_0_1_SrsResourceIndicator_Type_SrsResourceIndicator_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_DciFormat_0_1_SrsResourceIndicator_Type_SrsResourceIndicator_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecNR_DciFormat_0_1_SrsResourceIndicator_Type(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_DciFormat_0_1_PrecodingInfo_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union NR_DciFormat_0_1_PrecodingInfo_Type_Value* p, enum NR_DciFormat_0_1_PrecodingInfo_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_DciFormat_0_1_PrecodingInfo_Type_NonCodeBook) {
		NTOH_8(p->NonCodeBook, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == NR_DciFormat_0_1_PrecodingInfo_Type_CodeBook) {
		NTOH_32(p->CodeBook.d, &_buffer[*_lidx], _lidx);
		p->CodeBook.v = (BIT_STRING_ELEMENT*)serMalloc(_mem, p->CodeBook.d * sizeof(BIT_STRING_ELEMENT));
		for (size_t i2 = 0; i2 < p->CodeBook.d; i2++) {
			NTOH_8(p->CodeBook.v[i2], &_buffer[*_lidx], _lidx);
		}
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecNR_DciFormat_0_1_PrecodingInfo_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_DciFormat_0_1_PrecodingInfo_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum NR_DciFormat_0_1_PrecodingInfo_Type_Sel)_tmp;
	}
	_serNrSysDecNR_DciFormat_0_1_PrecodingInfo_Type_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_DciFormat_0_1_PrecodingInfo_Type_PrecodingInfo_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_DciFormat_0_1_PrecodingInfo_Type_PrecodingInfo_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecNR_DciFormat_0_1_PrecodingInfo_Type(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_DciFormat_0_1_AntennaPorts_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union NR_DciFormat_0_1_AntennaPorts_Type_Value* p, enum NR_DciFormat_0_1_AntennaPorts_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_DciFormat_0_1_AntennaPorts_Type_Index) {
		NTOH_32(p->Index.d, &_buffer[*_lidx], _lidx);
		p->Index.v = (BIT_STRING_ELEMENT*)serMalloc(_mem, p->Index.d * sizeof(BIT_STRING_ELEMENT));
		for (size_t i2 = 0; i2 < p->Index.d; i2++) {
			NTOH_8(p->Index.v[i2], &_buffer[*_lidx], _lidx);
		}
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecNR_DciFormat_0_1_AntennaPorts_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_DciFormat_0_1_AntennaPorts_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum NR_DciFormat_0_1_AntennaPorts_Type_Sel)_tmp;
	}
	_serNrSysDecNR_DciFormat_0_1_AntennaPorts_Type_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_DciFormat_0_1_AntennaPorts_Type_AntennaPorts_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_DciFormat_0_1_AntennaPorts_Type_AntennaPorts_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecNR_DciFormat_0_1_AntennaPorts_Type(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_DciFormat_X_1_SrsRequest_Type_NR_DciFormat_0_1_SpecificInfo_Type_SrsRequest_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_DciFormat_X_1_SrsRequest_Type_NR_DciFormat_0_1_SpecificInfo_Type_SrsRequest_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecNR_DciFormat_X_1_SrsRequest_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_DciFormat_0_1_CsiRequest_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union NR_DciFormat_0_1_CsiRequest_Type_Value* p, enum NR_DciFormat_0_1_CsiRequest_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_DciFormat_0_1_CsiRequest_Type_Index) {
		NTOH_32(p->Index.d, &_buffer[*_lidx], _lidx);
		p->Index.v = (BIT_STRING_ELEMENT*)serMalloc(_mem, p->Index.d * sizeof(BIT_STRING_ELEMENT));
		for (size_t i2 = 0; i2 < p->Index.d; i2++) {
			NTOH_8(p->Index.v[i2], &_buffer[*_lidx], _lidx);
		}
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecNR_DciFormat_0_1_CsiRequest_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_DciFormat_0_1_CsiRequest_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum NR_DciFormat_0_1_CsiRequest_Type_Sel)_tmp;
	}
	_serNrSysDecNR_DciFormat_0_1_CsiRequest_Type_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_DciFormat_0_1_CsiRequest_Type_CsiRequest_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_DciFormat_0_1_CsiRequest_Type_CsiRequest_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecNR_DciFormat_0_1_CsiRequest_Type(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_DciFormat_0_1_CBGTI_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union NR_DciFormat_0_1_CBGTI_Type_Value* p, enum NR_DciFormat_0_1_CBGTI_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_DciFormat_0_1_CBGTI_Type_Index) {
		NTOH_32(p->Index.d, &_buffer[*_lidx], _lidx);
		p->Index.v = (BIT_STRING_ELEMENT*)serMalloc(_mem, p->Index.d * sizeof(BIT_STRING_ELEMENT));
		for (size_t i2 = 0; i2 < p->Index.d; i2++) {
			NTOH_8(p->Index.v[i2], &_buffer[*_lidx], _lidx);
		}
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecNR_DciFormat_0_1_CBGTI_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_DciFormat_0_1_CBGTI_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum NR_DciFormat_0_1_CBGTI_Type_Sel)_tmp;
	}
	_serNrSysDecNR_DciFormat_0_1_CBGTI_Type_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_DciFormat_0_1_CBGTI_Type_CBGTI_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_DciFormat_0_1_CBGTI_Type_CBGTI_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecNR_DciFormat_0_1_CBGTI_Type(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_DciFormat_0_1_PtrsDmrsAssociation_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union NR_DciFormat_0_1_PtrsDmrsAssociation_Type_Value* p, enum NR_DciFormat_0_1_PtrsDmrsAssociation_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_DciFormat_0_1_PtrsDmrsAssociation_Type_None) {
		NTOH_8(p->None, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == NR_DciFormat_0_1_PtrsDmrsAssociation_Type_Value) {
		for (size_t i2 = 0; i2 < 2; i2++) {
			NTOH_8(p->Value[i2], &_buffer[*_lidx], _lidx);
		}
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecNR_DciFormat_0_1_PtrsDmrsAssociation_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_DciFormat_0_1_PtrsDmrsAssociation_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum NR_DciFormat_0_1_PtrsDmrsAssociation_Type_Sel)_tmp;
	}
	_serNrSysDecNR_DciFormat_0_1_PtrsDmrsAssociation_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_DciFormat_0_1_PtrsDmrsAssociation_Type_PtrsDmrsAssociation_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_DciFormat_0_1_PtrsDmrsAssociation_Type_PtrsDmrsAssociation_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecNR_DciFormat_0_1_PtrsDmrsAssociation_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_DciFormat_0_1_BetaOffsetIndicator_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union NR_DciFormat_0_1_BetaOffsetIndicator_Type_Value* p, enum NR_DciFormat_0_1_BetaOffsetIndicator_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_DciFormat_0_1_BetaOffsetIndicator_Type_None) {
		NTOH_8(p->None, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == NR_DciFormat_0_1_BetaOffsetIndicator_Type_Value) {
		for (size_t i2 = 0; i2 < 2; i2++) {
			NTOH_8(p->Value[i2], &_buffer[*_lidx], _lidx);
		}
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecNR_DciFormat_0_1_BetaOffsetIndicator_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_DciFormat_0_1_BetaOffsetIndicator_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum NR_DciFormat_0_1_BetaOffsetIndicator_Type_Sel)_tmp;
	}
	_serNrSysDecNR_DciFormat_0_1_BetaOffsetIndicator_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_DciFormat_0_1_BetaOffsetIndicator_Type_BetaOffsetIndicator_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_DciFormat_0_1_BetaOffsetIndicator_Type_BetaOffsetIndicator_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecNR_DciFormat_0_1_BetaOffsetIndicator_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_DciFormat_X_1_DmrsSequenceInit_Type_NR_DciFormat_0_1_SpecificInfo_Type_DmrsSequenceInit_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_DciFormat_X_1_DmrsSequenceInit_Type_NR_DciFormat_0_1_SpecificInfo_Type_DmrsSequenceInit_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecNR_DciFormat_X_1_DmrsSequenceInit_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_DciFormat_0_1_UlschIndicator_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union NR_DciFormat_0_1_UlschIndicator_Type_Value* p, enum NR_DciFormat_0_1_UlschIndicator_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_DciFormat_0_1_UlschIndicator_Type_None) {
		NTOH_8(p->None, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == NR_DciFormat_0_1_UlschIndicator_Type_Value) {
		for (size_t i2 = 0; i2 < 1; i2++) {
			NTOH_8(p->Value[i2], &_buffer[*_lidx], _lidx);
		}
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecNR_DciFormat_0_1_UlschIndicator_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_DciFormat_0_1_UlschIndicator_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum NR_DciFormat_0_1_UlschIndicator_Type_Sel)_tmp;
	}
	_serNrSysDecNR_DciFormat_0_1_UlschIndicator_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_DciFormat_0_1_UlschIndicator_Type_UlschIndicator_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_DciFormat_0_1_UlschIndicator_Type_UlschIndicator_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecNR_DciFormat_0_1_UlschIndicator_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_DciFormat_0_1_ChannelAccessCPextCAPC_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union NR_DciFormat_0_1_ChannelAccessCPextCAPC_Type_Value* p, enum NR_DciFormat_0_1_ChannelAccessCPextCAPC_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_DciFormat_0_1_ChannelAccessCPextCAPC_Type_None) {
		NTOH_8(p->None, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == NR_DciFormat_0_1_ChannelAccessCPextCAPC_Type_Value) {
		NTOH_32(p->Value.d, &_buffer[*_lidx], _lidx);
		p->Value.v = (BIT_STRING_ELEMENT*)serMalloc(_mem, p->Value.d * sizeof(BIT_STRING_ELEMENT));
		for (size_t i2 = 0; i2 < p->Value.d; i2++) {
			NTOH_8(p->Value.v[i2], &_buffer[*_lidx], _lidx);
		}
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecNR_DciFormat_0_1_ChannelAccessCPextCAPC_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_DciFormat_0_1_ChannelAccessCPextCAPC_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum NR_DciFormat_0_1_ChannelAccessCPextCAPC_Type_Sel)_tmp;
	}
	_serNrSysDecNR_DciFormat_0_1_ChannelAccessCPextCAPC_Type_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_DciFormat_0_1_ChannelAccessCPextCAPC_Type_ChannelAccessCPextCAPC_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_DciFormat_0_1_ChannelAccessCPextCAPC_Type_ChannelAccessCPextCAPC_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecNR_DciFormat_0_1_ChannelAccessCPextCAPC_Type(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_DciFormat_0_1_OpenLoopPowerControl_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union NR_DciFormat_0_1_OpenLoopPowerControl_Type_Value* p, enum NR_DciFormat_0_1_OpenLoopPowerControl_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_DciFormat_0_1_OpenLoopPowerControl_Type_None) {
		NTOH_8(p->None, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == NR_DciFormat_0_1_OpenLoopPowerControl_Type_Value) {
		NTOH_32(p->Value.d, &_buffer[*_lidx], _lidx);
		p->Value.v = (BIT_STRING_ELEMENT*)serMalloc(_mem, p->Value.d * sizeof(BIT_STRING_ELEMENT));
		for (size_t i2 = 0; i2 < p->Value.d; i2++) {
			NTOH_8(p->Value.v[i2], &_buffer[*_lidx], _lidx);
		}
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecNR_DciFormat_0_1_OpenLoopPowerControl_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_DciFormat_0_1_OpenLoopPowerControl_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum NR_DciFormat_0_1_OpenLoopPowerControl_Type_Sel)_tmp;
	}
	_serNrSysDecNR_DciFormat_0_1_OpenLoopPowerControl_Type_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_DciFormat_0_1_OpenLoopPowerControl_Type_OpenLoopPowerControl_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_DciFormat_0_1_OpenLoopPowerControl_Type_OpenLoopPowerControl_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecNR_DciFormat_0_1_OpenLoopPowerControl_Type(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_DciFormat_X_1_PriorityIndicator_Type_NR_DciFormat_0_1_SpecificInfo_Type_PriorityIndicator_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_DciFormat_X_1_PriorityIndicator_Type_NR_DciFormat_0_1_SpecificInfo_Type_PriorityIndicator_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecNR_DciFormat_X_1_PriorityIndicator_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_DciFormat_0_1_InvalidSymbolPatternIndicator_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union NR_DciFormat_0_1_InvalidSymbolPatternIndicator_Type_Value* p, enum NR_DciFormat_0_1_InvalidSymbolPatternIndicator_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_DciFormat_0_1_InvalidSymbolPatternIndicator_Type_None) {
		NTOH_8(p->None, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == NR_DciFormat_0_1_InvalidSymbolPatternIndicator_Type_Value) {
		for (size_t i2 = 0; i2 < 1; i2++) {
			NTOH_8(p->Value[i2], &_buffer[*_lidx], _lidx);
		}
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecNR_DciFormat_0_1_InvalidSymbolPatternIndicator_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_DciFormat_0_1_InvalidSymbolPatternIndicator_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum NR_DciFormat_0_1_InvalidSymbolPatternIndicator_Type_Sel)_tmp;
	}
	_serNrSysDecNR_DciFormat_0_1_InvalidSymbolPatternIndicator_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_DciFormat_0_1_InvalidSymbolPatternIndicator_Type_InvalidSymbolPatternIndicator_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_DciFormat_0_1_InvalidSymbolPatternIndicator_Type_InvalidSymbolPatternIndicator_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecNR_DciFormat_0_1_InvalidSymbolPatternIndicator_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_DciFormat_X_1_MinimumApplicableSchedulingOffset_Type_NR_DciFormat_0_1_SpecificInfo_Type_MinimumApplicableSchedulingOffset_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_DciFormat_X_1_MinimumApplicableSchedulingOffset_Type_NR_DciFormat_0_1_SpecificInfo_Type_MinimumApplicableSchedulingOffset_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecNR_DciFormat_X_1_MinimumApplicableSchedulingOffset_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_DciFormat_X_1_SCellDormancyIndication_Type_NR_DciFormat_0_1_SpecificInfo_Type_SCellDormancyIndication_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_DciFormat_X_1_SCellDormancyIndication_Type_NR_DciFormat_0_1_SpecificInfo_Type_SCellDormancyIndication_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecNR_DciFormat_X_1_SCellDormancyIndication_Type(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_DciFormat_0_1_SidelinkAssignmentIndex_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union NR_DciFormat_0_1_SidelinkAssignmentIndex_Type_Value* p, enum NR_DciFormat_0_1_SidelinkAssignmentIndex_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_DciFormat_0_1_SidelinkAssignmentIndex_Type_None) {
		NTOH_8(p->None, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == NR_DciFormat_0_1_SidelinkAssignmentIndex_Type_Value) {
		NTOH_32(p->Value.d, &_buffer[*_lidx], _lidx);
		p->Value.v = (BIT_STRING_ELEMENT*)serMalloc(_mem, p->Value.d * sizeof(BIT_STRING_ELEMENT));
		for (size_t i2 = 0; i2 < p->Value.d; i2++) {
			NTOH_8(p->Value.v[i2], &_buffer[*_lidx], _lidx);
		}
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecNR_DciFormat_0_1_SidelinkAssignmentIndex_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_DciFormat_0_1_SidelinkAssignmentIndex_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum NR_DciFormat_0_1_SidelinkAssignmentIndex_Type_Sel)_tmp;
	}
	_serNrSysDecNR_DciFormat_0_1_SidelinkAssignmentIndex_Type_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_DciFormat_0_1_SidelinkAssignmentIndex_Type_SidelinkAssignmentIndex_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_DciFormat_0_1_SidelinkAssignmentIndex_Type_SidelinkAssignmentIndex_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecNR_DciFormat_0_1_SidelinkAssignmentIndex_Type(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_DciFormat_0_1_SpecificInfo_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_DciFormat_0_1_SpecificInfo_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecNR_DciCommon_CarrierIndicator_Type_NR_DciFormat_0_1_SpecificInfo_Type_CarrierIndicator_Optional(_buffer, _size, _lidx, &p->CarrierIndicator);
	_serNrSysDecNR_DciFormat_0_1_DfiFlag_Type_DfiFlag_Optional(_buffer, _size, _lidx, &p->DfiFlag);
	_serNrSysDecNR_DciCommon_BWPIndicator_Type_NR_DciFormat_0_1_SpecificInfo_Type_BWPIndicator_Optional(_buffer, _size, _lidx, _mem, &p->BWPIndicator);
	_serNrSysDecNR_DciFormat_0_1_FirstDAI_Type_FirstDAI_Optional(_buffer, _size, _lidx, &p->FirstDAI);
	_serNrSysDecNR_DciFormat_0_1_SecondDAI_Type_SecondDAI_Optional(_buffer, _size, _lidx, &p->SecondDAI);
	_serNrSysDecNR_DciFormat_0_1_SrsResourceIndicator_Type_SrsResourceIndicator_Optional(_buffer, _size, _lidx, _mem, &p->SrsResourceIndicator);
	_serNrSysDecNR_DciFormat_0_1_PrecodingInfo_Type_PrecodingInfo_Optional(_buffer, _size, _lidx, _mem, &p->PrecodingInfo);
	_serNrSysDecNR_DciFormat_0_1_AntennaPorts_Type_AntennaPorts_Optional(_buffer, _size, _lidx, _mem, &p->AntennaPorts);
	_serNrSysDecNR_DciFormat_X_1_SrsRequest_Type_NR_DciFormat_0_1_SpecificInfo_Type_SrsRequest_Optional(_buffer, _size, _lidx, &p->SrsRequest);
	_serNrSysDecNR_DciFormat_0_1_CsiRequest_Type_CsiRequest_Optional(_buffer, _size, _lidx, _mem, &p->CsiRequest);
	_serNrSysDecNR_DciFormat_0_1_CBGTI_Type_CBGTI_Optional(_buffer, _size, _lidx, _mem, &p->CBGTI);
	_serNrSysDecNR_DciFormat_0_1_PtrsDmrsAssociation_Type_PtrsDmrsAssociation_Optional(_buffer, _size, _lidx, &p->PtrsDmrsAssociation);
	_serNrSysDecNR_DciFormat_0_1_BetaOffsetIndicator_Type_BetaOffsetIndicator_Optional(_buffer, _size, _lidx, &p->BetaOffsetIndicator);
	_serNrSysDecNR_DciFormat_X_1_DmrsSequenceInit_Type_NR_DciFormat_0_1_SpecificInfo_Type_DmrsSequenceInit_Optional(_buffer, _size, _lidx, &p->DmrsSequenceInit);
	_serNrSysDecNR_DciFormat_0_1_UlschIndicator_Type_UlschIndicator_Optional(_buffer, _size, _lidx, &p->UlschIndicator);
	_serNrSysDecNR_DciFormat_0_1_ChannelAccessCPextCAPC_Type_ChannelAccessCPextCAPC_Optional(_buffer, _size, _lidx, _mem, &p->ChannelAccessCPextCAPC);
	_serNrSysDecNR_DciFormat_0_1_OpenLoopPowerControl_Type_OpenLoopPowerControl_Optional(_buffer, _size, _lidx, _mem, &p->OpenLoopPowerControl);
	_serNrSysDecNR_DciFormat_X_1_PriorityIndicator_Type_NR_DciFormat_0_1_SpecificInfo_Type_PriorityIndicator_Optional(_buffer, _size, _lidx, &p->PriorityIndicator);
	_serNrSysDecNR_DciFormat_0_1_InvalidSymbolPatternIndicator_Type_InvalidSymbolPatternIndicator_Optional(_buffer, _size, _lidx, &p->InvalidSymbolPatternIndicator);
	_serNrSysDecNR_DciFormat_X_1_MinimumApplicableSchedulingOffset_Type_NR_DciFormat_0_1_SpecificInfo_Type_MinimumApplicableSchedulingOffset_Optional(_buffer, _size, _lidx, &p->MinimumApplicableSchedulingOffset);
	_serNrSysDecNR_DciFormat_X_1_SCellDormancyIndication_Type_NR_DciFormat_0_1_SpecificInfo_Type_SCellDormancyIndication_Optional(_buffer, _size, _lidx, _mem, &p->SCellDormancyIndication);
	_serNrSysDecNR_DciFormat_0_1_SidelinkAssignmentIndex_Type_SidelinkAssignmentIndex_Optional(_buffer, _size, _lidx, _mem, &p->SidelinkAssignmentIndex);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_DciFormat_0_X_SpecificInfo_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union NR_DciFormat_0_X_SpecificInfo_Type_Value* p, enum NR_DciFormat_0_X_SpecificInfo_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_DciFormat_0_X_SpecificInfo_Type_Format_0_0) {
		_serNrSysDecNR_DciFormat_0_0_SpecificInfo_Type(_buffer, _size, _lidx, &p->Format_0_0);
		return SIDL_STATUS_OK;
	}
	if (d == NR_DciFormat_0_X_SpecificInfo_Type_Format_0_1) {
		_serNrSysDecNR_DciFormat_0_1_SpecificInfo_Type(_buffer, _size, _lidx, _mem, &p->Format_0_1);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecNR_DciFormat_0_X_SpecificInfo_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_DciFormat_0_X_SpecificInfo_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum NR_DciFormat_0_X_SpecificInfo_Type_Sel)_tmp;
	}
	_serNrSysDecNR_DciFormat_0_X_SpecificInfo_Type_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_DciFormat_0_X_SpecificInfo_Type_Format_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_DciFormat_0_X_SpecificInfo_Type_Format_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecNR_DciFormat_0_X_SpecificInfo_Type(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_DciUlInfo_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_DciUlInfo_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecNR_DciFormat_0_X_ResourceAssignment_Type_ResoureAssignment_Optional(_buffer, _size, _lidx, _mem, &p->ResoureAssignment);
	_serNrSysDecNR_DciFormat_0_X_PuschHoppingCtrl_Type_PuschHoppingCtrl_Optional(_buffer, _size, _lidx, &p->PuschHoppingCtrl);
	_serNrSysDecNR_DciCommon_TpcCommand_Type_TpcCommandPusch_Optional(_buffer, _size, _lidx, &p->TpcCommandPusch);
	_serNrSysDecNR_DciCommon_UL_SUL_Indicator_Type_UL_SUL_Indicator_Optional(_buffer, _size, _lidx, &p->UL_SUL_Indicator);
	_serNrSysDecNR_DciFormat_0_X_SpecificInfo_Type_Format_Optional(_buffer, _size, _lidx, _mem, &p->Format);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_DciUlInfo_Type_DciInfo_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_DciUlInfo_Type_DciInfo_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecNR_DciUlInfo_Type(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_SearchSpaceUlDciAssignment_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_SearchSpaceUlDciAssignment_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecNR_AssignedBWPs_Type_NR_SearchSpaceUlDciAssignment_Type_AssignedBWPs_Optional(_buffer, _size, _lidx, _mem, &p->AssignedBWPs);
	_serNrSysDecNR_SearchSpaceType_Type_NR_SearchSpaceUlDciAssignment_Type_SearchSpaceType_Optional(_buffer, _size, _lidx, &p->SearchSpaceType);
	_serNrSysDecNR_DciUlInfo_Type_DciInfo_Optional(_buffer, _size, _lidx, _mem, &p->DciInfo);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_SearchSpaceDlDciAssignment_Type_NR_RachProcedureMsg4_Type_SearchSpaceAndDci_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_SearchSpaceDlDciAssignment_Type_NR_RachProcedureMsg4_Type_SearchSpaceAndDci_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecNR_SearchSpaceDlDciAssignment_Type(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_ContentionResolutionId_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union NR_ContentionResolutionId_Type_Value* p, enum NR_ContentionResolutionId_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_ContentionResolutionId_Type_XorMask) {
		for (size_t i2 = 0; i2 < 48; i2++) {
			NTOH_8(p->XorMask[i2], &_buffer[*_lidx], _lidx);
		}
		return SIDL_STATUS_OK;
	}
	if (d == NR_ContentionResolutionId_Type_None) {
		NTOH_8(p->None, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecNR_ContentionResolutionId_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_ContentionResolutionId_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum NR_ContentionResolutionId_Type_Sel)_tmp;
	}
	_serNrSysDecNR_ContentionResolutionId_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_ContentionResolutionId_Type_ContentionResolutionId_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_ContentionResolutionId_Type_ContentionResolutionId_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecNR_ContentionResolutionId_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_RachProcedureMsg4RrcMsg_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union NR_RachProcedureMsg4RrcMsg_Type_Value* p, enum NR_RachProcedureMsg4RrcMsg_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_RachProcedureMsg4RrcMsg_Type_RrcCcchMsg) {
		NTOH_32(p->RrcCcchMsg.d, &_buffer[*_lidx], _lidx);
		p->RrcCcchMsg.v = (OCTET_STRING_ELEMENT*)serMalloc(_mem, p->RrcCcchMsg.d * sizeof(OCTET_STRING_ELEMENT));
		for (size_t i2 = 0; i2 < p->RrcCcchMsg.d; i2++) {
			NTOH_8(p->RrcCcchMsg.v[i2], &_buffer[*_lidx], _lidx);
		}
		return SIDL_STATUS_OK;
	}
	if (d == NR_RachProcedureMsg4RrcMsg_Type_RrcDcchMsg) {
		NTOH_32(p->RrcDcchMsg.d, &_buffer[*_lidx], _lidx);
		p->RrcDcchMsg.v = (OCTET_STRING_ELEMENT*)serMalloc(_mem, p->RrcDcchMsg.d * sizeof(OCTET_STRING_ELEMENT));
		for (size_t i2 = 0; i2 < p->RrcDcchMsg.d; i2++) {
			NTOH_8(p->RrcDcchMsg.v[i2], &_buffer[*_lidx], _lidx);
		}
		return SIDL_STATUS_OK;
	}
	if (d == NR_RachProcedureMsg4RrcMsg_Type_None) {
		NTOH_8(p->None, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecNR_RachProcedureMsg4RrcMsg_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_RachProcedureMsg4RrcMsg_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum NR_RachProcedureMsg4RrcMsg_Type_Sel)_tmp;
	}
	_serNrSysDecNR_RachProcedureMsg4RrcMsg_Type_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_RachProcedureMsg4RrcMsg_Type_RrcPdu_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_RachProcedureMsg4RrcMsg_Type_RrcPdu_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecNR_RachProcedureMsg4RrcMsg_Type(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecBool_NR_RachProcedureMsg4_Type_CrcError_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct bool_NR_RachProcedureMsg4_Type_CrcError_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_RachProcedureMsg4_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_RachProcedureMsg4_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecNR_SearchSpaceDlDciAssignment_Type_NR_RachProcedureMsg4_Type_SearchSpaceAndDci_Optional(_buffer, _size, _lidx, _mem, &p->SearchSpaceAndDci);
	_serNrSysDecNR_ContentionResolutionId_Type_ContentionResolutionId_Optional(_buffer, _size, _lidx, &p->ContentionResolutionId);
	_serNrSysDecNR_RachProcedureMsg4RrcMsg_Type_RrcPdu_Optional(_buffer, _size, _lidx, _mem, &p->RrcPdu);
	_serNrSysDecBool_NR_RachProcedureMsg4_Type_CrcError_Optional(_buffer, _size, _lidx, &p->CrcError);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_ContentionResolutionCtrl_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union NR_ContentionResolutionCtrl_Type_Value* p, enum NR_ContentionResolutionCtrl_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_ContentionResolutionCtrl_Type_None) {
		NTOH_8(p->None, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == NR_ContentionResolutionCtrl_Type_CRNTI_Based) {
		_serNrSysDecNR_SearchSpaceUlDciAssignment_Type(_buffer, _size, _lidx, _mem, &p->CRNTI_Based);
		return SIDL_STATUS_OK;
	}
	if (d == NR_ContentionResolutionCtrl_Type_Msg4_Based) {
		_serNrSysDecNR_RachProcedureMsg4_Type(_buffer, _size, _lidx, _mem, &p->Msg4_Based);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecNR_ContentionResolutionCtrl_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_ContentionResolutionCtrl_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum NR_ContentionResolutionCtrl_Type_Sel)_tmp;
	}
	_serNrSysDecNR_ContentionResolutionCtrl_Type_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_ContentionResolutionCtrl_Type_ContentionResolution_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_ContentionResolutionCtrl_Type_ContentionResolution_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecNR_ContentionResolutionCtrl_Type(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_RachProcedure_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_RachProcedure_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecNR_RandomAccessResponseConfig_Type_RandomAccessResponse_Optional(_buffer, _size, _lidx, _mem, &p->RandomAccessResponse);
	_serNrSysDecNR_ContentionResolutionCtrl_Type_ContentionResolution_Optional(_buffer, _size, _lidx, _mem, &p->ContentionResolution);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_RachProcedureList_Type_RachProcedureList_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_RachProcedureList_Type_RachProcedureList_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = (struct NR_RachProcedure_Type*)serMalloc(_mem, p->v.d * sizeof(struct NR_RachProcedure_Type));
	for (size_t i1 = 0; i1 < p->v.d; i1++) {
		_serNrSysDecNR_RachProcedure_Type(_buffer, _size, _lidx, _mem, &p->v.v[i1]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_RachProcedureConfig_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_RachProcedureConfig_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecNR_RachProcedureList_Type_RachProcedureList_Optional(_buffer, _size, _lidx, _mem, &p->RachProcedureList);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_RachProcedureConfig_Type_RachProcedureConfig_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_RachProcedureConfig_Type_RachProcedureConfig_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecNR_RachProcedureConfig_Type(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_SearchSpaceDlDciAssignment_Type_NR_DcchDtchConfigDL_Type_SearchSpaceAndDci_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_SearchSpaceDlDciAssignment_Type_NR_DcchDtchConfigDL_Type_SearchSpaceAndDci_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecNR_SearchSpaceDlDciAssignment_Type(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_DcchDtchConfigDL_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_DcchDtchConfigDL_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecNR_SearchSpaceDlDciAssignment_Type_NR_DcchDtchConfigDL_Type_SearchSpaceAndDci_Optional(_buffer, _size, _lidx, _mem, &p->SearchSpaceAndDci);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_DcchDtchConfigDL_Type_DL_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_DcchDtchConfigDL_Type_DL_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecNR_DcchDtchConfigDL_Type(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_SearchSpaceUlDciAssignment_Type_SearchSpaceAndDci_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_SearchSpaceUlDciAssignment_Type_SearchSpaceAndDci_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecNR_SearchSpaceUlDciAssignment_Type(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_UplinkTimeAlignment_AutoSynch_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_UplinkTimeAlignment_AutoSynch_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->TimingAdvance, &_buffer[*_lidx], _lidx);
	NTOH_16(p->TA_Period, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_UplinkTimeAlignment_Synch_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union NR_UplinkTimeAlignment_Synch_Type_Value* p, enum NR_UplinkTimeAlignment_Synch_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_UplinkTimeAlignment_Synch_Type_None) {
		NTOH_8(p->None, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == NR_UplinkTimeAlignment_Synch_Type_Auto) {
		_serNrSysDecNR_UplinkTimeAlignment_AutoSynch_Type(_buffer, _size, _lidx, &p->Auto);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecNR_UplinkTimeAlignment_Synch_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_UplinkTimeAlignment_Synch_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum NR_UplinkTimeAlignment_Synch_Type_Sel)_tmp;
	}
	_serNrSysDecNR_UplinkTimeAlignment_Synch_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_UplinkTimeAlignment_Synch_Type_PUCCH_Synch_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_UplinkTimeAlignment_Synch_Type_PUCCH_Synch_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecNR_UplinkTimeAlignment_Synch_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecULGrant_Period_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union ULGrant_Period_Type_Value* p, enum ULGrant_Period_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == ULGrant_Period_Type_OnlyOnce) {
		NTOH_8(p->OnlyOnce, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == ULGrant_Period_Type_Duration) {
		NTOH_32(p->Duration, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecULGrant_Period_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct ULGrant_Period_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum ULGrant_Period_Type_Sel)_tmp;
	}
	_serNrSysDecULGrant_Period_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecTransmissionRepetition_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union TransmissionRepetition_Type_Value* p, enum TransmissionRepetition_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == TransmissionRepetition_Type_Continuous) {
		NTOH_8(p->Continuous, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == TransmissionRepetition_Type_NumOfCycles) {
		NTOH_32(p->NumOfCycles, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecTransmissionRepetition_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct TransmissionRepetition_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum TransmissionRepetition_Type_Sel)_tmp;
	}
	_serNrSysDecTransmissionRepetition_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecPeriodicGrant_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct PeriodicGrant_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecULGrant_Period_Type(_buffer, _size, _lidx, &p->Period);
	_serNrSysDecTransmissionRepetition_Type(_buffer, _size, _lidx, &p->NoOfRepetitions);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecUL_GrantConfig_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union UL_GrantConfig_Type_Value* p, enum UL_GrantConfig_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == UL_GrantConfig_Type_OnSR_Reception) {
		NTOH_8(p->OnSR_Reception, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == UL_GrantConfig_Type_Periodic) {
		_serNrSysDecPeriodicGrant_Type(_buffer, _size, _lidx, &p->Periodic);
		return SIDL_STATUS_OK;
	}
	if (d == UL_GrantConfig_Type_PeriodicOnSR_Reception) {
		_serNrSysDecPeriodicGrant_Type(_buffer, _size, _lidx, &p->PeriodicOnSR_Reception);
		return SIDL_STATUS_OK;
	}
	if (d == UL_GrantConfig_Type_None) {
		NTOH_8(p->None, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecUL_GrantConfig_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct UL_GrantConfig_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum UL_GrantConfig_Type_Sel)_tmp;
	}
	_serNrSysDecUL_GrantConfig_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecUL_GrantConfig_Type_GrantConfig_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct UL_GrantConfig_Type_GrantConfig_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecUL_GrantConfig_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_DcchDtchConfigUL_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_DcchDtchConfigUL_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecNR_SearchSpaceUlDciAssignment_Type_SearchSpaceAndDci_Optional(_buffer, _size, _lidx, _mem, &p->SearchSpaceAndDci);
	_serNrSysDecNR_UplinkTimeAlignment_Synch_Type_PUCCH_Synch_Optional(_buffer, _size, _lidx, &p->PUCCH_Synch);
	_serNrSysDecUL_GrantConfig_Type_GrantConfig_Optional(_buffer, _size, _lidx, &p->GrantConfig);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_DcchDtchConfigUL_Type_UL_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_DcchDtchConfigUL_Type_UL_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecNR_DcchDtchConfigUL_Type(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_DRX_Config_drx_onDurationTimer_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union SQN_NR_DRX_Config_drx_onDurationTimer_Value* p, enum SQN_NR_DRX_Config_drx_onDurationTimer_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_DRX_Config_drx_onDurationTimer_subMilliSeconds) {
		NTOH_8(p->subMilliSeconds, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_DRX_Config_drx_onDurationTimer_milliSeconds) {
		{
			size_t _tmp;
			NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
			p->milliSeconds = (SQN_NR_DRX_Config_drx_onDurationTimer_milliSeconds_e)_tmp;
		}
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecSQN_NR_DRX_Config_drx_onDurationTimer(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_DRX_Config_drx_onDurationTimer* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SQN_NR_DRX_Config_drx_onDurationTimer_Sel)_tmp;
	}
	_serNrSysDecSQN_NR_DRX_Config_drx_onDurationTimer_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_DRX_Config_drx_LongCycleStartOffset_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union SQN_NR_DRX_Config_drx_LongCycleStartOffset_Value* p, enum SQN_NR_DRX_Config_drx_LongCycleStartOffset_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_DRX_Config_drx_LongCycleStartOffset_ms10) {
		NTOH_8(p->ms10, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_DRX_Config_drx_LongCycleStartOffset_ms20) {
		NTOH_8(p->ms20, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_DRX_Config_drx_LongCycleStartOffset_ms32) {
		NTOH_8(p->ms32, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_DRX_Config_drx_LongCycleStartOffset_ms40) {
		NTOH_8(p->ms40, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_DRX_Config_drx_LongCycleStartOffset_ms60) {
		NTOH_8(p->ms60, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_DRX_Config_drx_LongCycleStartOffset_ms64) {
		NTOH_8(p->ms64, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_DRX_Config_drx_LongCycleStartOffset_ms70) {
		NTOH_8(p->ms70, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_DRX_Config_drx_LongCycleStartOffset_ms80) {
		NTOH_8(p->ms80, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_DRX_Config_drx_LongCycleStartOffset_ms128) {
		NTOH_8(p->ms128, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_DRX_Config_drx_LongCycleStartOffset_ms160) {
		NTOH_8(p->ms160, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_DRX_Config_drx_LongCycleStartOffset_ms256) {
		NTOH_8(p->ms256, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_DRX_Config_drx_LongCycleStartOffset_ms320) {
		NTOH_16(p->ms320, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_DRX_Config_drx_LongCycleStartOffset_ms512) {
		NTOH_16(p->ms512, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_DRX_Config_drx_LongCycleStartOffset_ms640) {
		NTOH_16(p->ms640, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_DRX_Config_drx_LongCycleStartOffset_ms1024) {
		NTOH_16(p->ms1024, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_DRX_Config_drx_LongCycleStartOffset_ms1280) {
		NTOH_16(p->ms1280, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_DRX_Config_drx_LongCycleStartOffset_ms2048) {
		NTOH_16(p->ms2048, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_DRX_Config_drx_LongCycleStartOffset_ms2560) {
		NTOH_16(p->ms2560, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_DRX_Config_drx_LongCycleStartOffset_ms5120) {
		NTOH_16(p->ms5120, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_DRX_Config_drx_LongCycleStartOffset_ms10240) {
		NTOH_16(p->ms10240, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecSQN_NR_DRX_Config_drx_LongCycleStartOffset(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_DRX_Config_drx_LongCycleStartOffset* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SQN_NR_DRX_Config_drx_LongCycleStartOffset_Sel)_tmp;
	}
	_serNrSysDecSQN_NR_DRX_Config_drx_LongCycleStartOffset_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_DRX_Config_shortDRX(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_DRX_Config_shortDRX* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->drx_ShortCycle = (SQN_NR_DRX_Config_shortDRX_drx_ShortCycle_e)_tmp;
	}
	NTOH_8(p->drx_ShortCycleTimer, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_DRX_Config_shortDRX_shortDRX_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_DRX_Config_shortDRX_shortDRX_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_DRX_Config_shortDRX(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_DRX_Config(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_DRX_Config* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecSQN_NR_DRX_Config_drx_onDurationTimer(_buffer, _size, _lidx, &p->drx_onDurationTimer);
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->drx_InactivityTimer = (SQN_NR_DRX_Config_drx_InactivityTimer_e)_tmp;
	}
	NTOH_8(p->drx_HARQ_RTT_TimerDL, &_buffer[*_lidx], _lidx);
	NTOH_8(p->drx_HARQ_RTT_TimerUL, &_buffer[*_lidx], _lidx);
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->drx_RetransmissionTimerDL = (SQN_NR_DRX_Config_drx_RetransmissionTimerDL_e)_tmp;
	}
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->drx_RetransmissionTimerUL = (SQN_NR_DRX_Config_drx_RetransmissionTimerUL_e)_tmp;
	}
	_serNrSysDecSQN_NR_DRX_Config_drx_LongCycleStartOffset(_buffer, _size, _lidx, &p->drx_LongCycleStartOffset);
	_serNrSysDecSQN_NR_DRX_Config_shortDRX_shortDRX_Optional(_buffer, _size, _lidx, &p->shortDRX);
	NTOH_8(p->drx_SlotOffset, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_ASN1_DRX_Config_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union NR_ASN1_DRX_Config_Type_Value* p, enum NR_ASN1_DRX_Config_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_ASN1_DRX_Config_Type_R15) {
		_serNrSysDecSQN_NR_DRX_Config(_buffer, _size, _lidx, &p->R15);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecNR_ASN1_DRX_Config_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_ASN1_DRX_Config_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum NR_ASN1_DRX_Config_Type_Sel)_tmp;
	}
	_serNrSysDecNR_ASN1_DRX_Config_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_DrxCtrl_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union NR_DrxCtrl_Type_Value* p, enum NR_DrxCtrl_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_DrxCtrl_Type_None) {
		NTOH_8(p->None, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == NR_DrxCtrl_Type_Config) {
		_serNrSysDecNR_ASN1_DRX_Config_Type(_buffer, _size, _lidx, &p->Config);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecNR_DrxCtrl_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_DrxCtrl_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum NR_DrxCtrl_Type_Sel)_tmp;
	}
	_serNrSysDecNR_DrxCtrl_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_DrxCtrl_Type_DrxCtrl_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_DrxCtrl_Type_DrxCtrl_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecNR_DrxCtrl_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_GapConfig_refServCellIndicator_e_refServCellIndicator_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_GapConfig_refServCellIndicator_e_refServCellIndicator_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_GapConfig_refServCellIndicator_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_ServCellIndex_SQN_NR_GapConfig_refFR2ServCellAsyncCA_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_ServCellIndex_SQN_NR_GapConfig_refFR2ServCellAsyncCA_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_GapConfig_mgl_r16_e_mgl_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_GapConfig_mgl_r16_e_mgl_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_GapConfig_mgl_r16_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_GapConfig(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_GapConfig* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->gapOffset, &_buffer[*_lidx], _lidx);
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->mgl = (SQN_NR_GapConfig_mgl_e)_tmp;
	}
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->mgrp = (SQN_NR_GapConfig_mgrp_e)_tmp;
	}
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->mgta = (SQN_NR_GapConfig_mgta_e)_tmp;
	}
	_serNrSysDecSQN_NR_GapConfig_refServCellIndicator_e_refServCellIndicator_Optional(_buffer, _size, _lidx, &p->refServCellIndicator);
	_serNrSysDecSQN_NR_ServCellIndex_SQN_NR_GapConfig_refFR2ServCellAsyncCA_r16_Optional(_buffer, _size, _lidx, &p->refFR2ServCellAsyncCA_r16);
	_serNrSysDecSQN_NR_GapConfig_mgl_r16_e_mgl_r16_Optional(_buffer, _size, _lidx, &p->mgl_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SetupRelease_MeasGapConfig_gapFR2_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union SQN_NR_SetupRelease_MeasGapConfig_gapFR2_Value* p, enum SQN_NR_SetupRelease_MeasGapConfig_gapFR2_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SetupRelease_MeasGapConfig_gapFR2_release) {
		NTOH_8(p->release, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SetupRelease_MeasGapConfig_gapFR2_setup) {
		_serNrSysDecSQN_NR_GapConfig(_buffer, _size, _lidx, &p->setup);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecSQN_NR_SetupRelease_MeasGapConfig_gapFR2(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SetupRelease_MeasGapConfig_gapFR2* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SQN_NR_SetupRelease_MeasGapConfig_gapFR2_Sel)_tmp;
	}
	_serNrSysDecSQN_NR_SetupRelease_MeasGapConfig_gapFR2_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SetupRelease_MeasGapConfig_gapFR2_SQN_NR_MeasGapConfig_gapFR2_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SetupRelease_MeasGapConfig_gapFR2_SQN_NR_MeasGapConfig_gapFR2_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_SetupRelease_MeasGapConfig_gapFR2(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SetupRelease_MeasGapConfig_gapFR1_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union SQN_NR_SetupRelease_MeasGapConfig_gapFR1_Value* p, enum SQN_NR_SetupRelease_MeasGapConfig_gapFR1_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SetupRelease_MeasGapConfig_gapFR1_release) {
		NTOH_8(p->release, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SetupRelease_MeasGapConfig_gapFR1_setup) {
		_serNrSysDecSQN_NR_GapConfig(_buffer, _size, _lidx, &p->setup);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecSQN_NR_SetupRelease_MeasGapConfig_gapFR1(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SetupRelease_MeasGapConfig_gapFR1* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SQN_NR_SetupRelease_MeasGapConfig_gapFR1_Sel)_tmp;
	}
	_serNrSysDecSQN_NR_SetupRelease_MeasGapConfig_gapFR1_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SetupRelease_MeasGapConfig_gapFR1_SQN_NR_MeasGapConfig_gapFR1_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SetupRelease_MeasGapConfig_gapFR1_SQN_NR_MeasGapConfig_gapFR1_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_SetupRelease_MeasGapConfig_gapFR1(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SetupRelease_MeasGapConfig_gapUE_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union SQN_NR_SetupRelease_MeasGapConfig_gapUE_Value* p, enum SQN_NR_SetupRelease_MeasGapConfig_gapUE_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SetupRelease_MeasGapConfig_gapUE_release) {
		NTOH_8(p->release, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SetupRelease_MeasGapConfig_gapUE_setup) {
		_serNrSysDecSQN_NR_GapConfig(_buffer, _size, _lidx, &p->setup);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecSQN_NR_SetupRelease_MeasGapConfig_gapUE(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SetupRelease_MeasGapConfig_gapUE* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SQN_NR_SetupRelease_MeasGapConfig_gapUE_Sel)_tmp;
	}
	_serNrSysDecSQN_NR_SetupRelease_MeasGapConfig_gapUE_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SetupRelease_MeasGapConfig_gapUE_SQN_NR_MeasGapConfig_gapUE_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SetupRelease_MeasGapConfig_gapUE_SQN_NR_MeasGapConfig_gapUE_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_SetupRelease_MeasGapConfig_gapUE(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_MeasGapConfig(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_MeasGapConfig* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecSQN_NR_SetupRelease_MeasGapConfig_gapFR2_SQN_NR_MeasGapConfig_gapFR2_Optional(_buffer, _size, _lidx, &p->gapFR2);
	_serNrSysDecSQN_NR_SetupRelease_MeasGapConfig_gapFR1_SQN_NR_MeasGapConfig_gapFR1_Optional(_buffer, _size, _lidx, &p->gapFR1);
	_serNrSysDecSQN_NR_SetupRelease_MeasGapConfig_gapUE_SQN_NR_MeasGapConfig_gapUE_Optional(_buffer, _size, _lidx, &p->gapUE);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_ASN1_MeasGapConfig_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union NR_ASN1_MeasGapConfig_Type_Value* p, enum NR_ASN1_MeasGapConfig_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_ASN1_MeasGapConfig_Type_R15) {
		_serNrSysDecSQN_NR_MeasGapConfig(_buffer, _size, _lidx, &p->R15);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecNR_ASN1_MeasGapConfig_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_ASN1_MeasGapConfig_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum NR_ASN1_MeasGapConfig_Type_Sel)_tmp;
	}
	_serNrSysDecNR_ASN1_MeasGapConfig_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_MeasGapCtrl_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union NR_MeasGapCtrl_Type_Value* p, enum NR_MeasGapCtrl_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_MeasGapCtrl_Type_None) {
		NTOH_8(p->None, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == NR_MeasGapCtrl_Type_Config) {
		_serNrSysDecNR_ASN1_MeasGapConfig_Type(_buffer, _size, _lidx, &p->Config);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecNR_MeasGapCtrl_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_MeasGapCtrl_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum NR_MeasGapCtrl_Type_Sel)_tmp;
	}
	_serNrSysDecNR_MeasGapCtrl_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_MeasGapCtrl_Type_MeasGapCtrl_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_MeasGapCtrl_Type_MeasGapCtrl_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecNR_MeasGapCtrl_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_DcchDtchConfig_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_DcchDtchConfig_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecNR_DcchDtchConfigDL_Type_DL_Optional(_buffer, _size, _lidx, _mem, &p->DL);
	_serNrSysDecNR_DcchDtchConfigUL_Type_UL_Optional(_buffer, _size, _lidx, _mem, &p->UL);
	_serNrSysDecNR_DrxCtrl_Type_DrxCtrl_Optional(_buffer, _size, _lidx, &p->DrxCtrl);
	_serNrSysDecNR_MeasGapCtrl_Type_MeasGapCtrl_Optional(_buffer, _size, _lidx, &p->MeasGapCtrl);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_DcchDtchConfig_Type_DcchDtchConfig_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_DcchDtchConfig_Type_DcchDtchConfig_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecNR_DcchDtchConfig_Type(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_ServingCellIndex_Type_NR_SpCellConfig_Type_ServingCellIndex_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_ServingCellIndex_Type_NR_SpCellConfig_Type_ServingCellIndex_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_CellGroupId_CellGroupId_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_CellGroupId_CellGroupId_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_CellIdList_Type_SCellList_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_CellIdList_Type_SCellList_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = (NR_CellId_Type*)serMalloc(_mem, p->v.d * sizeof(NR_CellId_Type));
	for (size_t i1 = 0; i1 < p->v.d; i1++) {
		{
			size_t _tmp;
			NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
			p->v.v[i1] = (NR_CellId_Type)_tmp;
		}
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SetupRelease_MAC_CellGroupConfig_drx_Config_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union SQN_NR_SetupRelease_MAC_CellGroupConfig_drx_Config_Value* p, enum SQN_NR_SetupRelease_MAC_CellGroupConfig_drx_Config_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SetupRelease_MAC_CellGroupConfig_drx_Config_release) {
		NTOH_8(p->release, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SetupRelease_MAC_CellGroupConfig_drx_Config_setup) {
		_serNrSysDecSQN_NR_DRX_Config(_buffer, _size, _lidx, &p->setup);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecSQN_NR_SetupRelease_MAC_CellGroupConfig_drx_Config(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SetupRelease_MAC_CellGroupConfig_drx_Config* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SQN_NR_SetupRelease_MAC_CellGroupConfig_drx_Config_Sel)_tmp;
	}
	_serNrSysDecSQN_NR_SetupRelease_MAC_CellGroupConfig_drx_Config_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SetupRelease_MAC_CellGroupConfig_drx_Config_SQN_NR_MAC_CellGroupConfig_drx_Config_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SetupRelease_MAC_CellGroupConfig_drx_Config_SQN_NR_MAC_CellGroupConfig_drx_Config_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_SetupRelease_MAC_CellGroupConfig_drx_Config(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SchedulingRequestToAddMod_sr_ProhibitTimer_e_sr_ProhibitTimer_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SchedulingRequestToAddMod_sr_ProhibitTimer_e_sr_ProhibitTimer_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_SchedulingRequestToAddMod_sr_ProhibitTimer_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SchedulingRequestToAddMod(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SchedulingRequestToAddMod* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->schedulingRequestId, &_buffer[*_lidx], _lidx);
	_serNrSysDecSQN_NR_SchedulingRequestToAddMod_sr_ProhibitTimer_e_sr_ProhibitTimer_Optional(_buffer, _size, _lidx, &p->sr_ProhibitTimer);
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->sr_TransMax = (SQN_NR_SchedulingRequestToAddMod_sr_TransMax_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SchedulingRequestToAddMod_SQN_NR_SchedulingRequestConfig_schedulingRequestToAddModList_DynamicOptional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_SchedulingRequestToAddMod_SQN_NR_SchedulingRequestConfig_schedulingRequestToAddModList_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = (struct SQN_NR_SchedulingRequestToAddMod*)serMalloc(_mem, p->v.d * sizeof(struct SQN_NR_SchedulingRequestToAddMod));
	for (size_t i1 = 0; i1 < p->v.d; i1++) {
		_serNrSysDecSQN_NR_SchedulingRequestToAddMod(_buffer, _size, _lidx, &p->v.v[i1]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SchedulingRequestId_SQN_NR_SchedulingRequestConfig_schedulingRequestToReleaseList_DynamicOptional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_SchedulingRequestId_SQN_NR_SchedulingRequestConfig_schedulingRequestToReleaseList_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = (SQN_NR_SchedulingRequestId*)serMalloc(_mem, p->v.d * sizeof(SQN_NR_SchedulingRequestId));
	for (size_t i1 = 0; i1 < p->v.d; i1++) {
		NTOH_8(p->v.v[i1], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SchedulingRequestConfig(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_SchedulingRequestConfig* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecSQN_NR_SchedulingRequestToAddMod_SQN_NR_SchedulingRequestConfig_schedulingRequestToAddModList_DynamicOptional(_buffer, _size, _lidx, _mem, &p->schedulingRequestToAddModList);
	_serNrSysDecSQN_NR_SchedulingRequestId_SQN_NR_SchedulingRequestConfig_schedulingRequestToReleaseList_DynamicOptional(_buffer, _size, _lidx, _mem, &p->schedulingRequestToReleaseList);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SchedulingRequestConfig_SQN_NR_MAC_CellGroupConfig_schedulingRequestConfig_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_SchedulingRequestConfig_SQN_NR_MAC_CellGroupConfig_schedulingRequestConfig_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_SchedulingRequestConfig(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_BSR_Config_logicalChannelSR_DelayTimer_e_logicalChannelSR_DelayTimer_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_BSR_Config_logicalChannelSR_DelayTimer_e_logicalChannelSR_DelayTimer_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_BSR_Config_logicalChannelSR_DelayTimer_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_BSR_Config(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_BSR_Config* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->periodicBSR_Timer = (SQN_NR_BSR_Config_periodicBSR_Timer_e)_tmp;
	}
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->retxBSR_Timer = (SQN_NR_BSR_Config_retxBSR_Timer_e)_tmp;
	}
	_serNrSysDecSQN_NR_BSR_Config_logicalChannelSR_DelayTimer_e_logicalChannelSR_DelayTimer_Optional(_buffer, _size, _lidx, &p->logicalChannelSR_DelayTimer);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_BSR_Config_SQN_NR_MAC_CellGroupConfig_bsr_Config_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_BSR_Config_SQN_NR_MAC_CellGroupConfig_bsr_Config_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_BSR_Config(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_TAG_Id_SQN_NR_TAG_Config_tag_ToReleaseList_DynamicOptional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_TAG_Id_SQN_NR_TAG_Config_tag_ToReleaseList_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = (SQN_NR_TAG_Id*)serMalloc(_mem, p->v.d * sizeof(SQN_NR_TAG_Id));
	for (size_t i1 = 0; i1 < p->v.d; i1++) {
		NTOH_8(p->v.v[i1], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_TAG(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_TAG* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->tag_Id, &_buffer[*_lidx], _lidx);
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->timeAlignmentTimer = (SQN_NR_TimeAlignmentTimer_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_TAG_SQN_NR_TAG_Config_tag_ToAddModList_DynamicOptional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_TAG_SQN_NR_TAG_Config_tag_ToAddModList_DynamicOptional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = (struct SQN_NR_TAG*)serMalloc(_mem, p->v.d * sizeof(struct SQN_NR_TAG));
	for (size_t i1 = 0; i1 < p->v.d; i1++) {
		_serNrSysDecSQN_NR_TAG(_buffer, _size, _lidx, &p->v.v[i1]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_TAG_Config(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_TAG_Config* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecSQN_NR_TAG_Id_SQN_NR_TAG_Config_tag_ToReleaseList_DynamicOptional(_buffer, _size, _lidx, _mem, &p->tag_ToReleaseList);
	_serNrSysDecSQN_NR_TAG_SQN_NR_TAG_Config_tag_ToAddModList_DynamicOptional(_buffer, _size, _lidx, _mem, &p->tag_ToAddModList);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_TAG_Config_SQN_NR_MAC_CellGroupConfig_tag_Config_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_TAG_Config_SQN_NR_MAC_CellGroupConfig_tag_Config_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_TAG_Config(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_MPE_Config_FR2_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_MPE_Config_FR2_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->mpe_ProhibitTimer_r16 = (SQN_NR_MPE_Config_FR2_r16_mpe_ProhibitTimer_r16_e)_tmp;
	}
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->mpe_Threshold_r16 = (SQN_NR_MPE_Config_FR2_r16_mpe_Threshold_r16_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SetupRelease_PHR_Config_mpe_Reporting_FR2_r16_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union SQN_NR_SetupRelease_PHR_Config_mpe_Reporting_FR2_r16_Value* p, enum SQN_NR_SetupRelease_PHR_Config_mpe_Reporting_FR2_r16_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SetupRelease_PHR_Config_mpe_Reporting_FR2_r16_release) {
		NTOH_8(p->release, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SetupRelease_PHR_Config_mpe_Reporting_FR2_r16_setup) {
		_serNrSysDecSQN_NR_MPE_Config_FR2_r16(_buffer, _size, _lidx, &p->setup);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecSQN_NR_SetupRelease_PHR_Config_mpe_Reporting_FR2_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SetupRelease_PHR_Config_mpe_Reporting_FR2_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SQN_NR_SetupRelease_PHR_Config_mpe_Reporting_FR2_r16_Sel)_tmp;
	}
	_serNrSysDecSQN_NR_SetupRelease_PHR_Config_mpe_Reporting_FR2_r16_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SetupRelease_PHR_Config_mpe_Reporting_FR2_r16_SQN_NR_PHR_Config_mpe_Reporting_FR2_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SetupRelease_PHR_Config_mpe_Reporting_FR2_r16_SQN_NR_PHR_Config_mpe_Reporting_FR2_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_SetupRelease_PHR_Config_mpe_Reporting_FR2_r16(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PHR_Config(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_PHR_Config* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->phr_PeriodicTimer = (SQN_NR_PHR_Config_phr_PeriodicTimer_e)_tmp;
	}
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->phr_ProhibitTimer = (SQN_NR_PHR_Config_phr_ProhibitTimer_e)_tmp;
	}
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->phr_Tx_PowerFactorChange = (SQN_NR_PHR_Config_phr_Tx_PowerFactorChange_e)_tmp;
	}
	NTOH_8(p->multiplePHR, &_buffer[*_lidx], _lidx);
	NTOH_8(p->dummy, &_buffer[*_lidx], _lidx);
	NTOH_8(p->phr_Type2OtherCell, &_buffer[*_lidx], _lidx);
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->phr_ModeOtherCG = (SQN_NR_PHR_Config_phr_ModeOtherCG_e)_tmp;
	}
	_serNrSysDecSQN_NR_SetupRelease_PHR_Config_mpe_Reporting_FR2_r16_SQN_NR_PHR_Config_mpe_Reporting_FR2_r16_Optional(_buffer, _size, _lidx, &p->mpe_Reporting_FR2_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SetupRelease_MAC_CellGroupConfig_phr_Config_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union SQN_NR_SetupRelease_MAC_CellGroupConfig_phr_Config_Value* p, enum SQN_NR_SetupRelease_MAC_CellGroupConfig_phr_Config_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SetupRelease_MAC_CellGroupConfig_phr_Config_release) {
		NTOH_8(p->release, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SetupRelease_MAC_CellGroupConfig_phr_Config_setup) {
		_serNrSysDecSQN_NR_PHR_Config(_buffer, _size, _lidx, &p->setup);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecSQN_NR_SetupRelease_MAC_CellGroupConfig_phr_Config(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SetupRelease_MAC_CellGroupConfig_phr_Config* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SQN_NR_SetupRelease_MAC_CellGroupConfig_phr_Config_Sel)_tmp;
	}
	_serNrSysDecSQN_NR_SetupRelease_MAC_CellGroupConfig_phr_Config_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SetupRelease_MAC_CellGroupConfig_phr_Config_SQN_NR_MAC_CellGroupConfig_phr_Config_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SetupRelease_MAC_CellGroupConfig_phr_Config_SQN_NR_MAC_CellGroupConfig_phr_Config_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_SetupRelease_MAC_CellGroupConfig_phr_Config(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecBool_SQN_NR_MAC_CellGroupConfig_csi_Mask_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct bool_SQN_NR_MAC_CellGroupConfig_csi_Mask_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SetupRelease_MAC_CellGroupConfig_dataInactivityTimer_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union SQN_NR_SetupRelease_MAC_CellGroupConfig_dataInactivityTimer_Value* p, enum SQN_NR_SetupRelease_MAC_CellGroupConfig_dataInactivityTimer_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SetupRelease_MAC_CellGroupConfig_dataInactivityTimer_release) {
		NTOH_8(p->release, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SetupRelease_MAC_CellGroupConfig_dataInactivityTimer_setup) {
		{
			size_t _tmp;
			NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
			p->setup = (SQN_NR_DataInactivityTimer_e)_tmp;
		}
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecSQN_NR_SetupRelease_MAC_CellGroupConfig_dataInactivityTimer(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SetupRelease_MAC_CellGroupConfig_dataInactivityTimer* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SQN_NR_SetupRelease_MAC_CellGroupConfig_dataInactivityTimer_Sel)_tmp;
	}
	_serNrSysDecSQN_NR_SetupRelease_MAC_CellGroupConfig_dataInactivityTimer_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SetupRelease_MAC_CellGroupConfig_dataInactivityTimer_SQN_NR_MAC_CellGroupConfig_dataInactivityTimer_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SetupRelease_MAC_CellGroupConfig_dataInactivityTimer_SQN_NR_MAC_CellGroupConfig_dataInactivityTimer_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_SetupRelease_MAC_CellGroupConfig_dataInactivityTimer(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_MAC_CellGroupConfig_usePreBSR_r16_e_usePreBSR_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_MAC_CellGroupConfig_usePreBSR_r16_e_usePreBSR_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_MAC_CellGroupConfig_usePreBSR_r16_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SchedulingRequestId_SQN_NR_MAC_CellGroupConfig_schedulingRequestID_LBT_SCell_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SchedulingRequestId_SQN_NR_MAC_CellGroupConfig_schedulingRequestID_LBT_SCell_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_MAC_CellGroupConfig_lch_BasedPrioritization_r16_e_lch_BasedPrioritization_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_MAC_CellGroupConfig_lch_BasedPrioritization_r16_e_lch_BasedPrioritization_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_MAC_CellGroupConfig_lch_BasedPrioritization_r16_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SchedulingRequestId_SQN_NR_MAC_CellGroupConfig_schedulingRequestID_BFR_SCell_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SchedulingRequestId_SQN_NR_MAC_CellGroupConfig_schedulingRequestID_BFR_SCell_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_DRX_ConfigSecondaryGroup_drx_onDurationTimer_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union SQN_NR_DRX_ConfigSecondaryGroup_drx_onDurationTimer_Value* p, enum SQN_NR_DRX_ConfigSecondaryGroup_drx_onDurationTimer_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_DRX_ConfigSecondaryGroup_drx_onDurationTimer_subMilliSeconds) {
		NTOH_8(p->subMilliSeconds, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_DRX_ConfigSecondaryGroup_drx_onDurationTimer_milliSeconds) {
		{
			size_t _tmp;
			NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
			p->milliSeconds = (SQN_NR_DRX_ConfigSecondaryGroup_drx_onDurationTimer_milliSeconds_e)_tmp;
		}
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecSQN_NR_DRX_ConfigSecondaryGroup_drx_onDurationTimer(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_DRX_ConfigSecondaryGroup_drx_onDurationTimer* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SQN_NR_DRX_ConfigSecondaryGroup_drx_onDurationTimer_Sel)_tmp;
	}
	_serNrSysDecSQN_NR_DRX_ConfigSecondaryGroup_drx_onDurationTimer_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_DRX_ConfigSecondaryGroup(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_DRX_ConfigSecondaryGroup* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecSQN_NR_DRX_ConfigSecondaryGroup_drx_onDurationTimer(_buffer, _size, _lidx, &p->drx_onDurationTimer);
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->drx_InactivityTimer = (SQN_NR_DRX_ConfigSecondaryGroup_drx_InactivityTimer_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SetupRelease_MAC_CellGroupConfig_drx_ConfigSecondaryGroup_r16_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union SQN_NR_SetupRelease_MAC_CellGroupConfig_drx_ConfigSecondaryGroup_r16_Value* p, enum SQN_NR_SetupRelease_MAC_CellGroupConfig_drx_ConfigSecondaryGroup_r16_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SetupRelease_MAC_CellGroupConfig_drx_ConfigSecondaryGroup_r16_release) {
		NTOH_8(p->release, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SetupRelease_MAC_CellGroupConfig_drx_ConfigSecondaryGroup_r16_setup) {
		_serNrSysDecSQN_NR_DRX_ConfigSecondaryGroup(_buffer, _size, _lidx, &p->setup);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecSQN_NR_SetupRelease_MAC_CellGroupConfig_drx_ConfigSecondaryGroup_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SetupRelease_MAC_CellGroupConfig_drx_ConfigSecondaryGroup_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SQN_NR_SetupRelease_MAC_CellGroupConfig_drx_ConfigSecondaryGroup_r16_Sel)_tmp;
	}
	_serNrSysDecSQN_NR_SetupRelease_MAC_CellGroupConfig_drx_ConfigSecondaryGroup_r16_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SetupRelease_MAC_CellGroupConfig_drx_ConfigSecondaryGroup_r16_SQN_NR_MAC_CellGroupConfig_drx_ConfigSecondaryGroup_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SetupRelease_MAC_CellGroupConfig_drx_ConfigSecondaryGroup_r16_SQN_NR_MAC_CellGroupConfig_drx_ConfigSecondaryGroup_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_SetupRelease_MAC_CellGroupConfig_drx_ConfigSecondaryGroup_r16(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_MAC_CellGroupConfig(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_MAC_CellGroupConfig* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecSQN_NR_SetupRelease_MAC_CellGroupConfig_drx_Config_SQN_NR_MAC_CellGroupConfig_drx_Config_Optional(_buffer, _size, _lidx, &p->drx_Config);
	_serNrSysDecSQN_NR_SchedulingRequestConfig_SQN_NR_MAC_CellGroupConfig_schedulingRequestConfig_Optional(_buffer, _size, _lidx, _mem, &p->schedulingRequestConfig);
	_serNrSysDecSQN_NR_BSR_Config_SQN_NR_MAC_CellGroupConfig_bsr_Config_Optional(_buffer, _size, _lidx, &p->bsr_Config);
	_serNrSysDecSQN_NR_TAG_Config_SQN_NR_MAC_CellGroupConfig_tag_Config_Optional(_buffer, _size, _lidx, _mem, &p->tag_Config);
	_serNrSysDecSQN_NR_SetupRelease_MAC_CellGroupConfig_phr_Config_SQN_NR_MAC_CellGroupConfig_phr_Config_Optional(_buffer, _size, _lidx, &p->phr_Config);
	NTOH_8(p->skipUplinkTxDynamic, &_buffer[*_lidx], _lidx);
	_serNrSysDecBool_SQN_NR_MAC_CellGroupConfig_csi_Mask_Optional(_buffer, _size, _lidx, &p->csi_Mask);
	_serNrSysDecSQN_NR_SetupRelease_MAC_CellGroupConfig_dataInactivityTimer_SQN_NR_MAC_CellGroupConfig_dataInactivityTimer_Optional(_buffer, _size, _lidx, &p->dataInactivityTimer);
	_serNrSysDecSQN_NR_MAC_CellGroupConfig_usePreBSR_r16_e_usePreBSR_r16_Optional(_buffer, _size, _lidx, &p->usePreBSR_r16);
	_serNrSysDecSQN_NR_SchedulingRequestId_SQN_NR_MAC_CellGroupConfig_schedulingRequestID_LBT_SCell_r16_Optional(_buffer, _size, _lidx, &p->schedulingRequestID_LBT_SCell_r16);
	_serNrSysDecSQN_NR_MAC_CellGroupConfig_lch_BasedPrioritization_r16_e_lch_BasedPrioritization_r16_Optional(_buffer, _size, _lidx, &p->lch_BasedPrioritization_r16);
	_serNrSysDecSQN_NR_SchedulingRequestId_SQN_NR_MAC_CellGroupConfig_schedulingRequestID_BFR_SCell_r16_Optional(_buffer, _size, _lidx, &p->schedulingRequestID_BFR_SCell_r16);
	_serNrSysDecSQN_NR_SetupRelease_MAC_CellGroupConfig_drx_ConfigSecondaryGroup_r16_SQN_NR_MAC_CellGroupConfig_drx_ConfigSecondaryGroup_r16_Optional(_buffer, _size, _lidx, &p->drx_ConfigSecondaryGroup_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_ASN1_MAC_CellGroupConfig_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union NR_ASN1_MAC_CellGroupConfig_Type_Value* p, enum NR_ASN1_MAC_CellGroupConfig_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_ASN1_MAC_CellGroupConfig_Type_R15) {
		_serNrSysDecSQN_NR_MAC_CellGroupConfig(_buffer, _size, _lidx, _mem, &p->R15);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecNR_ASN1_MAC_CellGroupConfig_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_ASN1_MAC_CellGroupConfig_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum NR_ASN1_MAC_CellGroupConfig_Type_Sel)_tmp;
	}
	_serNrSysDecNR_ASN1_MAC_CellGroupConfig_Type_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_ASN1_MAC_CellGroupConfig_Type_MAC_CellGroupConfig_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_ASN1_MAC_CellGroupConfig_Type_MAC_CellGroupConfig_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecNR_ASN1_MAC_CellGroupConfig_Type(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PhysicalCellGroupConfig_harq_ACK_SpatialBundlingPUCCH_e_harq_ACK_SpatialBundlingPUCCH_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_PhysicalCellGroupConfig_harq_ACK_SpatialBundlingPUCCH_e_harq_ACK_SpatialBundlingPUCCH_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_PhysicalCellGroupConfig_harq_ACK_SpatialBundlingPUCCH_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PhysicalCellGroupConfig_harq_ACK_SpatialBundlingPUSCH_e_harq_ACK_SpatialBundlingPUSCH_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_PhysicalCellGroupConfig_harq_ACK_SpatialBundlingPUSCH_e_harq_ACK_SpatialBundlingPUSCH_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_PhysicalCellGroupConfig_harq_ACK_SpatialBundlingPUSCH_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_P_Max_SQN_NR_PhysicalCellGroupConfig_p_NR_FR1_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_P_Max_SQN_NR_PhysicalCellGroupConfig_p_NR_FR1_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_RNTI_Value_SQN_NR_PhysicalCellGroupConfig_tpc_SRS_RNTI_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_RNTI_Value_SQN_NR_PhysicalCellGroupConfig_tpc_SRS_RNTI_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_16(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_RNTI_Value_SQN_NR_PhysicalCellGroupConfig_tpc_PUCCH_RNTI_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_RNTI_Value_SQN_NR_PhysicalCellGroupConfig_tpc_PUCCH_RNTI_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_16(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_RNTI_Value_SQN_NR_PhysicalCellGroupConfig_tpc_PUSCH_RNTI_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_RNTI_Value_SQN_NR_PhysicalCellGroupConfig_tpc_PUSCH_RNTI_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_16(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_RNTI_Value_SQN_NR_PhysicalCellGroupConfig_sp_CSI_RNTI_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_RNTI_Value_SQN_NR_PhysicalCellGroupConfig_sp_CSI_RNTI_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_16(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SetupRelease_PhysicalCellGroupConfig_cs_RNTI_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union SQN_NR_SetupRelease_PhysicalCellGroupConfig_cs_RNTI_Value* p, enum SQN_NR_SetupRelease_PhysicalCellGroupConfig_cs_RNTI_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SetupRelease_PhysicalCellGroupConfig_cs_RNTI_release) {
		NTOH_8(p->release, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SetupRelease_PhysicalCellGroupConfig_cs_RNTI_setup) {
		NTOH_16(p->setup, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecSQN_NR_SetupRelease_PhysicalCellGroupConfig_cs_RNTI(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SetupRelease_PhysicalCellGroupConfig_cs_RNTI* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SQN_NR_SetupRelease_PhysicalCellGroupConfig_cs_RNTI_Sel)_tmp;
	}
	_serNrSysDecSQN_NR_SetupRelease_PhysicalCellGroupConfig_cs_RNTI_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SetupRelease_PhysicalCellGroupConfig_cs_RNTI_SQN_NR_PhysicalCellGroupConfig_cs_RNTI_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SetupRelease_PhysicalCellGroupConfig_cs_RNTI_SQN_NR_PhysicalCellGroupConfig_cs_RNTI_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_SetupRelease_PhysicalCellGroupConfig_cs_RNTI(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_RNTI_Value_SQN_NR_PhysicalCellGroupConfig_mcs_C_RNTI_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_RNTI_Value_SQN_NR_PhysicalCellGroupConfig_mcs_C_RNTI_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_16(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_P_Max_SQN_NR_PhysicalCellGroupConfig_p_UE_FR1_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_P_Max_SQN_NR_PhysicalCellGroupConfig_p_UE_FR1_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PhysicalCellGroupConfig_xScale_e_xScale_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_PhysicalCellGroupConfig_xScale_e_xScale_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_PhysicalCellGroupConfig_xScale_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SetupRelease_PhysicalCellGroupConfig_pdcch_BlindDetection_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union SQN_NR_SetupRelease_PhysicalCellGroupConfig_pdcch_BlindDetection_Value* p, enum SQN_NR_SetupRelease_PhysicalCellGroupConfig_pdcch_BlindDetection_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SetupRelease_PhysicalCellGroupConfig_pdcch_BlindDetection_release) {
		NTOH_8(p->release, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SetupRelease_PhysicalCellGroupConfig_pdcch_BlindDetection_setup) {
		NTOH_8(p->setup, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecSQN_NR_SetupRelease_PhysicalCellGroupConfig_pdcch_BlindDetection(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SetupRelease_PhysicalCellGroupConfig_pdcch_BlindDetection* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SQN_NR_SetupRelease_PhysicalCellGroupConfig_pdcch_BlindDetection_Sel)_tmp;
	}
	_serNrSysDecSQN_NR_SetupRelease_PhysicalCellGroupConfig_pdcch_BlindDetection_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SetupRelease_PhysicalCellGroupConfig_pdcch_BlindDetection_SQN_NR_PhysicalCellGroupConfig_pdcch_BlindDetection_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SetupRelease_PhysicalCellGroupConfig_pdcch_BlindDetection_SQN_NR_PhysicalCellGroupConfig_pdcch_BlindDetection_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_SetupRelease_PhysicalCellGroupConfig_pdcch_BlindDetection(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_DCP_Config_r16_ps_WakeUp_r16_e_ps_WakeUp_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_DCP_Config_r16_ps_WakeUp_r16_e_ps_WakeUp_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_DCP_Config_r16_ps_WakeUp_r16_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_DCP_Config_r16_ps_TransmitPeriodicL1_RSRP_r16_e_ps_TransmitPeriodicL1_RSRP_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_DCP_Config_r16_ps_TransmitPeriodicL1_RSRP_r16_e_ps_TransmitPeriodicL1_RSRP_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_DCP_Config_r16_ps_TransmitPeriodicL1_RSRP_r16_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_DCP_Config_r16_ps_TransmitOtherPeriodicCSI_r16_e_ps_TransmitOtherPeriodicCSI_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_DCP_Config_r16_ps_TransmitOtherPeriodicCSI_r16_e_ps_TransmitOtherPeriodicCSI_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_DCP_Config_r16_ps_TransmitOtherPeriodicCSI_r16_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_DCP_Config_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_DCP_Config_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_16(p->ps_RNTI_r16, &_buffer[*_lidx], _lidx);
	NTOH_8(p->ps_Offset_r16, &_buffer[*_lidx], _lidx);
	NTOH_8(p->sizeDCI_2_6_r16, &_buffer[*_lidx], _lidx);
	NTOH_8(p->ps_PositionDCI_2_6_r16, &_buffer[*_lidx], _lidx);
	_serNrSysDecSQN_NR_DCP_Config_r16_ps_WakeUp_r16_e_ps_WakeUp_r16_Optional(_buffer, _size, _lidx, &p->ps_WakeUp_r16);
	_serNrSysDecSQN_NR_DCP_Config_r16_ps_TransmitPeriodicL1_RSRP_r16_e_ps_TransmitPeriodicL1_RSRP_r16_Optional(_buffer, _size, _lidx, &p->ps_TransmitPeriodicL1_RSRP_r16);
	_serNrSysDecSQN_NR_DCP_Config_r16_ps_TransmitOtherPeriodicCSI_r16_e_ps_TransmitOtherPeriodicCSI_r16_Optional(_buffer, _size, _lidx, &p->ps_TransmitOtherPeriodicCSI_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SetupRelease_PhysicalCellGroupConfig_dcp_Config_r16_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union SQN_NR_SetupRelease_PhysicalCellGroupConfig_dcp_Config_r16_Value* p, enum SQN_NR_SetupRelease_PhysicalCellGroupConfig_dcp_Config_r16_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SetupRelease_PhysicalCellGroupConfig_dcp_Config_r16_release) {
		NTOH_8(p->release, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SetupRelease_PhysicalCellGroupConfig_dcp_Config_r16_setup) {
		_serNrSysDecSQN_NR_DCP_Config_r16(_buffer, _size, _lidx, &p->setup);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecSQN_NR_SetupRelease_PhysicalCellGroupConfig_dcp_Config_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SetupRelease_PhysicalCellGroupConfig_dcp_Config_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SQN_NR_SetupRelease_PhysicalCellGroupConfig_dcp_Config_r16_Sel)_tmp;
	}
	_serNrSysDecSQN_NR_SetupRelease_PhysicalCellGroupConfig_dcp_Config_r16_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SetupRelease_PhysicalCellGroupConfig_dcp_Config_r16_SQN_NR_PhysicalCellGroupConfig_dcp_Config_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SetupRelease_PhysicalCellGroupConfig_dcp_Config_r16_SQN_NR_PhysicalCellGroupConfig_dcp_Config_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_SetupRelease_PhysicalCellGroupConfig_dcp_Config_r16(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PhysicalCellGroupConfig_harq_ACK_SpatialBundlingPUCCH_secondaryPUCCHgroup_r16_e_harq_ACK_SpatialBundlingPUCCH_secondaryPUCCHgroup_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_PhysicalCellGroupConfig_harq_ACK_SpatialBundlingPUCCH_secondaryPUCCHgroup_r16_e_harq_ACK_SpatialBundlingPUCCH_secondaryPUCCHgroup_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_PhysicalCellGroupConfig_harq_ACK_SpatialBundlingPUCCH_secondaryPUCCHgroup_r16_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PhysicalCellGroupConfig_harq_ACK_SpatialBundlingPUSCH_secondaryPUCCHgroup_r16_e_harq_ACK_SpatialBundlingPUSCH_secondaryPUCCHgroup_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_PhysicalCellGroupConfig_harq_ACK_SpatialBundlingPUSCH_secondaryPUCCHgroup_r16_e_harq_ACK_SpatialBundlingPUSCH_secondaryPUCCHgroup_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_PhysicalCellGroupConfig_harq_ACK_SpatialBundlingPUSCH_secondaryPUCCHgroup_r16_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PhysicalCellGroupConfig_pdsch_HARQ_ACK_Codebook_secondaryPUCCHgroup_r16_e_pdsch_HARQ_ACK_Codebook_secondaryPUCCHgroup_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_PhysicalCellGroupConfig_pdsch_HARQ_ACK_Codebook_secondaryPUCCHgroup_r16_e_pdsch_HARQ_ACK_Codebook_secondaryPUCCHgroup_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_PhysicalCellGroupConfig_pdsch_HARQ_ACK_Codebook_secondaryPUCCHgroup_r16_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_P_Max_SQN_NR_PhysicalCellGroupConfig_p_NR_FR2_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_P_Max_SQN_NR_PhysicalCellGroupConfig_p_NR_FR2_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_P_Max_SQN_NR_PhysicalCellGroupConfig_p_UE_FR2_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_P_Max_SQN_NR_PhysicalCellGroupConfig_p_UE_FR2_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PhysicalCellGroupConfig_nrdc_PCmode_FR1_r16_e_nrdc_PCmode_FR1_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_PhysicalCellGroupConfig_nrdc_PCmode_FR1_r16_e_nrdc_PCmode_FR1_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_PhysicalCellGroupConfig_nrdc_PCmode_FR1_r16_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PhysicalCellGroupConfig_nrdc_PCmode_FR2_r16_e_nrdc_PCmode_FR2_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_PhysicalCellGroupConfig_nrdc_PCmode_FR2_r16_e_nrdc_PCmode_FR2_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_PhysicalCellGroupConfig_nrdc_PCmode_FR2_r16_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PhysicalCellGroupConfig_pdsch_HARQ_ACK_Codebook_r16_e_pdsch_HARQ_ACK_Codebook_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_PhysicalCellGroupConfig_pdsch_HARQ_ACK_Codebook_r16_e_pdsch_HARQ_ACK_Codebook_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_PhysicalCellGroupConfig_pdsch_HARQ_ACK_Codebook_r16_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PhysicalCellGroupConfig_nfi_TotalDAI_Included_r16_e_nfi_TotalDAI_Included_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_PhysicalCellGroupConfig_nfi_TotalDAI_Included_r16_e_nfi_TotalDAI_Included_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_PhysicalCellGroupConfig_nfi_TotalDAI_Included_r16_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PhysicalCellGroupConfig_ul_TotalDAI_Included_r16_e_ul_TotalDAI_Included_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_PhysicalCellGroupConfig_ul_TotalDAI_Included_r16_e_ul_TotalDAI_Included_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_PhysicalCellGroupConfig_ul_TotalDAI_Included_r16_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PhysicalCellGroupConfig_pdsch_HARQ_ACK_OneShotFeedback_r16_e_pdsch_HARQ_ACK_OneShotFeedback_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_PhysicalCellGroupConfig_pdsch_HARQ_ACK_OneShotFeedback_r16_e_pdsch_HARQ_ACK_OneShotFeedback_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_PhysicalCellGroupConfig_pdsch_HARQ_ACK_OneShotFeedback_r16_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PhysicalCellGroupConfig_pdsch_HARQ_ACK_OneShotFeedbackNDI_r16_e_pdsch_HARQ_ACK_OneShotFeedbackNDI_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_PhysicalCellGroupConfig_pdsch_HARQ_ACK_OneShotFeedbackNDI_r16_e_pdsch_HARQ_ACK_OneShotFeedbackNDI_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_PhysicalCellGroupConfig_pdsch_HARQ_ACK_OneShotFeedbackNDI_r16_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PhysicalCellGroupConfig_pdsch_HARQ_ACK_OneShotFeedbackCBG_r16_e_pdsch_HARQ_ACK_OneShotFeedbackCBG_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_PhysicalCellGroupConfig_pdsch_HARQ_ACK_OneShotFeedbackCBG_r16_e_pdsch_HARQ_ACK_OneShotFeedbackCBG_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_PhysicalCellGroupConfig_pdsch_HARQ_ACK_OneShotFeedbackCBG_r16_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PhysicalCellGroupConfig_downlinkAssignmentIndexDCI_0_2_r16_e_downlinkAssignmentIndexDCI_0_2_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_PhysicalCellGroupConfig_downlinkAssignmentIndexDCI_0_2_r16_e_downlinkAssignmentIndexDCI_0_2_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_PhysicalCellGroupConfig_downlinkAssignmentIndexDCI_0_2_r16_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PhysicalCellGroupConfig_downlinkAssignmentIndexDCI_1_2_r16_e_downlinkAssignmentIndexDCI_1_2_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_PhysicalCellGroupConfig_downlinkAssignmentIndexDCI_1_2_r16_e_downlinkAssignmentIndexDCI_1_2_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_PhysicalCellGroupConfig_downlinkAssignmentIndexDCI_1_2_r16_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SetupRelease_PhysicalCellGroupConfig_pdsch_HARQ_ACK_CodebookList_r16_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union SQN_NR_SetupRelease_PhysicalCellGroupConfig_pdsch_HARQ_ACK_CodebookList_r16_Value* p, enum SQN_NR_SetupRelease_PhysicalCellGroupConfig_pdsch_HARQ_ACK_CodebookList_r16_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SetupRelease_PhysicalCellGroupConfig_pdsch_HARQ_ACK_CodebookList_r16_release) {
		NTOH_8(p->release, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SetupRelease_PhysicalCellGroupConfig_pdsch_HARQ_ACK_CodebookList_r16_setup) {
		NTOH_32(p->setup.d, &_buffer[*_lidx], _lidx);
		p->setup.v = (SQN_NR_PDSCH_HARQ_ACK_CodebookList_r16_e_e*)serMalloc(_mem, p->setup.d * sizeof(SQN_NR_PDSCH_HARQ_ACK_CodebookList_r16_e_e));
		for (size_t i1 = 0; i1 < p->setup.d; i1++) {
			{
				size_t _tmp;
				NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
				p->setup.v[i1] = (SQN_NR_PDSCH_HARQ_ACK_CodebookList_r16_e_e)_tmp;
			}
		}
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecSQN_NR_SetupRelease_PhysicalCellGroupConfig_pdsch_HARQ_ACK_CodebookList_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_SetupRelease_PhysicalCellGroupConfig_pdsch_HARQ_ACK_CodebookList_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SQN_NR_SetupRelease_PhysicalCellGroupConfig_pdsch_HARQ_ACK_CodebookList_r16_Sel)_tmp;
	}
	_serNrSysDecSQN_NR_SetupRelease_PhysicalCellGroupConfig_pdsch_HARQ_ACK_CodebookList_r16_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SetupRelease_PhysicalCellGroupConfig_pdsch_HARQ_ACK_CodebookList_r16_SQN_NR_PhysicalCellGroupConfig_pdsch_HARQ_ACK_CodebookList_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_SetupRelease_PhysicalCellGroupConfig_pdsch_HARQ_ACK_CodebookList_r16_SQN_NR_PhysicalCellGroupConfig_pdsch_HARQ_ACK_CodebookList_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_SetupRelease_PhysicalCellGroupConfig_pdsch_HARQ_ACK_CodebookList_r16(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PhysicalCellGroupConfig_ackNackFeedbackMode_r16_e_ackNackFeedbackMode_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_PhysicalCellGroupConfig_ackNackFeedbackMode_r16_e_ackNackFeedbackMode_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_PhysicalCellGroupConfig_ackNackFeedbackMode_r16_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PDCCH_BlindDetectionCA_CombIndicator_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_PDCCH_BlindDetectionCA_CombIndicator_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->pdcch_BlindDetectionCA1_r16, &_buffer[*_lidx], _lidx);
	NTOH_8(p->pdcch_BlindDetectionCA2_r16, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SetupRelease_PhysicalCellGroupConfig_pdcch_BlindDetectionCA_CombIndicator_r16_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union SQN_NR_SetupRelease_PhysicalCellGroupConfig_pdcch_BlindDetectionCA_CombIndicator_r16_Value* p, enum SQN_NR_SetupRelease_PhysicalCellGroupConfig_pdcch_BlindDetectionCA_CombIndicator_r16_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SetupRelease_PhysicalCellGroupConfig_pdcch_BlindDetectionCA_CombIndicator_r16_release) {
		NTOH_8(p->release, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SetupRelease_PhysicalCellGroupConfig_pdcch_BlindDetectionCA_CombIndicator_r16_setup) {
		_serNrSysDecSQN_NR_PDCCH_BlindDetectionCA_CombIndicator_r16(_buffer, _size, _lidx, &p->setup);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecSQN_NR_SetupRelease_PhysicalCellGroupConfig_pdcch_BlindDetectionCA_CombIndicator_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SetupRelease_PhysicalCellGroupConfig_pdcch_BlindDetectionCA_CombIndicator_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SQN_NR_SetupRelease_PhysicalCellGroupConfig_pdcch_BlindDetectionCA_CombIndicator_r16_Sel)_tmp;
	}
	_serNrSysDecSQN_NR_SetupRelease_PhysicalCellGroupConfig_pdcch_BlindDetectionCA_CombIndicator_r16_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SetupRelease_PhysicalCellGroupConfig_pdcch_BlindDetectionCA_CombIndicator_r16_SQN_NR_PhysicalCellGroupConfig_pdcch_BlindDetectionCA_CombIndicator_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SetupRelease_PhysicalCellGroupConfig_pdcch_BlindDetectionCA_CombIndicator_r16_SQN_NR_PhysicalCellGroupConfig_pdcch_BlindDetectionCA_CombIndicator_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_SetupRelease_PhysicalCellGroupConfig_pdcch_BlindDetectionCA_CombIndicator_r16(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SetupRelease_PhysicalCellGroupConfig_pdcch_BlindDetection2_r16_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union SQN_NR_SetupRelease_PhysicalCellGroupConfig_pdcch_BlindDetection2_r16_Value* p, enum SQN_NR_SetupRelease_PhysicalCellGroupConfig_pdcch_BlindDetection2_r16_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SetupRelease_PhysicalCellGroupConfig_pdcch_BlindDetection2_r16_release) {
		NTOH_8(p->release, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SetupRelease_PhysicalCellGroupConfig_pdcch_BlindDetection2_r16_setup) {
		NTOH_8(p->setup, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecSQN_NR_SetupRelease_PhysicalCellGroupConfig_pdcch_BlindDetection2_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SetupRelease_PhysicalCellGroupConfig_pdcch_BlindDetection2_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SQN_NR_SetupRelease_PhysicalCellGroupConfig_pdcch_BlindDetection2_r16_Sel)_tmp;
	}
	_serNrSysDecSQN_NR_SetupRelease_PhysicalCellGroupConfig_pdcch_BlindDetection2_r16_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SetupRelease_PhysicalCellGroupConfig_pdcch_BlindDetection2_r16_SQN_NR_PhysicalCellGroupConfig_pdcch_BlindDetection2_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SetupRelease_PhysicalCellGroupConfig_pdcch_BlindDetection2_r16_SQN_NR_PhysicalCellGroupConfig_pdcch_BlindDetection2_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_SetupRelease_PhysicalCellGroupConfig_pdcch_BlindDetection2_r16(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SetupRelease_PhysicalCellGroupConfig_pdcch_BlindDetection3_r16_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union SQN_NR_SetupRelease_PhysicalCellGroupConfig_pdcch_BlindDetection3_r16_Value* p, enum SQN_NR_SetupRelease_PhysicalCellGroupConfig_pdcch_BlindDetection3_r16_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_SetupRelease_PhysicalCellGroupConfig_pdcch_BlindDetection3_r16_release) {
		NTOH_8(p->release, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_SetupRelease_PhysicalCellGroupConfig_pdcch_BlindDetection3_r16_setup) {
		NTOH_8(p->setup, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecSQN_NR_SetupRelease_PhysicalCellGroupConfig_pdcch_BlindDetection3_r16(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SetupRelease_PhysicalCellGroupConfig_pdcch_BlindDetection3_r16* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SQN_NR_SetupRelease_PhysicalCellGroupConfig_pdcch_BlindDetection3_r16_Sel)_tmp;
	}
	_serNrSysDecSQN_NR_SetupRelease_PhysicalCellGroupConfig_pdcch_BlindDetection3_r16_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SetupRelease_PhysicalCellGroupConfig_pdcch_BlindDetection3_r16_SQN_NR_PhysicalCellGroupConfig_pdcch_BlindDetection3_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SetupRelease_PhysicalCellGroupConfig_pdcch_BlindDetection3_r16_SQN_NR_PhysicalCellGroupConfig_pdcch_BlindDetection3_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_SetupRelease_PhysicalCellGroupConfig_pdcch_BlindDetection3_r16(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PhysicalCellGroupConfig_bdFactorR_r16_e_bdFactorR_r16_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_PhysicalCellGroupConfig_bdFactorR_r16_e_bdFactorR_r16_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_PhysicalCellGroupConfig_bdFactorR_r16_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PhysicalCellGroupConfig(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_PhysicalCellGroupConfig* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecSQN_NR_PhysicalCellGroupConfig_harq_ACK_SpatialBundlingPUCCH_e_harq_ACK_SpatialBundlingPUCCH_Optional(_buffer, _size, _lidx, &p->harq_ACK_SpatialBundlingPUCCH);
	_serNrSysDecSQN_NR_PhysicalCellGroupConfig_harq_ACK_SpatialBundlingPUSCH_e_harq_ACK_SpatialBundlingPUSCH_Optional(_buffer, _size, _lidx, &p->harq_ACK_SpatialBundlingPUSCH);
	_serNrSysDecSQN_NR_P_Max_SQN_NR_PhysicalCellGroupConfig_p_NR_FR1_Optional(_buffer, _size, _lidx, &p->p_NR_FR1);
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->pdsch_HARQ_ACK_Codebook = (SQN_NR_PhysicalCellGroupConfig_pdsch_HARQ_ACK_Codebook_e)_tmp;
	}
	_serNrSysDecSQN_NR_RNTI_Value_SQN_NR_PhysicalCellGroupConfig_tpc_SRS_RNTI_Optional(_buffer, _size, _lidx, &p->tpc_SRS_RNTI);
	_serNrSysDecSQN_NR_RNTI_Value_SQN_NR_PhysicalCellGroupConfig_tpc_PUCCH_RNTI_Optional(_buffer, _size, _lidx, &p->tpc_PUCCH_RNTI);
	_serNrSysDecSQN_NR_RNTI_Value_SQN_NR_PhysicalCellGroupConfig_tpc_PUSCH_RNTI_Optional(_buffer, _size, _lidx, &p->tpc_PUSCH_RNTI);
	_serNrSysDecSQN_NR_RNTI_Value_SQN_NR_PhysicalCellGroupConfig_sp_CSI_RNTI_Optional(_buffer, _size, _lidx, &p->sp_CSI_RNTI);
	_serNrSysDecSQN_NR_SetupRelease_PhysicalCellGroupConfig_cs_RNTI_SQN_NR_PhysicalCellGroupConfig_cs_RNTI_Optional(_buffer, _size, _lidx, &p->cs_RNTI);
	_serNrSysDecSQN_NR_RNTI_Value_SQN_NR_PhysicalCellGroupConfig_mcs_C_RNTI_Optional(_buffer, _size, _lidx, &p->mcs_C_RNTI);
	_serNrSysDecSQN_NR_P_Max_SQN_NR_PhysicalCellGroupConfig_p_UE_FR1_Optional(_buffer, _size, _lidx, &p->p_UE_FR1);
	_serNrSysDecSQN_NR_PhysicalCellGroupConfig_xScale_e_xScale_Optional(_buffer, _size, _lidx, &p->xScale);
	_serNrSysDecSQN_NR_SetupRelease_PhysicalCellGroupConfig_pdcch_BlindDetection_SQN_NR_PhysicalCellGroupConfig_pdcch_BlindDetection_Optional(_buffer, _size, _lidx, &p->pdcch_BlindDetection);
	_serNrSysDecSQN_NR_SetupRelease_PhysicalCellGroupConfig_dcp_Config_r16_SQN_NR_PhysicalCellGroupConfig_dcp_Config_r16_Optional(_buffer, _size, _lidx, &p->dcp_Config_r16);
	_serNrSysDecSQN_NR_PhysicalCellGroupConfig_harq_ACK_SpatialBundlingPUCCH_secondaryPUCCHgroup_r16_e_harq_ACK_SpatialBundlingPUCCH_secondaryPUCCHgroup_r16_Optional(_buffer, _size, _lidx, &p->harq_ACK_SpatialBundlingPUCCH_secondaryPUCCHgroup_r16);
	_serNrSysDecSQN_NR_PhysicalCellGroupConfig_harq_ACK_SpatialBundlingPUSCH_secondaryPUCCHgroup_r16_e_harq_ACK_SpatialBundlingPUSCH_secondaryPUCCHgroup_r16_Optional(_buffer, _size, _lidx, &p->harq_ACK_SpatialBundlingPUSCH_secondaryPUCCHgroup_r16);
	_serNrSysDecSQN_NR_PhysicalCellGroupConfig_pdsch_HARQ_ACK_Codebook_secondaryPUCCHgroup_r16_e_pdsch_HARQ_ACK_Codebook_secondaryPUCCHgroup_r16_Optional(_buffer, _size, _lidx, &p->pdsch_HARQ_ACK_Codebook_secondaryPUCCHgroup_r16);
	_serNrSysDecSQN_NR_P_Max_SQN_NR_PhysicalCellGroupConfig_p_NR_FR2_r16_Optional(_buffer, _size, _lidx, &p->p_NR_FR2_r16);
	_serNrSysDecSQN_NR_P_Max_SQN_NR_PhysicalCellGroupConfig_p_UE_FR2_r16_Optional(_buffer, _size, _lidx, &p->p_UE_FR2_r16);
	_serNrSysDecSQN_NR_PhysicalCellGroupConfig_nrdc_PCmode_FR1_r16_e_nrdc_PCmode_FR1_r16_Optional(_buffer, _size, _lidx, &p->nrdc_PCmode_FR1_r16);
	_serNrSysDecSQN_NR_PhysicalCellGroupConfig_nrdc_PCmode_FR2_r16_e_nrdc_PCmode_FR2_r16_Optional(_buffer, _size, _lidx, &p->nrdc_PCmode_FR2_r16);
	_serNrSysDecSQN_NR_PhysicalCellGroupConfig_pdsch_HARQ_ACK_Codebook_r16_e_pdsch_HARQ_ACK_Codebook_r16_Optional(_buffer, _size, _lidx, &p->pdsch_HARQ_ACK_Codebook_r16);
	_serNrSysDecSQN_NR_PhysicalCellGroupConfig_nfi_TotalDAI_Included_r16_e_nfi_TotalDAI_Included_r16_Optional(_buffer, _size, _lidx, &p->nfi_TotalDAI_Included_r16);
	_serNrSysDecSQN_NR_PhysicalCellGroupConfig_ul_TotalDAI_Included_r16_e_ul_TotalDAI_Included_r16_Optional(_buffer, _size, _lidx, &p->ul_TotalDAI_Included_r16);
	_serNrSysDecSQN_NR_PhysicalCellGroupConfig_pdsch_HARQ_ACK_OneShotFeedback_r16_e_pdsch_HARQ_ACK_OneShotFeedback_r16_Optional(_buffer, _size, _lidx, &p->pdsch_HARQ_ACK_OneShotFeedback_r16);
	_serNrSysDecSQN_NR_PhysicalCellGroupConfig_pdsch_HARQ_ACK_OneShotFeedbackNDI_r16_e_pdsch_HARQ_ACK_OneShotFeedbackNDI_r16_Optional(_buffer, _size, _lidx, &p->pdsch_HARQ_ACK_OneShotFeedbackNDI_r16);
	_serNrSysDecSQN_NR_PhysicalCellGroupConfig_pdsch_HARQ_ACK_OneShotFeedbackCBG_r16_e_pdsch_HARQ_ACK_OneShotFeedbackCBG_r16_Optional(_buffer, _size, _lidx, &p->pdsch_HARQ_ACK_OneShotFeedbackCBG_r16);
	_serNrSysDecSQN_NR_PhysicalCellGroupConfig_downlinkAssignmentIndexDCI_0_2_r16_e_downlinkAssignmentIndexDCI_0_2_r16_Optional(_buffer, _size, _lidx, &p->downlinkAssignmentIndexDCI_0_2_r16);
	_serNrSysDecSQN_NR_PhysicalCellGroupConfig_downlinkAssignmentIndexDCI_1_2_r16_e_downlinkAssignmentIndexDCI_1_2_r16_Optional(_buffer, _size, _lidx, &p->downlinkAssignmentIndexDCI_1_2_r16);
	_serNrSysDecSQN_NR_SetupRelease_PhysicalCellGroupConfig_pdsch_HARQ_ACK_CodebookList_r16_SQN_NR_PhysicalCellGroupConfig_pdsch_HARQ_ACK_CodebookList_r16_Optional(_buffer, _size, _lidx, _mem, &p->pdsch_HARQ_ACK_CodebookList_r16);
	_serNrSysDecSQN_NR_PhysicalCellGroupConfig_ackNackFeedbackMode_r16_e_ackNackFeedbackMode_r16_Optional(_buffer, _size, _lidx, &p->ackNackFeedbackMode_r16);
	_serNrSysDecSQN_NR_SetupRelease_PhysicalCellGroupConfig_pdcch_BlindDetectionCA_CombIndicator_r16_SQN_NR_PhysicalCellGroupConfig_pdcch_BlindDetectionCA_CombIndicator_r16_Optional(_buffer, _size, _lidx, &p->pdcch_BlindDetectionCA_CombIndicator_r16);
	_serNrSysDecSQN_NR_SetupRelease_PhysicalCellGroupConfig_pdcch_BlindDetection2_r16_SQN_NR_PhysicalCellGroupConfig_pdcch_BlindDetection2_r16_Optional(_buffer, _size, _lidx, &p->pdcch_BlindDetection2_r16);
	_serNrSysDecSQN_NR_SetupRelease_PhysicalCellGroupConfig_pdcch_BlindDetection3_r16_SQN_NR_PhysicalCellGroupConfig_pdcch_BlindDetection3_r16_Optional(_buffer, _size, _lidx, &p->pdcch_BlindDetection3_r16);
	_serNrSysDecSQN_NR_PhysicalCellGroupConfig_bdFactorR_r16_e_bdFactorR_r16_Optional(_buffer, _size, _lidx, &p->bdFactorR_r16);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_ASN1_PhysicalCellGroupConfig_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union NR_ASN1_PhysicalCellGroupConfig_Type_Value* p, enum NR_ASN1_PhysicalCellGroupConfig_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_ASN1_PhysicalCellGroupConfig_Type_R15) {
		_serNrSysDecSQN_NR_PhysicalCellGroupConfig(_buffer, _size, _lidx, _mem, &p->R15);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecNR_ASN1_PhysicalCellGroupConfig_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_ASN1_PhysicalCellGroupConfig_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum NR_ASN1_PhysicalCellGroupConfig_Type_Sel)_tmp;
	}
	_serNrSysDecNR_ASN1_PhysicalCellGroupConfig_Type_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_ASN1_PhysicalCellGroupConfig_Type_PhysicalCellGroupConfig_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_ASN1_PhysicalCellGroupConfig_Type_PhysicalCellGroupConfig_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecNR_ASN1_PhysicalCellGroupConfig_Type(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_SpCell_CellGroupConfig_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_SpCell_CellGroupConfig_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecSQN_NR_CellGroupId_CellGroupId_Optional(_buffer, _size, _lidx, &p->CellGroupId);
	_serNrSysDecNR_CellIdList_Type_SCellList_Optional(_buffer, _size, _lidx, _mem, &p->SCellList);
	_serNrSysDecNR_ASN1_MAC_CellGroupConfig_Type_MAC_CellGroupConfig_Optional(_buffer, _size, _lidx, _mem, &p->MAC_CellGroupConfig);
	_serNrSysDecNR_ASN1_PhysicalCellGroupConfig_Type_PhysicalCellGroupConfig_Optional(_buffer, _size, _lidx, _mem, &p->PhysicalCellGroupConfig);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_SpCell_CellGroupConfig_Type_CellGroupConfig_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_SpCell_CellGroupConfig_Type_CellGroupConfig_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecNR_SpCell_CellGroupConfig_Type(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_SpCellConfig_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_SpCellConfig_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecNR_ServingCellIndex_Type_NR_SpCellConfig_Type_ServingCellIndex_Optional(_buffer, _size, _lidx, &p->ServingCellIndex);
	_serNrSysDecNR_SpCell_CellGroupConfig_Type_CellGroupConfig_Optional(_buffer, _size, _lidx, _mem, &p->CellGroupConfig);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_ServingCellIndex_Type_NR_SCellConfig_Type_ServingCellIndex_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_ServingCellIndex_Type_NR_SCellConfig_Type_ServingCellIndex_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_TAG_Id_TAG_Id_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_TAG_Id_TAG_Id_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_SCellConfig_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_SCellConfig_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecNR_ServingCellIndex_Type_NR_SCellConfig_Type_ServingCellIndex_Optional(_buffer, _size, _lidx, &p->ServingCellIndex);
	_serNrSysDecSQN_NR_TAG_Id_TAG_Id_Optional(_buffer, _size, _lidx, &p->TAG_Id);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_ServingCellConfig_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union NR_ServingCellConfig_Type_Value* p, enum NR_ServingCellConfig_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_ServingCellConfig_Type_SpCell) {
		_serNrSysDecNR_SpCellConfig_Type(_buffer, _size, _lidx, _mem, &p->SpCell);
		return SIDL_STATUS_OK;
	}
	if (d == NR_ServingCellConfig_Type_SCell) {
		_serNrSysDecNR_SCellConfig_Type(_buffer, _size, _lidx, &p->SCell);
		return SIDL_STATUS_OK;
	}
	if (d == NR_ServingCellConfig_Type_None) {
		NTOH_8(p->None, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecNR_ServingCellConfig_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_ServingCellConfig_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum NR_ServingCellConfig_Type_Sel)_tmp;
	}
	_serNrSysDecNR_ServingCellConfig_Type_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_ServingCellConfig_Type_ServingCellConfig_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_ServingCellConfig_Type_ServingCellConfig_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecNR_ServingCellConfig_Type(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_CellConfigInfo_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_CellConfigInfo_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecNR_SS_StaticCellResourceConfig_Type_StaticResourceConfig_Optional(_buffer, _size, _lidx, &p->StaticResourceConfig);
	_serNrSysDecNR_CellConfigCommon_Type_CellConfigCommon_Optional(_buffer, _size, _lidx, &p->CellConfigCommon);
	_serNrSysDecNR_CellConfigPhysicalLayer_Type_PhysicalLayer_Optional(_buffer, _size, _lidx, _mem, &p->PhysicalLayer);
	_serNrSysDecNR_BcchConfig_Type_BcchConfig_Optional(_buffer, _size, _lidx, _mem, &p->BcchConfig);
	_serNrSysDecNR_PcchConfig_Type_PcchConfig_Optional(_buffer, _size, _lidx, _mem, &p->PcchConfig);
	_serNrSysDecNR_RachProcedureConfig_Type_RachProcedureConfig_Optional(_buffer, _size, _lidx, _mem, &p->RachProcedureConfig);
	_serNrSysDecNR_DcchDtchConfig_Type_DcchDtchConfig_Optional(_buffer, _size, _lidx, _mem, &p->DcchDtchConfig);
	_serNrSysDecNR_ServingCellConfig_Type_ServingCellConfig_Optional(_buffer, _size, _lidx, _mem, &p->ServingCellConfig);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_CellConfigRequest_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union NR_CellConfigRequest_Type_Value* p, enum NR_CellConfigRequest_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_CellConfigRequest_Type_AddOrReconfigure) {
		_serNrSysDecNR_CellConfigInfo_Type(_buffer, _size, _lidx, _mem, &p->AddOrReconfigure);
		return SIDL_STATUS_OK;
	}
	if (d == NR_CellConfigRequest_Type_Release) {
		NTOH_8(p->Release, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecNR_CellConfigRequest_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_CellConfigRequest_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum NR_CellConfigRequest_Type_Sel)_tmp;
	}
	_serNrSysDecNR_CellConfigRequest_Type_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_Attenuation_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_Attenuation_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum NR_Attenuation_Type_Sel)_tmp;
	}
	_serNrSysDecNR_Attenuation_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecTimingInfo_Type_NR_TimingInfo_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct TimingInfo_Type_NR_TimingInfo_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecTimingInfo_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_CellAttenuationConfig_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_CellAttenuationConfig_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->CellId = (NR_CellId_Type)_tmp;
	}
	_serNrSysDecNR_Attenuation_Type(_buffer, _size, _lidx, &p->Attenuation);
	_serNrSysDecTimingInfo_Type_NR_TimingInfo_Optional(_buffer, _size, _lidx, &p->TimingInfo);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSDAP_Header_Type_Sdap_HeaderDL_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SDAP_Header_Type_Sdap_HeaderDL_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SDAP_Header_Type)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecQFI_List_Type_MappedQoS_Flows_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct QFI_List_Type_MappedQoS_Flows_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = (int32_t*)serMalloc(_mem, p->v.d * sizeof(int32_t));
	for (size_t i2 = 0; i2 < p->v.d; i2++) {
		NTOH_32(p->v.v[i2], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSdapConfig_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SdapConfig_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_32(p->Pdu_SessionId, &_buffer[*_lidx], _lidx);
	_serNrSysDecSDAP_Header_Type_Sdap_HeaderDL_Optional(_buffer, _size, _lidx, &p->Sdap_HeaderDL);
	_serNrSysDecQFI_List_Type_MappedQoS_Flows_Optional(_buffer, _size, _lidx, _mem, &p->MappedQoS_Flows);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSdapTransparentMode_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SdapTransparentMode_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->Sdap_HeaderUL = (SDAP_Header_Type)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSdapConfigInfo_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union SdapConfigInfo_Type_Value* p, enum SdapConfigInfo_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SdapConfigInfo_Type_SdapConfig) {
		_serNrSysDecSdapConfig_Type(_buffer, _size, _lidx, _mem, &p->SdapConfig);
		return SIDL_STATUS_OK;
	}
	if (d == SdapConfigInfo_Type_TransparentMode) {
		_serNrSysDecSdapTransparentMode_Type(_buffer, _size, _lidx, &p->TransparentMode);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecSdapConfigInfo_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SdapConfigInfo_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SdapConfigInfo_Type_Sel)_tmp;
	}
	_serNrSysDecSdapConfigInfo_Type_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSDAP_Configuration_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union SDAP_Configuration_Type_Value* p, enum SDAP_Configuration_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SDAP_Configuration_Type_None) {
		NTOH_8(p->None, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == SDAP_Configuration_Type_Config) {
		_serNrSysDecSdapConfigInfo_Type(_buffer, _size, _lidx, _mem, &p->Config);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecSDAP_Configuration_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SDAP_Configuration_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SDAP_Configuration_Type_Sel)_tmp;
	}
	_serNrSysDecSDAP_Configuration_Type_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSDAP_Configuration_Type_Sdap_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SDAP_Configuration_Type_Sdap_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSDAP_Configuration_Type(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_PDCP_DRB_HeaderCompression_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union NR_PDCP_DRB_HeaderCompression_Type_Value* p, enum NR_PDCP_DRB_HeaderCompression_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_PDCP_DRB_HeaderCompression_Type_None) {
		NTOH_8(p->None, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecNR_PDCP_DRB_HeaderCompression_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_PDCP_DRB_HeaderCompression_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum NR_PDCP_DRB_HeaderCompression_Type_Sel)_tmp;
	}
	_serNrSysDecNR_PDCP_DRB_HeaderCompression_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_PDCP_DRB_Config_Parameters_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_PDCP_DRB_Config_Parameters_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->SN_SizeUL = (NR_PDCP_SN_Size_Type)_tmp;
	}
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->SN_SizeDL = (NR_PDCP_SN_Size_Type)_tmp;
	}
	_serNrSysDecNR_PDCP_DRB_HeaderCompression_Type(_buffer, _size, _lidx, &p->HeaderCompression);
	NTOH_8(p->IntegrityProtectionEnabled, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_PDCP_RB_Config_Parameters_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union NR_PDCP_RB_Config_Parameters_Type_Value* p, enum NR_PDCP_RB_Config_Parameters_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_PDCP_RB_Config_Parameters_Type_Srb) {
		NTOH_8(p->Srb, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == NR_PDCP_RB_Config_Parameters_Type_Drb) {
		_serNrSysDecNR_PDCP_DRB_Config_Parameters_Type(_buffer, _size, _lidx, &p->Drb);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecNR_PDCP_RB_Config_Parameters_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_PDCP_RB_Config_Parameters_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum NR_PDCP_RB_Config_Parameters_Type_Sel)_tmp;
	}
	_serNrSysDecNR_PDCP_RB_Config_Parameters_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_PDCP_Config_Parameters_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_PDCP_Config_Parameters_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecNR_PDCP_RB_Config_Parameters_Type(_buffer, _size, _lidx, &p->Rb);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_PDCP_TransparentMode(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_PDCP_TransparentMode* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->SN_Size = (NR_PDCP_SN_Size_Type)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_PDCP_RbConfig_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union NR_PDCP_RbConfig_Type_Value* p, enum NR_PDCP_RbConfig_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_PDCP_RbConfig_Type_Params) {
		_serNrSysDecNR_PDCP_Config_Parameters_Type(_buffer, _size, _lidx, &p->Params);
		return SIDL_STATUS_OK;
	}
	if (d == NR_PDCP_RbConfig_Type_TransparentMode) {
		_serNrSysDecNR_PDCP_TransparentMode(_buffer, _size, _lidx, &p->TransparentMode);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecNR_PDCP_RbConfig_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_PDCP_RbConfig_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum NR_PDCP_RbConfig_Type_Sel)_tmp;
	}
	_serNrSysDecNR_PDCP_RbConfig_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_PDCP_RbConfig_Type_RbConfig_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_PDCP_RbConfig_Type_RbConfig_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecNR_PDCP_RbConfig_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecRlcBearerRouting_Type_LinkToOtherCellGroup_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct RlcBearerRouting_Type_LinkToOtherCellGroup_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecRlcBearerRouting_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_PDCP_RBTerminating_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_PDCP_RBTerminating_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecNR_PDCP_RbConfig_Type_RbConfig_Optional(_buffer, _size, _lidx, &p->RbConfig);
	_serNrSysDecRlcBearerRouting_Type_LinkToOtherCellGroup_Optional(_buffer, _size, _lidx, &p->LinkToOtherCellGroup);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_PDCP_Proxy_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_PDCP_Proxy_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecRlcBearerRouting_Type(_buffer, _size, _lidx, &p->LinkToOtherNode);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_PDCP_Configuration_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union NR_PDCP_Configuration_Type_Value* p, enum NR_PDCP_Configuration_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_PDCP_Configuration_Type_None) {
		NTOH_8(p->None, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == NR_PDCP_Configuration_Type_RBTerminating) {
		_serNrSysDecNR_PDCP_RBTerminating_Type(_buffer, _size, _lidx, &p->RBTerminating);
		return SIDL_STATUS_OK;
	}
	if (d == NR_PDCP_Configuration_Type_Proxy) {
		_serNrSysDecNR_PDCP_Proxy_Type(_buffer, _size, _lidx, &p->Proxy);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecNR_PDCP_Configuration_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_PDCP_Configuration_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum NR_PDCP_Configuration_Type_Sel)_tmp;
	}
	_serNrSysDecNR_PDCP_Configuration_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_PDCP_Configuration_Type_Pdcp_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_PDCP_Configuration_Type_Pdcp_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecNR_PDCP_Configuration_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SN_FieldLengthAM_e_SQN_NR_UL_AM_RLC_sn_FieldLength_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SN_FieldLengthAM_e_SQN_NR_UL_AM_RLC_sn_FieldLength_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_SN_FieldLengthAM_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_UL_AM_RLC(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_UL_AM_RLC* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecSQN_NR_SN_FieldLengthAM_e_SQN_NR_UL_AM_RLC_sn_FieldLength_Optional(_buffer, _size, _lidx, &p->sn_FieldLength);
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->t_PollRetransmit = (SQN_NR_T_PollRetransmit_e)_tmp;
	}
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->pollPDU = (SQN_NR_PollPDU_e)_tmp;
	}
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->pollByte = (SQN_NR_PollByte_e)_tmp;
	}
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->maxRetxThreshold = (SQN_NR_UL_AM_RLC_maxRetxThreshold_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_ASN1_UL_AM_RLC_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union NR_ASN1_UL_AM_RLC_Type_Value* p, enum NR_ASN1_UL_AM_RLC_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_ASN1_UL_AM_RLC_Type_R15) {
		_serNrSysDecSQN_NR_UL_AM_RLC(_buffer, _size, _lidx, &p->R15);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecNR_ASN1_UL_AM_RLC_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_ASN1_UL_AM_RLC_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum NR_ASN1_UL_AM_RLC_Type_Sel)_tmp;
	}
	_serNrSysDecNR_ASN1_UL_AM_RLC_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_ASN1_UL_AM_RLC_Type_Tx_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_ASN1_UL_AM_RLC_Type_Tx_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecNR_ASN1_UL_AM_RLC_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SN_FieldLengthAM_e_SQN_NR_DL_AM_RLC_sn_FieldLength_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SN_FieldLengthAM_e_SQN_NR_DL_AM_RLC_sn_FieldLength_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_SN_FieldLengthAM_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_DL_AM_RLC(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_DL_AM_RLC* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecSQN_NR_SN_FieldLengthAM_e_SQN_NR_DL_AM_RLC_sn_FieldLength_Optional(_buffer, _size, _lidx, &p->sn_FieldLength);
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->t_Reassembly = (SQN_NR_T_Reassembly_e)_tmp;
	}
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->t_StatusProhibit = (SQN_NR_T_StatusProhibit_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_ASN1_DL_AM_RLC_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union NR_ASN1_DL_AM_RLC_Type_Value* p, enum NR_ASN1_DL_AM_RLC_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_ASN1_DL_AM_RLC_Type_R15) {
		_serNrSysDecSQN_NR_DL_AM_RLC(_buffer, _size, _lidx, &p->R15);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecNR_ASN1_DL_AM_RLC_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_ASN1_DL_AM_RLC_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum NR_ASN1_DL_AM_RLC_Type_Sel)_tmp;
	}
	_serNrSysDecNR_ASN1_DL_AM_RLC_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_ASN1_DL_AM_RLC_Type_Rx_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_ASN1_DL_AM_RLC_Type_Rx_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecNR_ASN1_DL_AM_RLC_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_SS_RLC_AM_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_SS_RLC_AM_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecNR_ASN1_UL_AM_RLC_Type_Tx_Optional(_buffer, _size, _lidx, &p->Tx);
	_serNrSysDecNR_ASN1_DL_AM_RLC_Type_Rx_Optional(_buffer, _size, _lidx, &p->Rx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SN_FieldLengthUM_e_SQN_NR_UL_UM_RLC_sn_FieldLength_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SN_FieldLengthUM_e_SQN_NR_UL_UM_RLC_sn_FieldLength_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_SN_FieldLengthUM_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_UL_UM_RLC(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_UL_UM_RLC* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecSQN_NR_SN_FieldLengthUM_e_SQN_NR_UL_UM_RLC_sn_FieldLength_Optional(_buffer, _size, _lidx, &p->sn_FieldLength);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_ASN1_UL_UM_RLC_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union NR_ASN1_UL_UM_RLC_Type_Value* p, enum NR_ASN1_UL_UM_RLC_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_ASN1_UL_UM_RLC_Type_R15) {
		_serNrSysDecSQN_NR_UL_UM_RLC(_buffer, _size, _lidx, &p->R15);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecNR_ASN1_UL_UM_RLC_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_ASN1_UL_UM_RLC_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum NR_ASN1_UL_UM_RLC_Type_Sel)_tmp;
	}
	_serNrSysDecNR_ASN1_UL_UM_RLC_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_ASN1_UL_UM_RLC_Type_Tx_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_ASN1_UL_UM_RLC_Type_Tx_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecNR_ASN1_UL_UM_RLC_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_SN_FieldLengthUM_e_SQN_NR_DL_UM_RLC_sn_FieldLength_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_SN_FieldLengthUM_e_SQN_NR_DL_UM_RLC_sn_FieldLength_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_SN_FieldLengthUM_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_DL_UM_RLC(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_DL_UM_RLC* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecSQN_NR_SN_FieldLengthUM_e_SQN_NR_DL_UM_RLC_sn_FieldLength_Optional(_buffer, _size, _lidx, &p->sn_FieldLength);
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->t_Reassembly = (SQN_NR_T_Reassembly_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_ASN1_DL_UM_RLC_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union NR_ASN1_DL_UM_RLC_Type_Value* p, enum NR_ASN1_DL_UM_RLC_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_ASN1_DL_UM_RLC_Type_R15) {
		_serNrSysDecSQN_NR_DL_UM_RLC(_buffer, _size, _lidx, &p->R15);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecNR_ASN1_DL_UM_RLC_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_ASN1_DL_UM_RLC_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum NR_ASN1_DL_UM_RLC_Type_Sel)_tmp;
	}
	_serNrSysDecNR_ASN1_DL_UM_RLC_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_ASN1_DL_UM_RLC_Type_Rx_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_ASN1_DL_UM_RLC_Type_Rx_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecNR_ASN1_DL_UM_RLC_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_SS_RLC_UM_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_SS_RLC_UM_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecNR_ASN1_UL_UM_RLC_Type_Tx_Optional(_buffer, _size, _lidx, &p->Tx);
	_serNrSysDecNR_ASN1_DL_UM_RLC_Type_Rx_Optional(_buffer, _size, _lidx, &p->Rx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_RLC_RbConfig_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union NR_RLC_RbConfig_Type_Value* p, enum NR_RLC_RbConfig_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_RLC_RbConfig_Type_AM) {
		_serNrSysDecNR_SS_RLC_AM_Type(_buffer, _size, _lidx, &p->AM);
		return SIDL_STATUS_OK;
	}
	if (d == NR_RLC_RbConfig_Type_UM) {
		_serNrSysDecNR_SS_RLC_UM_Type(_buffer, _size, _lidx, &p->UM);
		return SIDL_STATUS_OK;
	}
	if (d == NR_RLC_RbConfig_Type_TM) {
		NTOH_8(p->TM, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecNR_RLC_RbConfig_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_RLC_RbConfig_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum NR_RLC_RbConfig_Type_Sel)_tmp;
	}
	_serNrSysDecNR_RLC_RbConfig_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_RLC_RbConfig_Type_Rb_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_RLC_RbConfig_Type_Rb_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecNR_RLC_RbConfig_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_RLC_TransparentMode_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union NR_RLC_TransparentMode_Value* p, enum NR_RLC_TransparentMode_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_RLC_TransparentMode_Umd) {
		{
			size_t _tmp;
			NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
			p->Umd = (SQN_NR_SN_FieldLengthUM_e)_tmp;
		}
		return SIDL_STATUS_OK;
	}
	if (d == NR_RLC_TransparentMode_Amd) {
		{
			size_t _tmp;
			NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
			p->Amd = (SQN_NR_SN_FieldLengthUM_e)_tmp;
		}
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecNR_RLC_TransparentMode(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_RLC_TransparentMode* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum NR_RLC_TransparentMode_Sel)_tmp;
	}
	_serNrSysDecNR_RLC_TransparentMode_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_RLC_TestModeInfo_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union NR_RLC_TestModeInfo_Type_Value* p, enum NR_RLC_TestModeInfo_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_RLC_TestModeInfo_Type_AckProhibit) {
		{
			size_t _tmp;
			NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
			p->AckProhibit = (NR_RLC_ACK_Prohibit_Type)_tmp;
		}
		return SIDL_STATUS_OK;
	}
	if (d == NR_RLC_TestModeInfo_Type_NotACK_NextRLC_PDU) {
		{
			size_t _tmp;
			NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
			p->NotACK_NextRLC_PDU = (NR_RLC_NotACK_NextRLC_PDU_Type)_tmp;
		}
		return SIDL_STATUS_OK;
	}
	if (d == NR_RLC_TestModeInfo_Type_TransparentMode) {
		_serNrSysDecNR_RLC_TransparentMode(_buffer, _size, _lidx, &p->TransparentMode);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecNR_RLC_TestModeInfo_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_RLC_TestModeInfo_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum NR_RLC_TestModeInfo_Type_Sel)_tmp;
	}
	_serNrSysDecNR_RLC_TestModeInfo_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_RLC_TestModeConfig_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union NR_RLC_TestModeConfig_Type_Value* p, enum NR_RLC_TestModeConfig_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_RLC_TestModeConfig_Type_None) {
		NTOH_8(p->None, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == NR_RLC_TestModeConfig_Type_Info) {
		_serNrSysDecNR_RLC_TestModeInfo_Type(_buffer, _size, _lidx, &p->Info);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecNR_RLC_TestModeConfig_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_RLC_TestModeConfig_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum NR_RLC_TestModeConfig_Type_Sel)_tmp;
	}
	_serNrSysDecNR_RLC_TestModeConfig_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_RLC_TestModeConfig_Type_TestMode_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_RLC_TestModeConfig_Type_TestMode_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecNR_RLC_TestModeConfig_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_RLC_Configuration_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_RLC_Configuration_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecNR_RLC_RbConfig_Type_Rb_Optional(_buffer, _size, _lidx, &p->Rb);
	_serNrSysDecNR_RLC_TestModeConfig_Type_TestMode_Optional(_buffer, _size, _lidx, &p->TestMode);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_RLC_Configuration_Type_Rlc_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_RLC_Configuration_Type_Rlc_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecNR_RLC_Configuration_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_LogicalChannelId_Type_LogicalChannelId_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_LogicalChannelId_Type_LogicalChannelId_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_MAC_LogicalChannelConfig_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_MAC_LogicalChannelConfig_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_32(p->Priority, &_buffer[*_lidx], _lidx);
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->PrioritizedBitRate = (NR_PrioritizedBitRate_Type)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_MAC_LogicalChannelConfig_Type_LogicalChannel_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_MAC_LogicalChannelConfig_Type_LogicalChannel_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecNR_MAC_LogicalChannelConfig_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_MAC_Test_DLLogChID_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_MAC_Test_DLLogChID_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_32(p->LogChId, &_buffer[*_lidx], _lidx);
	NTOH_8(p->ConfigLchId, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_MAC_TestModeInfo_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_MAC_TestModeInfo_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecNR_MAC_Test_DLLogChID_Type(_buffer, _size, _lidx, &p->DiffLogChId);
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->No_HeaderManipulation = (NR_MAC_Test_SCH_NoHeaderManipulation_Type)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_MAC_TestModeConfig_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union NR_MAC_TestModeConfig_Type_Value* p, enum NR_MAC_TestModeConfig_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_MAC_TestModeConfig_Type_None) {
		NTOH_8(p->None, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == NR_MAC_TestModeConfig_Type_Info) {
		_serNrSysDecNR_MAC_TestModeInfo_Type(_buffer, _size, _lidx, &p->Info);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecNR_MAC_TestModeConfig_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_MAC_TestModeConfig_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum NR_MAC_TestModeConfig_Type_Sel)_tmp;
	}
	_serNrSysDecNR_MAC_TestModeConfig_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_MAC_TestModeConfig_Type_TestMode_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_MAC_TestModeConfig_Type_TestMode_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecNR_MAC_TestModeConfig_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_MAC_Configuration_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_MAC_Configuration_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecNR_MAC_LogicalChannelConfig_Type_LogicalChannel_Optional(_buffer, _size, _lidx, &p->LogicalChannel);
	_serNrSysDecNR_MAC_TestModeConfig_Type_TestMode_Optional(_buffer, _size, _lidx, &p->TestMode);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_MAC_Configuration_Type_Mac_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_MAC_Configuration_Type_Mac_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecNR_MAC_Configuration_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecBool_NR_RlcBearerConfigInfo_Type_DiscardULData_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct bool_NR_RlcBearerConfigInfo_Type_DiscardULData_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_8(p->v, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_RlcBearerConfigInfo_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_RlcBearerConfigInfo_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecNR_RLC_Configuration_Type_Rlc_Optional(_buffer, _size, _lidx, &p->Rlc);
	_serNrSysDecNR_LogicalChannelId_Type_LogicalChannelId_Optional(_buffer, _size, _lidx, &p->LogicalChannelId);
	_serNrSysDecNR_MAC_Configuration_Type_Mac_Optional(_buffer, _size, _lidx, &p->Mac);
	_serNrSysDecBool_NR_RlcBearerConfigInfo_Type_DiscardULData_Optional(_buffer, _size, _lidx, &p->DiscardULData);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_RlcBearerConfig_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union NR_RlcBearerConfig_Type_Value* p, enum NR_RlcBearerConfig_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_RlcBearerConfig_Type_Config) {
		_serNrSysDecNR_RlcBearerConfigInfo_Type(_buffer, _size, _lidx, &p->Config);
		return SIDL_STATUS_OK;
	}
	if (d == NR_RlcBearerConfig_Type_None) {
		NTOH_8(p->None, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecNR_RlcBearerConfig_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_RlcBearerConfig_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum NR_RlcBearerConfig_Type_Sel)_tmp;
	}
	_serNrSysDecNR_RlcBearerConfig_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_RlcBearerConfig_Type_RlcBearer_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_RlcBearerConfig_Type_RlcBearer_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecNR_RlcBearerConfig_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_RadioBearerConfigInfo_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_RadioBearerConfigInfo_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecSDAP_Configuration_Type_Sdap_Optional(_buffer, _size, _lidx, _mem, &p->Sdap);
	_serNrSysDecNR_PDCP_Configuration_Type_Pdcp_Optional(_buffer, _size, _lidx, &p->Pdcp);
	_serNrSysDecNR_RlcBearerConfig_Type_RlcBearer_Optional(_buffer, _size, _lidx, &p->RlcBearer);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_RadioBearerConfig_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union NR_RadioBearerConfig_Type_Value* p, enum NR_RadioBearerConfig_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_RadioBearerConfig_Type_AddOrReconfigure) {
		_serNrSysDecNR_RadioBearerConfigInfo_Type(_buffer, _size, _lidx, _mem, &p->AddOrReconfigure);
		return SIDL_STATUS_OK;
	}
	if (d == NR_RadioBearerConfig_Type_Release) {
		NTOH_8(p->Release, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecNR_RadioBearerConfig_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_RadioBearerConfig_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum NR_RadioBearerConfig_Type_Sel)_tmp;
	}
	_serNrSysDecNR_RadioBearerConfig_Type_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_RadioBearer_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_RadioBearer_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecNR_RadioBearerId_Type(_buffer, _size, _lidx, &p->Id);
	_serNrSysDecNR_RadioBearerConfig_Type(_buffer, _size, _lidx, _mem, &p->Config);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecB128_Key_Type_KUPint_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct B128_Key_Type_KUPint_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	for (size_t i1 = 0; i1 < 128; i1++) {
		NTOH_8(p->v[i1], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_PdcpSQN_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_PdcpSQN_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->Format = (NR_PdcpCountFormat_Type)_tmp;
	}
	NTOH_32(p->Value, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_PDCP_ActTime_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union NR_PDCP_ActTime_Type_Value* p, enum NR_PDCP_ActTime_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_PDCP_ActTime_Type_None) {
		NTOH_8(p->None, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == NR_PDCP_ActTime_Type_SQN) {
		_serNrSysDecNR_PdcpSQN_Type(_buffer, _size, _lidx, &p->SQN);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecNR_PDCP_ActTime_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_PDCP_ActTime_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum NR_PDCP_ActTime_Type_Sel)_tmp;
	}
	_serNrSysDecNR_PDCP_ActTime_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_SecurityActTime_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_SecurityActTime_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecNR_RadioBearerId_Type(_buffer, _size, _lidx, &p->RadioBearerId);
	_serNrSysDecNR_PDCP_ActTime_Type(_buffer, _size, _lidx, &p->UL);
	_serNrSysDecNR_PDCP_ActTime_Type(_buffer, _size, _lidx, &p->DL);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_SecurityActTimeList_Type_ActTimeList_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_SecurityActTimeList_Type_ActTimeList_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = (struct NR_SecurityActTime_Type*)serMalloc(_mem, p->v.d * sizeof(struct NR_SecurityActTime_Type));
	for (size_t i1 = 0; i1 < p->v.d; i1++) {
		_serNrSysDecNR_SecurityActTime_Type(_buffer, _size, _lidx, &p->v.v[i1]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_AS_IntegrityInfo_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_AS_IntegrityInfo_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->Algorithm = (SQN_NR_IntegrityProtAlgorithm_e)_tmp;
	}
	for (size_t i1 = 0; i1 < 128; i1++) {
		NTOH_8(p->KRRCint[i1], &_buffer[*_lidx], _lidx);
	}
	_serNrSysDecB128_Key_Type_KUPint_Optional(_buffer, _size, _lidx, &p->KUPint);
	_serNrSysDecNR_SecurityActTimeList_Type_ActTimeList_Optional(_buffer, _size, _lidx, _mem, &p->ActTimeList);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_AS_IntegrityInfo_Type_Integrity_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_AS_IntegrityInfo_Type_Integrity_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecNR_AS_IntegrityInfo_Type(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_AS_CipheringInfo_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_AS_CipheringInfo_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->Algorithm = (SQN_NR_CipheringAlgorithm_e)_tmp;
	}
	for (size_t i1 = 0; i1 < 128; i1++) {
		NTOH_8(p->KRRCenc[i1], &_buffer[*_lidx], _lidx);
	}
	for (size_t i1 = 0; i1 < 128; i1++) {
		NTOH_8(p->KUPenc[i1], &_buffer[*_lidx], _lidx);
	}
	NTOH_32(p->ActTimeList.d, &_buffer[*_lidx], _lidx);
	p->ActTimeList.v = (struct NR_SecurityActTime_Type*)serMalloc(_mem, p->ActTimeList.d * sizeof(struct NR_SecurityActTime_Type));
	for (size_t i1 = 0; i1 < p->ActTimeList.d; i1++) {
		_serNrSysDecNR_SecurityActTime_Type(_buffer, _size, _lidx, &p->ActTimeList.v[i1]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_AS_CipheringInfo_Type_Ciphering_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_AS_CipheringInfo_Type_Ciphering_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecNR_AS_CipheringInfo_Type(_buffer, _size, _lidx, _mem, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_AS_SecStartRestart_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_AS_SecStartRestart_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecNR_AS_IntegrityInfo_Type_Integrity_Optional(_buffer, _size, _lidx, _mem, &p->Integrity);
	_serNrSysDecNR_AS_CipheringInfo_Type_Ciphering_Optional(_buffer, _size, _lidx, _mem, &p->Ciphering);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_AS_Security_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union NR_AS_Security_Type_Value* p, enum NR_AS_Security_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_AS_Security_Type_StartRestart) {
		_serNrSysDecNR_AS_SecStartRestart_Type(_buffer, _size, _lidx, _mem, &p->StartRestart);
		return SIDL_STATUS_OK;
	}
	if (d == NR_AS_Security_Type_Release) {
		NTOH_8(p->Release, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecNR_AS_Security_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_AS_Security_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum NR_AS_Security_Type_Sel)_tmp;
	}
	_serNrSysDecNR_AS_Security_Type_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_PdcpCountGetReq_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union NR_PdcpCountGetReq_Type_Value* p, enum NR_PdcpCountGetReq_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_PdcpCountGetReq_Type_AllRBs) {
		NTOH_8(p->AllRBs, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == NR_PdcpCountGetReq_Type_SingleRB) {
		_serNrSysDecNR_RadioBearerId_Type(_buffer, _size, _lidx, &p->SingleRB);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecNR_PdcpCountGetReq_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_PdcpCountGetReq_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum NR_PdcpCountGetReq_Type_Sel)_tmp;
	}
	_serNrSysDecNR_PdcpCountGetReq_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_PdcpCount_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_PdcpCount_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->Format = (NR_PdcpCountFormat_Type)_tmp;
	}
	for (size_t i2 = 0; i2 < 32; i2++) {
		NTOH_8(p->Value[i2], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_PdcpCount_Type_UL_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_PdcpCount_Type_UL_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecNR_PdcpCount_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_PdcpCount_Type_DL_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_PdcpCount_Type_DL_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecNR_PdcpCount_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_PdcpCountInfo_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_PdcpCountInfo_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecNR_RadioBearerId_Type(_buffer, _size, _lidx, &p->RadioBearerId);
	_serNrSysDecNR_PdcpCount_Type_UL_Optional(_buffer, _size, _lidx, &p->UL);
	_serNrSysDecNR_PdcpCount_Type_DL_Optional(_buffer, _size, _lidx, &p->DL);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_PDCP_CountReq_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union NR_PDCP_CountReq_Type_Value* p, enum NR_PDCP_CountReq_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_PDCP_CountReq_Type_Get) {
		_serNrSysDecNR_PdcpCountGetReq_Type(_buffer, _size, _lidx, &p->Get);
		return SIDL_STATUS_OK;
	}
	if (d == NR_PDCP_CountReq_Type_Set) {
		NTOH_32(p->Set.d, &_buffer[*_lidx], _lidx);
		p->Set.v = (struct NR_PdcpCountInfo_Type*)serMalloc(_mem, p->Set.d * sizeof(struct NR_PdcpCountInfo_Type));
		for (size_t i1 = 0; i1 < p->Set.d; i1++) {
			_serNrSysDecNR_PdcpCountInfo_Type(_buffer, _size, _lidx, &p->Set.v[i1]);
		}
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecNR_PDCP_CountReq_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_PDCP_CountReq_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum NR_PDCP_CountReq_Type_Sel)_tmp;
	}
	_serNrSysDecNR_PDCP_CountReq_Type_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PagingUE_Identity_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union SQN_NR_PagingUE_Identity_Value* p, enum SQN_NR_PagingUE_Identity_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_PagingUE_Identity_ng_5G_S_TMSI) {
		for (size_t i2 = 0; i2 < 48; i2++) {
			NTOH_8(p->ng_5G_S_TMSI[i2], &_buffer[*_lidx], _lidx);
		}
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_PagingUE_Identity_fullI_RNTI) {
		for (size_t i2 = 0; i2 < 40; i2++) {
			NTOH_8(p->fullI_RNTI[i2], &_buffer[*_lidx], _lidx);
		}
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecSQN_NR_PagingUE_Identity(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_PagingUE_Identity* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SQN_NR_PagingUE_Identity_Sel)_tmp;
	}
	_serNrSysDecSQN_NR_PagingUE_Identity_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PagingRecord_accessType_e_accessType_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_PagingRecord_accessType_e_accessType_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->v = (SQN_NR_PagingRecord_accessType_e)_tmp;
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PagingRecord(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_PagingRecord* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecSQN_NR_PagingUE_Identity(_buffer, _size, _lidx, &p->ue_Identity);
	_serNrSysDecSQN_NR_PagingRecord_accessType_e_accessType_Optional(_buffer, _size, _lidx, &p->accessType);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PagingRecordList_SQN_NR_Paging_pagingRecordList_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_PagingRecordList_SQN_NR_Paging_pagingRecordList_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = (struct SQN_NR_PagingRecord*)serMalloc(_mem, p->v.d * sizeof(struct SQN_NR_PagingRecord));
	for (size_t i1 = 0; i1 < p->v.d; i1++) {
		_serNrSysDecSQN_NR_PagingRecord(_buffer, _size, _lidx, &p->v.v[i1]);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecOCTET_STRING_SQN_NR_Paging_lateNonCriticalExtension_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct OCTET_STRING_SQN_NR_Paging_lateNonCriticalExtension_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = (OCTET_STRING_ELEMENT*)serMalloc(_mem, p->v.d * sizeof(OCTET_STRING_ELEMENT));
	for (size_t i1 = 0; i1 < p->v.d; i1++) {
		NTOH_8(p->v.v[i1], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_Paging_nonCriticalExtension(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_Paging_nonCriticalExtension* p)
{
	(void)_size; // TODO: generate boundaries checking

	(void)_buffer;
	(void)_size;
	(void)_lidx;
	(void)p;

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_Paging_nonCriticalExtension_nonCriticalExtension_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_Paging_nonCriticalExtension_nonCriticalExtension_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecSQN_NR_Paging_nonCriticalExtension(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_Paging(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_Paging* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecSQN_NR_PagingRecordList_SQN_NR_Paging_pagingRecordList_Optional(_buffer, _size, _lidx, _mem, &p->pagingRecordList);
	_serNrSysDecOCTET_STRING_SQN_NR_Paging_lateNonCriticalExtension_Optional(_buffer, _size, _lidx, _mem, &p->lateNonCriticalExtension);
	_serNrSysDecSQN_NR_Paging_nonCriticalExtension_nonCriticalExtension_Optional(_buffer, _size, _lidx, &p->nonCriticalExtension);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PCCH_MessageType_c1_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union SQN_NR_PCCH_MessageType_c1_Value* p, enum SQN_NR_PCCH_MessageType_c1_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_PCCH_MessageType_c1_paging) {
		_serNrSysDecSQN_NR_Paging(_buffer, _size, _lidx, _mem, &p->paging);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_PCCH_MessageType_c1_spare1) {
		NTOH_8(p->spare1, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecSQN_NR_PCCH_MessageType_c1(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_PCCH_MessageType_c1* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SQN_NR_PCCH_MessageType_c1_Sel)_tmp;
	}
	_serNrSysDecSQN_NR_PCCH_MessageType_c1_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PCCH_MessageType_messageClassExtension(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct SQN_NR_PCCH_MessageType_messageClassExtension* p)
{
	(void)_size; // TODO: generate boundaries checking

	(void)_buffer;
	(void)_size;
	(void)_lidx;
	(void)p;

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PCCH_MessageType_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union SQN_NR_PCCH_MessageType_Value* p, enum SQN_NR_PCCH_MessageType_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == SQN_NR_PCCH_MessageType_c1) {
		_serNrSysDecSQN_NR_PCCH_MessageType_c1(_buffer, _size, _lidx, _mem, &p->c1);
		return SIDL_STATUS_OK;
	}
	if (d == SQN_NR_PCCH_MessageType_messageClassExtension) {
		_serNrSysDecSQN_NR_PCCH_MessageType_messageClassExtension(_buffer, _size, _lidx, &p->messageClassExtension);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecSQN_NR_PCCH_MessageType(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_PCCH_MessageType* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum SQN_NR_PCCH_MessageType_Sel)_tmp;
	}
	_serNrSysDecSQN_NR_PCCH_MessageType_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecSQN_NR_PCCH_Message(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct SQN_NR_PCCH_Message* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecSQN_NR_PCCH_MessageType(_buffer, _size, _lidx, _mem, &p->message);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_SlotOffsetList_Type_SlotOffsetList_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_SlotOffsetList_Type_SlotOffsetList_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	NTOH_32(p->v.d, &_buffer[*_lidx], _lidx);
	p->v.v = (int32_t*)serMalloc(_mem, p->v.d * sizeof(int32_t));
	for (size_t i1 = 0; i1 < p->v.d; i1++) {
		NTOH_32(p->v.v[i1], &_buffer[*_lidx], _lidx);
	}

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_PagingTrigger_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_PagingTrigger_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecSQN_NR_PCCH_Message(_buffer, _size, _lidx, _mem, &p->Paging);
	_serNrSysDecNR_SlotOffsetList_Type_SlotOffsetList_Optional(_buffer, _size, _lidx, _mem, &p->SlotOffsetList);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_ASN1_ARFCN_ValueNR_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union NR_ASN1_ARFCN_ValueNR_Type_Value* p, enum NR_ASN1_ARFCN_ValueNR_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_ASN1_ARFCN_ValueNR_Type_R15) {
		NTOH_32(p->R15, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecNR_ASN1_ARFCN_ValueNR_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_ASN1_ARFCN_ValueNR_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum NR_ASN1_ARFCN_ValueNR_Type_Sel)_tmp;
	}
	_serNrSysDecNR_ASN1_ARFCN_ValueNR_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_ASN1_ARFCN_ValueNR_Type_Ssb_NRf1_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_ASN1_ARFCN_ValueNR_Type_Ssb_NRf1_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecNR_ASN1_ARFCN_ValueNR_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_ASN1_ARFCN_ValueNR_Type_Ssb_NRf2_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_ASN1_ARFCN_ValueNR_Type_Ssb_NRf2_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecNR_ASN1_ARFCN_ValueNR_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_ASN1_ARFCN_ValueNR_Type_Ssb_NRf3_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_ASN1_ARFCN_ValueNR_Type_Ssb_NRf3_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecNR_ASN1_ARFCN_ValueNR_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_ASN1_ARFCN_ValueNR_Type_Ssb_NRf4_Optional(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_ASN1_ARFCN_ValueNR_Type_Ssb_NRf4_Optional* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_8(p->d, &_buffer[*_lidx], _lidx);
	if (!p->d) return SIDL_STATUS_OK;
	_serNrSysDecNR_ASN1_ARFCN_ValueNR_Type(_buffer, _size, _lidx, &p->v);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecBand_SsbInfo_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct Band_SsbInfo_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_16(p->DeltaBand, &_buffer[*_lidx], _lidx);
	_serNrSysDecNR_ASN1_ARFCN_ValueNR_Type_Ssb_NRf1_Optional(_buffer, _size, _lidx, &p->Ssb_NRf1);
	_serNrSysDecNR_ASN1_ARFCN_ValueNR_Type_Ssb_NRf2_Optional(_buffer, _size, _lidx, &p->Ssb_NRf2);
	_serNrSysDecNR_ASN1_ARFCN_ValueNR_Type_Ssb_NRf3_Optional(_buffer, _size, _lidx, &p->Ssb_NRf3);
	_serNrSysDecNR_ASN1_ARFCN_ValueNR_Type_Ssb_NRf4_Optional(_buffer, _size, _lidx, &p->Ssb_NRf4);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_Band_SsbForDelta_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_Band_SsbForDelta_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecBand_SsbInfo_Type(_buffer, _size, _lidx, &p->DeltaPrimary);
	_serNrSysDecBand_SsbInfo_Type(_buffer, _size, _lidx, &p->DeltaSecondary);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_SystemRequest_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union NR_SystemRequest_Type_Value* p, enum NR_SystemRequest_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_SystemRequest_Type_Cell) {
		_serNrSysDecNR_CellConfigRequest_Type(_buffer, _size, _lidx, _mem, &p->Cell);
		return SIDL_STATUS_OK;
	}
	if (d == NR_SystemRequest_Type_CellAttenuationList) {
		NTOH_32(p->CellAttenuationList.d, &_buffer[*_lidx], _lidx);
		p->CellAttenuationList.v = (struct NR_CellAttenuationConfig_Type*)serMalloc(_mem, p->CellAttenuationList.d * sizeof(struct NR_CellAttenuationConfig_Type));
		for (size_t i1 = 0; i1 < p->CellAttenuationList.d; i1++) {
			_serNrSysDecNR_CellAttenuationConfig_Type(_buffer, _size, _lidx, &p->CellAttenuationList.v[i1]);
		}
		return SIDL_STATUS_OK;
	}
	if (d == NR_SystemRequest_Type_RadioBearerList) {
		NTOH_32(p->RadioBearerList.d, &_buffer[*_lidx], _lidx);
		p->RadioBearerList.v = (struct NR_RadioBearer_Type*)serMalloc(_mem, p->RadioBearerList.d * sizeof(struct NR_RadioBearer_Type));
		for (size_t i1 = 0; i1 < p->RadioBearerList.d; i1++) {
			_serNrSysDecNR_RadioBearer_Type(_buffer, _size, _lidx, _mem, &p->RadioBearerList.v[i1]);
		}
		return SIDL_STATUS_OK;
	}
	if (d == NR_SystemRequest_Type_EnquireTiming) {
		NTOH_8(p->EnquireTiming, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == NR_SystemRequest_Type_AS_Security) {
		_serNrSysDecNR_AS_Security_Type(_buffer, _size, _lidx, _mem, &p->AS_Security);
		return SIDL_STATUS_OK;
	}
	if (d == NR_SystemRequest_Type_PdcpCount) {
		_serNrSysDecNR_PDCP_CountReq_Type(_buffer, _size, _lidx, _mem, &p->PdcpCount);
		return SIDL_STATUS_OK;
	}
	if (d == NR_SystemRequest_Type_Paging) {
		_serNrSysDecNR_PagingTrigger_Type(_buffer, _size, _lidx, _mem, &p->Paging);
		return SIDL_STATUS_OK;
	}
	if (d == NR_SystemRequest_Type_DeltaValues) {
		_serNrSysDecNR_Band_SsbForDelta_Type(_buffer, _size, _lidx, &p->DeltaValues);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecNR_SystemRequest_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_SystemRequest_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum NR_SystemRequest_Type_Sel)_tmp;
	}
	_serNrSysDecNR_SystemRequest_Type_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_SYSTEM_CTRL_REQ(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_SYSTEM_CTRL_REQ* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecNR_ReqAspCommonPart_Type(_buffer, _size, _lidx, &p->Common);
	_serNrSysDecNR_SystemRequest_Type(_buffer, _size, _lidx, _mem, &p->Request);

	return SIDL_STATUS_OK;
}

int serNrSysProcessDecSrv(const unsigned char* _buffer, size_t _size, unsigned char* _arena, size_t _aSize, struct NR_SYSTEM_CTRL_REQ** FromSS)
{
	(void)_size; // TODO: generate boundaries checking

	serMem_t _mem = serMemInit(_arena, _aSize);

	size_t __lidx = 0;
	size_t* _lidx = &__lidx;

	*FromSS = (struct NR_SYSTEM_CTRL_REQ*)serMalloc(_mem, sizeof(struct NR_SYSTEM_CTRL_REQ));
	_serNrSysDecNR_SYSTEM_CTRL_REQ(_buffer, _size, _lidx, _mem, *FromSS);

	return SIDL_STATUS_OK;
}

static void _serNrSysFreeNR_TDD_UL_DL_SlotConfigList_Type_Dedicated_Optional(struct NR_TDD_UL_DL_SlotConfigList_Type_Dedicated_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i1 = 0; i1 < p->v.d; i1++) {
		}
		serFree(p->v.v);
	}
}

static void _serNrSysFreeNR_TDD_Config_Type(struct NR_TDD_Config_Type* p)
{
	_serNrSysFreeNR_TDD_UL_DL_SlotConfigList_Type_Dedicated_Optional(&p->Dedicated);
}

static void _serNrSysFreeNR_TDD_Info_Type_Value(union NR_TDD_Info_Type_Value* p, enum NR_TDD_Info_Type_Sel d)
{
	if (d == NR_TDD_Info_Type_Config) {
		_serNrSysFreeNR_TDD_Config_Type(&p->Config);
		return;
	}
}

static void _serNrSysFreeNR_TDD_Info_Type(struct NR_TDD_Info_Type* p)
{
	_serNrSysFreeNR_TDD_Info_Type_Value(&p->v, p->d);
}

static void _serNrSysFreeNR_DuplexMode_Type_Value(union NR_DuplexMode_Type_Value* p, enum NR_DuplexMode_Type_Sel d)
{
	if (d == NR_DuplexMode_Type_TDD) {
		_serNrSysFreeNR_TDD_Info_Type(&p->TDD);
		return;
	}
}

static void _serNrSysFreeNR_DuplexMode_Type(struct NR_DuplexMode_Type* p)
{
	_serNrSysFreeNR_DuplexMode_Type_Value(&p->v, p->d);
}

static void _serNrSysFreeNR_DuplexMode_Type_DuplexMode_Optional(struct NR_DuplexMode_Type_DuplexMode_Optional* p)
{
	if (!p->d) return;
	_serNrSysFreeNR_DuplexMode_Type(&p->v);
}

static void _serNrSysFreeNR_CellConfigPhysicalLayerCommon_Type(struct NR_CellConfigPhysicalLayerCommon_Type* p)
{
	_serNrSysFreeNR_DuplexMode_Type_DuplexMode_Optional(&p->DuplexMode);
}

static void _serNrSysFreeNR_CellConfigPhysicalLayerCommon_Type_Common_Optional(struct NR_CellConfigPhysicalLayerCommon_Type_Common_Optional* p)
{
	if (!p->d) return;
	_serNrSysFreeNR_CellConfigPhysicalLayerCommon_Type(&p->v);
}

static void _serNrSysFreeSQN_NR_FrequencyInfoDL(struct SQN_NR_FrequencyInfoDL* p)
{
	if (p->frequencyBandList.v) {
		serFree(p->frequencyBandList.v);
	}
	if (p->scs_SpecificCarrierList.v) {
		for (size_t i1 = 0; i1 < p->scs_SpecificCarrierList.d; i1++) {
		}
		serFree(p->scs_SpecificCarrierList.v);
	}
}

static void _serNrSysFreeNR_ASN1_FrequencyInfoDL_Type_Value(union NR_ASN1_FrequencyInfoDL_Type_Value* p, enum NR_ASN1_FrequencyInfoDL_Type_Sel d)
{
	if (d == NR_ASN1_FrequencyInfoDL_Type_R15) {
		_serNrSysFreeSQN_NR_FrequencyInfoDL(&p->R15);
		return;
	}
}

static void _serNrSysFreeNR_ASN1_FrequencyInfoDL_Type(struct NR_ASN1_FrequencyInfoDL_Type* p)
{
	_serNrSysFreeNR_ASN1_FrequencyInfoDL_Type_Value(&p->v, p->d);
}

static void _serNrSysFreeNR_ASN1_FrequencyInfoDL_Type_FrequencyInfoDL_Optional(struct NR_ASN1_FrequencyInfoDL_Type_FrequencyInfoDL_Optional* p)
{
	if (!p->d) return;
	_serNrSysFreeNR_ASN1_FrequencyInfoDL_Type(&p->v);
}

static void _serNrSysFreeNR_SSB_BeamArray_Type_BeamArray_Optional(struct NR_SSB_BeamArray_Type_BeamArray_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i1 = 0; i1 < p->v.d; i1++) {
		}
		serFree(p->v.v);
	}
}

static void _serNrSysFreeNR_SSB_BurstConfig_Type(struct NR_SSB_BurstConfig_Type* p)
{
	_serNrSysFreeNR_SSB_BeamArray_Type_BeamArray_Optional(&p->BeamArray);
}

static void _serNrSysFreeNR_SSB_BurstConfig_Type_BurstConfig_Optional(struct NR_SSB_BurstConfig_Type_BurstConfig_Optional* p)
{
	if (!p->d) return;
	_serNrSysFreeNR_SSB_BurstConfig_Type(&p->v);
}

static void _serNrSysFreeNR_SSB_Config_Type(struct NR_SSB_Config_Type* p)
{
	_serNrSysFreeNR_SSB_BurstConfig_Type_BurstConfig_Optional(&p->BurstConfig);
}

static void _serNrSysFreeNR_SSB_Config_Type_SSPbchBlock_Optional(struct NR_SSB_Config_Type_SSPbchBlock_Optional* p)
{
	if (!p->d) return;
	_serNrSysFreeNR_SSB_Config_Type(&p->v);
}

static void _serNrSysFreeNR_RateMatchPatternList_Type_PatternList_Optional(struct NR_RateMatchPatternList_Type_PatternList_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i1 = 0; i1 < p->v.d; i1++) {
		}
		serFree(p->v.v);
	}
}

static void _serNrSysFreeSQN_NR_EUTRA_MBSFN_SubframeConfigList_SQN_NR_RateMatchPatternLTE_CRS_mbsfn_SubframeConfigList_Optional(struct SQN_NR_EUTRA_MBSFN_SubframeConfigList_SQN_NR_RateMatchPatternLTE_CRS_mbsfn_SubframeConfigList_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i2 = 0; i2 < p->v.d; i2++) {
		}
		serFree(p->v.v);
	}
}

static void _serNrSysFreeSQN_NR_RateMatchPatternLTE_CRS(struct SQN_NR_RateMatchPatternLTE_CRS* p)
{
	_serNrSysFreeSQN_NR_EUTRA_MBSFN_SubframeConfigList_SQN_NR_RateMatchPatternLTE_CRS_mbsfn_SubframeConfigList_Optional(&p->mbsfn_SubframeConfigList);
}

static void _serNrSysFreeNR_ASN1_RateMatchPatternLTE_CRS_Type_Value(union NR_ASN1_RateMatchPatternLTE_CRS_Type_Value* p, enum NR_ASN1_RateMatchPatternLTE_CRS_Type_Sel d)
{
	if (d == NR_ASN1_RateMatchPatternLTE_CRS_Type_R15) {
		_serNrSysFreeSQN_NR_RateMatchPatternLTE_CRS(&p->R15);
		return;
	}
}

static void _serNrSysFreeNR_ASN1_RateMatchPatternLTE_CRS_Type(struct NR_ASN1_RateMatchPatternLTE_CRS_Type* p)
{
	_serNrSysFreeNR_ASN1_RateMatchPatternLTE_CRS_Type_Value(&p->v, p->d);
}

static void _serNrSysFreeNR_RateMatchPatternLteCrsList_Type_PatternListLteCrs_Optional(struct NR_RateMatchPatternLteCrsList_Type_PatternListLteCrs_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i1 = 0; i1 < p->v.d; i1++) {
			_serNrSysFreeNR_ASN1_RateMatchPatternLTE_CRS_Type(&p->v.v[i1]);
		}
		serFree(p->v.v);
	}
}

static void _serNrSysFreeNR_CellLevelRateMatchPattern_Type(struct NR_CellLevelRateMatchPattern_Type* p)
{
	_serNrSysFreeNR_RateMatchPatternList_Type_PatternList_Optional(&p->PatternList);
	_serNrSysFreeNR_RateMatchPatternLteCrsList_Type_PatternListLteCrs_Optional(&p->PatternListLteCrs);
}

static void _serNrSysFreeNR_CellLevelRateMatchPattern_Type_RateMatchPattern_Optional(struct NR_CellLevelRateMatchPattern_Type_RateMatchPattern_Optional* p)
{
	if (!p->d) return;
	_serNrSysFreeNR_CellLevelRateMatchPattern_Type(&p->v);
}

static void _serNrSysFreeSQN_NR_SetupRelease_PDSCH_ServingCellConfig_pdsch_CodeBlockGroupTransmissionList_r16_Value(union SQN_NR_SetupRelease_PDSCH_ServingCellConfig_pdsch_CodeBlockGroupTransmissionList_r16_Value* p, enum SQN_NR_SetupRelease_PDSCH_ServingCellConfig_pdsch_CodeBlockGroupTransmissionList_r16_Sel d)
{
	if (d == SQN_NR_SetupRelease_PDSCH_ServingCellConfig_pdsch_CodeBlockGroupTransmissionList_r16_setup) {
		if (p->setup.v) {
			for (size_t i1 = 0; i1 < p->setup.d; i1++) {
			}
			serFree(p->setup.v);
		}
		return;
	}
}

static void _serNrSysFreeSQN_NR_SetupRelease_PDSCH_ServingCellConfig_pdsch_CodeBlockGroupTransmissionList_r16(struct SQN_NR_SetupRelease_PDSCH_ServingCellConfig_pdsch_CodeBlockGroupTransmissionList_r16* p)
{
	_serNrSysFreeSQN_NR_SetupRelease_PDSCH_ServingCellConfig_pdsch_CodeBlockGroupTransmissionList_r16_Value(&p->v, p->d);
}

static void _serNrSysFreeSQN_NR_SetupRelease_PDSCH_ServingCellConfig_pdsch_CodeBlockGroupTransmissionList_r16_SQN_NR_PDSCH_ServingCellConfig_pdsch_CodeBlockGroupTransmissionList_r16_Optional(struct SQN_NR_SetupRelease_PDSCH_ServingCellConfig_pdsch_CodeBlockGroupTransmissionList_r16_SQN_NR_PDSCH_ServingCellConfig_pdsch_CodeBlockGroupTransmissionList_r16_Optional* p)
{
	if (!p->d) return;
	_serNrSysFreeSQN_NR_SetupRelease_PDSCH_ServingCellConfig_pdsch_CodeBlockGroupTransmissionList_r16(&p->v);
}

static void _serNrSysFreeSQN_NR_PDSCH_ServingCellConfig(struct SQN_NR_PDSCH_ServingCellConfig* p)
{
	_serNrSysFreeSQN_NR_SetupRelease_PDSCH_ServingCellConfig_pdsch_CodeBlockGroupTransmissionList_r16_SQN_NR_PDSCH_ServingCellConfig_pdsch_CodeBlockGroupTransmissionList_r16_Optional(&p->pdsch_CodeBlockGroupTransmissionList_r16);
}

static void _serNrSysFreeNR_ASN1_PDSCH_ServingCellConfig_Type_Value(union NR_ASN1_PDSCH_ServingCellConfig_Type_Value* p, enum NR_ASN1_PDSCH_ServingCellConfig_Type_Sel d)
{
	if (d == NR_ASN1_PDSCH_ServingCellConfig_Type_R15) {
		_serNrSysFreeSQN_NR_PDSCH_ServingCellConfig(&p->R15);
		return;
	}
}

static void _serNrSysFreeNR_ASN1_PDSCH_ServingCellConfig_Type(struct NR_ASN1_PDSCH_ServingCellConfig_Type* p)
{
	_serNrSysFreeNR_ASN1_PDSCH_ServingCellConfig_Type_Value(&p->v, p->d);
}

static void _serNrSysFreeNR_ASN1_PDSCH_ServingCellConfig_Type_ServingCellConfig_Optional(struct NR_ASN1_PDSCH_ServingCellConfig_Type_ServingCellConfig_Optional* p)
{
	if (!p->d) return;
	_serNrSysFreeNR_ASN1_PDSCH_ServingCellConfig_Type(&p->v);
}

static void _serNrSysFreeNR_PDSCH_CellLevelConfig_Type(struct NR_PDSCH_CellLevelConfig_Type* p)
{
	_serNrSysFreeNR_CellLevelRateMatchPattern_Type_RateMatchPattern_Optional(&p->RateMatchPattern);
	_serNrSysFreeNR_ASN1_PDSCH_ServingCellConfig_Type_ServingCellConfig_Optional(&p->ServingCellConfig);
}

static void _serNrSysFreeNR_PDSCH_CellLevelConfig_Type_PdschCellLevelConfig_Optional(struct NR_PDSCH_CellLevelConfig_Type_PdschCellLevelConfig_Optional* p)
{
	if (!p->d) return;
	_serNrSysFreeNR_PDSCH_CellLevelConfig_Type(&p->v);
}

static void _serNrSysFreeNR_BWP_SearchSpaceConfig_Type(struct NR_BWP_SearchSpaceConfig_Type* p)
{
	if (p->TypeAndPriorityList.v) {
		for (size_t i3 = 0; i3 < p->TypeAndPriorityList.d; i3++) {
		}
		serFree(p->TypeAndPriorityList.v);
	}
}

static void _serNrSysFreeNR_BWP_SearchSpaceList_Type_SearchSpaceArray_Optional(struct NR_BWP_SearchSpaceList_Type_SearchSpaceArray_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i2 = 0; i2 < p->v.d; i2++) {
			_serNrSysFreeNR_BWP_SearchSpaceConfig_Type(&p->v.v[i2]);
		}
		serFree(p->v.v);
	}
}

static void _serNrSysFreeSQN_NR_TCI_StateId_SQN_NR_ControlResourceSet_tci_StatesPDCCH_ToAddList_DynamicOptional(struct SQN_NR_TCI_StateId_SQN_NR_ControlResourceSet_tci_StatesPDCCH_ToAddList_DynamicOptional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		serFree(p->v.v);
	}
}

static void _serNrSysFreeSQN_NR_TCI_StateId_SQN_NR_ControlResourceSet_tci_StatesPDCCH_ToReleaseList_DynamicOptional(struct SQN_NR_TCI_StateId_SQN_NR_ControlResourceSet_tci_StatesPDCCH_ToReleaseList_DynamicOptional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		serFree(p->v.v);
	}
}

static void _serNrSysFreeSQN_NR_ControlResourceSet(struct SQN_NR_ControlResourceSet* p)
{
	_serNrSysFreeSQN_NR_TCI_StateId_SQN_NR_ControlResourceSet_tci_StatesPDCCH_ToAddList_DynamicOptional(&p->tci_StatesPDCCH_ToAddList);
	_serNrSysFreeSQN_NR_TCI_StateId_SQN_NR_ControlResourceSet_tci_StatesPDCCH_ToReleaseList_DynamicOptional(&p->tci_StatesPDCCH_ToReleaseList);
}

static void _serNrSysFreeNR_ASN1_ControlResourceSet_Type_Value(union NR_ASN1_ControlResourceSet_Type_Value* p, enum NR_ASN1_ControlResourceSet_Type_Sel d)
{
	if (d == NR_ASN1_ControlResourceSet_Type_R15) {
		_serNrSysFreeSQN_NR_ControlResourceSet(&p->R15);
		return;
	}
}

static void _serNrSysFreeNR_ASN1_ControlResourceSet_Type(struct NR_ASN1_ControlResourceSet_Type* p)
{
	_serNrSysFreeNR_ASN1_ControlResourceSet_Type_Value(&p->v, p->d);
}

static void _serNrSysFreeNR_BWP_CoresetList_Type_CoresetArray_Optional(struct NR_BWP_CoresetList_Type_CoresetArray_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i2 = 0; i2 < p->v.d; i2++) {
			_serNrSysFreeNR_ASN1_ControlResourceSet_Type(&p->v.v[i2]);
		}
		serFree(p->v.v);
	}
}

static void _serNrSysFreeNR_BWP_PDCCH_Configuration_Type(struct NR_BWP_PDCCH_Configuration_Type* p)
{
	_serNrSysFreeNR_BWP_SearchSpaceList_Type_SearchSpaceArray_Optional(&p->SearchSpaceArray);
	_serNrSysFreeNR_BWP_CoresetList_Type_CoresetArray_Optional(&p->CoresetArray);
}

static void _serNrSysFreeNR_BWP_PDCCH_Configuration_Type_Pdcch_Optional(struct NR_BWP_PDCCH_Configuration_Type_Pdcch_Optional* p)
{
	if (!p->d) return;
	_serNrSysFreeNR_BWP_PDCCH_Configuration_Type(&p->v);
}

static void _serNrSysFreeSQN_NR_PDSCH_TimeDomainResourceAllocationList_SQN_NR_PDSCH_ConfigCommon_pdsch_TimeDomainAllocationList_Optional(struct SQN_NR_PDSCH_TimeDomainResourceAllocationList_SQN_NR_PDSCH_ConfigCommon_pdsch_TimeDomainAllocationList_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i2 = 0; i2 < p->v.d; i2++) {
		}
		serFree(p->v.v);
	}
}

static void _serNrSysFreeSQN_NR_PDSCH_ConfigCommon(struct SQN_NR_PDSCH_ConfigCommon* p)
{
	_serNrSysFreeSQN_NR_PDSCH_TimeDomainResourceAllocationList_SQN_NR_PDSCH_ConfigCommon_pdsch_TimeDomainAllocationList_Optional(&p->pdsch_TimeDomainAllocationList);
}

static void _serNrSysFreeNR_ASN1_PDSCH_ConfigCommon_Type_Value(union NR_ASN1_PDSCH_ConfigCommon_Type_Value* p, enum NR_ASN1_PDSCH_ConfigCommon_Type_Sel d)
{
	if (d == NR_ASN1_PDSCH_ConfigCommon_Type_R15) {
		_serNrSysFreeSQN_NR_PDSCH_ConfigCommon(&p->R15);
		return;
	}
}

static void _serNrSysFreeNR_ASN1_PDSCH_ConfigCommon_Type(struct NR_ASN1_PDSCH_ConfigCommon_Type* p)
{
	_serNrSysFreeNR_ASN1_PDSCH_ConfigCommon_Type_Value(&p->v, p->d);
}

static void _serNrSysFreeNR_ASN1_PDSCH_ConfigCommon_Type_ConfigCommon_Optional(struct NR_ASN1_PDSCH_ConfigCommon_Type_ConfigCommon_Optional* p)
{
	if (!p->d) return;
	_serNrSysFreeNR_ASN1_PDSCH_ConfigCommon_Type(&p->v);
}

static void _serNrSysFreeSQN_NR_TCI_State_SQN_NR_PDSCH_Config_tci_StatesToAddModList_DynamicOptional(struct SQN_NR_TCI_State_SQN_NR_PDSCH_Config_tci_StatesToAddModList_DynamicOptional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i2 = 0; i2 < p->v.d; i2++) {
		}
		serFree(p->v.v);
	}
}

static void _serNrSysFreeSQN_NR_TCI_StateId_SQN_NR_PDSCH_Config_tci_StatesToReleaseList_DynamicOptional(struct SQN_NR_TCI_StateId_SQN_NR_PDSCH_Config_tci_StatesToReleaseList_DynamicOptional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		serFree(p->v.v);
	}
}

static void _serNrSysFreeSQN_NR_SetupRelease_PDSCH_Config_pdsch_TimeDomainAllocationList_Value(union SQN_NR_SetupRelease_PDSCH_Config_pdsch_TimeDomainAllocationList_Value* p, enum SQN_NR_SetupRelease_PDSCH_Config_pdsch_TimeDomainAllocationList_Sel d)
{
	if (d == SQN_NR_SetupRelease_PDSCH_Config_pdsch_TimeDomainAllocationList_setup) {
		if (p->setup.v) {
			for (size_t i2 = 0; i2 < p->setup.d; i2++) {
			}
			serFree(p->setup.v);
		}
		return;
	}
}

static void _serNrSysFreeSQN_NR_SetupRelease_PDSCH_Config_pdsch_TimeDomainAllocationList(struct SQN_NR_SetupRelease_PDSCH_Config_pdsch_TimeDomainAllocationList* p)
{
	_serNrSysFreeSQN_NR_SetupRelease_PDSCH_Config_pdsch_TimeDomainAllocationList_Value(&p->v, p->d);
}

static void _serNrSysFreeSQN_NR_SetupRelease_PDSCH_Config_pdsch_TimeDomainAllocationList_SQN_NR_PDSCH_Config_pdsch_TimeDomainAllocationList_Optional(struct SQN_NR_SetupRelease_PDSCH_Config_pdsch_TimeDomainAllocationList_SQN_NR_PDSCH_Config_pdsch_TimeDomainAllocationList_Optional* p)
{
	if (!p->d) return;
	_serNrSysFreeSQN_NR_SetupRelease_PDSCH_Config_pdsch_TimeDomainAllocationList(&p->v);
}

static void _serNrSysFreeSQN_NR_RateMatchPattern_SQN_NR_PDSCH_Config_rateMatchPatternToAddModList_DynamicOptional(struct SQN_NR_RateMatchPattern_SQN_NR_PDSCH_Config_rateMatchPatternToAddModList_DynamicOptional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i2 = 0; i2 < p->v.d; i2++) {
		}
		serFree(p->v.v);
	}
}

static void _serNrSysFreeSQN_NR_RateMatchPatternId_SQN_NR_PDSCH_Config_rateMatchPatternToReleaseList_DynamicOptional(struct SQN_NR_RateMatchPatternId_SQN_NR_PDSCH_Config_rateMatchPatternToReleaseList_DynamicOptional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		serFree(p->v.v);
	}
}

static void _serNrSysFreeSQN_NR_RateMatchPatternGroup_SQN_NR_PDSCH_Config_rateMatchPatternGroup1_Optional(struct SQN_NR_RateMatchPatternGroup_SQN_NR_PDSCH_Config_rateMatchPatternGroup1_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i2 = 0; i2 < p->v.d; i2++) {
		}
		serFree(p->v.v);
	}
}

static void _serNrSysFreeSQN_NR_RateMatchPatternGroup_SQN_NR_PDSCH_Config_rateMatchPatternGroup2_Optional(struct SQN_NR_RateMatchPatternGroup_SQN_NR_PDSCH_Config_rateMatchPatternGroup2_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i2 = 0; i2 < p->v.d; i2++) {
		}
		serFree(p->v.v);
	}
}

static void _serNrSysFreeSQN_NR_ZP_CSI_RS_Resource_SQN_NR_PDSCH_Config_zp_CSI_RS_ResourceToAddModList_DynamicOptional(struct SQN_NR_ZP_CSI_RS_Resource_SQN_NR_PDSCH_Config_zp_CSI_RS_ResourceToAddModList_DynamicOptional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i2 = 0; i2 < p->v.d; i2++) {
		}
		serFree(p->v.v);
	}
}

static void _serNrSysFreeSQN_NR_ZP_CSI_RS_ResourceId_SQN_NR_PDSCH_Config_zp_CSI_RS_ResourceToReleaseList_DynamicOptional(struct SQN_NR_ZP_CSI_RS_ResourceId_SQN_NR_PDSCH_Config_zp_CSI_RS_ResourceToReleaseList_DynamicOptional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		serFree(p->v.v);
	}
}

static void _serNrSysFreeSQN_NR_ZP_CSI_RS_ResourceSet(struct SQN_NR_ZP_CSI_RS_ResourceSet* p)
{
	if (p->zp_CSI_RS_ResourceIdList.v) {
		serFree(p->zp_CSI_RS_ResourceIdList.v);
	}
}

static void _serNrSysFreeSQN_NR_ZP_CSI_RS_ResourceSet_SQN_NR_PDSCH_Config_aperiodic_ZP_CSI_RS_ResourceSetsToAddModList_DynamicOptional(struct SQN_NR_ZP_CSI_RS_ResourceSet_SQN_NR_PDSCH_Config_aperiodic_ZP_CSI_RS_ResourceSetsToAddModList_DynamicOptional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i2 = 0; i2 < p->v.d; i2++) {
			_serNrSysFreeSQN_NR_ZP_CSI_RS_ResourceSet(&p->v.v[i2]);
		}
		serFree(p->v.v);
	}
}

static void _serNrSysFreeSQN_NR_ZP_CSI_RS_ResourceSetId_SQN_NR_PDSCH_Config_aperiodic_ZP_CSI_RS_ResourceSetsToReleaseList_DynamicOptional(struct SQN_NR_ZP_CSI_RS_ResourceSetId_SQN_NR_PDSCH_Config_aperiodic_ZP_CSI_RS_ResourceSetsToReleaseList_DynamicOptional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		serFree(p->v.v);
	}
}

static void _serNrSysFreeSQN_NR_ZP_CSI_RS_ResourceSet_SQN_NR_PDSCH_Config_sp_ZP_CSI_RS_ResourceSetsToAddModList_DynamicOptional(struct SQN_NR_ZP_CSI_RS_ResourceSet_SQN_NR_PDSCH_Config_sp_ZP_CSI_RS_ResourceSetsToAddModList_DynamicOptional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i2 = 0; i2 < p->v.d; i2++) {
			_serNrSysFreeSQN_NR_ZP_CSI_RS_ResourceSet(&p->v.v[i2]);
		}
		serFree(p->v.v);
	}
}

static void _serNrSysFreeSQN_NR_ZP_CSI_RS_ResourceSetId_SQN_NR_PDSCH_Config_sp_ZP_CSI_RS_ResourceSetsToReleaseList_DynamicOptional(struct SQN_NR_ZP_CSI_RS_ResourceSetId_SQN_NR_PDSCH_Config_sp_ZP_CSI_RS_ResourceSetsToReleaseList_DynamicOptional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		serFree(p->v.v);
	}
}

static void _serNrSysFreeSQN_NR_SetupRelease_PDSCH_Config_p_ZP_CSI_RS_ResourceSet_Value(union SQN_NR_SetupRelease_PDSCH_Config_p_ZP_CSI_RS_ResourceSet_Value* p, enum SQN_NR_SetupRelease_PDSCH_Config_p_ZP_CSI_RS_ResourceSet_Sel d)
{
	if (d == SQN_NR_SetupRelease_PDSCH_Config_p_ZP_CSI_RS_ResourceSet_setup) {
		_serNrSysFreeSQN_NR_ZP_CSI_RS_ResourceSet(&p->setup);
		return;
	}
}

static void _serNrSysFreeSQN_NR_SetupRelease_PDSCH_Config_p_ZP_CSI_RS_ResourceSet(struct SQN_NR_SetupRelease_PDSCH_Config_p_ZP_CSI_RS_ResourceSet* p)
{
	_serNrSysFreeSQN_NR_SetupRelease_PDSCH_Config_p_ZP_CSI_RS_ResourceSet_Value(&p->v, p->d);
}

static void _serNrSysFreeSQN_NR_SetupRelease_PDSCH_Config_p_ZP_CSI_RS_ResourceSet_SQN_NR_PDSCH_Config_p_ZP_CSI_RS_ResourceSet_Optional(struct SQN_NR_SetupRelease_PDSCH_Config_p_ZP_CSI_RS_ResourceSet_SQN_NR_PDSCH_Config_p_ZP_CSI_RS_ResourceSet_Optional* p)
{
	if (!p->d) return;
	_serNrSysFreeSQN_NR_SetupRelease_PDSCH_Config_p_ZP_CSI_RS_ResourceSet(&p->v);
}

static void _serNrSysFreeSQN_NR_SetupRelease_PDSCH_Config_minimumSchedulingOffsetK0_r16_Value(union SQN_NR_SetupRelease_PDSCH_Config_minimumSchedulingOffsetK0_r16_Value* p, enum SQN_NR_SetupRelease_PDSCH_Config_minimumSchedulingOffsetK0_r16_Sel d)
{
	if (d == SQN_NR_SetupRelease_PDSCH_Config_minimumSchedulingOffsetK0_r16_setup) {
		if (p->setup.v) {
			serFree(p->setup.v);
		}
		return;
	}
}

static void _serNrSysFreeSQN_NR_SetupRelease_PDSCH_Config_minimumSchedulingOffsetK0_r16(struct SQN_NR_SetupRelease_PDSCH_Config_minimumSchedulingOffsetK0_r16* p)
{
	_serNrSysFreeSQN_NR_SetupRelease_PDSCH_Config_minimumSchedulingOffsetK0_r16_Value(&p->v, p->d);
}

static void _serNrSysFreeSQN_NR_SetupRelease_PDSCH_Config_minimumSchedulingOffsetK0_r16_SQN_NR_PDSCH_Config_minimumSchedulingOffsetK0_r16_Optional(struct SQN_NR_SetupRelease_PDSCH_Config_minimumSchedulingOffsetK0_r16_SQN_NR_PDSCH_Config_minimumSchedulingOffsetK0_r16_Optional* p)
{
	if (!p->d) return;
	_serNrSysFreeSQN_NR_SetupRelease_PDSCH_Config_minimumSchedulingOffsetK0_r16(&p->v);
}

static void _serNrSysFreeSQN_NR_ZP_CSI_RS_ResourceSet_SQN_NR_PDSCH_Config_aperiodicZP_CSI_RS_ResourceSetsToAddModListDCI_1_2_r16_DynamicOptional(struct SQN_NR_ZP_CSI_RS_ResourceSet_SQN_NR_PDSCH_Config_aperiodicZP_CSI_RS_ResourceSetsToAddModListDCI_1_2_r16_DynamicOptional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i2 = 0; i2 < p->v.d; i2++) {
			_serNrSysFreeSQN_NR_ZP_CSI_RS_ResourceSet(&p->v.v[i2]);
		}
		serFree(p->v.v);
	}
}

static void _serNrSysFreeSQN_NR_ZP_CSI_RS_ResourceSetId_SQN_NR_PDSCH_Config_aperiodicZP_CSI_RS_ResourceSetsToReleaseListDCI_1_2_r16_DynamicOptional(struct SQN_NR_ZP_CSI_RS_ResourceSetId_SQN_NR_PDSCH_Config_aperiodicZP_CSI_RS_ResourceSetsToReleaseListDCI_1_2_r16_DynamicOptional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		serFree(p->v.v);
	}
}

static void _serNrSysFreeSQN_NR_SetupRelease_PDSCH_Config_pdsch_TimeDomainAllocationListDCI_1_2_r16_Value(union SQN_NR_SetupRelease_PDSCH_Config_pdsch_TimeDomainAllocationListDCI_1_2_r16_Value* p, enum SQN_NR_SetupRelease_PDSCH_Config_pdsch_TimeDomainAllocationListDCI_1_2_r16_Sel d)
{
	if (d == SQN_NR_SetupRelease_PDSCH_Config_pdsch_TimeDomainAllocationListDCI_1_2_r16_setup) {
		if (p->setup.v) {
			for (size_t i2 = 0; i2 < p->setup.d; i2++) {
			}
			serFree(p->setup.v);
		}
		return;
	}
}

static void _serNrSysFreeSQN_NR_SetupRelease_PDSCH_Config_pdsch_TimeDomainAllocationListDCI_1_2_r16(struct SQN_NR_SetupRelease_PDSCH_Config_pdsch_TimeDomainAllocationListDCI_1_2_r16* p)
{
	_serNrSysFreeSQN_NR_SetupRelease_PDSCH_Config_pdsch_TimeDomainAllocationListDCI_1_2_r16_Value(&p->v, p->d);
}

static void _serNrSysFreeSQN_NR_SetupRelease_PDSCH_Config_pdsch_TimeDomainAllocationListDCI_1_2_r16_SQN_NR_PDSCH_Config_pdsch_TimeDomainAllocationListDCI_1_2_r16_Optional(struct SQN_NR_SetupRelease_PDSCH_Config_pdsch_TimeDomainAllocationListDCI_1_2_r16_SQN_NR_PDSCH_Config_pdsch_TimeDomainAllocationListDCI_1_2_r16_Optional* p)
{
	if (!p->d) return;
	_serNrSysFreeSQN_NR_SetupRelease_PDSCH_Config_pdsch_TimeDomainAllocationListDCI_1_2_r16(&p->v);
}

static void _serNrSysFreeSQN_NR_RateMatchPatternGroup_SQN_NR_PDSCH_Config_rateMatchPatternGroup1DCI_1_2_r16_Optional(struct SQN_NR_RateMatchPatternGroup_SQN_NR_PDSCH_Config_rateMatchPatternGroup1DCI_1_2_r16_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i2 = 0; i2 < p->v.d; i2++) {
		}
		serFree(p->v.v);
	}
}

static void _serNrSysFreeSQN_NR_RateMatchPatternGroup_SQN_NR_PDSCH_Config_rateMatchPatternGroup2DCI_1_2_r16_Optional(struct SQN_NR_RateMatchPatternGroup_SQN_NR_PDSCH_Config_rateMatchPatternGroup2DCI_1_2_r16_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i2 = 0; i2 < p->v.d; i2++) {
		}
		serFree(p->v.v);
	}
}

static void _serNrSysFreeSQN_NR_SetupRelease_PDSCH_Config_pdsch_TimeDomainAllocationList_r16_Value(union SQN_NR_SetupRelease_PDSCH_Config_pdsch_TimeDomainAllocationList_r16_Value* p, enum SQN_NR_SetupRelease_PDSCH_Config_pdsch_TimeDomainAllocationList_r16_Sel d)
{
	if (d == SQN_NR_SetupRelease_PDSCH_Config_pdsch_TimeDomainAllocationList_r16_setup) {
		if (p->setup.v) {
			for (size_t i2 = 0; i2 < p->setup.d; i2++) {
			}
			serFree(p->setup.v);
		}
		return;
	}
}

static void _serNrSysFreeSQN_NR_SetupRelease_PDSCH_Config_pdsch_TimeDomainAllocationList_r16(struct SQN_NR_SetupRelease_PDSCH_Config_pdsch_TimeDomainAllocationList_r16* p)
{
	_serNrSysFreeSQN_NR_SetupRelease_PDSCH_Config_pdsch_TimeDomainAllocationList_r16_Value(&p->v, p->d);
}

static void _serNrSysFreeSQN_NR_SetupRelease_PDSCH_Config_pdsch_TimeDomainAllocationList_r16_SQN_NR_PDSCH_Config_pdsch_TimeDomainAllocationList_r16_Optional(struct SQN_NR_SetupRelease_PDSCH_Config_pdsch_TimeDomainAllocationList_r16_SQN_NR_PDSCH_Config_pdsch_TimeDomainAllocationList_r16_Optional* p)
{
	if (!p->d) return;
	_serNrSysFreeSQN_NR_SetupRelease_PDSCH_Config_pdsch_TimeDomainAllocationList_r16(&p->v);
}

static void _serNrSysFreeSQN_NR_PDSCH_Config(struct SQN_NR_PDSCH_Config* p)
{
	_serNrSysFreeSQN_NR_TCI_State_SQN_NR_PDSCH_Config_tci_StatesToAddModList_DynamicOptional(&p->tci_StatesToAddModList);
	_serNrSysFreeSQN_NR_TCI_StateId_SQN_NR_PDSCH_Config_tci_StatesToReleaseList_DynamicOptional(&p->tci_StatesToReleaseList);
	_serNrSysFreeSQN_NR_SetupRelease_PDSCH_Config_pdsch_TimeDomainAllocationList_SQN_NR_PDSCH_Config_pdsch_TimeDomainAllocationList_Optional(&p->pdsch_TimeDomainAllocationList);
	_serNrSysFreeSQN_NR_RateMatchPattern_SQN_NR_PDSCH_Config_rateMatchPatternToAddModList_DynamicOptional(&p->rateMatchPatternToAddModList);
	_serNrSysFreeSQN_NR_RateMatchPatternId_SQN_NR_PDSCH_Config_rateMatchPatternToReleaseList_DynamicOptional(&p->rateMatchPatternToReleaseList);
	_serNrSysFreeSQN_NR_RateMatchPatternGroup_SQN_NR_PDSCH_Config_rateMatchPatternGroup1_Optional(&p->rateMatchPatternGroup1);
	_serNrSysFreeSQN_NR_RateMatchPatternGroup_SQN_NR_PDSCH_Config_rateMatchPatternGroup2_Optional(&p->rateMatchPatternGroup2);
	_serNrSysFreeSQN_NR_ZP_CSI_RS_Resource_SQN_NR_PDSCH_Config_zp_CSI_RS_ResourceToAddModList_DynamicOptional(&p->zp_CSI_RS_ResourceToAddModList);
	_serNrSysFreeSQN_NR_ZP_CSI_RS_ResourceId_SQN_NR_PDSCH_Config_zp_CSI_RS_ResourceToReleaseList_DynamicOptional(&p->zp_CSI_RS_ResourceToReleaseList);
	_serNrSysFreeSQN_NR_ZP_CSI_RS_ResourceSet_SQN_NR_PDSCH_Config_aperiodic_ZP_CSI_RS_ResourceSetsToAddModList_DynamicOptional(&p->aperiodic_ZP_CSI_RS_ResourceSetsToAddModList);
	_serNrSysFreeSQN_NR_ZP_CSI_RS_ResourceSetId_SQN_NR_PDSCH_Config_aperiodic_ZP_CSI_RS_ResourceSetsToReleaseList_DynamicOptional(&p->aperiodic_ZP_CSI_RS_ResourceSetsToReleaseList);
	_serNrSysFreeSQN_NR_ZP_CSI_RS_ResourceSet_SQN_NR_PDSCH_Config_sp_ZP_CSI_RS_ResourceSetsToAddModList_DynamicOptional(&p->sp_ZP_CSI_RS_ResourceSetsToAddModList);
	_serNrSysFreeSQN_NR_ZP_CSI_RS_ResourceSetId_SQN_NR_PDSCH_Config_sp_ZP_CSI_RS_ResourceSetsToReleaseList_DynamicOptional(&p->sp_ZP_CSI_RS_ResourceSetsToReleaseList);
	_serNrSysFreeSQN_NR_SetupRelease_PDSCH_Config_p_ZP_CSI_RS_ResourceSet_SQN_NR_PDSCH_Config_p_ZP_CSI_RS_ResourceSet_Optional(&p->p_ZP_CSI_RS_ResourceSet);
	_serNrSysFreeSQN_NR_SetupRelease_PDSCH_Config_minimumSchedulingOffsetK0_r16_SQN_NR_PDSCH_Config_minimumSchedulingOffsetK0_r16_Optional(&p->minimumSchedulingOffsetK0_r16);
	_serNrSysFreeSQN_NR_ZP_CSI_RS_ResourceSet_SQN_NR_PDSCH_Config_aperiodicZP_CSI_RS_ResourceSetsToAddModListDCI_1_2_r16_DynamicOptional(&p->aperiodicZP_CSI_RS_ResourceSetsToAddModListDCI_1_2_r16);
	_serNrSysFreeSQN_NR_ZP_CSI_RS_ResourceSetId_SQN_NR_PDSCH_Config_aperiodicZP_CSI_RS_ResourceSetsToReleaseListDCI_1_2_r16_DynamicOptional(&p->aperiodicZP_CSI_RS_ResourceSetsToReleaseListDCI_1_2_r16);
	_serNrSysFreeSQN_NR_SetupRelease_PDSCH_Config_pdsch_TimeDomainAllocationListDCI_1_2_r16_SQN_NR_PDSCH_Config_pdsch_TimeDomainAllocationListDCI_1_2_r16_Optional(&p->pdsch_TimeDomainAllocationListDCI_1_2_r16);
	_serNrSysFreeSQN_NR_RateMatchPatternGroup_SQN_NR_PDSCH_Config_rateMatchPatternGroup1DCI_1_2_r16_Optional(&p->rateMatchPatternGroup1DCI_1_2_r16);
	_serNrSysFreeSQN_NR_RateMatchPatternGroup_SQN_NR_PDSCH_Config_rateMatchPatternGroup2DCI_1_2_r16_Optional(&p->rateMatchPatternGroup2DCI_1_2_r16);
	_serNrSysFreeSQN_NR_SetupRelease_PDSCH_Config_pdsch_TimeDomainAllocationList_r16_SQN_NR_PDSCH_Config_pdsch_TimeDomainAllocationList_r16_Optional(&p->pdsch_TimeDomainAllocationList_r16);
}

static void _serNrSysFreeNR_ASN1_PDSCH_Config_Type_Value(union NR_ASN1_PDSCH_Config_Type_Value* p, enum NR_ASN1_PDSCH_Config_Type_Sel d)
{
	if (d == NR_ASN1_PDSCH_Config_Type_R15) {
		_serNrSysFreeSQN_NR_PDSCH_Config(&p->R15);
		return;
	}
}

static void _serNrSysFreeNR_ASN1_PDSCH_Config_Type(struct NR_ASN1_PDSCH_Config_Type* p)
{
	_serNrSysFreeNR_ASN1_PDSCH_Config_Type_Value(&p->v, p->d);
}

static void _serNrSysFreeNR_ASN1_PDSCH_Config_Type_ConfigDedicated_Optional(struct NR_ASN1_PDSCH_Config_Type_ConfigDedicated_Optional* p)
{
	if (!p->d) return;
	_serNrSysFreeNR_ASN1_PDSCH_Config_Type(&p->v);
}

static void _serNrSysFreeNR_BWP_PDSCH_Configuration_Type(struct NR_BWP_PDSCH_Configuration_Type* p)
{
	_serNrSysFreeNR_ASN1_PDSCH_ConfigCommon_Type_ConfigCommon_Optional(&p->ConfigCommon);
	_serNrSysFreeNR_ASN1_PDSCH_Config_Type_ConfigDedicated_Optional(&p->ConfigDedicated);
}

static void _serNrSysFreeNR_BWP_PDSCH_Configuration_Type_Pdsch_Optional(struct NR_BWP_PDSCH_Configuration_Type_Pdsch_Optional* p)
{
	if (!p->d) return;
	_serNrSysFreeNR_BWP_PDSCH_Configuration_Type(&p->v);
}

static void _serNrSysFreeNR_DownlinkBWP_Type(struct NR_DownlinkBWP_Type* p)
{
	_serNrSysFreeNR_BWP_PDCCH_Configuration_Type_Pdcch_Optional(&p->Pdcch);
	_serNrSysFreeNR_BWP_PDSCH_Configuration_Type_Pdsch_Optional(&p->Pdsch);
}

static void _serNrSysFreeNR_DownlinkBWP_List_Type_BwpArray_Optional(struct NR_DownlinkBWP_List_Type_BwpArray_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i1 = 0; i1 < p->v.d; i1++) {
			_serNrSysFreeNR_DownlinkBWP_Type(&p->v.v[i1]);
		}
		serFree(p->v.v);
	}
}

static void _serNrSysFreeNR_DownlinkBWPs_Type(struct NR_DownlinkBWPs_Type* p)
{
	_serNrSysFreeNR_DownlinkBWP_List_Type_BwpArray_Optional(&p->BwpArray);
}

static void _serNrSysFreeNR_DownlinkBWPs_Type_BWPs_Optional(struct NR_DownlinkBWPs_Type_BWPs_Optional* p)
{
	if (!p->d) return;
	_serNrSysFreeNR_DownlinkBWPs_Type(&p->v);
}

static void _serNrSysFreeNR_CSI_Config_Type_Value(union NR_CSI_Config_Type_Value* p, enum NR_CSI_Config_Type_Sel d)
{
	if (d == NR_CSI_Config_Type_CSI_RS) {
		if (p->CSI_RS.v) {
			for (size_t i1 = 0; i1 < p->CSI_RS.d; i1++) {
			}
			serFree(p->CSI_RS.v);
		}
		return;
	}
}

static void _serNrSysFreeNR_CSI_Config_Type(struct NR_CSI_Config_Type* p)
{
	_serNrSysFreeNR_CSI_Config_Type_Value(&p->v, p->d);
}

static void _serNrSysFreeNR_CSI_Config_Type_CsiConfig_Optional(struct NR_CSI_Config_Type_CsiConfig_Optional* p)
{
	if (!p->d) return;
	_serNrSysFreeNR_CSI_Config_Type(&p->v);
}

static void _serNrSysFreeNR_CellConfigPhysicalLayerDownlink_Type(struct NR_CellConfigPhysicalLayerDownlink_Type* p)
{
	_serNrSysFreeNR_ASN1_FrequencyInfoDL_Type_FrequencyInfoDL_Optional(&p->FrequencyInfoDL);
	_serNrSysFreeNR_SSB_Config_Type_SSPbchBlock_Optional(&p->SSPbchBlock);
	_serNrSysFreeNR_PDSCH_CellLevelConfig_Type_PdschCellLevelConfig_Optional(&p->PdschCellLevelConfig);
	_serNrSysFreeNR_DownlinkBWPs_Type_BWPs_Optional(&p->BWPs);
	_serNrSysFreeNR_CSI_Config_Type_CsiConfig_Optional(&p->CsiConfig);
}

static void _serNrSysFreeNR_CellConfigPhysicalLayerDownlink_Type_Downlink_Optional(struct NR_CellConfigPhysicalLayerDownlink_Type_Downlink_Optional* p)
{
	if (!p->d) return;
	_serNrSysFreeNR_CellConfigPhysicalLayerDownlink_Type(&p->v);
}

static void _serNrSysFreeSQN_NR_MultiFrequencyBandListNR_SQN_NR_FrequencyInfoUL_frequencyBandList_Optional(struct SQN_NR_MultiFrequencyBandListNR_SQN_NR_FrequencyInfoUL_frequencyBandList_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		serFree(p->v.v);
	}
}

static void _serNrSysFreeSQN_NR_FrequencyInfoUL(struct SQN_NR_FrequencyInfoUL* p)
{
	_serNrSysFreeSQN_NR_MultiFrequencyBandListNR_SQN_NR_FrequencyInfoUL_frequencyBandList_Optional(&p->frequencyBandList);
	if (p->scs_SpecificCarrierList.v) {
		for (size_t i1 = 0; i1 < p->scs_SpecificCarrierList.d; i1++) {
		}
		serFree(p->scs_SpecificCarrierList.v);
	}
}

static void _serNrSysFreeNR_ASN1_FrequencyInfoUL_Type_Value(union NR_ASN1_FrequencyInfoUL_Type_Value* p, enum NR_ASN1_FrequencyInfoUL_Type_Sel d)
{
	if (d == NR_ASN1_FrequencyInfoUL_Type_R15) {
		_serNrSysFreeSQN_NR_FrequencyInfoUL(&p->R15);
		return;
	}
}

static void _serNrSysFreeNR_ASN1_FrequencyInfoUL_Type(struct NR_ASN1_FrequencyInfoUL_Type* p)
{
	_serNrSysFreeNR_ASN1_FrequencyInfoUL_Type_Value(&p->v, p->d);
}

static void _serNrSysFreeNR_ASN1_FrequencyInfoUL_Type_FrequencyInfoUL_Optional(struct NR_ASN1_FrequencyInfoUL_Type_FrequencyInfoUL_Optional* p)
{
	if (!p->d) return;
	_serNrSysFreeNR_ASN1_FrequencyInfoUL_Type(&p->v);
}

static void _serNrSysFreeSQN_NR_PUSCH_TimeDomainResourceAllocationList_SQN_NR_PUSCH_ConfigCommon_pusch_TimeDomainAllocationList_Optional(struct SQN_NR_PUSCH_TimeDomainResourceAllocationList_SQN_NR_PUSCH_ConfigCommon_pusch_TimeDomainAllocationList_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i2 = 0; i2 < p->v.d; i2++) {
		}
		serFree(p->v.v);
	}
}

static void _serNrSysFreeSQN_NR_PUSCH_ConfigCommon(struct SQN_NR_PUSCH_ConfigCommon* p)
{
	_serNrSysFreeSQN_NR_PUSCH_TimeDomainResourceAllocationList_SQN_NR_PUSCH_ConfigCommon_pusch_TimeDomainAllocationList_Optional(&p->pusch_TimeDomainAllocationList);
}

static void _serNrSysFreeSQN_NR_SetupRelease_BWP_UplinkCommon_pusch_ConfigCommon_Value(union SQN_NR_SetupRelease_BWP_UplinkCommon_pusch_ConfigCommon_Value* p, enum SQN_NR_SetupRelease_BWP_UplinkCommon_pusch_ConfigCommon_Sel d)
{
	if (d == SQN_NR_SetupRelease_BWP_UplinkCommon_pusch_ConfigCommon_setup) {
		_serNrSysFreeSQN_NR_PUSCH_ConfigCommon(&p->setup);
		return;
	}
}

static void _serNrSysFreeSQN_NR_SetupRelease_BWP_UplinkCommon_pusch_ConfigCommon(struct SQN_NR_SetupRelease_BWP_UplinkCommon_pusch_ConfigCommon* p)
{
	_serNrSysFreeSQN_NR_SetupRelease_BWP_UplinkCommon_pusch_ConfigCommon_Value(&p->v, p->d);
}

static void _serNrSysFreeSQN_NR_SetupRelease_BWP_UplinkCommon_pusch_ConfigCommon_SQN_NR_BWP_UplinkCommon_pusch_ConfigCommon_Optional(struct SQN_NR_SetupRelease_BWP_UplinkCommon_pusch_ConfigCommon_SQN_NR_BWP_UplinkCommon_pusch_ConfigCommon_Optional* p)
{
	if (!p->d) return;
	_serNrSysFreeSQN_NR_SetupRelease_BWP_UplinkCommon_pusch_ConfigCommon(&p->v);
}

static void _serNrSysFreeSQN_NR_BWP_UplinkCommon(struct SQN_NR_BWP_UplinkCommon* p)
{
	_serNrSysFreeSQN_NR_SetupRelease_BWP_UplinkCommon_pusch_ConfigCommon_SQN_NR_BWP_UplinkCommon_pusch_ConfigCommon_Optional(&p->pusch_ConfigCommon);
}

static void _serNrSysFreeNR_ASN1_BWP_UplinkCommon_Type_Value(union NR_ASN1_BWP_UplinkCommon_Type_Value* p, enum NR_ASN1_BWP_UplinkCommon_Type_Sel d)
{
	if (d == NR_ASN1_BWP_UplinkCommon_Type_R15) {
		_serNrSysFreeSQN_NR_BWP_UplinkCommon(&p->R15);
		return;
	}
}

static void _serNrSysFreeNR_ASN1_BWP_UplinkCommon_Type(struct NR_ASN1_BWP_UplinkCommon_Type* p)
{
	_serNrSysFreeNR_ASN1_BWP_UplinkCommon_Type_Value(&p->v, p->d);
}

static void _serNrSysFreeNR_ASN1_BWP_UplinkCommon_Type_Common_Optional(struct NR_ASN1_BWP_UplinkCommon_Type_Common_Optional* p)
{
	if (!p->d) return;
	_serNrSysFreeNR_ASN1_BWP_UplinkCommon_Type(&p->v);
}

static void _serNrSysFreeSQN_NR_PUCCH_ResourceSet(struct SQN_NR_PUCCH_ResourceSet* p)
{
	if (p->resourceList.v) {
		serFree(p->resourceList.v);
	}
}

static void _serNrSysFreeSQN_NR_PUCCH_ResourceSet_SQN_NR_PUCCH_Config_resourceSetToAddModList_DynamicOptional(struct SQN_NR_PUCCH_ResourceSet_SQN_NR_PUCCH_Config_resourceSetToAddModList_DynamicOptional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i2 = 0; i2 < p->v.d; i2++) {
			_serNrSysFreeSQN_NR_PUCCH_ResourceSet(&p->v.v[i2]);
		}
		serFree(p->v.v);
	}
}

static void _serNrSysFreeSQN_NR_PUCCH_ResourceSetId_SQN_NR_PUCCH_Config_resourceSetToReleaseList_DynamicOptional(struct SQN_NR_PUCCH_ResourceSetId_SQN_NR_PUCCH_Config_resourceSetToReleaseList_DynamicOptional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		serFree(p->v.v);
	}
}

static void _serNrSysFreeSQN_NR_PUCCH_Resource_SQN_NR_PUCCH_Config_resourceToAddModList_DynamicOptional(struct SQN_NR_PUCCH_Resource_SQN_NR_PUCCH_Config_resourceToAddModList_DynamicOptional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i2 = 0; i2 < p->v.d; i2++) {
		}
		serFree(p->v.v);
	}
}

static void _serNrSysFreeSQN_NR_PUCCH_ResourceId_SQN_NR_PUCCH_Config_resourceToReleaseList_DynamicOptional(struct SQN_NR_PUCCH_ResourceId_SQN_NR_PUCCH_Config_resourceToReleaseList_DynamicOptional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		serFree(p->v.v);
	}
}

static void _serNrSysFreeSQN_NR_SchedulingRequestResourceConfig_SQN_NR_PUCCH_Config_schedulingRequestResourceToAddModList_DynamicOptional(struct SQN_NR_SchedulingRequestResourceConfig_SQN_NR_PUCCH_Config_schedulingRequestResourceToAddModList_DynamicOptional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i2 = 0; i2 < p->v.d; i2++) {
		}
		serFree(p->v.v);
	}
}

static void _serNrSysFreeSQN_NR_SchedulingRequestResourceId_SQN_NR_PUCCH_Config_schedulingRequestResourceToReleaseList_DynamicOptional(struct SQN_NR_SchedulingRequestResourceId_SQN_NR_PUCCH_Config_schedulingRequestResourceToReleaseList_DynamicOptional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		serFree(p->v.v);
	}
}

static void _serNrSysFreeSQN_NR_PUCCH_ResourceId_SQN_NR_PUCCH_Config_multi_CSI_PUCCH_ResourceList_DynamicOptional(struct SQN_NR_PUCCH_ResourceId_SQN_NR_PUCCH_Config_multi_CSI_PUCCH_ResourceList_DynamicOptional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		serFree(p->v.v);
	}
}

static void _serNrSysFreeUint8_t_SQN_NR_PUCCH_Config_dl_DataToUL_ACK_DynamicOptional(struct uint8_t_SQN_NR_PUCCH_Config_dl_DataToUL_ACK_DynamicOptional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		serFree(p->v.v);
	}
}

static void _serNrSysFreeSQN_NR_PUCCH_SpatialRelationInfo_SQN_NR_PUCCH_Config_spatialRelationInfoToAddModList_DynamicOptional(struct SQN_NR_PUCCH_SpatialRelationInfo_SQN_NR_PUCCH_Config_spatialRelationInfoToAddModList_DynamicOptional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i2 = 0; i2 < p->v.d; i2++) {
		}
		serFree(p->v.v);
	}
}

static void _serNrSysFreeSQN_NR_PUCCH_SpatialRelationInfoId_SQN_NR_PUCCH_Config_spatialRelationInfoToReleaseList_DynamicOptional(struct SQN_NR_PUCCH_SpatialRelationInfoId_SQN_NR_PUCCH_Config_spatialRelationInfoToReleaseList_DynamicOptional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		serFree(p->v.v);
	}
}

static void _serNrSysFreeSQN_NR_P0_PUCCH_SQN_NR_PUCCH_PowerControl_p0_Set_DynamicOptional(struct SQN_NR_P0_PUCCH_SQN_NR_PUCCH_PowerControl_p0_Set_DynamicOptional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i2 = 0; i2 < p->v.d; i2++) {
		}
		serFree(p->v.v);
	}
}

static void _serNrSysFreeSQN_NR_PUCCH_PathlossReferenceRS_SQN_NR_PUCCH_PowerControl_pathlossReferenceRSs_DynamicOptional(struct SQN_NR_PUCCH_PathlossReferenceRS_SQN_NR_PUCCH_PowerControl_pathlossReferenceRSs_DynamicOptional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i2 = 0; i2 < p->v.d; i2++) {
		}
		serFree(p->v.v);
	}
}

static void _serNrSysFreeSQN_NR_SetupRelease_PUCCH_PowerControl_pathlossReferenceRSs_v1610_Value(union SQN_NR_SetupRelease_PUCCH_PowerControl_pathlossReferenceRSs_v1610_Value* p, enum SQN_NR_SetupRelease_PUCCH_PowerControl_pathlossReferenceRSs_v1610_Sel d)
{
	if (d == SQN_NR_SetupRelease_PUCCH_PowerControl_pathlossReferenceRSs_v1610_setup) {
		if (p->setup.v) {
			for (size_t i2 = 0; i2 < p->setup.d; i2++) {
			}
			serFree(p->setup.v);
		}
		return;
	}
}

static void _serNrSysFreeSQN_NR_SetupRelease_PUCCH_PowerControl_pathlossReferenceRSs_v1610(struct SQN_NR_SetupRelease_PUCCH_PowerControl_pathlossReferenceRSs_v1610* p)
{
	_serNrSysFreeSQN_NR_SetupRelease_PUCCH_PowerControl_pathlossReferenceRSs_v1610_Value(&p->v, p->d);
}

static void _serNrSysFreeSQN_NR_SetupRelease_PUCCH_PowerControl_pathlossReferenceRSs_v1610_SQN_NR_PUCCH_PowerControl_pathlossReferenceRSs_v1610_Optional(struct SQN_NR_SetupRelease_PUCCH_PowerControl_pathlossReferenceRSs_v1610_SQN_NR_PUCCH_PowerControl_pathlossReferenceRSs_v1610_Optional* p)
{
	if (!p->d) return;
	_serNrSysFreeSQN_NR_SetupRelease_PUCCH_PowerControl_pathlossReferenceRSs_v1610(&p->v);
}

static void _serNrSysFreeSQN_NR_PUCCH_PowerControl(struct SQN_NR_PUCCH_PowerControl* p)
{
	_serNrSysFreeSQN_NR_P0_PUCCH_SQN_NR_PUCCH_PowerControl_p0_Set_DynamicOptional(&p->p0_Set);
	_serNrSysFreeSQN_NR_PUCCH_PathlossReferenceRS_SQN_NR_PUCCH_PowerControl_pathlossReferenceRSs_DynamicOptional(&p->pathlossReferenceRSs);
	_serNrSysFreeSQN_NR_SetupRelease_PUCCH_PowerControl_pathlossReferenceRSs_v1610_SQN_NR_PUCCH_PowerControl_pathlossReferenceRSs_v1610_Optional(&p->pathlossReferenceRSs_v1610);
}

static void _serNrSysFreeSQN_NR_PUCCH_PowerControl_SQN_NR_PUCCH_Config_pucch_PowerControl_Optional(struct SQN_NR_PUCCH_PowerControl_SQN_NR_PUCCH_Config_pucch_PowerControl_Optional* p)
{
	if (!p->d) return;
	_serNrSysFreeSQN_NR_PUCCH_PowerControl(&p->v);
}

static void _serNrSysFreeSQN_NR_PUCCH_ResourceExt_r16_SQN_NR_PUCCH_Config_resourceToAddModListExt_r16_DynamicOptional(struct SQN_NR_PUCCH_ResourceExt_r16_SQN_NR_PUCCH_Config_resourceToAddModListExt_r16_DynamicOptional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i2 = 0; i2 < p->v.d; i2++) {
		}
		serFree(p->v.v);
	}
}

static void _serNrSysFreeSQN_NR_SetupRelease_PUCCH_Config_dl_DataToUL_ACK_r16_Value(union SQN_NR_SetupRelease_PUCCH_Config_dl_DataToUL_ACK_r16_Value* p, enum SQN_NR_SetupRelease_PUCCH_Config_dl_DataToUL_ACK_r16_Sel d)
{
	if (d == SQN_NR_SetupRelease_PUCCH_Config_dl_DataToUL_ACK_r16_setup) {
		if (p->setup.v) {
			serFree(p->setup.v);
		}
		return;
	}
}

static void _serNrSysFreeSQN_NR_SetupRelease_PUCCH_Config_dl_DataToUL_ACK_r16(struct SQN_NR_SetupRelease_PUCCH_Config_dl_DataToUL_ACK_r16* p)
{
	_serNrSysFreeSQN_NR_SetupRelease_PUCCH_Config_dl_DataToUL_ACK_r16_Value(&p->v, p->d);
}

static void _serNrSysFreeSQN_NR_SetupRelease_PUCCH_Config_dl_DataToUL_ACK_r16_SQN_NR_PUCCH_Config_dl_DataToUL_ACK_r16_Optional(struct SQN_NR_SetupRelease_PUCCH_Config_dl_DataToUL_ACK_r16_SQN_NR_PUCCH_Config_dl_DataToUL_ACK_r16_Optional* p)
{
	if (!p->d) return;
	_serNrSysFreeSQN_NR_SetupRelease_PUCCH_Config_dl_DataToUL_ACK_r16(&p->v);
}

static void _serNrSysFreeSQN_NR_SetupRelease_PUCCH_Config_ul_AccessConfigListDCI_1_1_r16_Value(union SQN_NR_SetupRelease_PUCCH_Config_ul_AccessConfigListDCI_1_1_r16_Value* p, enum SQN_NR_SetupRelease_PUCCH_Config_ul_AccessConfigListDCI_1_1_r16_Sel d)
{
	if (d == SQN_NR_SetupRelease_PUCCH_Config_ul_AccessConfigListDCI_1_1_r16_setup) {
		if (p->setup.v) {
			serFree(p->setup.v);
		}
		return;
	}
}

static void _serNrSysFreeSQN_NR_SetupRelease_PUCCH_Config_ul_AccessConfigListDCI_1_1_r16(struct SQN_NR_SetupRelease_PUCCH_Config_ul_AccessConfigListDCI_1_1_r16* p)
{
	_serNrSysFreeSQN_NR_SetupRelease_PUCCH_Config_ul_AccessConfigListDCI_1_1_r16_Value(&p->v, p->d);
}

static void _serNrSysFreeSQN_NR_SetupRelease_PUCCH_Config_ul_AccessConfigListDCI_1_1_r16_SQN_NR_PUCCH_Config_ul_AccessConfigListDCI_1_1_r16_Optional(struct SQN_NR_SetupRelease_PUCCH_Config_ul_AccessConfigListDCI_1_1_r16_SQN_NR_PUCCH_Config_ul_AccessConfigListDCI_1_1_r16_Optional* p)
{
	if (!p->d) return;
	_serNrSysFreeSQN_NR_SetupRelease_PUCCH_Config_ul_AccessConfigListDCI_1_1_r16(&p->v);
}

static void _serNrSysFreeSQN_NR_SetupRelease_PUCCH_Config_dl_DataToUL_ACK_DCI_1_2_r16_Value(union SQN_NR_SetupRelease_PUCCH_Config_dl_DataToUL_ACK_DCI_1_2_r16_Value* p, enum SQN_NR_SetupRelease_PUCCH_Config_dl_DataToUL_ACK_DCI_1_2_r16_Sel d)
{
	if (d == SQN_NR_SetupRelease_PUCCH_Config_dl_DataToUL_ACK_DCI_1_2_r16_setup) {
		if (p->setup.v) {
			serFree(p->setup.v);
		}
		return;
	}
}

static void _serNrSysFreeSQN_NR_SetupRelease_PUCCH_Config_dl_DataToUL_ACK_DCI_1_2_r16(struct SQN_NR_SetupRelease_PUCCH_Config_dl_DataToUL_ACK_DCI_1_2_r16* p)
{
	_serNrSysFreeSQN_NR_SetupRelease_PUCCH_Config_dl_DataToUL_ACK_DCI_1_2_r16_Value(&p->v, p->d);
}

static void _serNrSysFreeSQN_NR_SetupRelease_PUCCH_Config_dl_DataToUL_ACK_DCI_1_2_r16_SQN_NR_PUCCH_Config_dl_DataToUL_ACK_DCI_1_2_r16_Optional(struct SQN_NR_SetupRelease_PUCCH_Config_dl_DataToUL_ACK_DCI_1_2_r16_SQN_NR_PUCCH_Config_dl_DataToUL_ACK_DCI_1_2_r16_Optional* p)
{
	if (!p->d) return;
	_serNrSysFreeSQN_NR_SetupRelease_PUCCH_Config_dl_DataToUL_ACK_DCI_1_2_r16(&p->v);
}

static void _serNrSysFreeSQN_NR_PUCCH_SpatialRelationInfo_SQN_NR_PUCCH_Config_spatialRelationInfoToAddModList2_r16_DynamicOptional(struct SQN_NR_PUCCH_SpatialRelationInfo_SQN_NR_PUCCH_Config_spatialRelationInfoToAddModList2_r16_DynamicOptional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i2 = 0; i2 < p->v.d; i2++) {
		}
		serFree(p->v.v);
	}
}

static void _serNrSysFreeSQN_NR_PUCCH_SpatialRelationInfoId_SQN_NR_PUCCH_Config_spatialRelationInfoToReleaseList2_r16_DynamicOptional(struct SQN_NR_PUCCH_SpatialRelationInfoId_SQN_NR_PUCCH_Config_spatialRelationInfoToReleaseList2_r16_DynamicOptional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		serFree(p->v.v);
	}
}

static void _serNrSysFreeSQN_NR_PUCCH_SpatialRelationInfoExt_r16_SQN_NR_PUCCH_Config_spatialRelationInfoToAddModListExt_r16_DynamicOptional(struct SQN_NR_PUCCH_SpatialRelationInfoExt_r16_SQN_NR_PUCCH_Config_spatialRelationInfoToAddModListExt_r16_DynamicOptional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i2 = 0; i2 < p->v.d; i2++) {
		}
		serFree(p->v.v);
	}
}

static void _serNrSysFreeSQN_NR_PUCCH_SpatialRelationInfoId_r16_SQN_NR_PUCCH_Config_spatialRelationInfoToReleaseList_r16_DynamicOptional(struct SQN_NR_PUCCH_SpatialRelationInfoId_r16_SQN_NR_PUCCH_Config_spatialRelationInfoToReleaseList_r16_DynamicOptional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		serFree(p->v.v);
	}
}

static void _serNrSysFreeSQN_NR_PUCCH_ResourceGroup_r16(struct SQN_NR_PUCCH_ResourceGroup_r16* p)
{
	if (p->resourcePerGroupList_r16.v) {
		serFree(p->resourcePerGroupList_r16.v);
	}
}

static void _serNrSysFreeSQN_NR_PUCCH_ResourceGroup_r16_SQN_NR_PUCCH_Config_resourceGroupToAddModList_r16_DynamicOptional(struct SQN_NR_PUCCH_ResourceGroup_r16_SQN_NR_PUCCH_Config_resourceGroupToAddModList_r16_DynamicOptional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i2 = 0; i2 < p->v.d; i2++) {
			_serNrSysFreeSQN_NR_PUCCH_ResourceGroup_r16(&p->v.v[i2]);
		}
		serFree(p->v.v);
	}
}

static void _serNrSysFreeSQN_NR_PUCCH_ResourceGroupId_r16_SQN_NR_PUCCH_Config_resourceGroupToReleaseList_r16_DynamicOptional(struct SQN_NR_PUCCH_ResourceGroupId_r16_SQN_NR_PUCCH_Config_resourceGroupToReleaseList_r16_DynamicOptional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		serFree(p->v.v);
	}
}

static void _serNrSysFreeSQN_NR_SetupRelease_PUCCH_Config_sps_PUCCH_AN_List_r16_Value(union SQN_NR_SetupRelease_PUCCH_Config_sps_PUCCH_AN_List_r16_Value* p, enum SQN_NR_SetupRelease_PUCCH_Config_sps_PUCCH_AN_List_r16_Sel d)
{
	if (d == SQN_NR_SetupRelease_PUCCH_Config_sps_PUCCH_AN_List_r16_setup) {
		if (p->setup.v) {
			for (size_t i2 = 0; i2 < p->setup.d; i2++) {
			}
			serFree(p->setup.v);
		}
		return;
	}
}

static void _serNrSysFreeSQN_NR_SetupRelease_PUCCH_Config_sps_PUCCH_AN_List_r16(struct SQN_NR_SetupRelease_PUCCH_Config_sps_PUCCH_AN_List_r16* p)
{
	_serNrSysFreeSQN_NR_SetupRelease_PUCCH_Config_sps_PUCCH_AN_List_r16_Value(&p->v, p->d);
}

static void _serNrSysFreeSQN_NR_SetupRelease_PUCCH_Config_sps_PUCCH_AN_List_r16_SQN_NR_PUCCH_Config_sps_PUCCH_AN_List_r16_Optional(struct SQN_NR_SetupRelease_PUCCH_Config_sps_PUCCH_AN_List_r16_SQN_NR_PUCCH_Config_sps_PUCCH_AN_List_r16_Optional* p)
{
	if (!p->d) return;
	_serNrSysFreeSQN_NR_SetupRelease_PUCCH_Config_sps_PUCCH_AN_List_r16(&p->v);
}

static void _serNrSysFreeSQN_NR_SchedulingRequestResourceConfig_v1610_SQN_NR_PUCCH_Config_schedulingRequestResourceToAddModList_v1610_DynamicOptional(struct SQN_NR_SchedulingRequestResourceConfig_v1610_SQN_NR_PUCCH_Config_schedulingRequestResourceToAddModList_v1610_DynamicOptional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i2 = 0; i2 < p->v.d; i2++) {
		}
		serFree(p->v.v);
	}
}

static void _serNrSysFreeSQN_NR_PUCCH_Config(struct SQN_NR_PUCCH_Config* p)
{
	_serNrSysFreeSQN_NR_PUCCH_ResourceSet_SQN_NR_PUCCH_Config_resourceSetToAddModList_DynamicOptional(&p->resourceSetToAddModList);
	_serNrSysFreeSQN_NR_PUCCH_ResourceSetId_SQN_NR_PUCCH_Config_resourceSetToReleaseList_DynamicOptional(&p->resourceSetToReleaseList);
	_serNrSysFreeSQN_NR_PUCCH_Resource_SQN_NR_PUCCH_Config_resourceToAddModList_DynamicOptional(&p->resourceToAddModList);
	_serNrSysFreeSQN_NR_PUCCH_ResourceId_SQN_NR_PUCCH_Config_resourceToReleaseList_DynamicOptional(&p->resourceToReleaseList);
	_serNrSysFreeSQN_NR_SchedulingRequestResourceConfig_SQN_NR_PUCCH_Config_schedulingRequestResourceToAddModList_DynamicOptional(&p->schedulingRequestResourceToAddModList);
	_serNrSysFreeSQN_NR_SchedulingRequestResourceId_SQN_NR_PUCCH_Config_schedulingRequestResourceToReleaseList_DynamicOptional(&p->schedulingRequestResourceToReleaseList);
	_serNrSysFreeSQN_NR_PUCCH_ResourceId_SQN_NR_PUCCH_Config_multi_CSI_PUCCH_ResourceList_DynamicOptional(&p->multi_CSI_PUCCH_ResourceList);
	_serNrSysFreeUint8_t_SQN_NR_PUCCH_Config_dl_DataToUL_ACK_DynamicOptional(&p->dl_DataToUL_ACK);
	_serNrSysFreeSQN_NR_PUCCH_SpatialRelationInfo_SQN_NR_PUCCH_Config_spatialRelationInfoToAddModList_DynamicOptional(&p->spatialRelationInfoToAddModList);
	_serNrSysFreeSQN_NR_PUCCH_SpatialRelationInfoId_SQN_NR_PUCCH_Config_spatialRelationInfoToReleaseList_DynamicOptional(&p->spatialRelationInfoToReleaseList);
	_serNrSysFreeSQN_NR_PUCCH_PowerControl_SQN_NR_PUCCH_Config_pucch_PowerControl_Optional(&p->pucch_PowerControl);
	_serNrSysFreeSQN_NR_PUCCH_ResourceExt_r16_SQN_NR_PUCCH_Config_resourceToAddModListExt_r16_DynamicOptional(&p->resourceToAddModListExt_r16);
	_serNrSysFreeSQN_NR_SetupRelease_PUCCH_Config_dl_DataToUL_ACK_r16_SQN_NR_PUCCH_Config_dl_DataToUL_ACK_r16_Optional(&p->dl_DataToUL_ACK_r16);
	_serNrSysFreeSQN_NR_SetupRelease_PUCCH_Config_ul_AccessConfigListDCI_1_1_r16_SQN_NR_PUCCH_Config_ul_AccessConfigListDCI_1_1_r16_Optional(&p->ul_AccessConfigListDCI_1_1_r16);
	_serNrSysFreeSQN_NR_SetupRelease_PUCCH_Config_dl_DataToUL_ACK_DCI_1_2_r16_SQN_NR_PUCCH_Config_dl_DataToUL_ACK_DCI_1_2_r16_Optional(&p->dl_DataToUL_ACK_DCI_1_2_r16);
	_serNrSysFreeSQN_NR_PUCCH_SpatialRelationInfo_SQN_NR_PUCCH_Config_spatialRelationInfoToAddModList2_r16_DynamicOptional(&p->spatialRelationInfoToAddModList2_r16);
	_serNrSysFreeSQN_NR_PUCCH_SpatialRelationInfoId_SQN_NR_PUCCH_Config_spatialRelationInfoToReleaseList2_r16_DynamicOptional(&p->spatialRelationInfoToReleaseList2_r16);
	_serNrSysFreeSQN_NR_PUCCH_SpatialRelationInfoExt_r16_SQN_NR_PUCCH_Config_spatialRelationInfoToAddModListExt_r16_DynamicOptional(&p->spatialRelationInfoToAddModListExt_r16);
	_serNrSysFreeSQN_NR_PUCCH_SpatialRelationInfoId_r16_SQN_NR_PUCCH_Config_spatialRelationInfoToReleaseList_r16_DynamicOptional(&p->spatialRelationInfoToReleaseList_r16);
	_serNrSysFreeSQN_NR_PUCCH_ResourceGroup_r16_SQN_NR_PUCCH_Config_resourceGroupToAddModList_r16_DynamicOptional(&p->resourceGroupToAddModList_r16);
	_serNrSysFreeSQN_NR_PUCCH_ResourceGroupId_r16_SQN_NR_PUCCH_Config_resourceGroupToReleaseList_r16_DynamicOptional(&p->resourceGroupToReleaseList_r16);
	_serNrSysFreeSQN_NR_SetupRelease_PUCCH_Config_sps_PUCCH_AN_List_r16_SQN_NR_PUCCH_Config_sps_PUCCH_AN_List_r16_Optional(&p->sps_PUCCH_AN_List_r16);
	_serNrSysFreeSQN_NR_SchedulingRequestResourceConfig_v1610_SQN_NR_PUCCH_Config_schedulingRequestResourceToAddModList_v1610_DynamicOptional(&p->schedulingRequestResourceToAddModList_v1610);
}

static void _serNrSysFreeSQN_NR_SetupRelease_BWP_UplinkDedicated_pucch_Config_Value(union SQN_NR_SetupRelease_BWP_UplinkDedicated_pucch_Config_Value* p, enum SQN_NR_SetupRelease_BWP_UplinkDedicated_pucch_Config_Sel d)
{
	if (d == SQN_NR_SetupRelease_BWP_UplinkDedicated_pucch_Config_setup) {
		_serNrSysFreeSQN_NR_PUCCH_Config(&p->setup);
		return;
	}
}

static void _serNrSysFreeSQN_NR_SetupRelease_BWP_UplinkDedicated_pucch_Config(struct SQN_NR_SetupRelease_BWP_UplinkDedicated_pucch_Config* p)
{
	_serNrSysFreeSQN_NR_SetupRelease_BWP_UplinkDedicated_pucch_Config_Value(&p->v, p->d);
}

static void _serNrSysFreeSQN_NR_SetupRelease_BWP_UplinkDedicated_pucch_Config_SQN_NR_BWP_UplinkDedicated_pucch_Config_Optional(struct SQN_NR_SetupRelease_BWP_UplinkDedicated_pucch_Config_SQN_NR_BWP_UplinkDedicated_pucch_Config_Optional* p)
{
	if (!p->d) return;
	_serNrSysFreeSQN_NR_SetupRelease_BWP_UplinkDedicated_pucch_Config(&p->v);
}

static void _serNrSysFreeSQN_NR_P0_PUSCH_AlphaSet_SQN_NR_PUSCH_PowerControl_p0_AlphaSets_DynamicOptional(struct SQN_NR_P0_PUSCH_AlphaSet_SQN_NR_PUSCH_PowerControl_p0_AlphaSets_DynamicOptional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i2 = 0; i2 < p->v.d; i2++) {
		}
		serFree(p->v.v);
	}
}

static void _serNrSysFreeSQN_NR_PUSCH_PathlossReferenceRS_SQN_NR_PUSCH_PowerControl_pathlossReferenceRSToAddModList_DynamicOptional(struct SQN_NR_PUSCH_PathlossReferenceRS_SQN_NR_PUSCH_PowerControl_pathlossReferenceRSToAddModList_DynamicOptional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i2 = 0; i2 < p->v.d; i2++) {
		}
		serFree(p->v.v);
	}
}

static void _serNrSysFreeSQN_NR_PUSCH_PathlossReferenceRS_Id_SQN_NR_PUSCH_PowerControl_pathlossReferenceRSToReleaseList_DynamicOptional(struct SQN_NR_PUSCH_PathlossReferenceRS_Id_SQN_NR_PUSCH_PowerControl_pathlossReferenceRSToReleaseList_DynamicOptional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		serFree(p->v.v);
	}
}

static void _serNrSysFreeSQN_NR_SRI_PUSCH_PowerControl_SQN_NR_PUSCH_PowerControl_sri_PUSCH_MappingToAddModList_DynamicOptional(struct SQN_NR_SRI_PUSCH_PowerControl_SQN_NR_PUSCH_PowerControl_sri_PUSCH_MappingToAddModList_DynamicOptional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i2 = 0; i2 < p->v.d; i2++) {
		}
		serFree(p->v.v);
	}
}

static void _serNrSysFreeSQN_NR_SRI_PUSCH_PowerControlId_SQN_NR_PUSCH_PowerControl_sri_PUSCH_MappingToReleaseList_DynamicOptional(struct SQN_NR_SRI_PUSCH_PowerControlId_SQN_NR_PUSCH_PowerControl_sri_PUSCH_MappingToReleaseList_DynamicOptional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		serFree(p->v.v);
	}
}

static void _serNrSysFreeSQN_NR_PUSCH_PowerControl(struct SQN_NR_PUSCH_PowerControl* p)
{
	_serNrSysFreeSQN_NR_P0_PUSCH_AlphaSet_SQN_NR_PUSCH_PowerControl_p0_AlphaSets_DynamicOptional(&p->p0_AlphaSets);
	_serNrSysFreeSQN_NR_PUSCH_PathlossReferenceRS_SQN_NR_PUSCH_PowerControl_pathlossReferenceRSToAddModList_DynamicOptional(&p->pathlossReferenceRSToAddModList);
	_serNrSysFreeSQN_NR_PUSCH_PathlossReferenceRS_Id_SQN_NR_PUSCH_PowerControl_pathlossReferenceRSToReleaseList_DynamicOptional(&p->pathlossReferenceRSToReleaseList);
	_serNrSysFreeSQN_NR_SRI_PUSCH_PowerControl_SQN_NR_PUSCH_PowerControl_sri_PUSCH_MappingToAddModList_DynamicOptional(&p->sri_PUSCH_MappingToAddModList);
	_serNrSysFreeSQN_NR_SRI_PUSCH_PowerControlId_SQN_NR_PUSCH_PowerControl_sri_PUSCH_MappingToReleaseList_DynamicOptional(&p->sri_PUSCH_MappingToReleaseList);
}

static void _serNrSysFreeSQN_NR_PUSCH_PowerControl_SQN_NR_PUSCH_Config_pusch_PowerControl_Optional(struct SQN_NR_PUSCH_PowerControl_SQN_NR_PUSCH_Config_pusch_PowerControl_Optional* p)
{
	if (!p->d) return;
	_serNrSysFreeSQN_NR_PUSCH_PowerControl(&p->v);
}

static void _serNrSysFreeUint16_t_SQN_NR_PUSCH_Config_frequencyHoppingOffsetLists_DynamicOptional(struct uint16_t_SQN_NR_PUSCH_Config_frequencyHoppingOffsetLists_DynamicOptional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		serFree(p->v.v);
	}
}

static void _serNrSysFreeSQN_NR_SetupRelease_PUSCH_Config_pusch_TimeDomainAllocationList_Value(union SQN_NR_SetupRelease_PUSCH_Config_pusch_TimeDomainAllocationList_Value* p, enum SQN_NR_SetupRelease_PUSCH_Config_pusch_TimeDomainAllocationList_Sel d)
{
	if (d == SQN_NR_SetupRelease_PUSCH_Config_pusch_TimeDomainAllocationList_setup) {
		if (p->setup.v) {
			for (size_t i2 = 0; i2 < p->setup.d; i2++) {
			}
			serFree(p->setup.v);
		}
		return;
	}
}

static void _serNrSysFreeSQN_NR_SetupRelease_PUSCH_Config_pusch_TimeDomainAllocationList(struct SQN_NR_SetupRelease_PUSCH_Config_pusch_TimeDomainAllocationList* p)
{
	_serNrSysFreeSQN_NR_SetupRelease_PUSCH_Config_pusch_TimeDomainAllocationList_Value(&p->v, p->d);
}

static void _serNrSysFreeSQN_NR_SetupRelease_PUSCH_Config_pusch_TimeDomainAllocationList_SQN_NR_PUSCH_Config_pusch_TimeDomainAllocationList_Optional(struct SQN_NR_SetupRelease_PUSCH_Config_pusch_TimeDomainAllocationList_SQN_NR_PUSCH_Config_pusch_TimeDomainAllocationList_Optional* p)
{
	if (!p->d) return;
	_serNrSysFreeSQN_NR_SetupRelease_PUSCH_Config_pusch_TimeDomainAllocationList(&p->v);
}

static void _serNrSysFreeSQN_NR_SetupRelease_PUSCH_Config_minimumSchedulingOffsetK2_r16_Value(union SQN_NR_SetupRelease_PUSCH_Config_minimumSchedulingOffsetK2_r16_Value* p, enum SQN_NR_SetupRelease_PUSCH_Config_minimumSchedulingOffsetK2_r16_Sel d)
{
	if (d == SQN_NR_SetupRelease_PUSCH_Config_minimumSchedulingOffsetK2_r16_setup) {
		if (p->setup.v) {
			serFree(p->setup.v);
		}
		return;
	}
}

static void _serNrSysFreeSQN_NR_SetupRelease_PUSCH_Config_minimumSchedulingOffsetK2_r16(struct SQN_NR_SetupRelease_PUSCH_Config_minimumSchedulingOffsetK2_r16* p)
{
	_serNrSysFreeSQN_NR_SetupRelease_PUSCH_Config_minimumSchedulingOffsetK2_r16_Value(&p->v, p->d);
}

static void _serNrSysFreeSQN_NR_SetupRelease_PUSCH_Config_minimumSchedulingOffsetK2_r16_SQN_NR_PUSCH_Config_minimumSchedulingOffsetK2_r16_Optional(struct SQN_NR_SetupRelease_PUSCH_Config_minimumSchedulingOffsetK2_r16_SQN_NR_PUSCH_Config_minimumSchedulingOffsetK2_r16_Optional* p)
{
	if (!p->d) return;
	_serNrSysFreeSQN_NR_SetupRelease_PUSCH_Config_minimumSchedulingOffsetK2_r16(&p->v);
}

static void _serNrSysFreeSQN_NR_SetupRelease_PUSCH_Config_ul_AccessConfigListDCI_0_1_r16_Value(union SQN_NR_SetupRelease_PUSCH_Config_ul_AccessConfigListDCI_0_1_r16_Value* p, enum SQN_NR_SetupRelease_PUSCH_Config_ul_AccessConfigListDCI_0_1_r16_Sel d)
{
	if (d == SQN_NR_SetupRelease_PUSCH_Config_ul_AccessConfigListDCI_0_1_r16_setup) {
		if (p->setup.v) {
			serFree(p->setup.v);
		}
		return;
	}
}

static void _serNrSysFreeSQN_NR_SetupRelease_PUSCH_Config_ul_AccessConfigListDCI_0_1_r16(struct SQN_NR_SetupRelease_PUSCH_Config_ul_AccessConfigListDCI_0_1_r16* p)
{
	_serNrSysFreeSQN_NR_SetupRelease_PUSCH_Config_ul_AccessConfigListDCI_0_1_r16_Value(&p->v, p->d);
}

static void _serNrSysFreeSQN_NR_SetupRelease_PUSCH_Config_ul_AccessConfigListDCI_0_1_r16_SQN_NR_PUSCH_Config_ul_AccessConfigListDCI_0_1_r16_Optional(struct SQN_NR_SetupRelease_PUSCH_Config_ul_AccessConfigListDCI_0_1_r16_SQN_NR_PUSCH_Config_ul_AccessConfigListDCI_0_1_r16_Optional* p)
{
	if (!p->d) return;
	_serNrSysFreeSQN_NR_SetupRelease_PUSCH_Config_ul_AccessConfigListDCI_0_1_r16(&p->v);
}

static void _serNrSysFreeSQN_NR_SetupRelease_PUSCH_Config_frequencyHoppingOffsetListsDCI_0_2_r16_Value(union SQN_NR_SetupRelease_PUSCH_Config_frequencyHoppingOffsetListsDCI_0_2_r16_Value* p, enum SQN_NR_SetupRelease_PUSCH_Config_frequencyHoppingOffsetListsDCI_0_2_r16_Sel d)
{
	if (d == SQN_NR_SetupRelease_PUSCH_Config_frequencyHoppingOffsetListsDCI_0_2_r16_setup) {
		if (p->setup.v) {
			serFree(p->setup.v);
		}
		return;
	}
}

static void _serNrSysFreeSQN_NR_SetupRelease_PUSCH_Config_frequencyHoppingOffsetListsDCI_0_2_r16(struct SQN_NR_SetupRelease_PUSCH_Config_frequencyHoppingOffsetListsDCI_0_2_r16* p)
{
	_serNrSysFreeSQN_NR_SetupRelease_PUSCH_Config_frequencyHoppingOffsetListsDCI_0_2_r16_Value(&p->v, p->d);
}

static void _serNrSysFreeSQN_NR_SetupRelease_PUSCH_Config_frequencyHoppingOffsetListsDCI_0_2_r16_SQN_NR_PUSCH_Config_frequencyHoppingOffsetListsDCI_0_2_r16_Optional(struct SQN_NR_SetupRelease_PUSCH_Config_frequencyHoppingOffsetListsDCI_0_2_r16_SQN_NR_PUSCH_Config_frequencyHoppingOffsetListsDCI_0_2_r16_Optional* p)
{
	if (!p->d) return;
	_serNrSysFreeSQN_NR_SetupRelease_PUSCH_Config_frequencyHoppingOffsetListsDCI_0_2_r16(&p->v);
}

static void _serNrSysFreeSQN_NR_SetupRelease_PUSCH_Config_uci_OnPUSCH_ListDCI_0_2_r16_Value(union SQN_NR_SetupRelease_PUSCH_Config_uci_OnPUSCH_ListDCI_0_2_r16_Value* p, enum SQN_NR_SetupRelease_PUSCH_Config_uci_OnPUSCH_ListDCI_0_2_r16_Sel d)
{
	if (d == SQN_NR_SetupRelease_PUSCH_Config_uci_OnPUSCH_ListDCI_0_2_r16_setup) {
		if (p->setup.v) {
			for (size_t i2 = 0; i2 < p->setup.d; i2++) {
			}
			serFree(p->setup.v);
		}
		return;
	}
}

static void _serNrSysFreeSQN_NR_SetupRelease_PUSCH_Config_uci_OnPUSCH_ListDCI_0_2_r16(struct SQN_NR_SetupRelease_PUSCH_Config_uci_OnPUSCH_ListDCI_0_2_r16* p)
{
	_serNrSysFreeSQN_NR_SetupRelease_PUSCH_Config_uci_OnPUSCH_ListDCI_0_2_r16_Value(&p->v, p->d);
}

static void _serNrSysFreeSQN_NR_SetupRelease_PUSCH_Config_uci_OnPUSCH_ListDCI_0_2_r16_SQN_NR_PUSCH_Config_uci_OnPUSCH_ListDCI_0_2_r16_Optional(struct SQN_NR_SetupRelease_PUSCH_Config_uci_OnPUSCH_ListDCI_0_2_r16_SQN_NR_PUSCH_Config_uci_OnPUSCH_ListDCI_0_2_r16_Optional* p)
{
	if (!p->d) return;
	_serNrSysFreeSQN_NR_SetupRelease_PUSCH_Config_uci_OnPUSCH_ListDCI_0_2_r16(&p->v);
}

static void _serNrSysFreeSQN_NR_PUSCH_TimeDomainResourceAllocation_r16(struct SQN_NR_PUSCH_TimeDomainResourceAllocation_r16* p)
{
	if (p->puschAllocationList_r16.v) {
		for (size_t i3 = 0; i3 < p->puschAllocationList_r16.d; i3++) {
		}
		serFree(p->puschAllocationList_r16.v);
	}
}

static void _serNrSysFreeSQN_NR_SetupRelease_PUSCH_Config_pusch_TimeDomainAllocationListDCI_0_2_r16_Value(union SQN_NR_SetupRelease_PUSCH_Config_pusch_TimeDomainAllocationListDCI_0_2_r16_Value* p, enum SQN_NR_SetupRelease_PUSCH_Config_pusch_TimeDomainAllocationListDCI_0_2_r16_Sel d)
{
	if (d == SQN_NR_SetupRelease_PUSCH_Config_pusch_TimeDomainAllocationListDCI_0_2_r16_setup) {
		if (p->setup.v) {
			for (size_t i2 = 0; i2 < p->setup.d; i2++) {
				_serNrSysFreeSQN_NR_PUSCH_TimeDomainResourceAllocation_r16(&p->setup.v[i2]);
			}
			serFree(p->setup.v);
		}
		return;
	}
}

static void _serNrSysFreeSQN_NR_SetupRelease_PUSCH_Config_pusch_TimeDomainAllocationListDCI_0_2_r16(struct SQN_NR_SetupRelease_PUSCH_Config_pusch_TimeDomainAllocationListDCI_0_2_r16* p)
{
	_serNrSysFreeSQN_NR_SetupRelease_PUSCH_Config_pusch_TimeDomainAllocationListDCI_0_2_r16_Value(&p->v, p->d);
}

static void _serNrSysFreeSQN_NR_SetupRelease_PUSCH_Config_pusch_TimeDomainAllocationListDCI_0_2_r16_SQN_NR_PUSCH_Config_pusch_TimeDomainAllocationListDCI_0_2_r16_Optional(struct SQN_NR_SetupRelease_PUSCH_Config_pusch_TimeDomainAllocationListDCI_0_2_r16_SQN_NR_PUSCH_Config_pusch_TimeDomainAllocationListDCI_0_2_r16_Optional* p)
{
	if (!p->d) return;
	_serNrSysFreeSQN_NR_SetupRelease_PUSCH_Config_pusch_TimeDomainAllocationListDCI_0_2_r16(&p->v);
}

static void _serNrSysFreeSQN_NR_SetupRelease_PUSCH_Config_pusch_TimeDomainAllocationListDCI_0_1_r16_Value(union SQN_NR_SetupRelease_PUSCH_Config_pusch_TimeDomainAllocationListDCI_0_1_r16_Value* p, enum SQN_NR_SetupRelease_PUSCH_Config_pusch_TimeDomainAllocationListDCI_0_1_r16_Sel d)
{
	if (d == SQN_NR_SetupRelease_PUSCH_Config_pusch_TimeDomainAllocationListDCI_0_1_r16_setup) {
		if (p->setup.v) {
			for (size_t i2 = 0; i2 < p->setup.d; i2++) {
				_serNrSysFreeSQN_NR_PUSCH_TimeDomainResourceAllocation_r16(&p->setup.v[i2]);
			}
			serFree(p->setup.v);
		}
		return;
	}
}

static void _serNrSysFreeSQN_NR_SetupRelease_PUSCH_Config_pusch_TimeDomainAllocationListDCI_0_1_r16(struct SQN_NR_SetupRelease_PUSCH_Config_pusch_TimeDomainAllocationListDCI_0_1_r16* p)
{
	_serNrSysFreeSQN_NR_SetupRelease_PUSCH_Config_pusch_TimeDomainAllocationListDCI_0_1_r16_Value(&p->v, p->d);
}

static void _serNrSysFreeSQN_NR_SetupRelease_PUSCH_Config_pusch_TimeDomainAllocationListDCI_0_1_r16_SQN_NR_PUSCH_Config_pusch_TimeDomainAllocationListDCI_0_1_r16_Optional(struct SQN_NR_SetupRelease_PUSCH_Config_pusch_TimeDomainAllocationListDCI_0_1_r16_SQN_NR_PUSCH_Config_pusch_TimeDomainAllocationListDCI_0_1_r16_Optional* p)
{
	if (!p->d) return;
	_serNrSysFreeSQN_NR_SetupRelease_PUSCH_Config_pusch_TimeDomainAllocationListDCI_0_1_r16(&p->v);
}

static void _serNrSysFreeSQN_NR_SetupRelease_PUSCH_Config_uci_OnPUSCH_ListDCI_0_1_r16_Value(union SQN_NR_SetupRelease_PUSCH_Config_uci_OnPUSCH_ListDCI_0_1_r16_Value* p, enum SQN_NR_SetupRelease_PUSCH_Config_uci_OnPUSCH_ListDCI_0_1_r16_Sel d)
{
	if (d == SQN_NR_SetupRelease_PUSCH_Config_uci_OnPUSCH_ListDCI_0_1_r16_setup) {
		if (p->setup.v) {
			for (size_t i2 = 0; i2 < p->setup.d; i2++) {
			}
			serFree(p->setup.v);
		}
		return;
	}
}

static void _serNrSysFreeSQN_NR_SetupRelease_PUSCH_Config_uci_OnPUSCH_ListDCI_0_1_r16(struct SQN_NR_SetupRelease_PUSCH_Config_uci_OnPUSCH_ListDCI_0_1_r16* p)
{
	_serNrSysFreeSQN_NR_SetupRelease_PUSCH_Config_uci_OnPUSCH_ListDCI_0_1_r16_Value(&p->v, p->d);
}

static void _serNrSysFreeSQN_NR_SetupRelease_PUSCH_Config_uci_OnPUSCH_ListDCI_0_1_r16_SQN_NR_PUSCH_Config_uci_OnPUSCH_ListDCI_0_1_r16_Optional(struct SQN_NR_SetupRelease_PUSCH_Config_uci_OnPUSCH_ListDCI_0_1_r16_SQN_NR_PUSCH_Config_uci_OnPUSCH_ListDCI_0_1_r16_Optional* p)
{
	if (!p->d) return;
	_serNrSysFreeSQN_NR_SetupRelease_PUSCH_Config_uci_OnPUSCH_ListDCI_0_1_r16(&p->v);
}

static void _serNrSysFreeSQN_NR_PUSCH_PathlossReferenceRS_r16_SQN_NR_PUSCH_PowerControl_v1610_pathlossReferenceRSToAddModList2_r16_DynamicOptional(struct SQN_NR_PUSCH_PathlossReferenceRS_r16_SQN_NR_PUSCH_PowerControl_v1610_pathlossReferenceRSToAddModList2_r16_DynamicOptional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i2 = 0; i2 < p->v.d; i2++) {
		}
		serFree(p->v.v);
	}
}

static void _serNrSysFreeSQN_NR_PUSCH_PathlossReferenceRS_Id_v1610_SQN_NR_PUSCH_PowerControl_v1610_pathlossReferenceRSToReleaseList2_r16_DynamicOptional(struct SQN_NR_PUSCH_PathlossReferenceRS_Id_v1610_SQN_NR_PUSCH_PowerControl_v1610_pathlossReferenceRSToReleaseList2_r16_DynamicOptional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		serFree(p->v.v);
	}
}

static void _serNrSysFreeSQN_NR_P0_PUSCH_r16_SQN_NR_P0_PUSCH_Set_r16_p0_List_r16_DynamicOptional(struct SQN_NR_P0_PUSCH_r16_SQN_NR_P0_PUSCH_Set_r16_p0_List_r16_DynamicOptional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		serFree(p->v.v);
	}
}

static void _serNrSysFreeSQN_NR_P0_PUSCH_Set_r16(struct SQN_NR_P0_PUSCH_Set_r16* p)
{
	_serNrSysFreeSQN_NR_P0_PUSCH_r16_SQN_NR_P0_PUSCH_Set_r16_p0_List_r16_DynamicOptional(&p->p0_List_r16);
}

static void _serNrSysFreeSQN_NR_P0_PUSCH_Set_r16_SQN_NR_PUSCH_PowerControl_v1610_p0_PUSCH_SetList_r16_DynamicOptional(struct SQN_NR_P0_PUSCH_Set_r16_SQN_NR_PUSCH_PowerControl_v1610_p0_PUSCH_SetList_r16_DynamicOptional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i2 = 0; i2 < p->v.d; i2++) {
			_serNrSysFreeSQN_NR_P0_PUSCH_Set_r16(&p->v.v[i2]);
		}
		serFree(p->v.v);
	}
}

static void _serNrSysFreeSQN_NR_PUSCH_PowerControl_v1610(struct SQN_NR_PUSCH_PowerControl_v1610* p)
{
	_serNrSysFreeSQN_NR_PUSCH_PathlossReferenceRS_r16_SQN_NR_PUSCH_PowerControl_v1610_pathlossReferenceRSToAddModList2_r16_DynamicOptional(&p->pathlossReferenceRSToAddModList2_r16);
	_serNrSysFreeSQN_NR_PUSCH_PathlossReferenceRS_Id_v1610_SQN_NR_PUSCH_PowerControl_v1610_pathlossReferenceRSToReleaseList2_r16_DynamicOptional(&p->pathlossReferenceRSToReleaseList2_r16);
	_serNrSysFreeSQN_NR_P0_PUSCH_Set_r16_SQN_NR_PUSCH_PowerControl_v1610_p0_PUSCH_SetList_r16_DynamicOptional(&p->p0_PUSCH_SetList_r16);
}

static void _serNrSysFreeSQN_NR_SetupRelease_PUSCH_Config_pusch_PowerControl_v1610_Value(union SQN_NR_SetupRelease_PUSCH_Config_pusch_PowerControl_v1610_Value* p, enum SQN_NR_SetupRelease_PUSCH_Config_pusch_PowerControl_v1610_Sel d)
{
	if (d == SQN_NR_SetupRelease_PUSCH_Config_pusch_PowerControl_v1610_setup) {
		_serNrSysFreeSQN_NR_PUSCH_PowerControl_v1610(&p->setup);
		return;
	}
}

static void _serNrSysFreeSQN_NR_SetupRelease_PUSCH_Config_pusch_PowerControl_v1610(struct SQN_NR_SetupRelease_PUSCH_Config_pusch_PowerControl_v1610* p)
{
	_serNrSysFreeSQN_NR_SetupRelease_PUSCH_Config_pusch_PowerControl_v1610_Value(&p->v, p->d);
}

static void _serNrSysFreeSQN_NR_SetupRelease_PUSCH_Config_pusch_PowerControl_v1610_SQN_NR_PUSCH_Config_pusch_PowerControl_v1610_Optional(struct SQN_NR_SetupRelease_PUSCH_Config_pusch_PowerControl_v1610_SQN_NR_PUSCH_Config_pusch_PowerControl_v1610_Optional* p)
{
	if (!p->d) return;
	_serNrSysFreeSQN_NR_SetupRelease_PUSCH_Config_pusch_PowerControl_v1610(&p->v);
}

static void _serNrSysFreeSQN_NR_SetupRelease_PUSCH_Config_pusch_TimeDomainAllocationListForMultiPUSCH_r16_Value(union SQN_NR_SetupRelease_PUSCH_Config_pusch_TimeDomainAllocationListForMultiPUSCH_r16_Value* p, enum SQN_NR_SetupRelease_PUSCH_Config_pusch_TimeDomainAllocationListForMultiPUSCH_r16_Sel d)
{
	if (d == SQN_NR_SetupRelease_PUSCH_Config_pusch_TimeDomainAllocationListForMultiPUSCH_r16_setup) {
		if (p->setup.v) {
			for (size_t i2 = 0; i2 < p->setup.d; i2++) {
				_serNrSysFreeSQN_NR_PUSCH_TimeDomainResourceAllocation_r16(&p->setup.v[i2]);
			}
			serFree(p->setup.v);
		}
		return;
	}
}

static void _serNrSysFreeSQN_NR_SetupRelease_PUSCH_Config_pusch_TimeDomainAllocationListForMultiPUSCH_r16(struct SQN_NR_SetupRelease_PUSCH_Config_pusch_TimeDomainAllocationListForMultiPUSCH_r16* p)
{
	_serNrSysFreeSQN_NR_SetupRelease_PUSCH_Config_pusch_TimeDomainAllocationListForMultiPUSCH_r16_Value(&p->v, p->d);
}

static void _serNrSysFreeSQN_NR_SetupRelease_PUSCH_Config_pusch_TimeDomainAllocationListForMultiPUSCH_r16_SQN_NR_PUSCH_Config_pusch_TimeDomainAllocationListForMultiPUSCH_r16_Optional(struct SQN_NR_SetupRelease_PUSCH_Config_pusch_TimeDomainAllocationListForMultiPUSCH_r16_SQN_NR_PUSCH_Config_pusch_TimeDomainAllocationListForMultiPUSCH_r16_Optional* p)
{
	if (!p->d) return;
	_serNrSysFreeSQN_NR_SetupRelease_PUSCH_Config_pusch_TimeDomainAllocationListForMultiPUSCH_r16(&p->v);
}

static void _serNrSysFreeSQN_NR_PUSCH_Config(struct SQN_NR_PUSCH_Config* p)
{
	_serNrSysFreeSQN_NR_PUSCH_PowerControl_SQN_NR_PUSCH_Config_pusch_PowerControl_Optional(&p->pusch_PowerControl);
	_serNrSysFreeUint16_t_SQN_NR_PUSCH_Config_frequencyHoppingOffsetLists_DynamicOptional(&p->frequencyHoppingOffsetLists);
	_serNrSysFreeSQN_NR_SetupRelease_PUSCH_Config_pusch_TimeDomainAllocationList_SQN_NR_PUSCH_Config_pusch_TimeDomainAllocationList_Optional(&p->pusch_TimeDomainAllocationList);
	_serNrSysFreeSQN_NR_SetupRelease_PUSCH_Config_minimumSchedulingOffsetK2_r16_SQN_NR_PUSCH_Config_minimumSchedulingOffsetK2_r16_Optional(&p->minimumSchedulingOffsetK2_r16);
	_serNrSysFreeSQN_NR_SetupRelease_PUSCH_Config_ul_AccessConfigListDCI_0_1_r16_SQN_NR_PUSCH_Config_ul_AccessConfigListDCI_0_1_r16_Optional(&p->ul_AccessConfigListDCI_0_1_r16);
	_serNrSysFreeSQN_NR_SetupRelease_PUSCH_Config_frequencyHoppingOffsetListsDCI_0_2_r16_SQN_NR_PUSCH_Config_frequencyHoppingOffsetListsDCI_0_2_r16_Optional(&p->frequencyHoppingOffsetListsDCI_0_2_r16);
	_serNrSysFreeSQN_NR_SetupRelease_PUSCH_Config_uci_OnPUSCH_ListDCI_0_2_r16_SQN_NR_PUSCH_Config_uci_OnPUSCH_ListDCI_0_2_r16_Optional(&p->uci_OnPUSCH_ListDCI_0_2_r16);
	_serNrSysFreeSQN_NR_SetupRelease_PUSCH_Config_pusch_TimeDomainAllocationListDCI_0_2_r16_SQN_NR_PUSCH_Config_pusch_TimeDomainAllocationListDCI_0_2_r16_Optional(&p->pusch_TimeDomainAllocationListDCI_0_2_r16);
	_serNrSysFreeSQN_NR_SetupRelease_PUSCH_Config_pusch_TimeDomainAllocationListDCI_0_1_r16_SQN_NR_PUSCH_Config_pusch_TimeDomainAllocationListDCI_0_1_r16_Optional(&p->pusch_TimeDomainAllocationListDCI_0_1_r16);
	_serNrSysFreeSQN_NR_SetupRelease_PUSCH_Config_uci_OnPUSCH_ListDCI_0_1_r16_SQN_NR_PUSCH_Config_uci_OnPUSCH_ListDCI_0_1_r16_Optional(&p->uci_OnPUSCH_ListDCI_0_1_r16);
	_serNrSysFreeSQN_NR_SetupRelease_PUSCH_Config_pusch_PowerControl_v1610_SQN_NR_PUSCH_Config_pusch_PowerControl_v1610_Optional(&p->pusch_PowerControl_v1610);
	_serNrSysFreeSQN_NR_SetupRelease_PUSCH_Config_pusch_TimeDomainAllocationListForMultiPUSCH_r16_SQN_NR_PUSCH_Config_pusch_TimeDomainAllocationListForMultiPUSCH_r16_Optional(&p->pusch_TimeDomainAllocationListForMultiPUSCH_r16);
}

static void _serNrSysFreeSQN_NR_SetupRelease_BWP_UplinkDedicated_pusch_Config_Value(union SQN_NR_SetupRelease_BWP_UplinkDedicated_pusch_Config_Value* p, enum SQN_NR_SetupRelease_BWP_UplinkDedicated_pusch_Config_Sel d)
{
	if (d == SQN_NR_SetupRelease_BWP_UplinkDedicated_pusch_Config_setup) {
		_serNrSysFreeSQN_NR_PUSCH_Config(&p->setup);
		return;
	}
}

static void _serNrSysFreeSQN_NR_SetupRelease_BWP_UplinkDedicated_pusch_Config(struct SQN_NR_SetupRelease_BWP_UplinkDedicated_pusch_Config* p)
{
	_serNrSysFreeSQN_NR_SetupRelease_BWP_UplinkDedicated_pusch_Config_Value(&p->v, p->d);
}

static void _serNrSysFreeSQN_NR_SetupRelease_BWP_UplinkDedicated_pusch_Config_SQN_NR_BWP_UplinkDedicated_pusch_Config_Optional(struct SQN_NR_SetupRelease_BWP_UplinkDedicated_pusch_Config_SQN_NR_BWP_UplinkDedicated_pusch_Config_Optional* p)
{
	if (!p->d) return;
	_serNrSysFreeSQN_NR_SetupRelease_BWP_UplinkDedicated_pusch_Config(&p->v);
}

static void _serNrSysFreeSQN_NR_CG_UCI_OnPUSCH_Value(union SQN_NR_CG_UCI_OnPUSCH_Value* p, enum SQN_NR_CG_UCI_OnPUSCH_Sel d)
{
	if (d == SQN_NR_CG_UCI_OnPUSCH_dynamic) {
		if (p->dynamic.v) {
			for (size_t i2 = 0; i2 < p->dynamic.d; i2++) {
			}
			serFree(p->dynamic.v);
		}
		return;
	}
}

static void _serNrSysFreeSQN_NR_CG_UCI_OnPUSCH(struct SQN_NR_CG_UCI_OnPUSCH* p)
{
	_serNrSysFreeSQN_NR_CG_UCI_OnPUSCH_Value(&p->v, p->d);
}

static void _serNrSysFreeSQN_NR_SetupRelease_ConfiguredGrantConfig_uci_OnPUSCH_Value(union SQN_NR_SetupRelease_ConfiguredGrantConfig_uci_OnPUSCH_Value* p, enum SQN_NR_SetupRelease_ConfiguredGrantConfig_uci_OnPUSCH_Sel d)
{
	if (d == SQN_NR_SetupRelease_ConfiguredGrantConfig_uci_OnPUSCH_setup) {
		_serNrSysFreeSQN_NR_CG_UCI_OnPUSCH(&p->setup);
		return;
	}
}

static void _serNrSysFreeSQN_NR_SetupRelease_ConfiguredGrantConfig_uci_OnPUSCH(struct SQN_NR_SetupRelease_ConfiguredGrantConfig_uci_OnPUSCH* p)
{
	_serNrSysFreeSQN_NR_SetupRelease_ConfiguredGrantConfig_uci_OnPUSCH_Value(&p->v, p->d);
}

static void _serNrSysFreeSQN_NR_SetupRelease_ConfiguredGrantConfig_uci_OnPUSCH_SQN_NR_ConfiguredGrantConfig_uci_OnPUSCH_Optional(struct SQN_NR_SetupRelease_ConfiguredGrantConfig_uci_OnPUSCH_SQN_NR_ConfiguredGrantConfig_uci_OnPUSCH_Optional* p)
{
	if (!p->d) return;
	_serNrSysFreeSQN_NR_SetupRelease_ConfiguredGrantConfig_uci_OnPUSCH(&p->v);
}

static void _serNrSysFreeUint8_t_SQN_NR_CG_StartingOffsets_r16_cg_StartingFullBW_InsideCOT_r16_DynamicOptional(struct uint8_t_SQN_NR_CG_StartingOffsets_r16_cg_StartingFullBW_InsideCOT_r16_DynamicOptional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		serFree(p->v.v);
	}
}

static void _serNrSysFreeUint8_t_SQN_NR_CG_StartingOffsets_r16_cg_StartingFullBW_OutsideCOT_r16_DynamicOptional(struct uint8_t_SQN_NR_CG_StartingOffsets_r16_cg_StartingFullBW_OutsideCOT_r16_DynamicOptional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		serFree(p->v.v);
	}
}

static void _serNrSysFreeSQN_NR_CG_StartingOffsets_r16(struct SQN_NR_CG_StartingOffsets_r16* p)
{
	_serNrSysFreeUint8_t_SQN_NR_CG_StartingOffsets_r16_cg_StartingFullBW_InsideCOT_r16_DynamicOptional(&p->cg_StartingFullBW_InsideCOT_r16);
	_serNrSysFreeUint8_t_SQN_NR_CG_StartingOffsets_r16_cg_StartingFullBW_OutsideCOT_r16_DynamicOptional(&p->cg_StartingFullBW_OutsideCOT_r16);
}

static void _serNrSysFreeSQN_NR_CG_StartingOffsets_r16_SQN_NR_ConfiguredGrantConfig_cg_StartingOffsets_r16_Optional(struct SQN_NR_CG_StartingOffsets_r16_SQN_NR_ConfiguredGrantConfig_cg_StartingOffsets_r16_Optional* p)
{
	if (!p->d) return;
	_serNrSysFreeSQN_NR_CG_StartingOffsets_r16(&p->v);
}

static void _serNrSysFreeSQN_NR_CG_COT_Sharing_r16_SQN_NR_ConfiguredGrantConfig_cg_COT_SharingList_r16_DynamicOptional(struct SQN_NR_CG_COT_Sharing_r16_SQN_NR_ConfiguredGrantConfig_cg_COT_SharingList_r16_DynamicOptional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i2 = 0; i2 < p->v.d; i2++) {
		}
		serFree(p->v.v);
	}
}

static void _serNrSysFreeSQN_NR_ConfiguredGrantConfig(struct SQN_NR_ConfiguredGrantConfig* p)
{
	_serNrSysFreeSQN_NR_SetupRelease_ConfiguredGrantConfig_uci_OnPUSCH_SQN_NR_ConfiguredGrantConfig_uci_OnPUSCH_Optional(&p->uci_OnPUSCH);
	_serNrSysFreeSQN_NR_CG_StartingOffsets_r16_SQN_NR_ConfiguredGrantConfig_cg_StartingOffsets_r16_Optional(&p->cg_StartingOffsets_r16);
	_serNrSysFreeSQN_NR_CG_COT_Sharing_r16_SQN_NR_ConfiguredGrantConfig_cg_COT_SharingList_r16_DynamicOptional(&p->cg_COT_SharingList_r16);
}

static void _serNrSysFreeSQN_NR_SetupRelease_BWP_UplinkDedicated_configuredGrantConfig_Value(union SQN_NR_SetupRelease_BWP_UplinkDedicated_configuredGrantConfig_Value* p, enum SQN_NR_SetupRelease_BWP_UplinkDedicated_configuredGrantConfig_Sel d)
{
	if (d == SQN_NR_SetupRelease_BWP_UplinkDedicated_configuredGrantConfig_setup) {
		_serNrSysFreeSQN_NR_ConfiguredGrantConfig(&p->setup);
		return;
	}
}

static void _serNrSysFreeSQN_NR_SetupRelease_BWP_UplinkDedicated_configuredGrantConfig(struct SQN_NR_SetupRelease_BWP_UplinkDedicated_configuredGrantConfig* p)
{
	_serNrSysFreeSQN_NR_SetupRelease_BWP_UplinkDedicated_configuredGrantConfig_Value(&p->v, p->d);
}

static void _serNrSysFreeSQN_NR_SetupRelease_BWP_UplinkDedicated_configuredGrantConfig_SQN_NR_BWP_UplinkDedicated_configuredGrantConfig_Optional(struct SQN_NR_SetupRelease_BWP_UplinkDedicated_configuredGrantConfig_SQN_NR_BWP_UplinkDedicated_configuredGrantConfig_Optional* p)
{
	if (!p->d) return;
	_serNrSysFreeSQN_NR_SetupRelease_BWP_UplinkDedicated_configuredGrantConfig(&p->v);
}

static void _serNrSysFreeSQN_NR_SRS_ResourceSetId_SQN_NR_SRS_Config_srs_ResourceSetToReleaseList_DynamicOptional(struct SQN_NR_SRS_ResourceSetId_SQN_NR_SRS_Config_srs_ResourceSetToReleaseList_DynamicOptional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		serFree(p->v.v);
	}
}

static void _serNrSysFreeSQN_NR_SRS_ResourceId_SQN_NR_SRS_ResourceSet_srs_ResourceIdList_DynamicOptional(struct SQN_NR_SRS_ResourceId_SQN_NR_SRS_ResourceSet_srs_ResourceIdList_DynamicOptional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		serFree(p->v.v);
	}
}

static void _serNrSysFreeUint8_t_SQN_NR_SRS_ResourceSet_resourceType_aperiodic_aperiodicSRS_ResourceTriggerList_DynamicOptional(struct uint8_t_SQN_NR_SRS_ResourceSet_resourceType_aperiodic_aperiodicSRS_ResourceTriggerList_DynamicOptional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		serFree(p->v.v);
	}
}

static void _serNrSysFreeSQN_NR_SRS_ResourceSet_resourceType_aperiodic(struct SQN_NR_SRS_ResourceSet_resourceType_aperiodic* p)
{
	_serNrSysFreeUint8_t_SQN_NR_SRS_ResourceSet_resourceType_aperiodic_aperiodicSRS_ResourceTriggerList_DynamicOptional(&p->aperiodicSRS_ResourceTriggerList);
}

static void _serNrSysFreeSQN_NR_SRS_ResourceSet_resourceType_Value(union SQN_NR_SRS_ResourceSet_resourceType_Value* p, enum SQN_NR_SRS_ResourceSet_resourceType_Sel d)
{
	if (d == SQN_NR_SRS_ResourceSet_resourceType_aperiodic) {
		_serNrSysFreeSQN_NR_SRS_ResourceSet_resourceType_aperiodic(&p->aperiodic);
		return;
	}
}

static void _serNrSysFreeSQN_NR_SRS_ResourceSet_resourceType(struct SQN_NR_SRS_ResourceSet_resourceType* p)
{
	_serNrSysFreeSQN_NR_SRS_ResourceSet_resourceType_Value(&p->v, p->d);
}

static void _serNrSysFreeSQN_NR_SetupRelease_SRS_ResourceSet_pathlossReferenceRSList_r16_Value(union SQN_NR_SetupRelease_SRS_ResourceSet_pathlossReferenceRSList_r16_Value* p, enum SQN_NR_SetupRelease_SRS_ResourceSet_pathlossReferenceRSList_r16_Sel d)
{
	if (d == SQN_NR_SetupRelease_SRS_ResourceSet_pathlossReferenceRSList_r16_setup) {
		if (p->setup.v) {
			for (size_t i3 = 0; i3 < p->setup.d; i3++) {
			}
			serFree(p->setup.v);
		}
		return;
	}
}

static void _serNrSysFreeSQN_NR_SetupRelease_SRS_ResourceSet_pathlossReferenceRSList_r16(struct SQN_NR_SetupRelease_SRS_ResourceSet_pathlossReferenceRSList_r16* p)
{
	_serNrSysFreeSQN_NR_SetupRelease_SRS_ResourceSet_pathlossReferenceRSList_r16_Value(&p->v, p->d);
}

static void _serNrSysFreeSQN_NR_SetupRelease_SRS_ResourceSet_pathlossReferenceRSList_r16_SQN_NR_SRS_ResourceSet_pathlossReferenceRSList_r16_Optional(struct SQN_NR_SetupRelease_SRS_ResourceSet_pathlossReferenceRSList_r16_SQN_NR_SRS_ResourceSet_pathlossReferenceRSList_r16_Optional* p)
{
	if (!p->d) return;
	_serNrSysFreeSQN_NR_SetupRelease_SRS_ResourceSet_pathlossReferenceRSList_r16(&p->v);
}

static void _serNrSysFreeSQN_NR_SRS_ResourceSet(struct SQN_NR_SRS_ResourceSet* p)
{
	_serNrSysFreeSQN_NR_SRS_ResourceId_SQN_NR_SRS_ResourceSet_srs_ResourceIdList_DynamicOptional(&p->srs_ResourceIdList);
	_serNrSysFreeSQN_NR_SRS_ResourceSet_resourceType(&p->resourceType);
	_serNrSysFreeSQN_NR_SetupRelease_SRS_ResourceSet_pathlossReferenceRSList_r16_SQN_NR_SRS_ResourceSet_pathlossReferenceRSList_r16_Optional(&p->pathlossReferenceRSList_r16);
}

static void _serNrSysFreeSQN_NR_SRS_ResourceSet_SQN_NR_SRS_Config_srs_ResourceSetToAddModList_DynamicOptional(struct SQN_NR_SRS_ResourceSet_SQN_NR_SRS_Config_srs_ResourceSetToAddModList_DynamicOptional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i2 = 0; i2 < p->v.d; i2++) {
			_serNrSysFreeSQN_NR_SRS_ResourceSet(&p->v.v[i2]);
		}
		serFree(p->v.v);
	}
}

static void _serNrSysFreeSQN_NR_SRS_ResourceId_SQN_NR_SRS_Config_srs_ResourceToReleaseList_DynamicOptional(struct SQN_NR_SRS_ResourceId_SQN_NR_SRS_Config_srs_ResourceToReleaseList_DynamicOptional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		serFree(p->v.v);
	}
}

static void _serNrSysFreeSQN_NR_SRS_Resource_SQN_NR_SRS_Config_srs_ResourceToAddModList_DynamicOptional(struct SQN_NR_SRS_Resource_SQN_NR_SRS_Config_srs_ResourceToAddModList_DynamicOptional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i2 = 0; i2 < p->v.d; i2++) {
		}
		serFree(p->v.v);
	}
}

static void _serNrSysFreeSQN_NR_SRS_ResourceSet_SQN_NR_SRS_Config_srs_ResourceSetToAddModListDCI_0_2_r16_DynamicOptional(struct SQN_NR_SRS_ResourceSet_SQN_NR_SRS_Config_srs_ResourceSetToAddModListDCI_0_2_r16_DynamicOptional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i2 = 0; i2 < p->v.d; i2++) {
			_serNrSysFreeSQN_NR_SRS_ResourceSet(&p->v.v[i2]);
		}
		serFree(p->v.v);
	}
}

static void _serNrSysFreeSQN_NR_SRS_ResourceSetId_SQN_NR_SRS_Config_srs_ResourceSetToReleaseListDCI_0_2_r16_DynamicOptional(struct SQN_NR_SRS_ResourceSetId_SQN_NR_SRS_Config_srs_ResourceSetToReleaseListDCI_0_2_r16_DynamicOptional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		serFree(p->v.v);
	}
}

static void _serNrSysFreeSQN_NR_SRS_PosResourceSetId_r16_SQN_NR_SRS_Config_srs_PosResourceSetToReleaseList_r16_DynamicOptional(struct SQN_NR_SRS_PosResourceSetId_r16_SQN_NR_SRS_Config_srs_PosResourceSetToReleaseList_r16_DynamicOptional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		serFree(p->v.v);
	}
}

static void _serNrSysFreeSQN_NR_SRS_PosResourceId_r16_SQN_NR_SRS_PosResourceSet_r16_srs_PosResourceIdList_r16_DynamicOptional(struct SQN_NR_SRS_PosResourceId_r16_SQN_NR_SRS_PosResourceSet_r16_srs_PosResourceIdList_r16_DynamicOptional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		serFree(p->v.v);
	}
}

static void _serNrSysFreeUint8_t_SQN_NR_SRS_PosResourceSet_r16_resourceType_r16_aperiodic_r16_aperiodicSRS_ResourceTriggerList_r16_DynamicOptional(struct uint8_t_SQN_NR_SRS_PosResourceSet_r16_resourceType_r16_aperiodic_r16_aperiodicSRS_ResourceTriggerList_r16_DynamicOptional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		serFree(p->v.v);
	}
}

static void _serNrSysFreeSQN_NR_SRS_PosResourceSet_r16_resourceType_r16_aperiodic_r16(struct SQN_NR_SRS_PosResourceSet_r16_resourceType_r16_aperiodic_r16* p)
{
	_serNrSysFreeUint8_t_SQN_NR_SRS_PosResourceSet_r16_resourceType_r16_aperiodic_r16_aperiodicSRS_ResourceTriggerList_r16_DynamicOptional(&p->aperiodicSRS_ResourceTriggerList_r16);
}

static void _serNrSysFreeSQN_NR_SRS_PosResourceSet_r16_resourceType_r16_Value(union SQN_NR_SRS_PosResourceSet_r16_resourceType_r16_Value* p, enum SQN_NR_SRS_PosResourceSet_r16_resourceType_r16_Sel d)
{
	if (d == SQN_NR_SRS_PosResourceSet_r16_resourceType_r16_aperiodic_r16) {
		_serNrSysFreeSQN_NR_SRS_PosResourceSet_r16_resourceType_r16_aperiodic_r16(&p->aperiodic_r16);
		return;
	}
}

static void _serNrSysFreeSQN_NR_SRS_PosResourceSet_r16_resourceType_r16(struct SQN_NR_SRS_PosResourceSet_r16_resourceType_r16* p)
{
	_serNrSysFreeSQN_NR_SRS_PosResourceSet_r16_resourceType_r16_Value(&p->v, p->d);
}

static void _serNrSysFreeSQN_NR_SRS_PosResourceSet_r16(struct SQN_NR_SRS_PosResourceSet_r16* p)
{
	_serNrSysFreeSQN_NR_SRS_PosResourceId_r16_SQN_NR_SRS_PosResourceSet_r16_srs_PosResourceIdList_r16_DynamicOptional(&p->srs_PosResourceIdList_r16);
	_serNrSysFreeSQN_NR_SRS_PosResourceSet_r16_resourceType_r16(&p->resourceType_r16);
}

static void _serNrSysFreeSQN_NR_SRS_PosResourceSet_r16_SQN_NR_SRS_Config_srs_PosResourceSetToAddModList_r16_DynamicOptional(struct SQN_NR_SRS_PosResourceSet_r16_SQN_NR_SRS_Config_srs_PosResourceSetToAddModList_r16_DynamicOptional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i2 = 0; i2 < p->v.d; i2++) {
			_serNrSysFreeSQN_NR_SRS_PosResourceSet_r16(&p->v.v[i2]);
		}
		serFree(p->v.v);
	}
}

static void _serNrSysFreeSQN_NR_SRS_PosResourceId_r16_SQN_NR_SRS_Config_srs_PosResourceToReleaseList_r16_DynamicOptional(struct SQN_NR_SRS_PosResourceId_r16_SQN_NR_SRS_Config_srs_PosResourceToReleaseList_r16_DynamicOptional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		serFree(p->v.v);
	}
}

static void _serNrSysFreeSQN_NR_SRS_PosResource_r16_SQN_NR_SRS_Config_srs_PosResourceToAddModList_r16_DynamicOptional(struct SQN_NR_SRS_PosResource_r16_SQN_NR_SRS_Config_srs_PosResourceToAddModList_r16_DynamicOptional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i2 = 0; i2 < p->v.d; i2++) {
		}
		serFree(p->v.v);
	}
}

static void _serNrSysFreeSQN_NR_SRS_Config(struct SQN_NR_SRS_Config* p)
{
	_serNrSysFreeSQN_NR_SRS_ResourceSetId_SQN_NR_SRS_Config_srs_ResourceSetToReleaseList_DynamicOptional(&p->srs_ResourceSetToReleaseList);
	_serNrSysFreeSQN_NR_SRS_ResourceSet_SQN_NR_SRS_Config_srs_ResourceSetToAddModList_DynamicOptional(&p->srs_ResourceSetToAddModList);
	_serNrSysFreeSQN_NR_SRS_ResourceId_SQN_NR_SRS_Config_srs_ResourceToReleaseList_DynamicOptional(&p->srs_ResourceToReleaseList);
	_serNrSysFreeSQN_NR_SRS_Resource_SQN_NR_SRS_Config_srs_ResourceToAddModList_DynamicOptional(&p->srs_ResourceToAddModList);
	_serNrSysFreeSQN_NR_SRS_ResourceSet_SQN_NR_SRS_Config_srs_ResourceSetToAddModListDCI_0_2_r16_DynamicOptional(&p->srs_ResourceSetToAddModListDCI_0_2_r16);
	_serNrSysFreeSQN_NR_SRS_ResourceSetId_SQN_NR_SRS_Config_srs_ResourceSetToReleaseListDCI_0_2_r16_DynamicOptional(&p->srs_ResourceSetToReleaseListDCI_0_2_r16);
	_serNrSysFreeSQN_NR_SRS_PosResourceSetId_r16_SQN_NR_SRS_Config_srs_PosResourceSetToReleaseList_r16_DynamicOptional(&p->srs_PosResourceSetToReleaseList_r16);
	_serNrSysFreeSQN_NR_SRS_PosResourceSet_r16_SQN_NR_SRS_Config_srs_PosResourceSetToAddModList_r16_DynamicOptional(&p->srs_PosResourceSetToAddModList_r16);
	_serNrSysFreeSQN_NR_SRS_PosResourceId_r16_SQN_NR_SRS_Config_srs_PosResourceToReleaseList_r16_DynamicOptional(&p->srs_PosResourceToReleaseList_r16);
	_serNrSysFreeSQN_NR_SRS_PosResource_r16_SQN_NR_SRS_Config_srs_PosResourceToAddModList_r16_DynamicOptional(&p->srs_PosResourceToAddModList_r16);
}

static void _serNrSysFreeSQN_NR_SetupRelease_BWP_UplinkDedicated_srs_Config_Value(union SQN_NR_SetupRelease_BWP_UplinkDedicated_srs_Config_Value* p, enum SQN_NR_SetupRelease_BWP_UplinkDedicated_srs_Config_Sel d)
{
	if (d == SQN_NR_SetupRelease_BWP_UplinkDedicated_srs_Config_setup) {
		_serNrSysFreeSQN_NR_SRS_Config(&p->setup);
		return;
	}
}

static void _serNrSysFreeSQN_NR_SetupRelease_BWP_UplinkDedicated_srs_Config(struct SQN_NR_SetupRelease_BWP_UplinkDedicated_srs_Config* p)
{
	_serNrSysFreeSQN_NR_SetupRelease_BWP_UplinkDedicated_srs_Config_Value(&p->v, p->d);
}

static void _serNrSysFreeSQN_NR_SetupRelease_BWP_UplinkDedicated_srs_Config_SQN_NR_BWP_UplinkDedicated_srs_Config_Optional(struct SQN_NR_SetupRelease_BWP_UplinkDedicated_srs_Config_SQN_NR_BWP_UplinkDedicated_srs_Config_Optional* p)
{
	if (!p->d) return;
	_serNrSysFreeSQN_NR_SetupRelease_BWP_UplinkDedicated_srs_Config(&p->v);
}

static void _serNrSysFreeUint16_t_SQN_NR_BFR_CSIRS_Resource_ra_OccasionList_DynamicOptional(struct uint16_t_SQN_NR_BFR_CSIRS_Resource_ra_OccasionList_DynamicOptional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		serFree(p->v.v);
	}
}

static void _serNrSysFreeSQN_NR_BFR_CSIRS_Resource(struct SQN_NR_BFR_CSIRS_Resource* p)
{
	_serNrSysFreeUint16_t_SQN_NR_BFR_CSIRS_Resource_ra_OccasionList_DynamicOptional(&p->ra_OccasionList);
}

static void _serNrSysFreeSQN_NR_PRACH_ResourceDedicatedBFR_Value(union SQN_NR_PRACH_ResourceDedicatedBFR_Value* p, enum SQN_NR_PRACH_ResourceDedicatedBFR_Sel d)
{
	if (d == SQN_NR_PRACH_ResourceDedicatedBFR_csi_RS) {
		_serNrSysFreeSQN_NR_BFR_CSIRS_Resource(&p->csi_RS);
		return;
	}
}

static void _serNrSysFreeSQN_NR_PRACH_ResourceDedicatedBFR(struct SQN_NR_PRACH_ResourceDedicatedBFR* p)
{
	_serNrSysFreeSQN_NR_PRACH_ResourceDedicatedBFR_Value(&p->v, p->d);
}

static void _serNrSysFreeSQN_NR_PRACH_ResourceDedicatedBFR_SQN_NR_BeamFailureRecoveryConfig_candidateBeamRSList_DynamicOptional(struct SQN_NR_PRACH_ResourceDedicatedBFR_SQN_NR_BeamFailureRecoveryConfig_candidateBeamRSList_DynamicOptional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i2 = 0; i2 < p->v.d; i2++) {
			_serNrSysFreeSQN_NR_PRACH_ResourceDedicatedBFR(&p->v.v[i2]);
		}
		serFree(p->v.v);
	}
}

static void _serNrSysFreeSQN_NR_SetupRelease_BeamFailureRecoveryConfig_candidateBeamRSListExt_v1610_Value(union SQN_NR_SetupRelease_BeamFailureRecoveryConfig_candidateBeamRSListExt_v1610_Value* p, enum SQN_NR_SetupRelease_BeamFailureRecoveryConfig_candidateBeamRSListExt_v1610_Sel d)
{
	if (d == SQN_NR_SetupRelease_BeamFailureRecoveryConfig_candidateBeamRSListExt_v1610_setup) {
		if (p->setup.v) {
			for (size_t i2 = 0; i2 < p->setup.d; i2++) {
				_serNrSysFreeSQN_NR_PRACH_ResourceDedicatedBFR(&p->setup.v[i2]);
			}
			serFree(p->setup.v);
		}
		return;
	}
}

static void _serNrSysFreeSQN_NR_SetupRelease_BeamFailureRecoveryConfig_candidateBeamRSListExt_v1610(struct SQN_NR_SetupRelease_BeamFailureRecoveryConfig_candidateBeamRSListExt_v1610* p)
{
	_serNrSysFreeSQN_NR_SetupRelease_BeamFailureRecoveryConfig_candidateBeamRSListExt_v1610_Value(&p->v, p->d);
}

static void _serNrSysFreeSQN_NR_SetupRelease_BeamFailureRecoveryConfig_candidateBeamRSListExt_v1610_SQN_NR_BeamFailureRecoveryConfig_candidateBeamRSListExt_v1610_Optional(struct SQN_NR_SetupRelease_BeamFailureRecoveryConfig_candidateBeamRSListExt_v1610_SQN_NR_BeamFailureRecoveryConfig_candidateBeamRSListExt_v1610_Optional* p)
{
	if (!p->d) return;
	_serNrSysFreeSQN_NR_SetupRelease_BeamFailureRecoveryConfig_candidateBeamRSListExt_v1610(&p->v);
}

static void _serNrSysFreeSQN_NR_BeamFailureRecoveryConfig(struct SQN_NR_BeamFailureRecoveryConfig* p)
{
	_serNrSysFreeSQN_NR_PRACH_ResourceDedicatedBFR_SQN_NR_BeamFailureRecoveryConfig_candidateBeamRSList_DynamicOptional(&p->candidateBeamRSList);
	_serNrSysFreeSQN_NR_SetupRelease_BeamFailureRecoveryConfig_candidateBeamRSListExt_v1610_SQN_NR_BeamFailureRecoveryConfig_candidateBeamRSListExt_v1610_Optional(&p->candidateBeamRSListExt_v1610);
}

static void _serNrSysFreeSQN_NR_SetupRelease_BWP_UplinkDedicated_beamFailureRecoveryConfig_Value(union SQN_NR_SetupRelease_BWP_UplinkDedicated_beamFailureRecoveryConfig_Value* p, enum SQN_NR_SetupRelease_BWP_UplinkDedicated_beamFailureRecoveryConfig_Sel d)
{
	if (d == SQN_NR_SetupRelease_BWP_UplinkDedicated_beamFailureRecoveryConfig_setup) {
		_serNrSysFreeSQN_NR_BeamFailureRecoveryConfig(&p->setup);
		return;
	}
}

static void _serNrSysFreeSQN_NR_SetupRelease_BWP_UplinkDedicated_beamFailureRecoveryConfig(struct SQN_NR_SetupRelease_BWP_UplinkDedicated_beamFailureRecoveryConfig* p)
{
	_serNrSysFreeSQN_NR_SetupRelease_BWP_UplinkDedicated_beamFailureRecoveryConfig_Value(&p->v, p->d);
}

static void _serNrSysFreeSQN_NR_SetupRelease_BWP_UplinkDedicated_beamFailureRecoveryConfig_SQN_NR_BWP_UplinkDedicated_beamFailureRecoveryConfig_Optional(struct SQN_NR_SetupRelease_BWP_UplinkDedicated_beamFailureRecoveryConfig_SQN_NR_BWP_UplinkDedicated_beamFailureRecoveryConfig_Optional* p)
{
	if (!p->d) return;
	_serNrSysFreeSQN_NR_SetupRelease_BWP_UplinkDedicated_beamFailureRecoveryConfig(&p->v);
}

static void _serNrSysFreeSQN_NR_SetupRelease_BWP_UplinkDedicated_sl_PUCCH_Config_r16_Value(union SQN_NR_SetupRelease_BWP_UplinkDedicated_sl_PUCCH_Config_r16_Value* p, enum SQN_NR_SetupRelease_BWP_UplinkDedicated_sl_PUCCH_Config_r16_Sel d)
{
	if (d == SQN_NR_SetupRelease_BWP_UplinkDedicated_sl_PUCCH_Config_r16_setup) {
		_serNrSysFreeSQN_NR_PUCCH_Config(&p->setup);
		return;
	}
}

static void _serNrSysFreeSQN_NR_SetupRelease_BWP_UplinkDedicated_sl_PUCCH_Config_r16(struct SQN_NR_SetupRelease_BWP_UplinkDedicated_sl_PUCCH_Config_r16* p)
{
	_serNrSysFreeSQN_NR_SetupRelease_BWP_UplinkDedicated_sl_PUCCH_Config_r16_Value(&p->v, p->d);
}

static void _serNrSysFreeSQN_NR_SetupRelease_BWP_UplinkDedicated_sl_PUCCH_Config_r16_SQN_NR_BWP_UplinkDedicated_sl_PUCCH_Config_r16_Optional(struct SQN_NR_SetupRelease_BWP_UplinkDedicated_sl_PUCCH_Config_r16_SQN_NR_BWP_UplinkDedicated_sl_PUCCH_Config_r16_Optional* p)
{
	if (!p->d) return;
	_serNrSysFreeSQN_NR_SetupRelease_BWP_UplinkDedicated_sl_PUCCH_Config_r16(&p->v);
}

static void _serNrSysFreeSQN_NR_SetupRelease_BWP_UplinkDedicated_pucch_ConfigurationList_r16_Value(union SQN_NR_SetupRelease_BWP_UplinkDedicated_pucch_ConfigurationList_r16_Value* p, enum SQN_NR_SetupRelease_BWP_UplinkDedicated_pucch_ConfigurationList_r16_Sel d)
{
	if (d == SQN_NR_SetupRelease_BWP_UplinkDedicated_pucch_ConfigurationList_r16_setup) {
		if (p->setup.v) {
			for (size_t i2 = 0; i2 < p->setup.d; i2++) {
				_serNrSysFreeSQN_NR_PUCCH_Config(&p->setup.v[i2]);
			}
			serFree(p->setup.v);
		}
		return;
	}
}

static void _serNrSysFreeSQN_NR_SetupRelease_BWP_UplinkDedicated_pucch_ConfigurationList_r16(struct SQN_NR_SetupRelease_BWP_UplinkDedicated_pucch_ConfigurationList_r16* p)
{
	_serNrSysFreeSQN_NR_SetupRelease_BWP_UplinkDedicated_pucch_ConfigurationList_r16_Value(&p->v, p->d);
}

static void _serNrSysFreeSQN_NR_SetupRelease_BWP_UplinkDedicated_pucch_ConfigurationList_r16_SQN_NR_BWP_UplinkDedicated_pucch_ConfigurationList_r16_Optional(struct SQN_NR_SetupRelease_BWP_UplinkDedicated_pucch_ConfigurationList_r16_SQN_NR_BWP_UplinkDedicated_pucch_ConfigurationList_r16_Optional* p)
{
	if (!p->d) return;
	_serNrSysFreeSQN_NR_SetupRelease_BWP_UplinkDedicated_pucch_ConfigurationList_r16(&p->v);
}

static void _serNrSysFreeSQN_NR_ConfiguredGrantConfigToAddModList_r16_SQN_NR_BWP_UplinkDedicated_configuredGrantConfigToAddModList_r16_Optional(struct SQN_NR_ConfiguredGrantConfigToAddModList_r16_SQN_NR_BWP_UplinkDedicated_configuredGrantConfigToAddModList_r16_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i2 = 0; i2 < p->v.d; i2++) {
			_serNrSysFreeSQN_NR_ConfiguredGrantConfig(&p->v.v[i2]);
		}
		serFree(p->v.v);
	}
}

static void _serNrSysFreeSQN_NR_ConfiguredGrantConfigToReleaseList_r16_SQN_NR_BWP_UplinkDedicated_configuredGrantConfigToReleaseList_r16_Optional(struct SQN_NR_ConfiguredGrantConfigToReleaseList_r16_SQN_NR_BWP_UplinkDedicated_configuredGrantConfigToReleaseList_r16_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		serFree(p->v.v);
	}
}

static void _serNrSysFreeSQN_NR_ConfiguredGrantConfigType2DeactivationStateList_r16_SQN_NR_BWP_UplinkDedicated_configuredGrantConfigType2DeactivationStateList_r16_Optional(struct SQN_NR_ConfiguredGrantConfigType2DeactivationStateList_r16_SQN_NR_BWP_UplinkDedicated_configuredGrantConfigType2DeactivationStateList_r16_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i2 = 0; i2 < p->v.d; i2++) {
			if (p->v.v[i2].v) {
				serFree(p->v.v[i2].v);
			}
		}
		serFree(p->v.v);
	}
}

static void _serNrSysFreeSQN_NR_BWP_UplinkDedicated(struct SQN_NR_BWP_UplinkDedicated* p)
{
	_serNrSysFreeSQN_NR_SetupRelease_BWP_UplinkDedicated_pucch_Config_SQN_NR_BWP_UplinkDedicated_pucch_Config_Optional(&p->pucch_Config);
	_serNrSysFreeSQN_NR_SetupRelease_BWP_UplinkDedicated_pusch_Config_SQN_NR_BWP_UplinkDedicated_pusch_Config_Optional(&p->pusch_Config);
	_serNrSysFreeSQN_NR_SetupRelease_BWP_UplinkDedicated_configuredGrantConfig_SQN_NR_BWP_UplinkDedicated_configuredGrantConfig_Optional(&p->configuredGrantConfig);
	_serNrSysFreeSQN_NR_SetupRelease_BWP_UplinkDedicated_srs_Config_SQN_NR_BWP_UplinkDedicated_srs_Config_Optional(&p->srs_Config);
	_serNrSysFreeSQN_NR_SetupRelease_BWP_UplinkDedicated_beamFailureRecoveryConfig_SQN_NR_BWP_UplinkDedicated_beamFailureRecoveryConfig_Optional(&p->beamFailureRecoveryConfig);
	_serNrSysFreeSQN_NR_SetupRelease_BWP_UplinkDedicated_sl_PUCCH_Config_r16_SQN_NR_BWP_UplinkDedicated_sl_PUCCH_Config_r16_Optional(&p->sl_PUCCH_Config_r16);
	_serNrSysFreeSQN_NR_SetupRelease_BWP_UplinkDedicated_pucch_ConfigurationList_r16_SQN_NR_BWP_UplinkDedicated_pucch_ConfigurationList_r16_Optional(&p->pucch_ConfigurationList_r16);
	_serNrSysFreeSQN_NR_ConfiguredGrantConfigToAddModList_r16_SQN_NR_BWP_UplinkDedicated_configuredGrantConfigToAddModList_r16_Optional(&p->configuredGrantConfigToAddModList_r16);
	_serNrSysFreeSQN_NR_ConfiguredGrantConfigToReleaseList_r16_SQN_NR_BWP_UplinkDedicated_configuredGrantConfigToReleaseList_r16_Optional(&p->configuredGrantConfigToReleaseList_r16);
	_serNrSysFreeSQN_NR_ConfiguredGrantConfigType2DeactivationStateList_r16_SQN_NR_BWP_UplinkDedicated_configuredGrantConfigType2DeactivationStateList_r16_Optional(&p->configuredGrantConfigType2DeactivationStateList_r16);
}

static void _serNrSysFreeNR_ASN1_BWP_UplinkDedicated_Type_Value(union NR_ASN1_BWP_UplinkDedicated_Type_Value* p, enum NR_ASN1_BWP_UplinkDedicated_Type_Sel d)
{
	if (d == NR_ASN1_BWP_UplinkDedicated_Type_R15) {
		_serNrSysFreeSQN_NR_BWP_UplinkDedicated(&p->R15);
		return;
	}
}

static void _serNrSysFreeNR_ASN1_BWP_UplinkDedicated_Type(struct NR_ASN1_BWP_UplinkDedicated_Type* p)
{
	_serNrSysFreeNR_ASN1_BWP_UplinkDedicated_Type_Value(&p->v, p->d);
}

static void _serNrSysFreeNR_ASN1_BWP_UplinkDedicated_Type_Dedicated_Optional(struct NR_ASN1_BWP_UplinkDedicated_Type_Dedicated_Optional* p)
{
	if (!p->d) return;
	_serNrSysFreeNR_ASN1_BWP_UplinkDedicated_Type(&p->v);
}

static void _serNrSysFreeNR_UplinkBWP_Type(struct NR_UplinkBWP_Type* p)
{
	_serNrSysFreeNR_ASN1_BWP_UplinkCommon_Type_Common_Optional(&p->Common);
	_serNrSysFreeNR_ASN1_BWP_UplinkDedicated_Type_Dedicated_Optional(&p->Dedicated);
}

static void _serNrSysFreeNR_UplinkBWP_List_Type_BwpArray_Optional(struct NR_UplinkBWP_List_Type_BwpArray_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i1 = 0; i1 < p->v.d; i1++) {
			_serNrSysFreeNR_UplinkBWP_Type(&p->v.v[i1]);
		}
		serFree(p->v.v);
	}
}

static void _serNrSysFreeNR_UplinkBWPs_Type(struct NR_UplinkBWPs_Type* p)
{
	_serNrSysFreeNR_UplinkBWP_List_Type_BwpArray_Optional(&p->BwpArray);
}

static void _serNrSysFreeNR_UplinkBWPs_Type_BWPs_Optional(struct NR_UplinkBWPs_Type_BWPs_Optional* p)
{
	if (!p->d) return;
	_serNrSysFreeNR_UplinkBWPs_Type(&p->v);
}

static void _serNrSysFreeSQN_NR_CFRA_resources_ssb(struct SQN_NR_CFRA_resources_ssb* p)
{
	if (p->ssb_ResourceList.v) {
		for (size_t i1 = 0; i1 < p->ssb_ResourceList.d; i1++) {
		}
		serFree(p->ssb_ResourceList.v);
	}
}

static void _serNrSysFreeSQN_NR_CFRA_CSIRS_Resource(struct SQN_NR_CFRA_CSIRS_Resource* p)
{
	if (p->ra_OccasionList.v) {
		serFree(p->ra_OccasionList.v);
	}
}

static void _serNrSysFreeSQN_NR_CFRA_resources_csirs(struct SQN_NR_CFRA_resources_csirs* p)
{
	if (p->csirs_ResourceList.v) {
		for (size_t i1 = 0; i1 < p->csirs_ResourceList.d; i1++) {
			_serNrSysFreeSQN_NR_CFRA_CSIRS_Resource(&p->csirs_ResourceList.v[i1]);
		}
		serFree(p->csirs_ResourceList.v);
	}
}

static void _serNrSysFreeSQN_NR_CFRA_resources_Value(union SQN_NR_CFRA_resources_Value* p, enum SQN_NR_CFRA_resources_Sel d)
{
	if (d == SQN_NR_CFRA_resources_ssb) {
		_serNrSysFreeSQN_NR_CFRA_resources_ssb(&p->ssb);
		return;
	}
	if (d == SQN_NR_CFRA_resources_csirs) {
		_serNrSysFreeSQN_NR_CFRA_resources_csirs(&p->csirs);
		return;
	}
}

static void _serNrSysFreeSQN_NR_CFRA_resources(struct SQN_NR_CFRA_resources* p)
{
	_serNrSysFreeSQN_NR_CFRA_resources_Value(&p->v, p->d);
}

static void _serNrSysFreeSQN_NR_CFRA(struct SQN_NR_CFRA* p)
{
	_serNrSysFreeSQN_NR_CFRA_resources(&p->resources);
}

static void _serNrSysFreeSQN_NR_CFRA_SQN_NR_RACH_ConfigDedicated_cfra_Optional(struct SQN_NR_CFRA_SQN_NR_RACH_ConfigDedicated_cfra_Optional* p)
{
	if (!p->d) return;
	_serNrSysFreeSQN_NR_CFRA(&p->v);
}

static void _serNrSysFreeSQN_NR_CFRA_TwoStep_r16_resourcesTwoStep_r16(struct SQN_NR_CFRA_TwoStep_r16_resourcesTwoStep_r16* p)
{
	if (p->ssb_ResourceList.v) {
		for (size_t i1 = 0; i1 < p->ssb_ResourceList.d; i1++) {
		}
		serFree(p->ssb_ResourceList.v);
	}
}

static void _serNrSysFreeSQN_NR_CFRA_TwoStep_r16(struct SQN_NR_CFRA_TwoStep_r16* p)
{
	_serNrSysFreeSQN_NR_CFRA_TwoStep_r16_resourcesTwoStep_r16(&p->resourcesTwoStep_r16);
}

static void _serNrSysFreeSQN_NR_CFRA_TwoStep_r16_SQN_NR_RACH_ConfigDedicated_cfra_TwoStep_r16_Optional(struct SQN_NR_CFRA_TwoStep_r16_SQN_NR_RACH_ConfigDedicated_cfra_TwoStep_r16_Optional* p)
{
	if (!p->d) return;
	_serNrSysFreeSQN_NR_CFRA_TwoStep_r16(&p->v);
}

static void _serNrSysFreeSQN_NR_RACH_ConfigDedicated(struct SQN_NR_RACH_ConfigDedicated* p)
{
	_serNrSysFreeSQN_NR_CFRA_SQN_NR_RACH_ConfigDedicated_cfra_Optional(&p->cfra);
	_serNrSysFreeSQN_NR_CFRA_TwoStep_r16_SQN_NR_RACH_ConfigDedicated_cfra_TwoStep_r16_Optional(&p->cfra_TwoStep_r16);
}

static void _serNrSysFreeNR_ASN1_RACH_ConfigDedicated_Type_Value(union NR_ASN1_RACH_ConfigDedicated_Type_Value* p, enum NR_ASN1_RACH_ConfigDedicated_Type_Sel d)
{
	if (d == NR_ASN1_RACH_ConfigDedicated_Type_R15) {
		_serNrSysFreeSQN_NR_RACH_ConfigDedicated(&p->R15);
		return;
	}
}

static void _serNrSysFreeNR_ASN1_RACH_ConfigDedicated_Type(struct NR_ASN1_RACH_ConfigDedicated_Type* p)
{
	_serNrSysFreeNR_ASN1_RACH_ConfigDedicated_Type_Value(&p->v, p->d);
}

static void _serNrSysFreeNR_ASN1_RACH_ConfigDedicated_Type_RACH_ConfigDedicated_Optional(struct NR_ASN1_RACH_ConfigDedicated_Type_RACH_ConfigDedicated_Optional* p)
{
	if (!p->d) return;
	_serNrSysFreeNR_ASN1_RACH_ConfigDedicated_Type(&p->v);
}

static void _serNrSysFreeSQN_NR_SI_RequestConfig(struct SQN_NR_SI_RequestConfig* p)
{
	if (p->si_RequestResources.v) {
		for (size_t i1 = 0; i1 < p->si_RequestResources.d; i1++) {
		}
		serFree(p->si_RequestResources.v);
	}
}

static void _serNrSysFreeNR_ASN1_SI_RequestConfig_Type_Value(union NR_ASN1_SI_RequestConfig_Type_Value* p, enum NR_ASN1_SI_RequestConfig_Type_Sel d)
{
	if (d == NR_ASN1_SI_RequestConfig_Type_R15) {
		_serNrSysFreeSQN_NR_SI_RequestConfig(&p->R15);
		return;
	}
}

static void _serNrSysFreeNR_ASN1_SI_RequestConfig_Type(struct NR_ASN1_SI_RequestConfig_Type* p)
{
	_serNrSysFreeNR_ASN1_SI_RequestConfig_Type_Value(&p->v, p->d);
}

static void _serNrSysFreeNR_ASN1_SI_RequestConfig_Type_SI_RequestConfig_Optional(struct NR_ASN1_SI_RequestConfig_Type_SI_RequestConfig_Optional* p)
{
	if (!p->d) return;
	_serNrSysFreeNR_ASN1_SI_RequestConfig_Type(&p->v);
}

static void _serNrSysFreeNR_UplinkConfig_Type(struct NR_UplinkConfig_Type* p)
{
	_serNrSysFreeNR_ASN1_FrequencyInfoUL_Type_FrequencyInfoUL_Optional(&p->FrequencyInfoUL);
	_serNrSysFreeNR_UplinkBWPs_Type_BWPs_Optional(&p->BWPs);
	_serNrSysFreeNR_ASN1_RACH_ConfigDedicated_Type_RACH_ConfigDedicated_Optional(&p->RACH_ConfigDedicated);
	_serNrSysFreeNR_ASN1_SI_RequestConfig_Type_SI_RequestConfig_Optional(&p->SI_RequestConfig);
}

static void _serNrSysFreeNR_Uplink_Type_Value(union NR_Uplink_Type_Value* p, enum NR_Uplink_Type_Sel d)
{
	if (d == NR_Uplink_Type_Config) {
		_serNrSysFreeNR_UplinkConfig_Type(&p->Config);
		return;
	}
}

static void _serNrSysFreeNR_Uplink_Type(struct NR_Uplink_Type* p)
{
	_serNrSysFreeNR_Uplink_Type_Value(&p->v, p->d);
}

static void _serNrSysFreeNR_Uplink_Type_Uplink_Optional(struct NR_Uplink_Type_Uplink_Optional* p)
{
	if (!p->d) return;
	_serNrSysFreeNR_Uplink_Type(&p->v);
}

static void _serNrSysFreeNR_Uplink_Type_SupplementaryUplink_Optional(struct NR_Uplink_Type_SupplementaryUplink_Optional* p)
{
	if (!p->d) return;
	_serNrSysFreeNR_Uplink_Type(&p->v);
}

static void _serNrSysFreeNR_CellConfigPhysicalLayerUplink_Type(struct NR_CellConfigPhysicalLayerUplink_Type* p)
{
	_serNrSysFreeNR_Uplink_Type_Uplink_Optional(&p->Uplink);
	_serNrSysFreeNR_Uplink_Type_SupplementaryUplink_Optional(&p->SupplementaryUplink);
}

static void _serNrSysFreeNR_CellConfigPhysicalLayerUplink_Type_Uplink_Optional(struct NR_CellConfigPhysicalLayerUplink_Type_Uplink_Optional* p)
{
	if (!p->d) return;
	_serNrSysFreeNR_CellConfigPhysicalLayerUplink_Type(&p->v);
}

static void _serNrSysFreeNR_CellConfigPhysicalLayer_Type(struct NR_CellConfigPhysicalLayer_Type* p)
{
	_serNrSysFreeNR_CellConfigPhysicalLayerCommon_Type_Common_Optional(&p->Common);
	_serNrSysFreeNR_CellConfigPhysicalLayerDownlink_Type_Downlink_Optional(&p->Downlink);
	_serNrSysFreeNR_CellConfigPhysicalLayerUplink_Type_Uplink_Optional(&p->Uplink);
}

static void _serNrSysFreeNR_CellConfigPhysicalLayer_Type_PhysicalLayer_Optional(struct NR_CellConfigPhysicalLayer_Type_PhysicalLayer_Optional* p)
{
	if (!p->d) return;
	_serNrSysFreeNR_CellConfigPhysicalLayer_Type(&p->v);
}

static void _serNrSysFreeNR_AssignedBWPs_Type(struct NR_AssignedBWPs_Type* p)
{
	if (p->DedicatedBWPs.v) {
		serFree(p->DedicatedBWPs.v);
	}
}

static void _serNrSysFreeNR_AssignedBWPs_Type_NR_SearchSpaceDlDciAssignment_Type_AssignedBWPs_Optional(struct NR_AssignedBWPs_Type_NR_SearchSpaceDlDciAssignment_Type_AssignedBWPs_Optional* p)
{
	if (!p->d) return;
	_serNrSysFreeNR_AssignedBWPs_Type(&p->v);
}

static void _serNrSysFreeNR_DciCommon_TimeDomainResourceAssignment_Type_Value(union NR_DciCommon_TimeDomainResourceAssignment_Type_Value* p, enum NR_DciCommon_TimeDomainResourceAssignment_Type_Sel d)
{
	if (d == NR_DciCommon_TimeDomainResourceAssignment_Type_Index) {
		if (p->Index.v) {
			serFree(p->Index.v);
		}
		return;
	}
}

static void _serNrSysFreeNR_DciCommon_TimeDomainResourceAssignment_Type(struct NR_DciCommon_TimeDomainResourceAssignment_Type* p)
{
	_serNrSysFreeNR_DciCommon_TimeDomainResourceAssignment_Type_Value(&p->v, p->d);
}

static void _serNrSysFreeNR_DciCommon_TimeDomainResourceAssignment_Type_NR_DciFormat_1_X_ResourceAssignment_Type_TimeDomain_Optional(struct NR_DciCommon_TimeDomainResourceAssignment_Type_NR_DciFormat_1_X_ResourceAssignment_Type_TimeDomain_Optional* p)
{
	if (!p->d) return;
	_serNrSysFreeNR_DciCommon_TimeDomainResourceAssignment_Type(&p->v);
}

static void _serNrSysFreeNR_RedundancyVersionList_Type_RedundancyVersionList_Optional(struct NR_RedundancyVersionList_Type_RedundancyVersionList_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		serFree(p->v.v);
	}
}

static void _serNrSysFreeNR_TransportBlockSchedulingDL_Automatic_Type(struct NR_TransportBlockSchedulingDL_Automatic_Type* p)
{
	_serNrSysFreeNR_RedundancyVersionList_Type_RedundancyVersionList_Optional(&p->RedundancyVersionList);
}

static void _serNrSysFreeNR_TransportBlockRetransmissionList_Type_TransportBlock2_Optional(struct NR_TransportBlockRetransmissionList_Type_TransportBlock2_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i1 = 0; i1 < p->v.d; i1++) {
		}
		serFree(p->v.v);
	}
}

static void _serNrSysFreeNR_TransportBlockSchedulingDL_Explicit_Type(struct NR_TransportBlockSchedulingDL_Explicit_Type* p)
{
	if (p->TransportBlock1.v) {
		for (size_t i1 = 0; i1 < p->TransportBlock1.d; i1++) {
		}
		serFree(p->TransportBlock1.v);
	}
	_serNrSysFreeNR_TransportBlockRetransmissionList_Type_TransportBlock2_Optional(&p->TransportBlock2);
}

static void _serNrSysFreeNR_TransportBlockSchedulingDL_Type_Value(union NR_TransportBlockSchedulingDL_Type_Value* p, enum NR_TransportBlockSchedulingDL_Type_Sel d)
{
	if (d == NR_TransportBlockSchedulingDL_Type_Automatic) {
		_serNrSysFreeNR_TransportBlockSchedulingDL_Automatic_Type(&p->Automatic);
		return;
	}
	if (d == NR_TransportBlockSchedulingDL_Type_Explicit) {
		_serNrSysFreeNR_TransportBlockSchedulingDL_Explicit_Type(&p->Explicit);
		return;
	}
}

static void _serNrSysFreeNR_TransportBlockSchedulingDL_Type(struct NR_TransportBlockSchedulingDL_Type* p)
{
	_serNrSysFreeNR_TransportBlockSchedulingDL_Type_Value(&p->v, p->d);
}

static void _serNrSysFreeNR_TransportBlockSchedulingDL_Type_TransportBlockScheduling_Optional(struct NR_TransportBlockSchedulingDL_Type_TransportBlockScheduling_Optional* p)
{
	if (!p->d) return;
	_serNrSysFreeNR_TransportBlockSchedulingDL_Type(&p->v);
}

static void _serNrSysFreeNR_HarqProcessConfig_Type_Value(union NR_HarqProcessConfig_Type_Value* p, enum NR_HarqProcessConfig_Type_Sel d)
{
	if (d == NR_HarqProcessConfig_Type_SpecificSubset) {
		if (p->SpecificSubset.v) {
			serFree(p->SpecificSubset.v);
		}
		return;
	}
}

static void _serNrSysFreeNR_HarqProcessConfig_Type(struct NR_HarqProcessConfig_Type* p)
{
	_serNrSysFreeNR_HarqProcessConfig_Type_Value(&p->v, p->d);
}

static void _serNrSysFreeNR_HarqProcessConfig_Type_NR_DciFormat_1_X_ResourceAssignment_Type_HarqProcessConfig_Optional(struct NR_HarqProcessConfig_Type_NR_DciFormat_1_X_ResourceAssignment_Type_HarqProcessConfig_Optional* p)
{
	if (!p->d) return;
	_serNrSysFreeNR_HarqProcessConfig_Type(&p->v);
}

static void _serNrSysFreeNR_DciFormat_1_X_ResourceAssignment_Type(struct NR_DciFormat_1_X_ResourceAssignment_Type* p)
{
	_serNrSysFreeNR_DciCommon_TimeDomainResourceAssignment_Type_NR_DciFormat_1_X_ResourceAssignment_Type_TimeDomain_Optional(&p->TimeDomain);
	_serNrSysFreeNR_TransportBlockSchedulingDL_Type_TransportBlockScheduling_Optional(&p->TransportBlockScheduling);
	_serNrSysFreeNR_HarqProcessConfig_Type_NR_DciFormat_1_X_ResourceAssignment_Type_HarqProcessConfig_Optional(&p->HarqProcessConfig);
}

static void _serNrSysFreeNR_DciFormat_1_X_ResourceAssignment_Type_ResoureAssignment_Optional(struct NR_DciFormat_1_X_ResourceAssignment_Type_ResoureAssignment_Optional* p)
{
	if (!p->d) return;
	_serNrSysFreeNR_DciFormat_1_X_ResourceAssignment_Type(&p->v);
}

static void _serNrSysFreeNR_DciFormat_1_X_PdschHarqTimingIndicator_Type_Value(union NR_DciFormat_1_X_PdschHarqTimingIndicator_Type_Value* p, enum NR_DciFormat_1_X_PdschHarqTimingIndicator_Type_Sel d)
{
	if (d == NR_DciFormat_1_X_PdschHarqTimingIndicator_Type_Value) {
		if (p->Value.v) {
			serFree(p->Value.v);
		}
		return;
	}
}

static void _serNrSysFreeNR_DciFormat_1_X_PdschHarqTimingIndicator_Type(struct NR_DciFormat_1_X_PdschHarqTimingIndicator_Type* p)
{
	_serNrSysFreeNR_DciFormat_1_X_PdschHarqTimingIndicator_Type_Value(&p->v, p->d);
}

static void _serNrSysFreeNR_DciFormat_1_X_PdschHarqTimingIndicator_Type_NR_DciFormat_1_0_SpecificInfo_Type_PdschHarqTimingIndicator_Optional(struct NR_DciFormat_1_X_PdschHarqTimingIndicator_Type_NR_DciFormat_1_0_SpecificInfo_Type_PdschHarqTimingIndicator_Optional* p)
{
	if (!p->d) return;
	_serNrSysFreeNR_DciFormat_1_X_PdschHarqTimingIndicator_Type(&p->v);
}

static void _serNrSysFreeNR_DciFormat_1_0_SpecificInfo_Type(struct NR_DciFormat_1_0_SpecificInfo_Type* p)
{
	_serNrSysFreeNR_DciFormat_1_X_PdschHarqTimingIndicator_Type_NR_DciFormat_1_0_SpecificInfo_Type_PdschHarqTimingIndicator_Optional(&p->PdschHarqTimingIndicator);
}

static void _serNrSysFreeNR_DciCommon_BWPIndicator_Type_Value(union NR_DciCommon_BWPIndicator_Type_Value* p, enum NR_DciCommon_BWPIndicator_Type_Sel d)
{
	if (d == NR_DciCommon_BWPIndicator_Type_Index) {
		if (p->Index.v) {
			serFree(p->Index.v);
		}
		return;
	}
}

static void _serNrSysFreeNR_DciCommon_BWPIndicator_Type(struct NR_DciCommon_BWPIndicator_Type* p)
{
	_serNrSysFreeNR_DciCommon_BWPIndicator_Type_Value(&p->v, p->d);
}

static void _serNrSysFreeNR_DciCommon_BWPIndicator_Type_NR_DciFormat_1_1_SpecificInfo_Type_BWPIndicator_Optional(struct NR_DciCommon_BWPIndicator_Type_NR_DciFormat_1_1_SpecificInfo_Type_BWPIndicator_Optional* p)
{
	if (!p->d) return;
	_serNrSysFreeNR_DciCommon_BWPIndicator_Type(&p->v);
}

static void _serNrSysFreeNR_DciFormat_1_1_RateMatchingIndicator_Type_Value(union NR_DciFormat_1_1_RateMatchingIndicator_Type_Value* p, enum NR_DciFormat_1_1_RateMatchingIndicator_Type_Sel d)
{
	if (d == NR_DciFormat_1_1_RateMatchingIndicator_Type_Bitmap) {
		if (p->Bitmap.v) {
			serFree(p->Bitmap.v);
		}
		return;
	}
}

static void _serNrSysFreeNR_DciFormat_1_1_RateMatchingIndicator_Type(struct NR_DciFormat_1_1_RateMatchingIndicator_Type* p)
{
	_serNrSysFreeNR_DciFormat_1_1_RateMatchingIndicator_Type_Value(&p->v, p->d);
}

static void _serNrSysFreeNR_DciFormat_1_1_RateMatchingIndicator_Type_RateMatchingIndicator_Optional(struct NR_DciFormat_1_1_RateMatchingIndicator_Type_RateMatchingIndicator_Optional* p)
{
	if (!p->d) return;
	_serNrSysFreeNR_DciFormat_1_1_RateMatchingIndicator_Type(&p->v);
}

static void _serNrSysFreeNR_DciFormat_1_1_ZP_CSI_RS_Trigger_Type_Value(union NR_DciFormat_1_1_ZP_CSI_RS_Trigger_Type_Value* p, enum NR_DciFormat_1_1_ZP_CSI_RS_Trigger_Type_Sel d)
{
	if (d == NR_DciFormat_1_1_ZP_CSI_RS_Trigger_Type_Index) {
		if (p->Index.v) {
			serFree(p->Index.v);
		}
		return;
	}
}

static void _serNrSysFreeNR_DciFormat_1_1_ZP_CSI_RS_Trigger_Type(struct NR_DciFormat_1_1_ZP_CSI_RS_Trigger_Type* p)
{
	_serNrSysFreeNR_DciFormat_1_1_ZP_CSI_RS_Trigger_Type_Value(&p->v, p->d);
}

static void _serNrSysFreeNR_DciFormat_1_1_ZP_CSI_RS_Trigger_Type_ZP_CSI_RS_Trigger_Optional(struct NR_DciFormat_1_1_ZP_CSI_RS_Trigger_Type_ZP_CSI_RS_Trigger_Optional* p)
{
	if (!p->d) return;
	_serNrSysFreeNR_DciFormat_1_1_ZP_CSI_RS_Trigger_Type(&p->v);
}

static void _serNrSysFreeNR_DciFormat_1_X_PdschHarqTimingIndicator_Type_NR_DciFormat_1_1_SpecificInfo_Type_PdschHarqTimingIndicator_Optional(struct NR_DciFormat_1_X_PdschHarqTimingIndicator_Type_NR_DciFormat_1_1_SpecificInfo_Type_PdschHarqTimingIndicator_Optional* p)
{
	if (!p->d) return;
	_serNrSysFreeNR_DciFormat_1_X_PdschHarqTimingIndicator_Type(&p->v);
}

static void _serNrSysFreeNR_DciFormat_1_1_NewFeedbackIndicator_Type_Value(union NR_DciFormat_1_1_NewFeedbackIndicator_Type_Value* p, enum NR_DciFormat_1_1_NewFeedbackIndicator_Type_Sel d)
{
	if (d == NR_DciFormat_1_1_NewFeedbackIndicator_Type_Value) {
		if (p->Value.v) {
			serFree(p->Value.v);
		}
		return;
	}
}

static void _serNrSysFreeNR_DciFormat_1_1_NewFeedbackIndicator_Type(struct NR_DciFormat_1_1_NewFeedbackIndicator_Type* p)
{
	_serNrSysFreeNR_DciFormat_1_1_NewFeedbackIndicator_Type_Value(&p->v, p->d);
}

static void _serNrSysFreeNR_DciFormat_1_1_NewFeedbackIndicator_Type_NewFeedbackIndicator_Optional(struct NR_DciFormat_1_1_NewFeedbackIndicator_Type_NewFeedbackIndicator_Optional* p)
{
	if (!p->d) return;
	_serNrSysFreeNR_DciFormat_1_1_NewFeedbackIndicator_Type(&p->v);
}

static void _serNrSysFreeNR_DciFormat_1_1_AntennaPorts_Type_Value(union NR_DciFormat_1_1_AntennaPorts_Type_Value* p, enum NR_DciFormat_1_1_AntennaPorts_Type_Sel d)
{
	if (d == NR_DciFormat_1_1_AntennaPorts_Type_Index) {
		if (p->Index.v) {
			serFree(p->Index.v);
		}
		return;
	}
}

static void _serNrSysFreeNR_DciFormat_1_1_AntennaPorts_Type(struct NR_DciFormat_1_1_AntennaPorts_Type* p)
{
	_serNrSysFreeNR_DciFormat_1_1_AntennaPorts_Type_Value(&p->v, p->d);
}

static void _serNrSysFreeNR_DciFormat_1_1_AntennaPorts_Type_AntennaPorts_Optional(struct NR_DciFormat_1_1_AntennaPorts_Type_AntennaPorts_Optional* p)
{
	if (!p->d) return;
	_serNrSysFreeNR_DciFormat_1_1_AntennaPorts_Type(&p->v);
}

static void _serNrSysFreeNR_DciFormat_1_1_CBGTI_Type_Value(union NR_DciFormat_1_1_CBGTI_Type_Value* p, enum NR_DciFormat_1_1_CBGTI_Type_Sel d)
{
	if (d == NR_DciFormat_1_1_CBGTI_Type_Bitmap) {
		if (p->Bitmap.v) {
			serFree(p->Bitmap.v);
		}
		return;
	}
}

static void _serNrSysFreeNR_DciFormat_1_1_CBGTI_Type(struct NR_DciFormat_1_1_CBGTI_Type* p)
{
	_serNrSysFreeNR_DciFormat_1_1_CBGTI_Type_Value(&p->v, p->d);
}

static void _serNrSysFreeNR_DciFormat_1_1_CBGTI_Type_CBGTI_Optional(struct NR_DciFormat_1_1_CBGTI_Type_CBGTI_Optional* p)
{
	if (!p->d) return;
	_serNrSysFreeNR_DciFormat_1_1_CBGTI_Type(&p->v);
}

static void _serNrSysFreeNR_DciFormat_1_1_ChannelAccessCPext_Type_Value(union NR_DciFormat_1_1_ChannelAccessCPext_Type_Value* p, enum NR_DciFormat_1_1_ChannelAccessCPext_Type_Sel d)
{
	if (d == NR_DciFormat_1_1_ChannelAccessCPext_Type_Value) {
		if (p->Value.v) {
			serFree(p->Value.v);
		}
		return;
	}
}

static void _serNrSysFreeNR_DciFormat_1_1_ChannelAccessCPext_Type(struct NR_DciFormat_1_1_ChannelAccessCPext_Type* p)
{
	_serNrSysFreeNR_DciFormat_1_1_ChannelAccessCPext_Type_Value(&p->v, p->d);
}

static void _serNrSysFreeNR_DciFormat_1_1_ChannelAccessCPext_Type_ChannelAccessCPext_Optional(struct NR_DciFormat_1_1_ChannelAccessCPext_Type_ChannelAccessCPext_Optional* p)
{
	if (!p->d) return;
	_serNrSysFreeNR_DciFormat_1_1_ChannelAccessCPext_Type(&p->v);
}

static void _serNrSysFreeNR_DciFormat_X_1_SCellDormancyIndication_Type_Value(union NR_DciFormat_X_1_SCellDormancyIndication_Type_Value* p, enum NR_DciFormat_X_1_SCellDormancyIndication_Type_Sel d)
{
	if (d == NR_DciFormat_X_1_SCellDormancyIndication_Type_Value) {
		if (p->Value.v) {
			serFree(p->Value.v);
		}
		return;
	}
}

static void _serNrSysFreeNR_DciFormat_X_1_SCellDormancyIndication_Type(struct NR_DciFormat_X_1_SCellDormancyIndication_Type* p)
{
	_serNrSysFreeNR_DciFormat_X_1_SCellDormancyIndication_Type_Value(&p->v, p->d);
}

static void _serNrSysFreeNR_DciFormat_X_1_SCellDormancyIndication_Type_NR_DciFormat_1_1_SpecificInfo_Type_SCellDormancyIndication_Optional(struct NR_DciFormat_X_1_SCellDormancyIndication_Type_NR_DciFormat_1_1_SpecificInfo_Type_SCellDormancyIndication_Optional* p)
{
	if (!p->d) return;
	_serNrSysFreeNR_DciFormat_X_1_SCellDormancyIndication_Type(&p->v);
}

static void _serNrSysFreeNR_DciFormat_1_1_SpecificInfo_Type(struct NR_DciFormat_1_1_SpecificInfo_Type* p)
{
	_serNrSysFreeNR_DciCommon_BWPIndicator_Type_NR_DciFormat_1_1_SpecificInfo_Type_BWPIndicator_Optional(&p->BWPIndicator);
	_serNrSysFreeNR_DciFormat_1_1_RateMatchingIndicator_Type_RateMatchingIndicator_Optional(&p->RateMatchingIndicator);
	_serNrSysFreeNR_DciFormat_1_1_ZP_CSI_RS_Trigger_Type_ZP_CSI_RS_Trigger_Optional(&p->ZP_CSI_RS_Trigger);
	_serNrSysFreeNR_DciFormat_1_X_PdschHarqTimingIndicator_Type_NR_DciFormat_1_1_SpecificInfo_Type_PdschHarqTimingIndicator_Optional(&p->PdschHarqTimingIndicator);
	_serNrSysFreeNR_DciFormat_1_1_NewFeedbackIndicator_Type_NewFeedbackIndicator_Optional(&p->NewFeedbackIndicator);
	_serNrSysFreeNR_DciFormat_1_1_AntennaPorts_Type_AntennaPorts_Optional(&p->AntennaPorts);
	_serNrSysFreeNR_DciFormat_1_1_CBGTI_Type_CBGTI_Optional(&p->CBGTI);
	_serNrSysFreeNR_DciFormat_1_1_ChannelAccessCPext_Type_ChannelAccessCPext_Optional(&p->ChannelAccessCPext);
	_serNrSysFreeNR_DciFormat_X_1_SCellDormancyIndication_Type_NR_DciFormat_1_1_SpecificInfo_Type_SCellDormancyIndication_Optional(&p->SCellDormancyIndication);
}

static void _serNrSysFreeNR_DciFormat_1_X_SpecificInfo_Type_Value(union NR_DciFormat_1_X_SpecificInfo_Type_Value* p, enum NR_DciFormat_1_X_SpecificInfo_Type_Sel d)
{
	if (d == NR_DciFormat_1_X_SpecificInfo_Type_Format_1_0) {
		_serNrSysFreeNR_DciFormat_1_0_SpecificInfo_Type(&p->Format_1_0);
		return;
	}
	if (d == NR_DciFormat_1_X_SpecificInfo_Type_Format_1_1) {
		_serNrSysFreeNR_DciFormat_1_1_SpecificInfo_Type(&p->Format_1_1);
		return;
	}
}

static void _serNrSysFreeNR_DciFormat_1_X_SpecificInfo_Type(struct NR_DciFormat_1_X_SpecificInfo_Type* p)
{
	_serNrSysFreeNR_DciFormat_1_X_SpecificInfo_Type_Value(&p->v, p->d);
}

static void _serNrSysFreeNR_DciFormat_1_X_SpecificInfo_Type_Format_Optional(struct NR_DciFormat_1_X_SpecificInfo_Type_Format_Optional* p)
{
	if (!p->d) return;
	_serNrSysFreeNR_DciFormat_1_X_SpecificInfo_Type(&p->v);
}

static void _serNrSysFreeNR_DciDlInfo_Type(struct NR_DciDlInfo_Type* p)
{
	_serNrSysFreeNR_DciFormat_1_X_ResourceAssignment_Type_ResoureAssignment_Optional(&p->ResoureAssignment);
	_serNrSysFreeNR_DciFormat_1_X_SpecificInfo_Type_Format_Optional(&p->Format);
}

static void _serNrSysFreeNR_DciDlInfo_Type_DciInfo_Optional(struct NR_DciDlInfo_Type_DciInfo_Optional* p)
{
	if (!p->d) return;
	_serNrSysFreeNR_DciDlInfo_Type(&p->v);
}

static void _serNrSysFreeNR_SearchSpaceDlDciAssignment_Type(struct NR_SearchSpaceDlDciAssignment_Type* p)
{
	_serNrSysFreeNR_AssignedBWPs_Type_NR_SearchSpaceDlDciAssignment_Type_AssignedBWPs_Optional(&p->AssignedBWPs);
	_serNrSysFreeNR_DciDlInfo_Type_DciInfo_Optional(&p->DciInfo);
}

static void _serNrSysFreeNR_SearchSpaceDlDciAssignment_Type_NR_Sib1Schedul_Type_SearchSpaceAndDci_Optional(struct NR_SearchSpaceDlDciAssignment_Type_NR_Sib1Schedul_Type_SearchSpaceAndDci_Optional* p)
{
	if (!p->d) return;
	_serNrSysFreeNR_SearchSpaceDlDciAssignment_Type(&p->v);
}

static void _serNrSysFreeIntegerList_Type_SlotOffsetList_Optional(struct IntegerList_Type_SlotOffsetList_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		serFree(p->v.v);
	}
}

static void _serNrSysFreeNR_Sib1Schedul_Type(struct NR_Sib1Schedul_Type* p)
{
	_serNrSysFreeNR_SearchSpaceDlDciAssignment_Type_NR_Sib1Schedul_Type_SearchSpaceAndDci_Optional(&p->SearchSpaceAndDci);
	_serNrSysFreeIntegerList_Type_SlotOffsetList_Optional(&p->SlotOffsetList);
}

static void _serNrSysFreeNR_Sib1Schedul_Type_Sib1Schedul_Optional(struct NR_Sib1Schedul_Type_Sib1Schedul_Optional* p)
{
	if (!p->d) return;
	_serNrSysFreeNR_Sib1Schedul_Type(&p->v);
}

static void _serNrSysFreeNR_SearchSpaceDlDciAssignment_Type_NR_SingleSiSchedul_Type_SearchSpaceAndDci_Optional(struct NR_SearchSpaceDlDciAssignment_Type_NR_SingleSiSchedul_Type_SearchSpaceAndDci_Optional* p)
{
	if (!p->d) return;
	_serNrSysFreeNR_SearchSpaceDlDciAssignment_Type(&p->v);
}

static void _serNrSysFreeNR_SingleSiSchedul_Type(struct NR_SingleSiSchedul_Type* p)
{
	_serNrSysFreeNR_SearchSpaceDlDciAssignment_Type_NR_SingleSiSchedul_Type_SearchSpaceAndDci_Optional(&p->SearchSpaceAndDci);
}

static void _serNrSysFreeNR_SingleSiSchedul_Type_Window_DynamicOptional(struct NR_SingleSiSchedul_Type_Window_DynamicOptional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i2 = 0; i2 < p->v.d; i2++) {
			_serNrSysFreeNR_SingleSiSchedul_Type(&p->v.v[i2]);
		}
		serFree(p->v.v);
	}
}

static void _serNrSysFreeNR_OtherSiSchedul_Type(struct NR_OtherSiSchedul_Type* p)
{
	_serNrSysFreeNR_SingleSiSchedul_Type_Window_DynamicOptional(&p->Window);
}

static void _serNrSysFreeNR_OtherSiSchedulList_Type_SiList_Optional(struct NR_OtherSiSchedulList_Type_SiList_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i1 = 0; i1 < p->v.d; i1++) {
			_serNrSysFreeNR_OtherSiSchedul_Type(&p->v.v[i1]);
		}
		serFree(p->v.v);
	}
}

static void _serNrSysFreeNR_OtherSiSchedulList_Type_SegmentedSiList_Optional(struct NR_OtherSiSchedulList_Type_SegmentedSiList_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i1 = 0; i1 < p->v.d; i1++) {
			_serNrSysFreeNR_OtherSiSchedul_Type(&p->v.v[i1]);
		}
		serFree(p->v.v);
	}
}

static void _serNrSysFreeNR_AllOtherSiSchedul_Type(struct NR_AllOtherSiSchedul_Type* p)
{
	_serNrSysFreeNR_OtherSiSchedulList_Type_SiList_Optional(&p->SiList);
	_serNrSysFreeNR_OtherSiSchedulList_Type_SegmentedSiList_Optional(&p->SegmentedSiList);
}

static void _serNrSysFreeNR_AllOtherSiSchedul_Type_SiSchedul_Optional(struct NR_AllOtherSiSchedul_Type_SiSchedul_Optional* p)
{
	if (!p->d) return;
	_serNrSysFreeNR_AllOtherSiSchedul_Type(&p->v);
}

static void _serNrSysFreeNR_BcchToPdschConfig_Type(struct NR_BcchToPdschConfig_Type* p)
{
	_serNrSysFreeNR_Sib1Schedul_Type_Sib1Schedul_Optional(&p->Sib1Schedul);
	_serNrSysFreeNR_AllOtherSiSchedul_Type_SiSchedul_Optional(&p->SiSchedul);
}

static void _serNrSysFreeNR_BcchToPdschConfig_Type_Pdsch_Optional(struct NR_BcchToPdschConfig_Type_Pdsch_Optional* p)
{
	if (!p->d) return;
	_serNrSysFreeNR_BcchToPdschConfig_Type(&p->v);
}

static void _serNrSysFreeSQN_NR_NR_NS_PmaxList_SQN_NR_NR_MultiBandInfo_nr_NS_PmaxList_Optional(struct SQN_NR_NR_NS_PmaxList_SQN_NR_NR_MultiBandInfo_nr_NS_PmaxList_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i3 = 0; i3 < p->v.d; i3++) {
		}
		serFree(p->v.v);
	}
}

static void _serNrSysFreeSQN_NR_NR_MultiBandInfo(struct SQN_NR_NR_MultiBandInfo* p)
{
	_serNrSysFreeSQN_NR_NR_NS_PmaxList_SQN_NR_NR_MultiBandInfo_nr_NS_PmaxList_Optional(&p->nr_NS_PmaxList);
}

static void _serNrSysFreeSQN_NR_MultiFrequencyBandListNR_SIB_SQN_NR_SIB2_intraFreqCellReselectionInfo_frequencyBandList_Optional(struct SQN_NR_MultiFrequencyBandListNR_SIB_SQN_NR_SIB2_intraFreqCellReselectionInfo_frequencyBandList_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i2 = 0; i2 < p->v.d; i2++) {
			_serNrSysFreeSQN_NR_NR_MultiBandInfo(&p->v.v[i2]);
		}
		serFree(p->v.v);
	}
}

static void _serNrSysFreeSQN_NR_MultiFrequencyBandListNR_SIB_SQN_NR_SIB2_intraFreqCellReselectionInfo_frequencyBandListSUL_Optional(struct SQN_NR_MultiFrequencyBandListNR_SIB_SQN_NR_SIB2_intraFreqCellReselectionInfo_frequencyBandListSUL_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i2 = 0; i2 < p->v.d; i2++) {
			_serNrSysFreeSQN_NR_NR_MultiBandInfo(&p->v.v[i2]);
		}
		serFree(p->v.v);
	}
}

static void _serNrSysFreeSQN_NR_SS_RSSI_Measurement(struct SQN_NR_SS_RSSI_Measurement* p)
{
	if (p->measurementSlots.v) {
		serFree(p->measurementSlots.v);
	}
}

static void _serNrSysFreeSQN_NR_SS_RSSI_Measurement_SQN_NR_SIB2_intraFreqCellReselectionInfo_ss_RSSI_Measurement_Optional(struct SQN_NR_SS_RSSI_Measurement_SQN_NR_SIB2_intraFreqCellReselectionInfo_ss_RSSI_Measurement_Optional* p)
{
	if (!p->d) return;
	_serNrSysFreeSQN_NR_SS_RSSI_Measurement(&p->v);
}

static void _serNrSysFreeSQN_NR_PhysCellId_SQN_NR_SSB_MTC2_LP_r16_pci_List_DynamicOptional(struct SQN_NR_PhysCellId_SQN_NR_SSB_MTC2_LP_r16_pci_List_DynamicOptional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		serFree(p->v.v);
	}
}

static void _serNrSysFreeSQN_NR_SSB_MTC2_LP_r16(struct SQN_NR_SSB_MTC2_LP_r16* p)
{
	_serNrSysFreeSQN_NR_PhysCellId_SQN_NR_SSB_MTC2_LP_r16_pci_List_DynamicOptional(&p->pci_List);
}

static void _serNrSysFreeSQN_NR_SSB_MTC2_LP_r16_SQN_NR_SIB2_intraFreqCellReselectionInfo_smtc2_LP_r16_Optional(struct SQN_NR_SSB_MTC2_LP_r16_SQN_NR_SIB2_intraFreqCellReselectionInfo_smtc2_LP_r16_Optional* p)
{
	if (!p->d) return;
	_serNrSysFreeSQN_NR_SSB_MTC2_LP_r16(&p->v);
}

static void _serNrSysFreeSQN_NR_SIB2_intraFreqCellReselectionInfo(struct SQN_NR_SIB2_intraFreqCellReselectionInfo* p)
{
	_serNrSysFreeSQN_NR_MultiFrequencyBandListNR_SIB_SQN_NR_SIB2_intraFreqCellReselectionInfo_frequencyBandList_Optional(&p->frequencyBandList);
	_serNrSysFreeSQN_NR_MultiFrequencyBandListNR_SIB_SQN_NR_SIB2_intraFreqCellReselectionInfo_frequencyBandListSUL_Optional(&p->frequencyBandListSUL);
	_serNrSysFreeSQN_NR_SS_RSSI_Measurement_SQN_NR_SIB2_intraFreqCellReselectionInfo_ss_RSSI_Measurement_Optional(&p->ss_RSSI_Measurement);
	_serNrSysFreeSQN_NR_SSB_MTC2_LP_r16_SQN_NR_SIB2_intraFreqCellReselectionInfo_smtc2_LP_r16_Optional(&p->smtc2_LP_r16);
}

static void _serNrSysFreeSQN_NR_SIB2(struct SQN_NR_SIB2* p)
{
	_serNrSysFreeSQN_NR_SIB2_intraFreqCellReselectionInfo(&p->intraFreqCellReselectionInfo);
}

static void _serNrSysFreeSQN_NR_IntraFreqNeighCellList_SQN_NR_SIB3_intraFreqNeighCellList_Optional(struct SQN_NR_IntraFreqNeighCellList_SQN_NR_SIB3_intraFreqNeighCellList_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i2 = 0; i2 < p->v.d; i2++) {
		}
		serFree(p->v.v);
	}
}

static void _serNrSysFreeSQN_NR_IntraFreqBlackCellList_SQN_NR_SIB3_intraFreqBlackCellList_Optional(struct SQN_NR_IntraFreqBlackCellList_SQN_NR_SIB3_intraFreqBlackCellList_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i2 = 0; i2 < p->v.d; i2++) {
		}
		serFree(p->v.v);
	}
}

static void _serNrSysFreeOCTET_STRING_SQN_NR_SIB3_lateNonCriticalExtension_Optional(struct OCTET_STRING_SQN_NR_SIB3_lateNonCriticalExtension_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		serFree(p->v.v);
	}
}

static void _serNrSysFreeSQN_NR_IntraFreqNeighCellList_v1610_SQN_NR_SIB3_intraFreqNeighCellList_v1610_Optional(struct SQN_NR_IntraFreqNeighCellList_v1610_SQN_NR_SIB3_intraFreqNeighCellList_v1610_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i2 = 0; i2 < p->v.d; i2++) {
		}
		serFree(p->v.v);
	}
}

static void _serNrSysFreeSQN_NR_IntraFreqWhiteCellList_r16_SQN_NR_SIB3_intraFreqWhiteCellList_r16_Optional(struct SQN_NR_IntraFreqWhiteCellList_r16_SQN_NR_SIB3_intraFreqWhiteCellList_r16_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i2 = 0; i2 < p->v.d; i2++) {
		}
		serFree(p->v.v);
	}
}

static void _serNrSysFreeSQN_NR_IntraFreqCAG_CellListPerPLMN_r16(struct SQN_NR_IntraFreqCAG_CellListPerPLMN_r16* p)
{
	if (p->cag_CellList_r16.v) {
		for (size_t i3 = 0; i3 < p->cag_CellList_r16.d; i3++) {
		}
		serFree(p->cag_CellList_r16.v);
	}
}

static void _serNrSysFreeSQN_NR_IntraFreqCAG_CellListPerPLMN_r16_SQN_NR_SIB3_intraFreqCAG_CellList_r16_DynamicOptional(struct SQN_NR_IntraFreqCAG_CellListPerPLMN_r16_SQN_NR_SIB3_intraFreqCAG_CellList_r16_DynamicOptional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i2 = 0; i2 < p->v.d; i2++) {
			_serNrSysFreeSQN_NR_IntraFreqCAG_CellListPerPLMN_r16(&p->v.v[i2]);
		}
		serFree(p->v.v);
	}
}

static void _serNrSysFreeSQN_NR_SIB3(struct SQN_NR_SIB3* p)
{
	_serNrSysFreeSQN_NR_IntraFreqNeighCellList_SQN_NR_SIB3_intraFreqNeighCellList_Optional(&p->intraFreqNeighCellList);
	_serNrSysFreeSQN_NR_IntraFreqBlackCellList_SQN_NR_SIB3_intraFreqBlackCellList_Optional(&p->intraFreqBlackCellList);
	_serNrSysFreeOCTET_STRING_SQN_NR_SIB3_lateNonCriticalExtension_Optional(&p->lateNonCriticalExtension);
	_serNrSysFreeSQN_NR_IntraFreqNeighCellList_v1610_SQN_NR_SIB3_intraFreqNeighCellList_v1610_Optional(&p->intraFreqNeighCellList_v1610);
	_serNrSysFreeSQN_NR_IntraFreqWhiteCellList_r16_SQN_NR_SIB3_intraFreqWhiteCellList_r16_Optional(&p->intraFreqWhiteCellList_r16);
	_serNrSysFreeSQN_NR_IntraFreqCAG_CellListPerPLMN_r16_SQN_NR_SIB3_intraFreqCAG_CellList_r16_DynamicOptional(&p->intraFreqCAG_CellList_r16);
}

static void _serNrSysFreeSQN_NR_MultiFrequencyBandListNR_SIB_SQN_NR_InterFreqCarrierFreqInfo_frequencyBandList_Optional(struct SQN_NR_MultiFrequencyBandListNR_SIB_SQN_NR_InterFreqCarrierFreqInfo_frequencyBandList_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i3 = 0; i3 < p->v.d; i3++) {
			_serNrSysFreeSQN_NR_NR_MultiBandInfo(&p->v.v[i3]);
		}
		serFree(p->v.v);
	}
}

static void _serNrSysFreeSQN_NR_MultiFrequencyBandListNR_SIB_SQN_NR_InterFreqCarrierFreqInfo_frequencyBandListSUL_Optional(struct SQN_NR_MultiFrequencyBandListNR_SIB_SQN_NR_InterFreqCarrierFreqInfo_frequencyBandListSUL_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i3 = 0; i3 < p->v.d; i3++) {
			_serNrSysFreeSQN_NR_NR_MultiBandInfo(&p->v.v[i3]);
		}
		serFree(p->v.v);
	}
}

static void _serNrSysFreeSQN_NR_SS_RSSI_Measurement_SQN_NR_InterFreqCarrierFreqInfo_ss_RSSI_Measurement_Optional(struct SQN_NR_SS_RSSI_Measurement_SQN_NR_InterFreqCarrierFreqInfo_ss_RSSI_Measurement_Optional* p)
{
	if (!p->d) return;
	_serNrSysFreeSQN_NR_SS_RSSI_Measurement(&p->v);
}

static void _serNrSysFreeSQN_NR_InterFreqNeighCellList_SQN_NR_InterFreqCarrierFreqInfo_interFreqNeighCellList_Optional(struct SQN_NR_InterFreqNeighCellList_SQN_NR_InterFreqCarrierFreqInfo_interFreqNeighCellList_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i3 = 0; i3 < p->v.d; i3++) {
		}
		serFree(p->v.v);
	}
}

static void _serNrSysFreeSQN_NR_InterFreqBlackCellList_SQN_NR_InterFreqCarrierFreqInfo_interFreqBlackCellList_Optional(struct SQN_NR_InterFreqBlackCellList_SQN_NR_InterFreqCarrierFreqInfo_interFreqBlackCellList_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i3 = 0; i3 < p->v.d; i3++) {
		}
		serFree(p->v.v);
	}
}

static void _serNrSysFreeSQN_NR_InterFreqCarrierFreqInfo(struct SQN_NR_InterFreqCarrierFreqInfo* p)
{
	_serNrSysFreeSQN_NR_MultiFrequencyBandListNR_SIB_SQN_NR_InterFreqCarrierFreqInfo_frequencyBandList_Optional(&p->frequencyBandList);
	_serNrSysFreeSQN_NR_MultiFrequencyBandListNR_SIB_SQN_NR_InterFreqCarrierFreqInfo_frequencyBandListSUL_Optional(&p->frequencyBandListSUL);
	_serNrSysFreeSQN_NR_SS_RSSI_Measurement_SQN_NR_InterFreqCarrierFreqInfo_ss_RSSI_Measurement_Optional(&p->ss_RSSI_Measurement);
	_serNrSysFreeSQN_NR_InterFreqNeighCellList_SQN_NR_InterFreqCarrierFreqInfo_interFreqNeighCellList_Optional(&p->interFreqNeighCellList);
	_serNrSysFreeSQN_NR_InterFreqBlackCellList_SQN_NR_InterFreqCarrierFreqInfo_interFreqBlackCellList_Optional(&p->interFreqBlackCellList);
}

static void _serNrSysFreeOCTET_STRING_SQN_NR_SIB4_lateNonCriticalExtension_Optional(struct OCTET_STRING_SQN_NR_SIB4_lateNonCriticalExtension_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		serFree(p->v.v);
	}
}

static void _serNrSysFreeSQN_NR_InterFreqNeighCellList_v1610_SQN_NR_InterFreqCarrierFreqInfo_v1610_interFreqNeighCellList_v1610_Optional(struct SQN_NR_InterFreqNeighCellList_v1610_SQN_NR_InterFreqCarrierFreqInfo_v1610_interFreqNeighCellList_v1610_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i3 = 0; i3 < p->v.d; i3++) {
		}
		serFree(p->v.v);
	}
}

static void _serNrSysFreeSQN_NR_SSB_MTC2_LP_r16_SQN_NR_InterFreqCarrierFreqInfo_v1610_smtc2_LP_r16_Optional(struct SQN_NR_SSB_MTC2_LP_r16_SQN_NR_InterFreqCarrierFreqInfo_v1610_smtc2_LP_r16_Optional* p)
{
	if (!p->d) return;
	_serNrSysFreeSQN_NR_SSB_MTC2_LP_r16(&p->v);
}

static void _serNrSysFreeSQN_NR_InterFreqWhiteCellList_r16_SQN_NR_InterFreqCarrierFreqInfo_v1610_interFreqWhiteCellList_r16_Optional(struct SQN_NR_InterFreqWhiteCellList_r16_SQN_NR_InterFreqCarrierFreqInfo_v1610_interFreqWhiteCellList_r16_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i3 = 0; i3 < p->v.d; i3++) {
		}
		serFree(p->v.v);
	}
}

static void _serNrSysFreeSQN_NR_InterFreqCAG_CellListPerPLMN_r16(struct SQN_NR_InterFreqCAG_CellListPerPLMN_r16* p)
{
	if (p->cag_CellList_r16.v) {
		for (size_t i4 = 0; i4 < p->cag_CellList_r16.d; i4++) {
		}
		serFree(p->cag_CellList_r16.v);
	}
}

static void _serNrSysFreeSQN_NR_InterFreqCAG_CellListPerPLMN_r16_SQN_NR_InterFreqCarrierFreqInfo_v1610_interFreqCAG_CellList_r16_DynamicOptional(struct SQN_NR_InterFreqCAG_CellListPerPLMN_r16_SQN_NR_InterFreqCarrierFreqInfo_v1610_interFreqCAG_CellList_r16_DynamicOptional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i3 = 0; i3 < p->v.d; i3++) {
			_serNrSysFreeSQN_NR_InterFreqCAG_CellListPerPLMN_r16(&p->v.v[i3]);
		}
		serFree(p->v.v);
	}
}

static void _serNrSysFreeSQN_NR_InterFreqCarrierFreqInfo_v1610(struct SQN_NR_InterFreqCarrierFreqInfo_v1610* p)
{
	_serNrSysFreeSQN_NR_InterFreqNeighCellList_v1610_SQN_NR_InterFreqCarrierFreqInfo_v1610_interFreqNeighCellList_v1610_Optional(&p->interFreqNeighCellList_v1610);
	_serNrSysFreeSQN_NR_SSB_MTC2_LP_r16_SQN_NR_InterFreqCarrierFreqInfo_v1610_smtc2_LP_r16_Optional(&p->smtc2_LP_r16);
	_serNrSysFreeSQN_NR_InterFreqWhiteCellList_r16_SQN_NR_InterFreqCarrierFreqInfo_v1610_interFreqWhiteCellList_r16_Optional(&p->interFreqWhiteCellList_r16);
	_serNrSysFreeSQN_NR_InterFreqCAG_CellListPerPLMN_r16_SQN_NR_InterFreqCarrierFreqInfo_v1610_interFreqCAG_CellList_r16_DynamicOptional(&p->interFreqCAG_CellList_r16);
}

static void _serNrSysFreeSQN_NR_InterFreqCarrierFreqList_v1610_SQN_NR_SIB4_interFreqCarrierFreqList_v1610_Optional(struct SQN_NR_InterFreqCarrierFreqList_v1610_SQN_NR_SIB4_interFreqCarrierFreqList_v1610_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i2 = 0; i2 < p->v.d; i2++) {
			_serNrSysFreeSQN_NR_InterFreqCarrierFreqInfo_v1610(&p->v.v[i2]);
		}
		serFree(p->v.v);
	}
}

static void _serNrSysFreeSQN_NR_SIB4(struct SQN_NR_SIB4* p)
{
	if (p->interFreqCarrierFreqList.v) {
		for (size_t i2 = 0; i2 < p->interFreqCarrierFreqList.d; i2++) {
			_serNrSysFreeSQN_NR_InterFreqCarrierFreqInfo(&p->interFreqCarrierFreqList.v[i2]);
		}
		serFree(p->interFreqCarrierFreqList.v);
	}
	_serNrSysFreeOCTET_STRING_SQN_NR_SIB4_lateNonCriticalExtension_Optional(&p->lateNonCriticalExtension);
	_serNrSysFreeSQN_NR_InterFreqCarrierFreqList_v1610_SQN_NR_SIB4_interFreqCarrierFreqList_v1610_Optional(&p->interFreqCarrierFreqList_v1610);
}

static void _serNrSysFreeSQN_NR_EUTRA_NS_PmaxList_SQN_NR_EUTRA_MultiBandInfo_eutra_NS_PmaxList_Optional(struct SQN_NR_EUTRA_NS_PmaxList_SQN_NR_EUTRA_MultiBandInfo_eutra_NS_PmaxList_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i4 = 0; i4 < p->v.d; i4++) {
		}
		serFree(p->v.v);
	}
}

static void _serNrSysFreeSQN_NR_EUTRA_MultiBandInfo(struct SQN_NR_EUTRA_MultiBandInfo* p)
{
	_serNrSysFreeSQN_NR_EUTRA_NS_PmaxList_SQN_NR_EUTRA_MultiBandInfo_eutra_NS_PmaxList_Optional(&p->eutra_NS_PmaxList);
}

static void _serNrSysFreeSQN_NR_EUTRA_MultiBandInfoList_SQN_NR_CarrierFreqEUTRA_eutra_multiBandInfoList_Optional(struct SQN_NR_EUTRA_MultiBandInfoList_SQN_NR_CarrierFreqEUTRA_eutra_multiBandInfoList_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i3 = 0; i3 < p->v.d; i3++) {
			_serNrSysFreeSQN_NR_EUTRA_MultiBandInfo(&p->v.v[i3]);
		}
		serFree(p->v.v);
	}
}

static void _serNrSysFreeSQN_NR_EUTRA_FreqNeighCellList_SQN_NR_CarrierFreqEUTRA_eutra_FreqNeighCellList_Optional(struct SQN_NR_EUTRA_FreqNeighCellList_SQN_NR_CarrierFreqEUTRA_eutra_FreqNeighCellList_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i3 = 0; i3 < p->v.d; i3++) {
		}
		serFree(p->v.v);
	}
}

static void _serNrSysFreeSQN_NR_EUTRA_FreqBlackCellList_SQN_NR_CarrierFreqEUTRA_eutra_BlackCellList_Optional(struct SQN_NR_EUTRA_FreqBlackCellList_SQN_NR_CarrierFreqEUTRA_eutra_BlackCellList_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i3 = 0; i3 < p->v.d; i3++) {
		}
		serFree(p->v.v);
	}
}

static void _serNrSysFreeSQN_NR_CarrierFreqEUTRA(struct SQN_NR_CarrierFreqEUTRA* p)
{
	_serNrSysFreeSQN_NR_EUTRA_MultiBandInfoList_SQN_NR_CarrierFreqEUTRA_eutra_multiBandInfoList_Optional(&p->eutra_multiBandInfoList);
	_serNrSysFreeSQN_NR_EUTRA_FreqNeighCellList_SQN_NR_CarrierFreqEUTRA_eutra_FreqNeighCellList_Optional(&p->eutra_FreqNeighCellList);
	_serNrSysFreeSQN_NR_EUTRA_FreqBlackCellList_SQN_NR_CarrierFreqEUTRA_eutra_BlackCellList_Optional(&p->eutra_BlackCellList);
}

static void _serNrSysFreeSQN_NR_CarrierFreqListEUTRA_SQN_NR_SIB5_carrierFreqListEUTRA_Optional(struct SQN_NR_CarrierFreqListEUTRA_SQN_NR_SIB5_carrierFreqListEUTRA_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i2 = 0; i2 < p->v.d; i2++) {
			_serNrSysFreeSQN_NR_CarrierFreqEUTRA(&p->v.v[i2]);
		}
		serFree(p->v.v);
	}
}

static void _serNrSysFreeOCTET_STRING_SQN_NR_SIB5_lateNonCriticalExtension_Optional(struct OCTET_STRING_SQN_NR_SIB5_lateNonCriticalExtension_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		serFree(p->v.v);
	}
}

static void _serNrSysFreeSQN_NR_CarrierFreqListEUTRA_v1610_SQN_NR_SIB5_carrierFreqListEUTRA_v1610_Optional(struct SQN_NR_CarrierFreqListEUTRA_v1610_SQN_NR_SIB5_carrierFreqListEUTRA_v1610_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i2 = 0; i2 < p->v.d; i2++) {
		}
		serFree(p->v.v);
	}
}

static void _serNrSysFreeSQN_NR_SIB5(struct SQN_NR_SIB5* p)
{
	_serNrSysFreeSQN_NR_CarrierFreqListEUTRA_SQN_NR_SIB5_carrierFreqListEUTRA_Optional(&p->carrierFreqListEUTRA);
	_serNrSysFreeOCTET_STRING_SQN_NR_SIB5_lateNonCriticalExtension_Optional(&p->lateNonCriticalExtension);
	_serNrSysFreeSQN_NR_CarrierFreqListEUTRA_v1610_SQN_NR_SIB5_carrierFreqListEUTRA_v1610_Optional(&p->carrierFreqListEUTRA_v1610);
}

static void _serNrSysFreeOCTET_STRING_SQN_NR_SIB6_lateNonCriticalExtension_Optional(struct OCTET_STRING_SQN_NR_SIB6_lateNonCriticalExtension_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		serFree(p->v.v);
	}
}

static void _serNrSysFreeSQN_NR_SIB6(struct SQN_NR_SIB6* p)
{
	_serNrSysFreeOCTET_STRING_SQN_NR_SIB6_lateNonCriticalExtension_Optional(&p->lateNonCriticalExtension);
}

static void _serNrSysFreeOCTET_STRING_SQN_NR_SIB7_lateNonCriticalExtension_Optional(struct OCTET_STRING_SQN_NR_SIB7_lateNonCriticalExtension_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		serFree(p->v.v);
	}
}

static void _serNrSysFreeSQN_NR_SIB7(struct SQN_NR_SIB7* p)
{
	if (p->warningMessageSegment.v) {
		serFree(p->warningMessageSegment.v);
	}
	_serNrSysFreeOCTET_STRING_SQN_NR_SIB7_lateNonCriticalExtension_Optional(&p->lateNonCriticalExtension);
}

static void _serNrSysFreeOCTET_STRING_SQN_NR_SIB8_warningAreaCoordinatesSegment_Optional(struct OCTET_STRING_SQN_NR_SIB8_warningAreaCoordinatesSegment_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		serFree(p->v.v);
	}
}

static void _serNrSysFreeOCTET_STRING_SQN_NR_SIB8_lateNonCriticalExtension_Optional(struct OCTET_STRING_SQN_NR_SIB8_lateNonCriticalExtension_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		serFree(p->v.v);
	}
}

static void _serNrSysFreeSQN_NR_SIB8(struct SQN_NR_SIB8* p)
{
	if (p->warningMessageSegment.v) {
		serFree(p->warningMessageSegment.v);
	}
	_serNrSysFreeOCTET_STRING_SQN_NR_SIB8_warningAreaCoordinatesSegment_Optional(&p->warningAreaCoordinatesSegment);
	_serNrSysFreeOCTET_STRING_SQN_NR_SIB8_lateNonCriticalExtension_Optional(&p->lateNonCriticalExtension);
}

static void _serNrSysFreeOCTET_STRING_SQN_NR_SIB9_lateNonCriticalExtension_Optional(struct OCTET_STRING_SQN_NR_SIB9_lateNonCriticalExtension_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		serFree(p->v.v);
	}
}

static void _serNrSysFreeSQN_NR_SIB9(struct SQN_NR_SIB9* p)
{
	_serNrSysFreeOCTET_STRING_SQN_NR_SIB9_lateNonCriticalExtension_Optional(&p->lateNonCriticalExtension);
}

static void _serNrSysFreeOCTET_STRING_SQN_NR_HRNN_r16_hrnn_r16_Optional(struct OCTET_STRING_SQN_NR_HRNN_r16_hrnn_r16_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		serFree(p->v.v);
	}
}

static void _serNrSysFreeSQN_NR_HRNN_r16(struct SQN_NR_HRNN_r16* p)
{
	_serNrSysFreeOCTET_STRING_SQN_NR_HRNN_r16_hrnn_r16_Optional(&p->hrnn_r16);
}

static void _serNrSysFreeSQN_NR_HRNN_List_r16_SQN_NR_SIB10_r16_hrnn_List_r16_Optional(struct SQN_NR_HRNN_List_r16_SQN_NR_SIB10_r16_hrnn_List_r16_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i2 = 0; i2 < p->v.d; i2++) {
			_serNrSysFreeSQN_NR_HRNN_r16(&p->v.v[i2]);
		}
		serFree(p->v.v);
	}
}

static void _serNrSysFreeOCTET_STRING_SQN_NR_SIB10_r16_lateNonCriticalExtension_Optional(struct OCTET_STRING_SQN_NR_SIB10_r16_lateNonCriticalExtension_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		serFree(p->v.v);
	}
}

static void _serNrSysFreeSQN_NR_SIB10_r16(struct SQN_NR_SIB10_r16* p)
{
	_serNrSysFreeSQN_NR_HRNN_List_r16_SQN_NR_SIB10_r16_hrnn_List_r16_Optional(&p->hrnn_List_r16);
	_serNrSysFreeOCTET_STRING_SQN_NR_SIB10_r16_lateNonCriticalExtension_Optional(&p->lateNonCriticalExtension);
}

static void _serNrSysFreeSQN_NR_MultiFrequencyBandListNR_SQN_NR_MeasIdleCarrierNR_r16_frequencyBandList_Optional(struct SQN_NR_MultiFrequencyBandListNR_SQN_NR_MeasIdleCarrierNR_r16_frequencyBandList_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		serFree(p->v.v);
	}
}

static void _serNrSysFreeSQN_NR_CellListNR_r16_SQN_NR_MeasIdleCarrierNR_r16_measCellListNR_r16_Optional(struct SQN_NR_CellListNR_r16_SQN_NR_MeasIdleCarrierNR_r16_measCellListNR_r16_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i3 = 0; i3 < p->v.d; i3++) {
		}
		serFree(p->v.v);
	}
}

static void _serNrSysFreeSQN_NR_SS_RSSI_Measurement_SQN_NR_MeasIdleCarrierNR_r16_ssb_MeasConfig_r16_ss_RSSI_Measurement_r16_Optional(struct SQN_NR_SS_RSSI_Measurement_SQN_NR_MeasIdleCarrierNR_r16_ssb_MeasConfig_r16_ss_RSSI_Measurement_r16_Optional* p)
{
	if (!p->d) return;
	_serNrSysFreeSQN_NR_SS_RSSI_Measurement(&p->v);
}

static void _serNrSysFreeSQN_NR_MeasIdleCarrierNR_r16_ssb_MeasConfig_r16(struct SQN_NR_MeasIdleCarrierNR_r16_ssb_MeasConfig_r16* p)
{
	_serNrSysFreeSQN_NR_SS_RSSI_Measurement_SQN_NR_MeasIdleCarrierNR_r16_ssb_MeasConfig_r16_ss_RSSI_Measurement_r16_Optional(&p->ss_RSSI_Measurement_r16);
}

static void _serNrSysFreeSQN_NR_MeasIdleCarrierNR_r16_ssb_MeasConfig_r16_ssb_MeasConfig_r16_Optional(struct SQN_NR_MeasIdleCarrierNR_r16_ssb_MeasConfig_r16_ssb_MeasConfig_r16_Optional* p)
{
	if (!p->d) return;
	_serNrSysFreeSQN_NR_MeasIdleCarrierNR_r16_ssb_MeasConfig_r16(&p->v);
}

static void _serNrSysFreeSQN_NR_MeasIdleCarrierNR_r16(struct SQN_NR_MeasIdleCarrierNR_r16* p)
{
	_serNrSysFreeSQN_NR_MultiFrequencyBandListNR_SQN_NR_MeasIdleCarrierNR_r16_frequencyBandList_Optional(&p->frequencyBandList);
	_serNrSysFreeSQN_NR_CellListNR_r16_SQN_NR_MeasIdleCarrierNR_r16_measCellListNR_r16_Optional(&p->measCellListNR_r16);
	_serNrSysFreeSQN_NR_MeasIdleCarrierNR_r16_ssb_MeasConfig_r16_ssb_MeasConfig_r16_Optional(&p->ssb_MeasConfig_r16);
}

static void _serNrSysFreeSQN_NR_MeasIdleCarrierNR_r16_SQN_NR_MeasIdleConfigSIB_r16_measIdleCarrierListNR_r16_DynamicOptional(struct SQN_NR_MeasIdleCarrierNR_r16_SQN_NR_MeasIdleConfigSIB_r16_measIdleCarrierListNR_r16_DynamicOptional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i2 = 0; i2 < p->v.d; i2++) {
			_serNrSysFreeSQN_NR_MeasIdleCarrierNR_r16(&p->v.v[i2]);
		}
		serFree(p->v.v);
	}
}

static void _serNrSysFreeSQN_NR_CellListEUTRA_r16_SQN_NR_MeasIdleCarrierEUTRA_r16_measCellListEUTRA_r16_Optional(struct SQN_NR_CellListEUTRA_r16_SQN_NR_MeasIdleCarrierEUTRA_r16_measCellListEUTRA_r16_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i3 = 0; i3 < p->v.d; i3++) {
		}
		serFree(p->v.v);
	}
}

static void _serNrSysFreeSQN_NR_MeasIdleCarrierEUTRA_r16(struct SQN_NR_MeasIdleCarrierEUTRA_r16* p)
{
	_serNrSysFreeSQN_NR_CellListEUTRA_r16_SQN_NR_MeasIdleCarrierEUTRA_r16_measCellListEUTRA_r16_Optional(&p->measCellListEUTRA_r16);
}

static void _serNrSysFreeSQN_NR_MeasIdleCarrierEUTRA_r16_SQN_NR_MeasIdleConfigSIB_r16_measIdleCarrierListEUTRA_r16_DynamicOptional(struct SQN_NR_MeasIdleCarrierEUTRA_r16_SQN_NR_MeasIdleConfigSIB_r16_measIdleCarrierListEUTRA_r16_DynamicOptional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i2 = 0; i2 < p->v.d; i2++) {
			_serNrSysFreeSQN_NR_MeasIdleCarrierEUTRA_r16(&p->v.v[i2]);
		}
		serFree(p->v.v);
	}
}

static void _serNrSysFreeSQN_NR_MeasIdleConfigSIB_r16(struct SQN_NR_MeasIdleConfigSIB_r16* p)
{
	_serNrSysFreeSQN_NR_MeasIdleCarrierNR_r16_SQN_NR_MeasIdleConfigSIB_r16_measIdleCarrierListNR_r16_DynamicOptional(&p->measIdleCarrierListNR_r16);
	_serNrSysFreeSQN_NR_MeasIdleCarrierEUTRA_r16_SQN_NR_MeasIdleConfigSIB_r16_measIdleCarrierListEUTRA_r16_DynamicOptional(&p->measIdleCarrierListEUTRA_r16);
}

static void _serNrSysFreeSQN_NR_MeasIdleConfigSIB_r16_SQN_NR_SIB11_r16_measIdleConfigSIB_r16_Optional(struct SQN_NR_MeasIdleConfigSIB_r16_SQN_NR_SIB11_r16_measIdleConfigSIB_r16_Optional* p)
{
	if (!p->d) return;
	_serNrSysFreeSQN_NR_MeasIdleConfigSIB_r16(&p->v);
}

static void _serNrSysFreeOCTET_STRING_SQN_NR_SIB11_r16_lateNonCriticalExtension_Optional(struct OCTET_STRING_SQN_NR_SIB11_r16_lateNonCriticalExtension_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		serFree(p->v.v);
	}
}

static void _serNrSysFreeSQN_NR_SIB11_r16(struct SQN_NR_SIB11_r16* p)
{
	_serNrSysFreeSQN_NR_MeasIdleConfigSIB_r16_SQN_NR_SIB11_r16_measIdleConfigSIB_r16_Optional(&p->measIdleConfigSIB_r16);
	_serNrSysFreeOCTET_STRING_SQN_NR_SIB11_r16_lateNonCriticalExtension_Optional(&p->lateNonCriticalExtension);
}

static void _serNrSysFreeSQN_NR_SIB12_r16(struct SQN_NR_SIB12_r16* p)
{
	if (p->segmentContainer_r16.v) {
		serFree(p->segmentContainer_r16.v);
	}
}

static void _serNrSysFreeOCTET_STRING_SQN_NR_SIB13_r16_lateNonCriticalExtension_Optional(struct OCTET_STRING_SQN_NR_SIB13_r16_lateNonCriticalExtension_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		serFree(p->v.v);
	}
}

static void _serNrSysFreeSQN_NR_SIB13_r16(struct SQN_NR_SIB13_r16* p)
{
	if (p->sl_V2X_ConfigCommon_r16.v) {
		serFree(p->sl_V2X_ConfigCommon_r16.v);
	}
	if (p->sl_Bandwidth_r16.v) {
		serFree(p->sl_Bandwidth_r16.v);
	}
	if (p->tdd_Config_r16.v) {
		serFree(p->tdd_Config_r16.v);
	}
	_serNrSysFreeOCTET_STRING_SQN_NR_SIB13_r16_lateNonCriticalExtension_Optional(&p->lateNonCriticalExtension);
}

static void _serNrSysFreeOCTET_STRING_SQN_NR_SIB14_r16_lateNonCriticalExtension_Optional(struct OCTET_STRING_SQN_NR_SIB14_r16_lateNonCriticalExtension_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		serFree(p->v.v);
	}
}

static void _serNrSysFreeSQN_NR_SIB14_r16(struct SQN_NR_SIB14_r16* p)
{
	if (p->sl_V2X_ConfigCommonExt_r16.v) {
		serFree(p->sl_V2X_ConfigCommonExt_r16.v);
	}
	_serNrSysFreeOCTET_STRING_SQN_NR_SIB14_r16_lateNonCriticalExtension_Optional(&p->lateNonCriticalExtension);
}

static void _serNrSysFreeSQN_NR_SystemInformation_IEs_sib_TypeAndInfo_s_Value(union SQN_NR_SystemInformation_IEs_sib_TypeAndInfo_s_Value* p, enum SQN_NR_SystemInformation_IEs_sib_TypeAndInfo_s_Sel d)
{
	if (d == SQN_NR_SystemInformation_IEs_sib_TypeAndInfo_s_sib2) {
		_serNrSysFreeSQN_NR_SIB2(&p->sib2);
		return;
	}
	if (d == SQN_NR_SystemInformation_IEs_sib_TypeAndInfo_s_sib3) {
		_serNrSysFreeSQN_NR_SIB3(&p->sib3);
		return;
	}
	if (d == SQN_NR_SystemInformation_IEs_sib_TypeAndInfo_s_sib4) {
		_serNrSysFreeSQN_NR_SIB4(&p->sib4);
		return;
	}
	if (d == SQN_NR_SystemInformation_IEs_sib_TypeAndInfo_s_sib5) {
		_serNrSysFreeSQN_NR_SIB5(&p->sib5);
		return;
	}
	if (d == SQN_NR_SystemInformation_IEs_sib_TypeAndInfo_s_sib6) {
		_serNrSysFreeSQN_NR_SIB6(&p->sib6);
		return;
	}
	if (d == SQN_NR_SystemInformation_IEs_sib_TypeAndInfo_s_sib7) {
		_serNrSysFreeSQN_NR_SIB7(&p->sib7);
		return;
	}
	if (d == SQN_NR_SystemInformation_IEs_sib_TypeAndInfo_s_sib8) {
		_serNrSysFreeSQN_NR_SIB8(&p->sib8);
		return;
	}
	if (d == SQN_NR_SystemInformation_IEs_sib_TypeAndInfo_s_sib9) {
		_serNrSysFreeSQN_NR_SIB9(&p->sib9);
		return;
	}
	if (d == SQN_NR_SystemInformation_IEs_sib_TypeAndInfo_s_sib10_v1610) {
		_serNrSysFreeSQN_NR_SIB10_r16(&p->sib10_v1610);
		return;
	}
	if (d == SQN_NR_SystemInformation_IEs_sib_TypeAndInfo_s_sib11_v1610) {
		_serNrSysFreeSQN_NR_SIB11_r16(&p->sib11_v1610);
		return;
	}
	if (d == SQN_NR_SystemInformation_IEs_sib_TypeAndInfo_s_sib12_v1610) {
		_serNrSysFreeSQN_NR_SIB12_r16(&p->sib12_v1610);
		return;
	}
	if (d == SQN_NR_SystemInformation_IEs_sib_TypeAndInfo_s_sib13_v1610) {
		_serNrSysFreeSQN_NR_SIB13_r16(&p->sib13_v1610);
		return;
	}
	if (d == SQN_NR_SystemInformation_IEs_sib_TypeAndInfo_s_sib14_v1610) {
		_serNrSysFreeSQN_NR_SIB14_r16(&p->sib14_v1610);
		return;
	}
}

static void _serNrSysFreeSQN_NR_SystemInformation_IEs_sib_TypeAndInfo_s(struct SQN_NR_SystemInformation_IEs_sib_TypeAndInfo_s* p)
{
	_serNrSysFreeSQN_NR_SystemInformation_IEs_sib_TypeAndInfo_s_Value(&p->v, p->d);
}

static void _serNrSysFreeOCTET_STRING_SQN_NR_SystemInformation_IEs_lateNonCriticalExtension_Optional(struct OCTET_STRING_SQN_NR_SystemInformation_IEs_lateNonCriticalExtension_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		serFree(p->v.v);
	}
}

static void _serNrSysFreeSQN_NR_SystemInformation_IEs(struct SQN_NR_SystemInformation_IEs* p)
{
	if (p->sib_TypeAndInfo.v) {
		for (size_t i1 = 0; i1 < p->sib_TypeAndInfo.d; i1++) {
			_serNrSysFreeSQN_NR_SystemInformation_IEs_sib_TypeAndInfo_s(&p->sib_TypeAndInfo.v[i1]);
		}
		serFree(p->sib_TypeAndInfo.v);
	}
	_serNrSysFreeOCTET_STRING_SQN_NR_SystemInformation_IEs_lateNonCriticalExtension_Optional(&p->lateNonCriticalExtension);
}

static void _serNrSysFreeOCTET_STRING_SQN_NR_SIBpos_r16_lateNonCriticalExtension_Optional(struct OCTET_STRING_SQN_NR_SIBpos_r16_lateNonCriticalExtension_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		serFree(p->v.v);
	}
}

static void _serNrSysFreeSQN_NR_SIBpos_r16(struct SQN_NR_SIBpos_r16* p)
{
	if (p->assistanceDataSIB_Element_r16.v) {
		serFree(p->assistanceDataSIB_Element_r16.v);
	}
	_serNrSysFreeOCTET_STRING_SQN_NR_SIBpos_r16_lateNonCriticalExtension_Optional(&p->lateNonCriticalExtension);
}

static void _serNrSysFreeSQN_NR_PosSystemInformation_r16_IEs_posSIB_TypeAndInfo_r16_s_Value(union SQN_NR_PosSystemInformation_r16_IEs_posSIB_TypeAndInfo_r16_s_Value* p, enum SQN_NR_PosSystemInformation_r16_IEs_posSIB_TypeAndInfo_r16_s_Sel d)
{
	if (d == SQN_NR_PosSystemInformation_r16_IEs_posSIB_TypeAndInfo_r16_s_posSib1_1_r16) {
		_serNrSysFreeSQN_NR_SIBpos_r16(&p->posSib1_1_r16);
		return;
	}
	if (d == SQN_NR_PosSystemInformation_r16_IEs_posSIB_TypeAndInfo_r16_s_posSib1_2_r16) {
		_serNrSysFreeSQN_NR_SIBpos_r16(&p->posSib1_2_r16);
		return;
	}
	if (d == SQN_NR_PosSystemInformation_r16_IEs_posSIB_TypeAndInfo_r16_s_posSib1_3_r16) {
		_serNrSysFreeSQN_NR_SIBpos_r16(&p->posSib1_3_r16);
		return;
	}
	if (d == SQN_NR_PosSystemInformation_r16_IEs_posSIB_TypeAndInfo_r16_s_posSib1_4_r16) {
		_serNrSysFreeSQN_NR_SIBpos_r16(&p->posSib1_4_r16);
		return;
	}
	if (d == SQN_NR_PosSystemInformation_r16_IEs_posSIB_TypeAndInfo_r16_s_posSib1_5_r16) {
		_serNrSysFreeSQN_NR_SIBpos_r16(&p->posSib1_5_r16);
		return;
	}
	if (d == SQN_NR_PosSystemInformation_r16_IEs_posSIB_TypeAndInfo_r16_s_posSib1_6_r16) {
		_serNrSysFreeSQN_NR_SIBpos_r16(&p->posSib1_6_r16);
		return;
	}
	if (d == SQN_NR_PosSystemInformation_r16_IEs_posSIB_TypeAndInfo_r16_s_posSib1_7_r16) {
		_serNrSysFreeSQN_NR_SIBpos_r16(&p->posSib1_7_r16);
		return;
	}
	if (d == SQN_NR_PosSystemInformation_r16_IEs_posSIB_TypeAndInfo_r16_s_posSib1_8_r16) {
		_serNrSysFreeSQN_NR_SIBpos_r16(&p->posSib1_8_r16);
		return;
	}
	if (d == SQN_NR_PosSystemInformation_r16_IEs_posSIB_TypeAndInfo_r16_s_posSib2_1_r16) {
		_serNrSysFreeSQN_NR_SIBpos_r16(&p->posSib2_1_r16);
		return;
	}
	if (d == SQN_NR_PosSystemInformation_r16_IEs_posSIB_TypeAndInfo_r16_s_posSib2_2_r16) {
		_serNrSysFreeSQN_NR_SIBpos_r16(&p->posSib2_2_r16);
		return;
	}
	if (d == SQN_NR_PosSystemInformation_r16_IEs_posSIB_TypeAndInfo_r16_s_posSib2_3_r16) {
		_serNrSysFreeSQN_NR_SIBpos_r16(&p->posSib2_3_r16);
		return;
	}
	if (d == SQN_NR_PosSystemInformation_r16_IEs_posSIB_TypeAndInfo_r16_s_posSib2_4_r16) {
		_serNrSysFreeSQN_NR_SIBpos_r16(&p->posSib2_4_r16);
		return;
	}
	if (d == SQN_NR_PosSystemInformation_r16_IEs_posSIB_TypeAndInfo_r16_s_posSib2_5_r16) {
		_serNrSysFreeSQN_NR_SIBpos_r16(&p->posSib2_5_r16);
		return;
	}
	if (d == SQN_NR_PosSystemInformation_r16_IEs_posSIB_TypeAndInfo_r16_s_posSib2_6_r16) {
		_serNrSysFreeSQN_NR_SIBpos_r16(&p->posSib2_6_r16);
		return;
	}
	if (d == SQN_NR_PosSystemInformation_r16_IEs_posSIB_TypeAndInfo_r16_s_posSib2_7_r16) {
		_serNrSysFreeSQN_NR_SIBpos_r16(&p->posSib2_7_r16);
		return;
	}
	if (d == SQN_NR_PosSystemInformation_r16_IEs_posSIB_TypeAndInfo_r16_s_posSib2_8_r16) {
		_serNrSysFreeSQN_NR_SIBpos_r16(&p->posSib2_8_r16);
		return;
	}
	if (d == SQN_NR_PosSystemInformation_r16_IEs_posSIB_TypeAndInfo_r16_s_posSib2_9_r16) {
		_serNrSysFreeSQN_NR_SIBpos_r16(&p->posSib2_9_r16);
		return;
	}
	if (d == SQN_NR_PosSystemInformation_r16_IEs_posSIB_TypeAndInfo_r16_s_posSib2_10_r16) {
		_serNrSysFreeSQN_NR_SIBpos_r16(&p->posSib2_10_r16);
		return;
	}
	if (d == SQN_NR_PosSystemInformation_r16_IEs_posSIB_TypeAndInfo_r16_s_posSib2_11_r16) {
		_serNrSysFreeSQN_NR_SIBpos_r16(&p->posSib2_11_r16);
		return;
	}
	if (d == SQN_NR_PosSystemInformation_r16_IEs_posSIB_TypeAndInfo_r16_s_posSib2_12_r16) {
		_serNrSysFreeSQN_NR_SIBpos_r16(&p->posSib2_12_r16);
		return;
	}
	if (d == SQN_NR_PosSystemInformation_r16_IEs_posSIB_TypeAndInfo_r16_s_posSib2_13_r16) {
		_serNrSysFreeSQN_NR_SIBpos_r16(&p->posSib2_13_r16);
		return;
	}
	if (d == SQN_NR_PosSystemInformation_r16_IEs_posSIB_TypeAndInfo_r16_s_posSib2_14_r16) {
		_serNrSysFreeSQN_NR_SIBpos_r16(&p->posSib2_14_r16);
		return;
	}
	if (d == SQN_NR_PosSystemInformation_r16_IEs_posSIB_TypeAndInfo_r16_s_posSib2_15_r16) {
		_serNrSysFreeSQN_NR_SIBpos_r16(&p->posSib2_15_r16);
		return;
	}
	if (d == SQN_NR_PosSystemInformation_r16_IEs_posSIB_TypeAndInfo_r16_s_posSib2_16_r16) {
		_serNrSysFreeSQN_NR_SIBpos_r16(&p->posSib2_16_r16);
		return;
	}
	if (d == SQN_NR_PosSystemInformation_r16_IEs_posSIB_TypeAndInfo_r16_s_posSib2_17_r16) {
		_serNrSysFreeSQN_NR_SIBpos_r16(&p->posSib2_17_r16);
		return;
	}
	if (d == SQN_NR_PosSystemInformation_r16_IEs_posSIB_TypeAndInfo_r16_s_posSib2_18_r16) {
		_serNrSysFreeSQN_NR_SIBpos_r16(&p->posSib2_18_r16);
		return;
	}
	if (d == SQN_NR_PosSystemInformation_r16_IEs_posSIB_TypeAndInfo_r16_s_posSib2_19_r16) {
		_serNrSysFreeSQN_NR_SIBpos_r16(&p->posSib2_19_r16);
		return;
	}
	if (d == SQN_NR_PosSystemInformation_r16_IEs_posSIB_TypeAndInfo_r16_s_posSib2_20_r16) {
		_serNrSysFreeSQN_NR_SIBpos_r16(&p->posSib2_20_r16);
		return;
	}
	if (d == SQN_NR_PosSystemInformation_r16_IEs_posSIB_TypeAndInfo_r16_s_posSib2_21_r16) {
		_serNrSysFreeSQN_NR_SIBpos_r16(&p->posSib2_21_r16);
		return;
	}
	if (d == SQN_NR_PosSystemInformation_r16_IEs_posSIB_TypeAndInfo_r16_s_posSib2_22_r16) {
		_serNrSysFreeSQN_NR_SIBpos_r16(&p->posSib2_22_r16);
		return;
	}
	if (d == SQN_NR_PosSystemInformation_r16_IEs_posSIB_TypeAndInfo_r16_s_posSib2_23_r16) {
		_serNrSysFreeSQN_NR_SIBpos_r16(&p->posSib2_23_r16);
		return;
	}
	if (d == SQN_NR_PosSystemInformation_r16_IEs_posSIB_TypeAndInfo_r16_s_posSib3_1_r16) {
		_serNrSysFreeSQN_NR_SIBpos_r16(&p->posSib3_1_r16);
		return;
	}
	if (d == SQN_NR_PosSystemInformation_r16_IEs_posSIB_TypeAndInfo_r16_s_posSib4_1_r16) {
		_serNrSysFreeSQN_NR_SIBpos_r16(&p->posSib4_1_r16);
		return;
	}
	if (d == SQN_NR_PosSystemInformation_r16_IEs_posSIB_TypeAndInfo_r16_s_posSib5_1_r16) {
		_serNrSysFreeSQN_NR_SIBpos_r16(&p->posSib5_1_r16);
		return;
	}
	if (d == SQN_NR_PosSystemInformation_r16_IEs_posSIB_TypeAndInfo_r16_s_posSib6_1_r16) {
		_serNrSysFreeSQN_NR_SIBpos_r16(&p->posSib6_1_r16);
		return;
	}
	if (d == SQN_NR_PosSystemInformation_r16_IEs_posSIB_TypeAndInfo_r16_s_posSib6_2_r16) {
		_serNrSysFreeSQN_NR_SIBpos_r16(&p->posSib6_2_r16);
		return;
	}
	if (d == SQN_NR_PosSystemInformation_r16_IEs_posSIB_TypeAndInfo_r16_s_posSib6_3_r16) {
		_serNrSysFreeSQN_NR_SIBpos_r16(&p->posSib6_3_r16);
		return;
	}
}

static void _serNrSysFreeSQN_NR_PosSystemInformation_r16_IEs_posSIB_TypeAndInfo_r16_s(struct SQN_NR_PosSystemInformation_r16_IEs_posSIB_TypeAndInfo_r16_s* p)
{
	_serNrSysFreeSQN_NR_PosSystemInformation_r16_IEs_posSIB_TypeAndInfo_r16_s_Value(&p->v, p->d);
}

static void _serNrSysFreeOCTET_STRING_SQN_NR_PosSystemInformation_r16_IEs_lateNonCriticalExtension_Optional(struct OCTET_STRING_SQN_NR_PosSystemInformation_r16_IEs_lateNonCriticalExtension_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		serFree(p->v.v);
	}
}

static void _serNrSysFreeSQN_NR_PosSystemInformation_r16_IEs(struct SQN_NR_PosSystemInformation_r16_IEs* p)
{
	if (p->posSIB_TypeAndInfo_r16.v) {
		for (size_t i1 = 0; i1 < p->posSIB_TypeAndInfo_r16.d; i1++) {
			_serNrSysFreeSQN_NR_PosSystemInformation_r16_IEs_posSIB_TypeAndInfo_r16_s(&p->posSIB_TypeAndInfo_r16.v[i1]);
		}
		serFree(p->posSIB_TypeAndInfo_r16.v);
	}
	_serNrSysFreeOCTET_STRING_SQN_NR_PosSystemInformation_r16_IEs_lateNonCriticalExtension_Optional(&p->lateNonCriticalExtension);
}

static void _serNrSysFreeSQN_NR_SystemInformation_criticalExtensions_criticalExtensionsFuture_r16_Value(union SQN_NR_SystemInformation_criticalExtensions_criticalExtensionsFuture_r16_Value* p, enum SQN_NR_SystemInformation_criticalExtensions_criticalExtensionsFuture_r16_Sel d)
{
	if (d == SQN_NR_SystemInformation_criticalExtensions_criticalExtensionsFuture_r16_posSystemInformation_r16) {
		_serNrSysFreeSQN_NR_PosSystemInformation_r16_IEs(&p->posSystemInformation_r16);
		return;
	}
}

static void _serNrSysFreeSQN_NR_SystemInformation_criticalExtensions_criticalExtensionsFuture_r16(struct SQN_NR_SystemInformation_criticalExtensions_criticalExtensionsFuture_r16* p)
{
	_serNrSysFreeSQN_NR_SystemInformation_criticalExtensions_criticalExtensionsFuture_r16_Value(&p->v, p->d);
}

static void _serNrSysFreeSQN_NR_SystemInformation_criticalExtensions_Value(union SQN_NR_SystemInformation_criticalExtensions_Value* p, enum SQN_NR_SystemInformation_criticalExtensions_Sel d)
{
	if (d == SQN_NR_SystemInformation_criticalExtensions_systemInformation) {
		_serNrSysFreeSQN_NR_SystemInformation_IEs(&p->systemInformation);
		return;
	}
	if (d == SQN_NR_SystemInformation_criticalExtensions_criticalExtensionsFuture_r16) {
		_serNrSysFreeSQN_NR_SystemInformation_criticalExtensions_criticalExtensionsFuture_r16(&p->criticalExtensionsFuture_r16);
		return;
	}
}

static void _serNrSysFreeSQN_NR_SystemInformation_criticalExtensions(struct SQN_NR_SystemInformation_criticalExtensions* p)
{
	_serNrSysFreeSQN_NR_SystemInformation_criticalExtensions_Value(&p->v, p->d);
}

static void _serNrSysFreeSQN_NR_SystemInformation(struct SQN_NR_SystemInformation* p)
{
	_serNrSysFreeSQN_NR_SystemInformation_criticalExtensions(&p->criticalExtensions);
}

static void _serNrSysFreeSQN_NR_PLMN_Identity(struct SQN_NR_PLMN_Identity* p)
{
	if (p->mnc.v) {
		serFree(p->mnc.v);
	}
}

static void _serNrSysFreeSQN_NR_PLMN_IdentityInfo(struct SQN_NR_PLMN_IdentityInfo* p)
{
	if (p->plmn_IdentityList.v) {
		for (size_t i2 = 0; i2 < p->plmn_IdentityList.d; i2++) {
			_serNrSysFreeSQN_NR_PLMN_Identity(&p->plmn_IdentityList.v[i2]);
		}
		serFree(p->plmn_IdentityList.v);
	}
}

static void _serNrSysFreeSQN_NR_NPN_Identity_r16_pni_npn_r16(struct SQN_NR_NPN_Identity_r16_pni_npn_r16* p)
{
	_serNrSysFreeSQN_NR_PLMN_Identity(&p->plmn_Identity_r16);
	if (p->cag_IdentityList_r16.v) {
		for (size_t i3 = 0; i3 < p->cag_IdentityList_r16.d; i3++) {
		}
		serFree(p->cag_IdentityList_r16.v);
	}
}

static void _serNrSysFreeSQN_NR_NPN_Identity_r16_snpn_r16(struct SQN_NR_NPN_Identity_r16_snpn_r16* p)
{
	_serNrSysFreeSQN_NR_PLMN_Identity(&p->plmn_Identity);
	if (p->nid_List_r16.v) {
		serFree(p->nid_List_r16.v);
	}
}

static void _serNrSysFreeSQN_NR_NPN_Identity_r16_Value(union SQN_NR_NPN_Identity_r16_Value* p, enum SQN_NR_NPN_Identity_r16_Sel d)
{
	if (d == SQN_NR_NPN_Identity_r16_pni_npn_r16) {
		_serNrSysFreeSQN_NR_NPN_Identity_r16_pni_npn_r16(&p->pni_npn_r16);
		return;
	}
	if (d == SQN_NR_NPN_Identity_r16_snpn_r16) {
		_serNrSysFreeSQN_NR_NPN_Identity_r16_snpn_r16(&p->snpn_r16);
		return;
	}
}

static void _serNrSysFreeSQN_NR_NPN_Identity_r16(struct SQN_NR_NPN_Identity_r16* p)
{
	_serNrSysFreeSQN_NR_NPN_Identity_r16_Value(&p->v, p->d);
}

static void _serNrSysFreeSQN_NR_NPN_IdentityInfo_r16(struct SQN_NR_NPN_IdentityInfo_r16* p)
{
	if (p->npn_IdentityList_r16.v) {
		for (size_t i2 = 0; i2 < p->npn_IdentityList_r16.d; i2++) {
			_serNrSysFreeSQN_NR_NPN_Identity_r16(&p->npn_IdentityList_r16.v[i2]);
		}
		serFree(p->npn_IdentityList_r16.v);
	}
}

static void _serNrSysFreeSQN_NR_NPN_IdentityInfoList_r16_SQN_NR_CellAccessRelatedInfo_npn_IdentityInfoList_r16_Optional(struct SQN_NR_NPN_IdentityInfoList_r16_SQN_NR_CellAccessRelatedInfo_npn_IdentityInfoList_r16_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i1 = 0; i1 < p->v.d; i1++) {
			_serNrSysFreeSQN_NR_NPN_IdentityInfo_r16(&p->v.v[i1]);
		}
		serFree(p->v.v);
	}
}

static void _serNrSysFreeSQN_NR_CellAccessRelatedInfo(struct SQN_NR_CellAccessRelatedInfo* p)
{
	if (p->plmn_IdentityList.v) {
		for (size_t i1 = 0; i1 < p->plmn_IdentityList.d; i1++) {
			_serNrSysFreeSQN_NR_PLMN_IdentityInfo(&p->plmn_IdentityList.v[i1]);
		}
		serFree(p->plmn_IdentityList.v);
	}
	_serNrSysFreeSQN_NR_NPN_IdentityInfoList_r16_SQN_NR_CellAccessRelatedInfo_npn_IdentityInfoList_r16_Optional(&p->npn_IdentityInfoList_r16);
}

static void _serNrSysFreeSQN_NR_SchedulingInfo(struct SQN_NR_SchedulingInfo* p)
{
	if (p->sib_MappingInfo.v) {
		for (size_t i2 = 0; i2 < p->sib_MappingInfo.d; i2++) {
		}
		serFree(p->sib_MappingInfo.v);
	}
}

static void _serNrSysFreeSQN_NR_SI_RequestConfig_SQN_NR_SI_SchedulingInfo_si_RequestConfig_Optional(struct SQN_NR_SI_RequestConfig_SQN_NR_SI_SchedulingInfo_si_RequestConfig_Optional* p)
{
	if (!p->d) return;
	_serNrSysFreeSQN_NR_SI_RequestConfig(&p->v);
}

static void _serNrSysFreeSQN_NR_SI_RequestConfig_SQN_NR_SI_SchedulingInfo_si_RequestConfigSUL_Optional(struct SQN_NR_SI_RequestConfig_SQN_NR_SI_SchedulingInfo_si_RequestConfigSUL_Optional* p)
{
	if (!p->d) return;
	_serNrSysFreeSQN_NR_SI_RequestConfig(&p->v);
}

static void _serNrSysFreeSQN_NR_SI_SchedulingInfo(struct SQN_NR_SI_SchedulingInfo* p)
{
	if (p->schedulingInfoList.v) {
		for (size_t i1 = 0; i1 < p->schedulingInfoList.d; i1++) {
			_serNrSysFreeSQN_NR_SchedulingInfo(&p->schedulingInfoList.v[i1]);
		}
		serFree(p->schedulingInfoList.v);
	}
	_serNrSysFreeSQN_NR_SI_RequestConfig_SQN_NR_SI_SchedulingInfo_si_RequestConfig_Optional(&p->si_RequestConfig);
	_serNrSysFreeSQN_NR_SI_RequestConfig_SQN_NR_SI_SchedulingInfo_si_RequestConfigSUL_Optional(&p->si_RequestConfigSUL);
}

static void _serNrSysFreeSQN_NR_SI_SchedulingInfo_SQN_NR_SIB1_si_SchedulingInfo_Optional(struct SQN_NR_SI_SchedulingInfo_SQN_NR_SIB1_si_SchedulingInfo_Optional* p)
{
	if (!p->d) return;
	_serNrSysFreeSQN_NR_SI_SchedulingInfo(&p->v);
}

static void _serNrSysFreeSQN_NR_FrequencyInfoDL_SIB(struct SQN_NR_FrequencyInfoDL_SIB* p)
{
	if (p->frequencyBandList.v) {
		for (size_t i1 = 0; i1 < p->frequencyBandList.d; i1++) {
			_serNrSysFreeSQN_NR_NR_MultiBandInfo(&p->frequencyBandList.v[i1]);
		}
		serFree(p->frequencyBandList.v);
	}
	if (p->scs_SpecificCarrierList.v) {
		for (size_t i1 = 0; i1 < p->scs_SpecificCarrierList.d; i1++) {
		}
		serFree(p->scs_SpecificCarrierList.v);
	}
}

static void _serNrSysFreeSQN_NR_ControlResourceSet_SQN_NR_PDCCH_ConfigCommon_commonControlResourceSet_Optional(struct SQN_NR_ControlResourceSet_SQN_NR_PDCCH_ConfigCommon_commonControlResourceSet_Optional* p)
{
	if (!p->d) return;
	_serNrSysFreeSQN_NR_ControlResourceSet(&p->v);
}

static void _serNrSysFreeSQN_NR_SearchSpace_SQN_NR_PDCCH_ConfigCommon_commonSearchSpaceList_DynamicOptional(struct SQN_NR_SearchSpace_SQN_NR_PDCCH_ConfigCommon_commonSearchSpaceList_DynamicOptional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i1 = 0; i1 < p->v.d; i1++) {
		}
		serFree(p->v.v);
	}
}

static void _serNrSysFreeSQN_NR_PDCCH_ConfigCommon_firstPDCCH_MonitoringOccasionOfPO_Value(union SQN_NR_PDCCH_ConfigCommon_firstPDCCH_MonitoringOccasionOfPO_Value* p, enum SQN_NR_PDCCH_ConfigCommon_firstPDCCH_MonitoringOccasionOfPO_Sel d)
{
	if (d == SQN_NR_PDCCH_ConfigCommon_firstPDCCH_MonitoringOccasionOfPO_sCS15KHZoneT) {
		if (p->sCS15KHZoneT.v) {
			serFree(p->sCS15KHZoneT.v);
		}
		return;
	}
	if (d == SQN_NR_PDCCH_ConfigCommon_firstPDCCH_MonitoringOccasionOfPO_sCS30KHZoneT_SCS15KHZhalfT) {
		if (p->sCS30KHZoneT_SCS15KHZhalfT.v) {
			serFree(p->sCS30KHZoneT_SCS15KHZhalfT.v);
		}
		return;
	}
	if (d == SQN_NR_PDCCH_ConfigCommon_firstPDCCH_MonitoringOccasionOfPO_sCS60KHZoneT_SCS30KHZhalfT_SCS15KHZquarterT) {
		if (p->sCS60KHZoneT_SCS30KHZhalfT_SCS15KHZquarterT.v) {
			serFree(p->sCS60KHZoneT_SCS30KHZhalfT_SCS15KHZquarterT.v);
		}
		return;
	}
	if (d == SQN_NR_PDCCH_ConfigCommon_firstPDCCH_MonitoringOccasionOfPO_sCS120KHZoneT_SCS60KHZhalfT_SCS30KHZquarterT_SCS15KHZoneEighthT) {
		if (p->sCS120KHZoneT_SCS60KHZhalfT_SCS30KHZquarterT_SCS15KHZoneEighthT.v) {
			serFree(p->sCS120KHZoneT_SCS60KHZhalfT_SCS30KHZquarterT_SCS15KHZoneEighthT.v);
		}
		return;
	}
	if (d == SQN_NR_PDCCH_ConfigCommon_firstPDCCH_MonitoringOccasionOfPO_sCS120KHZhalfT_SCS60KHZquarterT_SCS30KHZoneEighthT_SCS15KHZoneSixteenthT) {
		if (p->sCS120KHZhalfT_SCS60KHZquarterT_SCS30KHZoneEighthT_SCS15KHZoneSixteenthT.v) {
			serFree(p->sCS120KHZhalfT_SCS60KHZquarterT_SCS30KHZoneEighthT_SCS15KHZoneSixteenthT.v);
		}
		return;
	}
	if (d == SQN_NR_PDCCH_ConfigCommon_firstPDCCH_MonitoringOccasionOfPO_sCS120KHZquarterT_SCS60KHZoneEighthT_SCS30KHZoneSixteenthT) {
		if (p->sCS120KHZquarterT_SCS60KHZoneEighthT_SCS30KHZoneSixteenthT.v) {
			serFree(p->sCS120KHZquarterT_SCS60KHZoneEighthT_SCS30KHZoneSixteenthT.v);
		}
		return;
	}
	if (d == SQN_NR_PDCCH_ConfigCommon_firstPDCCH_MonitoringOccasionOfPO_sCS120KHZoneEighthT_SCS60KHZoneSixteenthT) {
		if (p->sCS120KHZoneEighthT_SCS60KHZoneSixteenthT.v) {
			serFree(p->sCS120KHZoneEighthT_SCS60KHZoneSixteenthT.v);
		}
		return;
	}
	if (d == SQN_NR_PDCCH_ConfigCommon_firstPDCCH_MonitoringOccasionOfPO_sCS120KHZoneSixteenthT) {
		if (p->sCS120KHZoneSixteenthT.v) {
			serFree(p->sCS120KHZoneSixteenthT.v);
		}
		return;
	}
}

static void _serNrSysFreeSQN_NR_PDCCH_ConfigCommon_firstPDCCH_MonitoringOccasionOfPO(struct SQN_NR_PDCCH_ConfigCommon_firstPDCCH_MonitoringOccasionOfPO* p)
{
	_serNrSysFreeSQN_NR_PDCCH_ConfigCommon_firstPDCCH_MonitoringOccasionOfPO_Value(&p->v, p->d);
}

static void _serNrSysFreeSQN_NR_PDCCH_ConfigCommon_firstPDCCH_MonitoringOccasionOfPO_firstPDCCH_MonitoringOccasionOfPO_Optional(struct SQN_NR_PDCCH_ConfigCommon_firstPDCCH_MonitoringOccasionOfPO_firstPDCCH_MonitoringOccasionOfPO_Optional* p)
{
	if (!p->d) return;
	_serNrSysFreeSQN_NR_PDCCH_ConfigCommon_firstPDCCH_MonitoringOccasionOfPO(&p->v);
}

static void _serNrSysFreeUint8_t_SQN_NR_SearchSpaceExt_r16_searchSpaceGroupIdList_r16_DynamicOptional(struct uint8_t_SQN_NR_SearchSpaceExt_r16_searchSpaceGroupIdList_r16_DynamicOptional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		serFree(p->v.v);
	}
}

static void _serNrSysFreeSQN_NR_SearchSpaceExt_r16(struct SQN_NR_SearchSpaceExt_r16* p)
{
	_serNrSysFreeUint8_t_SQN_NR_SearchSpaceExt_r16_searchSpaceGroupIdList_r16_DynamicOptional(&p->searchSpaceGroupIdList_r16);
}

static void _serNrSysFreeSQN_NR_SearchSpaceExt_r16_SQN_NR_PDCCH_ConfigCommon_commonSearchSpaceListExt_r16_DynamicOptional(struct SQN_NR_SearchSpaceExt_r16_SQN_NR_PDCCH_ConfigCommon_commonSearchSpaceListExt_r16_DynamicOptional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i1 = 0; i1 < p->v.d; i1++) {
			_serNrSysFreeSQN_NR_SearchSpaceExt_r16(&p->v.v[i1]);
		}
		serFree(p->v.v);
	}
}

static void _serNrSysFreeSQN_NR_PDCCH_ConfigCommon(struct SQN_NR_PDCCH_ConfigCommon* p)
{
	_serNrSysFreeSQN_NR_ControlResourceSet_SQN_NR_PDCCH_ConfigCommon_commonControlResourceSet_Optional(&p->commonControlResourceSet);
	_serNrSysFreeSQN_NR_SearchSpace_SQN_NR_PDCCH_ConfigCommon_commonSearchSpaceList_DynamicOptional(&p->commonSearchSpaceList);
	_serNrSysFreeSQN_NR_PDCCH_ConfigCommon_firstPDCCH_MonitoringOccasionOfPO_firstPDCCH_MonitoringOccasionOfPO_Optional(&p->firstPDCCH_MonitoringOccasionOfPO);
	_serNrSysFreeSQN_NR_SearchSpaceExt_r16_SQN_NR_PDCCH_ConfigCommon_commonSearchSpaceListExt_r16_DynamicOptional(&p->commonSearchSpaceListExt_r16);
}

static void _serNrSysFreeSQN_NR_SetupRelease_BWP_DownlinkCommon_pdcch_ConfigCommon_Value(union SQN_NR_SetupRelease_BWP_DownlinkCommon_pdcch_ConfigCommon_Value* p, enum SQN_NR_SetupRelease_BWP_DownlinkCommon_pdcch_ConfigCommon_Sel d)
{
	if (d == SQN_NR_SetupRelease_BWP_DownlinkCommon_pdcch_ConfigCommon_setup) {
		_serNrSysFreeSQN_NR_PDCCH_ConfigCommon(&p->setup);
		return;
	}
}

static void _serNrSysFreeSQN_NR_SetupRelease_BWP_DownlinkCommon_pdcch_ConfigCommon(struct SQN_NR_SetupRelease_BWP_DownlinkCommon_pdcch_ConfigCommon* p)
{
	_serNrSysFreeSQN_NR_SetupRelease_BWP_DownlinkCommon_pdcch_ConfigCommon_Value(&p->v, p->d);
}

static void _serNrSysFreeSQN_NR_SetupRelease_BWP_DownlinkCommon_pdcch_ConfigCommon_SQN_NR_BWP_DownlinkCommon_pdcch_ConfigCommon_Optional(struct SQN_NR_SetupRelease_BWP_DownlinkCommon_pdcch_ConfigCommon_SQN_NR_BWP_DownlinkCommon_pdcch_ConfigCommon_Optional* p)
{
	if (!p->d) return;
	_serNrSysFreeSQN_NR_SetupRelease_BWP_DownlinkCommon_pdcch_ConfigCommon(&p->v);
}

static void _serNrSysFreeSQN_NR_SetupRelease_BWP_DownlinkCommon_pdsch_ConfigCommon_Value(union SQN_NR_SetupRelease_BWP_DownlinkCommon_pdsch_ConfigCommon_Value* p, enum SQN_NR_SetupRelease_BWP_DownlinkCommon_pdsch_ConfigCommon_Sel d)
{
	if (d == SQN_NR_SetupRelease_BWP_DownlinkCommon_pdsch_ConfigCommon_setup) {
		_serNrSysFreeSQN_NR_PDSCH_ConfigCommon(&p->setup);
		return;
	}
}

static void _serNrSysFreeSQN_NR_SetupRelease_BWP_DownlinkCommon_pdsch_ConfigCommon(struct SQN_NR_SetupRelease_BWP_DownlinkCommon_pdsch_ConfigCommon* p)
{
	_serNrSysFreeSQN_NR_SetupRelease_BWP_DownlinkCommon_pdsch_ConfigCommon_Value(&p->v, p->d);
}

static void _serNrSysFreeSQN_NR_SetupRelease_BWP_DownlinkCommon_pdsch_ConfigCommon_SQN_NR_BWP_DownlinkCommon_pdsch_ConfigCommon_Optional(struct SQN_NR_SetupRelease_BWP_DownlinkCommon_pdsch_ConfigCommon_SQN_NR_BWP_DownlinkCommon_pdsch_ConfigCommon_Optional* p)
{
	if (!p->d) return;
	_serNrSysFreeSQN_NR_SetupRelease_BWP_DownlinkCommon_pdsch_ConfigCommon(&p->v);
}

static void _serNrSysFreeSQN_NR_BWP_DownlinkCommon(struct SQN_NR_BWP_DownlinkCommon* p)
{
	_serNrSysFreeSQN_NR_SetupRelease_BWP_DownlinkCommon_pdcch_ConfigCommon_SQN_NR_BWP_DownlinkCommon_pdcch_ConfigCommon_Optional(&p->pdcch_ConfigCommon);
	_serNrSysFreeSQN_NR_SetupRelease_BWP_DownlinkCommon_pdsch_ConfigCommon_SQN_NR_BWP_DownlinkCommon_pdsch_ConfigCommon_Optional(&p->pdsch_ConfigCommon);
}

static void _serNrSysFreeSQN_NR_PCCH_Config_firstPDCCH_MonitoringOccasionOfPO_Value(union SQN_NR_PCCH_Config_firstPDCCH_MonitoringOccasionOfPO_Value* p, enum SQN_NR_PCCH_Config_firstPDCCH_MonitoringOccasionOfPO_Sel d)
{
	if (d == SQN_NR_PCCH_Config_firstPDCCH_MonitoringOccasionOfPO_sCS15KHZoneT) {
		if (p->sCS15KHZoneT.v) {
			serFree(p->sCS15KHZoneT.v);
		}
		return;
	}
	if (d == SQN_NR_PCCH_Config_firstPDCCH_MonitoringOccasionOfPO_sCS30KHZoneT_SCS15KHZhalfT) {
		if (p->sCS30KHZoneT_SCS15KHZhalfT.v) {
			serFree(p->sCS30KHZoneT_SCS15KHZhalfT.v);
		}
		return;
	}
	if (d == SQN_NR_PCCH_Config_firstPDCCH_MonitoringOccasionOfPO_sCS60KHZoneT_SCS30KHZhalfT_SCS15KHZquarterT) {
		if (p->sCS60KHZoneT_SCS30KHZhalfT_SCS15KHZquarterT.v) {
			serFree(p->sCS60KHZoneT_SCS30KHZhalfT_SCS15KHZquarterT.v);
		}
		return;
	}
	if (d == SQN_NR_PCCH_Config_firstPDCCH_MonitoringOccasionOfPO_sCS120KHZoneT_SCS60KHZhalfT_SCS30KHZquarterT_SCS15KHZoneEighthT) {
		if (p->sCS120KHZoneT_SCS60KHZhalfT_SCS30KHZquarterT_SCS15KHZoneEighthT.v) {
			serFree(p->sCS120KHZoneT_SCS60KHZhalfT_SCS30KHZquarterT_SCS15KHZoneEighthT.v);
		}
		return;
	}
	if (d == SQN_NR_PCCH_Config_firstPDCCH_MonitoringOccasionOfPO_sCS120KHZhalfT_SCS60KHZquarterT_SCS30KHZoneEighthT_SCS15KHZoneSixteenthT) {
		if (p->sCS120KHZhalfT_SCS60KHZquarterT_SCS30KHZoneEighthT_SCS15KHZoneSixteenthT.v) {
			serFree(p->sCS120KHZhalfT_SCS60KHZquarterT_SCS30KHZoneEighthT_SCS15KHZoneSixteenthT.v);
		}
		return;
	}
	if (d == SQN_NR_PCCH_Config_firstPDCCH_MonitoringOccasionOfPO_sCS120KHZquarterT_SCS60KHZoneEighthT_SCS30KHZoneSixteenthT) {
		if (p->sCS120KHZquarterT_SCS60KHZoneEighthT_SCS30KHZoneSixteenthT.v) {
			serFree(p->sCS120KHZquarterT_SCS60KHZoneEighthT_SCS30KHZoneSixteenthT.v);
		}
		return;
	}
	if (d == SQN_NR_PCCH_Config_firstPDCCH_MonitoringOccasionOfPO_sCS120KHZoneEighthT_SCS60KHZoneSixteenthT) {
		if (p->sCS120KHZoneEighthT_SCS60KHZoneSixteenthT.v) {
			serFree(p->sCS120KHZoneEighthT_SCS60KHZoneSixteenthT.v);
		}
		return;
	}
	if (d == SQN_NR_PCCH_Config_firstPDCCH_MonitoringOccasionOfPO_sCS120KHZoneSixteenthT) {
		if (p->sCS120KHZoneSixteenthT.v) {
			serFree(p->sCS120KHZoneSixteenthT.v);
		}
		return;
	}
}

static void _serNrSysFreeSQN_NR_PCCH_Config_firstPDCCH_MonitoringOccasionOfPO(struct SQN_NR_PCCH_Config_firstPDCCH_MonitoringOccasionOfPO* p)
{
	_serNrSysFreeSQN_NR_PCCH_Config_firstPDCCH_MonitoringOccasionOfPO_Value(&p->v, p->d);
}

static void _serNrSysFreeSQN_NR_PCCH_Config_firstPDCCH_MonitoringOccasionOfPO_firstPDCCH_MonitoringOccasionOfPO_Optional(struct SQN_NR_PCCH_Config_firstPDCCH_MonitoringOccasionOfPO_firstPDCCH_MonitoringOccasionOfPO_Optional* p)
{
	if (!p->d) return;
	_serNrSysFreeSQN_NR_PCCH_Config_firstPDCCH_MonitoringOccasionOfPO(&p->v);
}

static void _serNrSysFreeSQN_NR_PCCH_Config(struct SQN_NR_PCCH_Config* p)
{
	_serNrSysFreeSQN_NR_PCCH_Config_firstPDCCH_MonitoringOccasionOfPO_firstPDCCH_MonitoringOccasionOfPO_Optional(&p->firstPDCCH_MonitoringOccasionOfPO);
}

static void _serNrSysFreeSQN_NR_DownlinkConfigCommonSIB(struct SQN_NR_DownlinkConfigCommonSIB* p)
{
	_serNrSysFreeSQN_NR_FrequencyInfoDL_SIB(&p->frequencyInfoDL);
	_serNrSysFreeSQN_NR_BWP_DownlinkCommon(&p->initialDownlinkBWP);
	_serNrSysFreeSQN_NR_PCCH_Config(&p->pcch_Config);
}

static void _serNrSysFreeSQN_NR_MultiFrequencyBandListNR_SIB_SQN_NR_FrequencyInfoUL_SIB_frequencyBandList_Optional(struct SQN_NR_MultiFrequencyBandListNR_SIB_SQN_NR_FrequencyInfoUL_SIB_frequencyBandList_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i1 = 0; i1 < p->v.d; i1++) {
			_serNrSysFreeSQN_NR_NR_MultiBandInfo(&p->v.v[i1]);
		}
		serFree(p->v.v);
	}
}

static void _serNrSysFreeSQN_NR_FrequencyInfoUL_SIB(struct SQN_NR_FrequencyInfoUL_SIB* p)
{
	_serNrSysFreeSQN_NR_MultiFrequencyBandListNR_SIB_SQN_NR_FrequencyInfoUL_SIB_frequencyBandList_Optional(&p->frequencyBandList);
	if (p->scs_SpecificCarrierList.v) {
		for (size_t i1 = 0; i1 < p->scs_SpecificCarrierList.d; i1++) {
		}
		serFree(p->scs_SpecificCarrierList.v);
	}
}

static void _serNrSysFreeSQN_NR_UplinkConfigCommonSIB(struct SQN_NR_UplinkConfigCommonSIB* p)
{
	_serNrSysFreeSQN_NR_FrequencyInfoUL_SIB(&p->frequencyInfoUL);
	_serNrSysFreeSQN_NR_BWP_UplinkCommon(&p->initialUplinkBWP);
}

static void _serNrSysFreeSQN_NR_UplinkConfigCommonSIB_SQN_NR_ServingCellConfigCommonSIB_uplinkConfigCommon_Optional(struct SQN_NR_UplinkConfigCommonSIB_SQN_NR_ServingCellConfigCommonSIB_uplinkConfigCommon_Optional* p)
{
	if (!p->d) return;
	_serNrSysFreeSQN_NR_UplinkConfigCommonSIB(&p->v);
}

static void _serNrSysFreeSQN_NR_UplinkConfigCommonSIB_SQN_NR_ServingCellConfigCommonSIB_supplementaryUplink_Optional(struct SQN_NR_UplinkConfigCommonSIB_SQN_NR_ServingCellConfigCommonSIB_supplementaryUplink_Optional* p)
{
	if (!p->d) return;
	_serNrSysFreeSQN_NR_UplinkConfigCommonSIB(&p->v);
}

static void _serNrSysFreeSQN_NR_ServingCellConfigCommonSIB(struct SQN_NR_ServingCellConfigCommonSIB* p)
{
	_serNrSysFreeSQN_NR_DownlinkConfigCommonSIB(&p->downlinkConfigCommon);
	_serNrSysFreeSQN_NR_UplinkConfigCommonSIB_SQN_NR_ServingCellConfigCommonSIB_uplinkConfigCommon_Optional(&p->uplinkConfigCommon);
	_serNrSysFreeSQN_NR_UplinkConfigCommonSIB_SQN_NR_ServingCellConfigCommonSIB_supplementaryUplink_Optional(&p->supplementaryUplink);
}

static void _serNrSysFreeSQN_NR_ServingCellConfigCommonSIB_SQN_NR_SIB1_servingCellConfigCommon_Optional(struct SQN_NR_ServingCellConfigCommonSIB_SQN_NR_SIB1_servingCellConfigCommon_Optional* p)
{
	if (!p->d) return;
	_serNrSysFreeSQN_NR_ServingCellConfigCommonSIB(&p->v);
}

static void _serNrSysFreeSQN_NR_UAC_BarringPerCatList_SQN_NR_SIB1_uac_BarringInfo_uac_BarringForCommon_Optional(struct SQN_NR_UAC_BarringPerCatList_SQN_NR_SIB1_uac_BarringInfo_uac_BarringForCommon_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i1 = 0; i1 < p->v.d; i1++) {
		}
		serFree(p->v.v);
	}
}

static void _serNrSysFreeSQN_NR_UAC_BarringPerPLMN_uac_ACBarringListType_Value(union SQN_NR_UAC_BarringPerPLMN_uac_ACBarringListType_Value* p, enum SQN_NR_UAC_BarringPerPLMN_uac_ACBarringListType_Sel d)
{
	if (d == SQN_NR_UAC_BarringPerPLMN_uac_ACBarringListType_uac_ExplicitACBarringList) {
		if (p->uac_ExplicitACBarringList.v) {
			for (size_t i2 = 0; i2 < p->uac_ExplicitACBarringList.d; i2++) {
			}
			serFree(p->uac_ExplicitACBarringList.v);
		}
		return;
	}
}

static void _serNrSysFreeSQN_NR_UAC_BarringPerPLMN_uac_ACBarringListType(struct SQN_NR_UAC_BarringPerPLMN_uac_ACBarringListType* p)
{
	_serNrSysFreeSQN_NR_UAC_BarringPerPLMN_uac_ACBarringListType_Value(&p->v, p->d);
}

static void _serNrSysFreeSQN_NR_UAC_BarringPerPLMN_uac_ACBarringListType_uac_ACBarringListType_Optional(struct SQN_NR_UAC_BarringPerPLMN_uac_ACBarringListType_uac_ACBarringListType_Optional* p)
{
	if (!p->d) return;
	_serNrSysFreeSQN_NR_UAC_BarringPerPLMN_uac_ACBarringListType(&p->v);
}

static void _serNrSysFreeSQN_NR_UAC_BarringPerPLMN(struct SQN_NR_UAC_BarringPerPLMN* p)
{
	_serNrSysFreeSQN_NR_UAC_BarringPerPLMN_uac_ACBarringListType_uac_ACBarringListType_Optional(&p->uac_ACBarringListType);
}

static void _serNrSysFreeSQN_NR_UAC_BarringPerPLMN_List_SQN_NR_SIB1_uac_BarringInfo_uac_BarringPerPLMN_List_Optional(struct SQN_NR_UAC_BarringPerPLMN_List_SQN_NR_SIB1_uac_BarringInfo_uac_BarringPerPLMN_List_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i1 = 0; i1 < p->v.d; i1++) {
			_serNrSysFreeSQN_NR_UAC_BarringPerPLMN(&p->v.v[i1]);
		}
		serFree(p->v.v);
	}
}

static void _serNrSysFreeSQN_NR_SIB1_uac_BarringInfo_uac_AccessCategory1_SelectionAssistanceInfo_Value(union SQN_NR_SIB1_uac_BarringInfo_uac_AccessCategory1_SelectionAssistanceInfo_Value* p, enum SQN_NR_SIB1_uac_BarringInfo_uac_AccessCategory1_SelectionAssistanceInfo_Sel d)
{
	if (d == SQN_NR_SIB1_uac_BarringInfo_uac_AccessCategory1_SelectionAssistanceInfo_individualPLMNList) {
		if (p->individualPLMNList.v) {
			serFree(p->individualPLMNList.v);
		}
		return;
	}
}

static void _serNrSysFreeSQN_NR_SIB1_uac_BarringInfo_uac_AccessCategory1_SelectionAssistanceInfo(struct SQN_NR_SIB1_uac_BarringInfo_uac_AccessCategory1_SelectionAssistanceInfo* p)
{
	_serNrSysFreeSQN_NR_SIB1_uac_BarringInfo_uac_AccessCategory1_SelectionAssistanceInfo_Value(&p->v, p->d);
}

static void _serNrSysFreeSQN_NR_SIB1_uac_BarringInfo_uac_AccessCategory1_SelectionAssistanceInfo_uac_AccessCategory1_SelectionAssistanceInfo_Optional(struct SQN_NR_SIB1_uac_BarringInfo_uac_AccessCategory1_SelectionAssistanceInfo_uac_AccessCategory1_SelectionAssistanceInfo_Optional* p)
{
	if (!p->d) return;
	_serNrSysFreeSQN_NR_SIB1_uac_BarringInfo_uac_AccessCategory1_SelectionAssistanceInfo(&p->v);
}

static void _serNrSysFreeSQN_NR_SIB1_uac_BarringInfo(struct SQN_NR_SIB1_uac_BarringInfo* p)
{
	_serNrSysFreeSQN_NR_UAC_BarringPerCatList_SQN_NR_SIB1_uac_BarringInfo_uac_BarringForCommon_Optional(&p->uac_BarringForCommon);
	_serNrSysFreeSQN_NR_UAC_BarringPerPLMN_List_SQN_NR_SIB1_uac_BarringInfo_uac_BarringPerPLMN_List_Optional(&p->uac_BarringPerPLMN_List);
	if (p->uac_BarringInfoSetList.v) {
		for (size_t i1 = 0; i1 < p->uac_BarringInfoSetList.d; i1++) {
		}
		serFree(p->uac_BarringInfoSetList.v);
	}
	_serNrSysFreeSQN_NR_SIB1_uac_BarringInfo_uac_AccessCategory1_SelectionAssistanceInfo_uac_AccessCategory1_SelectionAssistanceInfo_Optional(&p->uac_AccessCategory1_SelectionAssistanceInfo);
}

static void _serNrSysFreeSQN_NR_SIB1_uac_BarringInfo_uac_BarringInfo_Optional(struct SQN_NR_SIB1_uac_BarringInfo_uac_BarringInfo_Optional* p)
{
	if (!p->d) return;
	_serNrSysFreeSQN_NR_SIB1_uac_BarringInfo(&p->v);
}

static void _serNrSysFreeOCTET_STRING_SQN_NR_SIB1_lateNonCriticalExtension_Optional(struct OCTET_STRING_SQN_NR_SIB1_lateNonCriticalExtension_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		serFree(p->v.v);
	}
}

static void _serNrSysFreeSQN_NR_PosSchedulingInfo_r16(struct SQN_NR_PosSchedulingInfo_r16* p)
{
	if (p->posSIB_MappingInfo_r16.v) {
		for (size_t i2 = 0; i2 < p->posSIB_MappingInfo_r16.d; i2++) {
		}
		serFree(p->posSIB_MappingInfo_r16.v);
	}
}

static void _serNrSysFreeSQN_NR_SI_RequestConfig_SQN_NR_PosSI_SchedulingInfo_r16_posSI_RequestConfig_r16_Optional(struct SQN_NR_SI_RequestConfig_SQN_NR_PosSI_SchedulingInfo_r16_posSI_RequestConfig_r16_Optional* p)
{
	if (!p->d) return;
	_serNrSysFreeSQN_NR_SI_RequestConfig(&p->v);
}

static void _serNrSysFreeSQN_NR_SI_RequestConfig_SQN_NR_PosSI_SchedulingInfo_r16_posSI_RequestConfigSUL_r16_Optional(struct SQN_NR_SI_RequestConfig_SQN_NR_PosSI_SchedulingInfo_r16_posSI_RequestConfigSUL_r16_Optional* p)
{
	if (!p->d) return;
	_serNrSysFreeSQN_NR_SI_RequestConfig(&p->v);
}

static void _serNrSysFreeSQN_NR_PosSI_SchedulingInfo_r16(struct SQN_NR_PosSI_SchedulingInfo_r16* p)
{
	if (p->posSchedulingInfoList_r16.v) {
		for (size_t i1 = 0; i1 < p->posSchedulingInfoList_r16.d; i1++) {
			_serNrSysFreeSQN_NR_PosSchedulingInfo_r16(&p->posSchedulingInfoList_r16.v[i1]);
		}
		serFree(p->posSchedulingInfoList_r16.v);
	}
	_serNrSysFreeSQN_NR_SI_RequestConfig_SQN_NR_PosSI_SchedulingInfo_r16_posSI_RequestConfig_r16_Optional(&p->posSI_RequestConfig_r16);
	_serNrSysFreeSQN_NR_SI_RequestConfig_SQN_NR_PosSI_SchedulingInfo_r16_posSI_RequestConfigSUL_r16_Optional(&p->posSI_RequestConfigSUL_r16);
}

static void _serNrSysFreeSQN_NR_PosSI_SchedulingInfo_r16_SQN_NR_SIB1_v1610_IEs_posSI_SchedulingInfo_r16_Optional(struct SQN_NR_PosSI_SchedulingInfo_r16_SQN_NR_SIB1_v1610_IEs_posSI_SchedulingInfo_r16_Optional* p)
{
	if (!p->d) return;
	_serNrSysFreeSQN_NR_PosSI_SchedulingInfo_r16(&p->v);
}

static void _serNrSysFreeSQN_NR_SIB1_v1610_IEs(struct SQN_NR_SIB1_v1610_IEs* p)
{
	_serNrSysFreeSQN_NR_PosSI_SchedulingInfo_r16_SQN_NR_SIB1_v1610_IEs_posSI_SchedulingInfo_r16_Optional(&p->posSI_SchedulingInfo_r16);
}

static void _serNrSysFreeSQN_NR_SIB1_v1610_IEs_SQN_NR_SIB1_nonCriticalExtension_Optional(struct SQN_NR_SIB1_v1610_IEs_SQN_NR_SIB1_nonCriticalExtension_Optional* p)
{
	if (!p->d) return;
	_serNrSysFreeSQN_NR_SIB1_v1610_IEs(&p->v);
}

static void _serNrSysFreeSQN_NR_SIB1(struct SQN_NR_SIB1* p)
{
	_serNrSysFreeSQN_NR_CellAccessRelatedInfo(&p->cellAccessRelatedInfo);
	_serNrSysFreeSQN_NR_SI_SchedulingInfo_SQN_NR_SIB1_si_SchedulingInfo_Optional(&p->si_SchedulingInfo);
	_serNrSysFreeSQN_NR_ServingCellConfigCommonSIB_SQN_NR_SIB1_servingCellConfigCommon_Optional(&p->servingCellConfigCommon);
	_serNrSysFreeSQN_NR_SIB1_uac_BarringInfo_uac_BarringInfo_Optional(&p->uac_BarringInfo);
	_serNrSysFreeOCTET_STRING_SQN_NR_SIB1_lateNonCriticalExtension_Optional(&p->lateNonCriticalExtension);
	_serNrSysFreeSQN_NR_SIB1_v1610_IEs_SQN_NR_SIB1_nonCriticalExtension_Optional(&p->nonCriticalExtension);
}

static void _serNrSysFreeSQN_NR_BCCH_DL_SCH_MessageType_c1_Value(union SQN_NR_BCCH_DL_SCH_MessageType_c1_Value* p, enum SQN_NR_BCCH_DL_SCH_MessageType_c1_Sel d)
{
	if (d == SQN_NR_BCCH_DL_SCH_MessageType_c1_systemInformation) {
		_serNrSysFreeSQN_NR_SystemInformation(&p->systemInformation);
		return;
	}
	if (d == SQN_NR_BCCH_DL_SCH_MessageType_c1_systemInformationBlockType1) {
		_serNrSysFreeSQN_NR_SIB1(&p->systemInformationBlockType1);
		return;
	}
}

static void _serNrSysFreeSQN_NR_BCCH_DL_SCH_MessageType_c1(struct SQN_NR_BCCH_DL_SCH_MessageType_c1* p)
{
	_serNrSysFreeSQN_NR_BCCH_DL_SCH_MessageType_c1_Value(&p->v, p->d);
}

static void _serNrSysFreeSQN_NR_BCCH_DL_SCH_MessageType_Value(union SQN_NR_BCCH_DL_SCH_MessageType_Value* p, enum SQN_NR_BCCH_DL_SCH_MessageType_Sel d)
{
	if (d == SQN_NR_BCCH_DL_SCH_MessageType_c1) {
		_serNrSysFreeSQN_NR_BCCH_DL_SCH_MessageType_c1(&p->c1);
		return;
	}
}

static void _serNrSysFreeSQN_NR_BCCH_DL_SCH_MessageType(struct SQN_NR_BCCH_DL_SCH_MessageType* p)
{
	_serNrSysFreeSQN_NR_BCCH_DL_SCH_MessageType_Value(&p->v, p->d);
}

static void _serNrSysFreeSQN_NR_BCCH_DL_SCH_Message(struct SQN_NR_BCCH_DL_SCH_Message* p)
{
	_serNrSysFreeSQN_NR_BCCH_DL_SCH_MessageType(&p->message);
}

static void _serNrSysFreeSQN_NR_BCCH_DL_SCH_Message_SIB1_Optional(struct SQN_NR_BCCH_DL_SCH_Message_SIB1_Optional* p)
{
	if (!p->d) return;
	_serNrSysFreeSQN_NR_BCCH_DL_SCH_Message(&p->v);
}

static void _serNrSysFreeNR_SI_List_Type_SIs_Optional(struct NR_SI_List_Type_SIs_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i1 = 0; i1 < p->v.d; i1++) {
			_serNrSysFreeSQN_NR_BCCH_DL_SCH_Message(&p->v.v[i1]);
		}
		serFree(p->v.v);
	}
}

static void _serNrSysFreeNR_SegmentedSI_List_Type_SegmentedSIs_Optional(struct NR_SegmentedSI_List_Type_SegmentedSIs_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i1 = 0; i1 < p->v.d; i1++) {
			if (p->v.v[i1].v) {
				for (size_t i2 = 0; i2 < p->v.v[i1].d; i2++) {
					_serNrSysFreeSQN_NR_BCCH_DL_SCH_Message(&p->v.v[i1].v[i2]);
				}
				serFree(p->v.v[i1].v);
			}
		}
		serFree(p->v.v);
	}
}

static void _serNrSysFreeNR_BcchInfo_Type(struct NR_BcchInfo_Type* p)
{
	_serNrSysFreeSQN_NR_BCCH_DL_SCH_Message_SIB1_Optional(&p->SIB1);
	_serNrSysFreeNR_SI_List_Type_SIs_Optional(&p->SIs);
	_serNrSysFreeNR_SegmentedSI_List_Type_SegmentedSIs_Optional(&p->SegmentedSIs);
}

static void _serNrSysFreeNR_BcchInfo_Type_BcchInfo_Optional(struct NR_BcchInfo_Type_BcchInfo_Optional* p)
{
	if (!p->d) return;
	_serNrSysFreeNR_BcchInfo_Type(&p->v);
}

static void _serNrSysFreeNR_BcchConfig_Type(struct NR_BcchConfig_Type* p)
{
	_serNrSysFreeNR_BcchToPdschConfig_Type_Pdsch_Optional(&p->Pdsch);
	_serNrSysFreeNR_BcchInfo_Type_BcchInfo_Optional(&p->BcchInfo);
}

static void _serNrSysFreeNR_BcchConfig_Type_BcchConfig_Optional(struct NR_BcchConfig_Type_BcchConfig_Optional* p)
{
	if (!p->d) return;
	_serNrSysFreeNR_BcchConfig_Type(&p->v);
}

static void _serNrSysFreeNR_SearchSpaceDlDciAssignment_Type_NR_PcchConfig_Type_SearchSpaceAndDci_Optional(struct NR_SearchSpaceDlDciAssignment_Type_NR_PcchConfig_Type_SearchSpaceAndDci_Optional* p)
{
	if (!p->d) return;
	_serNrSysFreeNR_SearchSpaceDlDciAssignment_Type(&p->v);
}

static void _serNrSysFreeNR_PcchConfig_Type(struct NR_PcchConfig_Type* p)
{
	_serNrSysFreeNR_SearchSpaceDlDciAssignment_Type_NR_PcchConfig_Type_SearchSpaceAndDci_Optional(&p->SearchSpaceAndDci);
}

static void _serNrSysFreeNR_PcchConfig_Type_PcchConfig_Optional(struct NR_PcchConfig_Type_PcchConfig_Optional* p)
{
	if (!p->d) return;
	_serNrSysFreeNR_PcchConfig_Type(&p->v);
}

static void _serNrSysFreeNR_SearchSpaceDlDciAssignment_Type_NR_RandomAccessResponseConfig_Type_SearchSpaceAndDci_Optional(struct NR_SearchSpaceDlDciAssignment_Type_NR_RandomAccessResponseConfig_Type_SearchSpaceAndDci_Optional* p)
{
	if (!p->d) return;
	_serNrSysFreeNR_SearchSpaceDlDciAssignment_Type(&p->v);
}

static void _serNrSysFreeNR_RAR_SubPduList_Type_SubPduList_Optional(struct NR_RAR_SubPduList_Type_SubPduList_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i2 = 0; i2 < p->v.d; i2++) {
		}
		serFree(p->v.v);
	}
}

static void _serNrSysFreeNR_RAR_MacPdu_Type(struct NR_RAR_MacPdu_Type* p)
{
	_serNrSysFreeNR_RAR_SubPduList_Type_SubPduList_Optional(&p->SubPduList);
}

static void _serNrSysFreeNR_RAR_MacPdu_Type_MacPdu_Optional(struct NR_RAR_MacPdu_Type_MacPdu_Optional* p)
{
	if (!p->d) return;
	_serNrSysFreeNR_RAR_MacPdu_Type(&p->v);
}

static void _serNrSysFreeNR_RandomAccessResponseConfig_Type(struct NR_RandomAccessResponseConfig_Type* p)
{
	_serNrSysFreeNR_SearchSpaceDlDciAssignment_Type_NR_RandomAccessResponseConfig_Type_SearchSpaceAndDci_Optional(&p->SearchSpaceAndDci);
	_serNrSysFreeNR_RAR_MacPdu_Type_MacPdu_Optional(&p->MacPdu);
}

static void _serNrSysFreeNR_RandomAccessResponseConfig_Type_RandomAccessResponse_Optional(struct NR_RandomAccessResponseConfig_Type_RandomAccessResponse_Optional* p)
{
	if (!p->d) return;
	_serNrSysFreeNR_RandomAccessResponseConfig_Type(&p->v);
}

static void _serNrSysFreeNR_AssignedBWPs_Type_NR_SearchSpaceUlDciAssignment_Type_AssignedBWPs_Optional(struct NR_AssignedBWPs_Type_NR_SearchSpaceUlDciAssignment_Type_AssignedBWPs_Optional* p)
{
	if (!p->d) return;
	_serNrSysFreeNR_AssignedBWPs_Type(&p->v);
}

static void _serNrSysFreeNR_DciCommon_TimeDomainResourceAssignment_Type_NR_DciFormat_0_X_ResourceAssignment_Type_TimeDomain_Optional(struct NR_DciCommon_TimeDomainResourceAssignment_Type_NR_DciFormat_0_X_ResourceAssignment_Type_TimeDomain_Optional* p)
{
	if (!p->d) return;
	_serNrSysFreeNR_DciCommon_TimeDomainResourceAssignment_Type(&p->v);
}

static void _serNrSysFreeNR_TransportBlockRetransmissionList_Type_TransportBlockScheduling_Optional(struct NR_TransportBlockRetransmissionList_Type_TransportBlockScheduling_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i2 = 0; i2 < p->v.d; i2++) {
		}
		serFree(p->v.v);
	}
}

static void _serNrSysFreeNR_HarqProcessConfig_Type_NR_DciFormat_0_X_ResourceAssignment_Type_HarqProcessConfig_Optional(struct NR_HarqProcessConfig_Type_NR_DciFormat_0_X_ResourceAssignment_Type_HarqProcessConfig_Optional* p)
{
	if (!p->d) return;
	_serNrSysFreeNR_HarqProcessConfig_Type(&p->v);
}

static void _serNrSysFreeNR_DciFormat_0_X_ResourceAssignment_Type(struct NR_DciFormat_0_X_ResourceAssignment_Type* p)
{
	_serNrSysFreeNR_DciCommon_TimeDomainResourceAssignment_Type_NR_DciFormat_0_X_ResourceAssignment_Type_TimeDomain_Optional(&p->TimeDomain);
	_serNrSysFreeNR_TransportBlockRetransmissionList_Type_TransportBlockScheduling_Optional(&p->TransportBlockScheduling);
	_serNrSysFreeNR_HarqProcessConfig_Type_NR_DciFormat_0_X_ResourceAssignment_Type_HarqProcessConfig_Optional(&p->HarqProcessConfig);
}

static void _serNrSysFreeNR_DciFormat_0_X_ResourceAssignment_Type_ResoureAssignment_Optional(struct NR_DciFormat_0_X_ResourceAssignment_Type_ResoureAssignment_Optional* p)
{
	if (!p->d) return;
	_serNrSysFreeNR_DciFormat_0_X_ResourceAssignment_Type(&p->v);
}

static void _serNrSysFreeNR_DciCommon_BWPIndicator_Type_NR_DciFormat_0_1_SpecificInfo_Type_BWPIndicator_Optional(struct NR_DciCommon_BWPIndicator_Type_NR_DciFormat_0_1_SpecificInfo_Type_BWPIndicator_Optional* p)
{
	if (!p->d) return;
	_serNrSysFreeNR_DciCommon_BWPIndicator_Type(&p->v);
}

static void _serNrSysFreeNR_DciFormat_0_1_SrsResourceIndicator_Type_Value(union NR_DciFormat_0_1_SrsResourceIndicator_Type_Value* p, enum NR_DciFormat_0_1_SrsResourceIndicator_Type_Sel d)
{
	if (d == NR_DciFormat_0_1_SrsResourceIndicator_Type_NonCodeBook) {
		if (p->NonCodeBook.v) {
			serFree(p->NonCodeBook.v);
		}
		return;
	}
	if (d == NR_DciFormat_0_1_SrsResourceIndicator_Type_CodeBook) {
		if (p->CodeBook.v) {
			serFree(p->CodeBook.v);
		}
		return;
	}
}

static void _serNrSysFreeNR_DciFormat_0_1_SrsResourceIndicator_Type(struct NR_DciFormat_0_1_SrsResourceIndicator_Type* p)
{
	_serNrSysFreeNR_DciFormat_0_1_SrsResourceIndicator_Type_Value(&p->v, p->d);
}

static void _serNrSysFreeNR_DciFormat_0_1_SrsResourceIndicator_Type_SrsResourceIndicator_Optional(struct NR_DciFormat_0_1_SrsResourceIndicator_Type_SrsResourceIndicator_Optional* p)
{
	if (!p->d) return;
	_serNrSysFreeNR_DciFormat_0_1_SrsResourceIndicator_Type(&p->v);
}

static void _serNrSysFreeNR_DciFormat_0_1_PrecodingInfo_Type_Value(union NR_DciFormat_0_1_PrecodingInfo_Type_Value* p, enum NR_DciFormat_0_1_PrecodingInfo_Type_Sel d)
{
	if (d == NR_DciFormat_0_1_PrecodingInfo_Type_CodeBook) {
		if (p->CodeBook.v) {
			serFree(p->CodeBook.v);
		}
		return;
	}
}

static void _serNrSysFreeNR_DciFormat_0_1_PrecodingInfo_Type(struct NR_DciFormat_0_1_PrecodingInfo_Type* p)
{
	_serNrSysFreeNR_DciFormat_0_1_PrecodingInfo_Type_Value(&p->v, p->d);
}

static void _serNrSysFreeNR_DciFormat_0_1_PrecodingInfo_Type_PrecodingInfo_Optional(struct NR_DciFormat_0_1_PrecodingInfo_Type_PrecodingInfo_Optional* p)
{
	if (!p->d) return;
	_serNrSysFreeNR_DciFormat_0_1_PrecodingInfo_Type(&p->v);
}

static void _serNrSysFreeNR_DciFormat_0_1_AntennaPorts_Type_Value(union NR_DciFormat_0_1_AntennaPorts_Type_Value* p, enum NR_DciFormat_0_1_AntennaPorts_Type_Sel d)
{
	if (d == NR_DciFormat_0_1_AntennaPorts_Type_Index) {
		if (p->Index.v) {
			serFree(p->Index.v);
		}
		return;
	}
}

static void _serNrSysFreeNR_DciFormat_0_1_AntennaPorts_Type(struct NR_DciFormat_0_1_AntennaPorts_Type* p)
{
	_serNrSysFreeNR_DciFormat_0_1_AntennaPorts_Type_Value(&p->v, p->d);
}

static void _serNrSysFreeNR_DciFormat_0_1_AntennaPorts_Type_AntennaPorts_Optional(struct NR_DciFormat_0_1_AntennaPorts_Type_AntennaPorts_Optional* p)
{
	if (!p->d) return;
	_serNrSysFreeNR_DciFormat_0_1_AntennaPorts_Type(&p->v);
}

static void _serNrSysFreeNR_DciFormat_0_1_CsiRequest_Type_Value(union NR_DciFormat_0_1_CsiRequest_Type_Value* p, enum NR_DciFormat_0_1_CsiRequest_Type_Sel d)
{
	if (d == NR_DciFormat_0_1_CsiRequest_Type_Index) {
		if (p->Index.v) {
			serFree(p->Index.v);
		}
		return;
	}
}

static void _serNrSysFreeNR_DciFormat_0_1_CsiRequest_Type(struct NR_DciFormat_0_1_CsiRequest_Type* p)
{
	_serNrSysFreeNR_DciFormat_0_1_CsiRequest_Type_Value(&p->v, p->d);
}

static void _serNrSysFreeNR_DciFormat_0_1_CsiRequest_Type_CsiRequest_Optional(struct NR_DciFormat_0_1_CsiRequest_Type_CsiRequest_Optional* p)
{
	if (!p->d) return;
	_serNrSysFreeNR_DciFormat_0_1_CsiRequest_Type(&p->v);
}

static void _serNrSysFreeNR_DciFormat_0_1_CBGTI_Type_Value(union NR_DciFormat_0_1_CBGTI_Type_Value* p, enum NR_DciFormat_0_1_CBGTI_Type_Sel d)
{
	if (d == NR_DciFormat_0_1_CBGTI_Type_Index) {
		if (p->Index.v) {
			serFree(p->Index.v);
		}
		return;
	}
}

static void _serNrSysFreeNR_DciFormat_0_1_CBGTI_Type(struct NR_DciFormat_0_1_CBGTI_Type* p)
{
	_serNrSysFreeNR_DciFormat_0_1_CBGTI_Type_Value(&p->v, p->d);
}

static void _serNrSysFreeNR_DciFormat_0_1_CBGTI_Type_CBGTI_Optional(struct NR_DciFormat_0_1_CBGTI_Type_CBGTI_Optional* p)
{
	if (!p->d) return;
	_serNrSysFreeNR_DciFormat_0_1_CBGTI_Type(&p->v);
}

static void _serNrSysFreeNR_DciFormat_0_1_ChannelAccessCPextCAPC_Type_Value(union NR_DciFormat_0_1_ChannelAccessCPextCAPC_Type_Value* p, enum NR_DciFormat_0_1_ChannelAccessCPextCAPC_Type_Sel d)
{
	if (d == NR_DciFormat_0_1_ChannelAccessCPextCAPC_Type_Value) {
		if (p->Value.v) {
			serFree(p->Value.v);
		}
		return;
	}
}

static void _serNrSysFreeNR_DciFormat_0_1_ChannelAccessCPextCAPC_Type(struct NR_DciFormat_0_1_ChannelAccessCPextCAPC_Type* p)
{
	_serNrSysFreeNR_DciFormat_0_1_ChannelAccessCPextCAPC_Type_Value(&p->v, p->d);
}

static void _serNrSysFreeNR_DciFormat_0_1_ChannelAccessCPextCAPC_Type_ChannelAccessCPextCAPC_Optional(struct NR_DciFormat_0_1_ChannelAccessCPextCAPC_Type_ChannelAccessCPextCAPC_Optional* p)
{
	if (!p->d) return;
	_serNrSysFreeNR_DciFormat_0_1_ChannelAccessCPextCAPC_Type(&p->v);
}

static void _serNrSysFreeNR_DciFormat_0_1_OpenLoopPowerControl_Type_Value(union NR_DciFormat_0_1_OpenLoopPowerControl_Type_Value* p, enum NR_DciFormat_0_1_OpenLoopPowerControl_Type_Sel d)
{
	if (d == NR_DciFormat_0_1_OpenLoopPowerControl_Type_Value) {
		if (p->Value.v) {
			serFree(p->Value.v);
		}
		return;
	}
}

static void _serNrSysFreeNR_DciFormat_0_1_OpenLoopPowerControl_Type(struct NR_DciFormat_0_1_OpenLoopPowerControl_Type* p)
{
	_serNrSysFreeNR_DciFormat_0_1_OpenLoopPowerControl_Type_Value(&p->v, p->d);
}

static void _serNrSysFreeNR_DciFormat_0_1_OpenLoopPowerControl_Type_OpenLoopPowerControl_Optional(struct NR_DciFormat_0_1_OpenLoopPowerControl_Type_OpenLoopPowerControl_Optional* p)
{
	if (!p->d) return;
	_serNrSysFreeNR_DciFormat_0_1_OpenLoopPowerControl_Type(&p->v);
}

static void _serNrSysFreeNR_DciFormat_X_1_SCellDormancyIndication_Type_NR_DciFormat_0_1_SpecificInfo_Type_SCellDormancyIndication_Optional(struct NR_DciFormat_X_1_SCellDormancyIndication_Type_NR_DciFormat_0_1_SpecificInfo_Type_SCellDormancyIndication_Optional* p)
{
	if (!p->d) return;
	_serNrSysFreeNR_DciFormat_X_1_SCellDormancyIndication_Type(&p->v);
}

static void _serNrSysFreeNR_DciFormat_0_1_SidelinkAssignmentIndex_Type_Value(union NR_DciFormat_0_1_SidelinkAssignmentIndex_Type_Value* p, enum NR_DciFormat_0_1_SidelinkAssignmentIndex_Type_Sel d)
{
	if (d == NR_DciFormat_0_1_SidelinkAssignmentIndex_Type_Value) {
		if (p->Value.v) {
			serFree(p->Value.v);
		}
		return;
	}
}

static void _serNrSysFreeNR_DciFormat_0_1_SidelinkAssignmentIndex_Type(struct NR_DciFormat_0_1_SidelinkAssignmentIndex_Type* p)
{
	_serNrSysFreeNR_DciFormat_0_1_SidelinkAssignmentIndex_Type_Value(&p->v, p->d);
}

static void _serNrSysFreeNR_DciFormat_0_1_SidelinkAssignmentIndex_Type_SidelinkAssignmentIndex_Optional(struct NR_DciFormat_0_1_SidelinkAssignmentIndex_Type_SidelinkAssignmentIndex_Optional* p)
{
	if (!p->d) return;
	_serNrSysFreeNR_DciFormat_0_1_SidelinkAssignmentIndex_Type(&p->v);
}

static void _serNrSysFreeNR_DciFormat_0_1_SpecificInfo_Type(struct NR_DciFormat_0_1_SpecificInfo_Type* p)
{
	_serNrSysFreeNR_DciCommon_BWPIndicator_Type_NR_DciFormat_0_1_SpecificInfo_Type_BWPIndicator_Optional(&p->BWPIndicator);
	_serNrSysFreeNR_DciFormat_0_1_SrsResourceIndicator_Type_SrsResourceIndicator_Optional(&p->SrsResourceIndicator);
	_serNrSysFreeNR_DciFormat_0_1_PrecodingInfo_Type_PrecodingInfo_Optional(&p->PrecodingInfo);
	_serNrSysFreeNR_DciFormat_0_1_AntennaPorts_Type_AntennaPorts_Optional(&p->AntennaPorts);
	_serNrSysFreeNR_DciFormat_0_1_CsiRequest_Type_CsiRequest_Optional(&p->CsiRequest);
	_serNrSysFreeNR_DciFormat_0_1_CBGTI_Type_CBGTI_Optional(&p->CBGTI);
	_serNrSysFreeNR_DciFormat_0_1_ChannelAccessCPextCAPC_Type_ChannelAccessCPextCAPC_Optional(&p->ChannelAccessCPextCAPC);
	_serNrSysFreeNR_DciFormat_0_1_OpenLoopPowerControl_Type_OpenLoopPowerControl_Optional(&p->OpenLoopPowerControl);
	_serNrSysFreeNR_DciFormat_X_1_SCellDormancyIndication_Type_NR_DciFormat_0_1_SpecificInfo_Type_SCellDormancyIndication_Optional(&p->SCellDormancyIndication);
	_serNrSysFreeNR_DciFormat_0_1_SidelinkAssignmentIndex_Type_SidelinkAssignmentIndex_Optional(&p->SidelinkAssignmentIndex);
}

static void _serNrSysFreeNR_DciFormat_0_X_SpecificInfo_Type_Value(union NR_DciFormat_0_X_SpecificInfo_Type_Value* p, enum NR_DciFormat_0_X_SpecificInfo_Type_Sel d)
{
	if (d == NR_DciFormat_0_X_SpecificInfo_Type_Format_0_1) {
		_serNrSysFreeNR_DciFormat_0_1_SpecificInfo_Type(&p->Format_0_1);
		return;
	}
}

static void _serNrSysFreeNR_DciFormat_0_X_SpecificInfo_Type(struct NR_DciFormat_0_X_SpecificInfo_Type* p)
{
	_serNrSysFreeNR_DciFormat_0_X_SpecificInfo_Type_Value(&p->v, p->d);
}

static void _serNrSysFreeNR_DciFormat_0_X_SpecificInfo_Type_Format_Optional(struct NR_DciFormat_0_X_SpecificInfo_Type_Format_Optional* p)
{
	if (!p->d) return;
	_serNrSysFreeNR_DciFormat_0_X_SpecificInfo_Type(&p->v);
}

static void _serNrSysFreeNR_DciUlInfo_Type(struct NR_DciUlInfo_Type* p)
{
	_serNrSysFreeNR_DciFormat_0_X_ResourceAssignment_Type_ResoureAssignment_Optional(&p->ResoureAssignment);
	_serNrSysFreeNR_DciFormat_0_X_SpecificInfo_Type_Format_Optional(&p->Format);
}

static void _serNrSysFreeNR_DciUlInfo_Type_DciInfo_Optional(struct NR_DciUlInfo_Type_DciInfo_Optional* p)
{
	if (!p->d) return;
	_serNrSysFreeNR_DciUlInfo_Type(&p->v);
}

static void _serNrSysFreeNR_SearchSpaceUlDciAssignment_Type(struct NR_SearchSpaceUlDciAssignment_Type* p)
{
	_serNrSysFreeNR_AssignedBWPs_Type_NR_SearchSpaceUlDciAssignment_Type_AssignedBWPs_Optional(&p->AssignedBWPs);
	_serNrSysFreeNR_DciUlInfo_Type_DciInfo_Optional(&p->DciInfo);
}

static void _serNrSysFreeNR_SearchSpaceDlDciAssignment_Type_NR_RachProcedureMsg4_Type_SearchSpaceAndDci_Optional(struct NR_SearchSpaceDlDciAssignment_Type_NR_RachProcedureMsg4_Type_SearchSpaceAndDci_Optional* p)
{
	if (!p->d) return;
	_serNrSysFreeNR_SearchSpaceDlDciAssignment_Type(&p->v);
}

static void _serNrSysFreeNR_RachProcedureMsg4RrcMsg_Type_Value(union NR_RachProcedureMsg4RrcMsg_Type_Value* p, enum NR_RachProcedureMsg4RrcMsg_Type_Sel d)
{
	if (d == NR_RachProcedureMsg4RrcMsg_Type_RrcCcchMsg) {
		if (p->RrcCcchMsg.v) {
			serFree(p->RrcCcchMsg.v);
		}
		return;
	}
	if (d == NR_RachProcedureMsg4RrcMsg_Type_RrcDcchMsg) {
		if (p->RrcDcchMsg.v) {
			serFree(p->RrcDcchMsg.v);
		}
		return;
	}
}

static void _serNrSysFreeNR_RachProcedureMsg4RrcMsg_Type(struct NR_RachProcedureMsg4RrcMsg_Type* p)
{
	_serNrSysFreeNR_RachProcedureMsg4RrcMsg_Type_Value(&p->v, p->d);
}

static void _serNrSysFreeNR_RachProcedureMsg4RrcMsg_Type_RrcPdu_Optional(struct NR_RachProcedureMsg4RrcMsg_Type_RrcPdu_Optional* p)
{
	if (!p->d) return;
	_serNrSysFreeNR_RachProcedureMsg4RrcMsg_Type(&p->v);
}

static void _serNrSysFreeNR_RachProcedureMsg4_Type(struct NR_RachProcedureMsg4_Type* p)
{
	_serNrSysFreeNR_SearchSpaceDlDciAssignment_Type_NR_RachProcedureMsg4_Type_SearchSpaceAndDci_Optional(&p->SearchSpaceAndDci);
	_serNrSysFreeNR_RachProcedureMsg4RrcMsg_Type_RrcPdu_Optional(&p->RrcPdu);
}

static void _serNrSysFreeNR_ContentionResolutionCtrl_Type_Value(union NR_ContentionResolutionCtrl_Type_Value* p, enum NR_ContentionResolutionCtrl_Type_Sel d)
{
	if (d == NR_ContentionResolutionCtrl_Type_CRNTI_Based) {
		_serNrSysFreeNR_SearchSpaceUlDciAssignment_Type(&p->CRNTI_Based);
		return;
	}
	if (d == NR_ContentionResolutionCtrl_Type_Msg4_Based) {
		_serNrSysFreeNR_RachProcedureMsg4_Type(&p->Msg4_Based);
		return;
	}
}

static void _serNrSysFreeNR_ContentionResolutionCtrl_Type(struct NR_ContentionResolutionCtrl_Type* p)
{
	_serNrSysFreeNR_ContentionResolutionCtrl_Type_Value(&p->v, p->d);
}

static void _serNrSysFreeNR_ContentionResolutionCtrl_Type_ContentionResolution_Optional(struct NR_ContentionResolutionCtrl_Type_ContentionResolution_Optional* p)
{
	if (!p->d) return;
	_serNrSysFreeNR_ContentionResolutionCtrl_Type(&p->v);
}

static void _serNrSysFreeNR_RachProcedure_Type(struct NR_RachProcedure_Type* p)
{
	_serNrSysFreeNR_RandomAccessResponseConfig_Type_RandomAccessResponse_Optional(&p->RandomAccessResponse);
	_serNrSysFreeNR_ContentionResolutionCtrl_Type_ContentionResolution_Optional(&p->ContentionResolution);
}

static void _serNrSysFreeNR_RachProcedureList_Type_RachProcedureList_Optional(struct NR_RachProcedureList_Type_RachProcedureList_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i1 = 0; i1 < p->v.d; i1++) {
			_serNrSysFreeNR_RachProcedure_Type(&p->v.v[i1]);
		}
		serFree(p->v.v);
	}
}

static void _serNrSysFreeNR_RachProcedureConfig_Type(struct NR_RachProcedureConfig_Type* p)
{
	_serNrSysFreeNR_RachProcedureList_Type_RachProcedureList_Optional(&p->RachProcedureList);
}

static void _serNrSysFreeNR_RachProcedureConfig_Type_RachProcedureConfig_Optional(struct NR_RachProcedureConfig_Type_RachProcedureConfig_Optional* p)
{
	if (!p->d) return;
	_serNrSysFreeNR_RachProcedureConfig_Type(&p->v);
}

static void _serNrSysFreeNR_SearchSpaceDlDciAssignment_Type_NR_DcchDtchConfigDL_Type_SearchSpaceAndDci_Optional(struct NR_SearchSpaceDlDciAssignment_Type_NR_DcchDtchConfigDL_Type_SearchSpaceAndDci_Optional* p)
{
	if (!p->d) return;
	_serNrSysFreeNR_SearchSpaceDlDciAssignment_Type(&p->v);
}

static void _serNrSysFreeNR_DcchDtchConfigDL_Type(struct NR_DcchDtchConfigDL_Type* p)
{
	_serNrSysFreeNR_SearchSpaceDlDciAssignment_Type_NR_DcchDtchConfigDL_Type_SearchSpaceAndDci_Optional(&p->SearchSpaceAndDci);
}

static void _serNrSysFreeNR_DcchDtchConfigDL_Type_DL_Optional(struct NR_DcchDtchConfigDL_Type_DL_Optional* p)
{
	if (!p->d) return;
	_serNrSysFreeNR_DcchDtchConfigDL_Type(&p->v);
}

static void _serNrSysFreeNR_SearchSpaceUlDciAssignment_Type_SearchSpaceAndDci_Optional(struct NR_SearchSpaceUlDciAssignment_Type_SearchSpaceAndDci_Optional* p)
{
	if (!p->d) return;
	_serNrSysFreeNR_SearchSpaceUlDciAssignment_Type(&p->v);
}

static void _serNrSysFreeNR_DcchDtchConfigUL_Type(struct NR_DcchDtchConfigUL_Type* p)
{
	_serNrSysFreeNR_SearchSpaceUlDciAssignment_Type_SearchSpaceAndDci_Optional(&p->SearchSpaceAndDci);
}

static void _serNrSysFreeNR_DcchDtchConfigUL_Type_UL_Optional(struct NR_DcchDtchConfigUL_Type_UL_Optional* p)
{
	if (!p->d) return;
	_serNrSysFreeNR_DcchDtchConfigUL_Type(&p->v);
}

static void _serNrSysFreeNR_DcchDtchConfig_Type(struct NR_DcchDtchConfig_Type* p)
{
	_serNrSysFreeNR_DcchDtchConfigDL_Type_DL_Optional(&p->DL);
	_serNrSysFreeNR_DcchDtchConfigUL_Type_UL_Optional(&p->UL);
}

static void _serNrSysFreeNR_DcchDtchConfig_Type_DcchDtchConfig_Optional(struct NR_DcchDtchConfig_Type_DcchDtchConfig_Optional* p)
{
	if (!p->d) return;
	_serNrSysFreeNR_DcchDtchConfig_Type(&p->v);
}

static void _serNrSysFreeNR_CellIdList_Type_SCellList_Optional(struct NR_CellIdList_Type_SCellList_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		serFree(p->v.v);
	}
}

static void _serNrSysFreeSQN_NR_SchedulingRequestToAddMod_SQN_NR_SchedulingRequestConfig_schedulingRequestToAddModList_DynamicOptional(struct SQN_NR_SchedulingRequestToAddMod_SQN_NR_SchedulingRequestConfig_schedulingRequestToAddModList_DynamicOptional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i1 = 0; i1 < p->v.d; i1++) {
		}
		serFree(p->v.v);
	}
}

static void _serNrSysFreeSQN_NR_SchedulingRequestId_SQN_NR_SchedulingRequestConfig_schedulingRequestToReleaseList_DynamicOptional(struct SQN_NR_SchedulingRequestId_SQN_NR_SchedulingRequestConfig_schedulingRequestToReleaseList_DynamicOptional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		serFree(p->v.v);
	}
}

static void _serNrSysFreeSQN_NR_SchedulingRequestConfig(struct SQN_NR_SchedulingRequestConfig* p)
{
	_serNrSysFreeSQN_NR_SchedulingRequestToAddMod_SQN_NR_SchedulingRequestConfig_schedulingRequestToAddModList_DynamicOptional(&p->schedulingRequestToAddModList);
	_serNrSysFreeSQN_NR_SchedulingRequestId_SQN_NR_SchedulingRequestConfig_schedulingRequestToReleaseList_DynamicOptional(&p->schedulingRequestToReleaseList);
}

static void _serNrSysFreeSQN_NR_SchedulingRequestConfig_SQN_NR_MAC_CellGroupConfig_schedulingRequestConfig_Optional(struct SQN_NR_SchedulingRequestConfig_SQN_NR_MAC_CellGroupConfig_schedulingRequestConfig_Optional* p)
{
	if (!p->d) return;
	_serNrSysFreeSQN_NR_SchedulingRequestConfig(&p->v);
}

static void _serNrSysFreeSQN_NR_TAG_Id_SQN_NR_TAG_Config_tag_ToReleaseList_DynamicOptional(struct SQN_NR_TAG_Id_SQN_NR_TAG_Config_tag_ToReleaseList_DynamicOptional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		serFree(p->v.v);
	}
}

static void _serNrSysFreeSQN_NR_TAG_SQN_NR_TAG_Config_tag_ToAddModList_DynamicOptional(struct SQN_NR_TAG_SQN_NR_TAG_Config_tag_ToAddModList_DynamicOptional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i1 = 0; i1 < p->v.d; i1++) {
		}
		serFree(p->v.v);
	}
}

static void _serNrSysFreeSQN_NR_TAG_Config(struct SQN_NR_TAG_Config* p)
{
	_serNrSysFreeSQN_NR_TAG_Id_SQN_NR_TAG_Config_tag_ToReleaseList_DynamicOptional(&p->tag_ToReleaseList);
	_serNrSysFreeSQN_NR_TAG_SQN_NR_TAG_Config_tag_ToAddModList_DynamicOptional(&p->tag_ToAddModList);
}

static void _serNrSysFreeSQN_NR_TAG_Config_SQN_NR_MAC_CellGroupConfig_tag_Config_Optional(struct SQN_NR_TAG_Config_SQN_NR_MAC_CellGroupConfig_tag_Config_Optional* p)
{
	if (!p->d) return;
	_serNrSysFreeSQN_NR_TAG_Config(&p->v);
}

static void _serNrSysFreeSQN_NR_MAC_CellGroupConfig(struct SQN_NR_MAC_CellGroupConfig* p)
{
	_serNrSysFreeSQN_NR_SchedulingRequestConfig_SQN_NR_MAC_CellGroupConfig_schedulingRequestConfig_Optional(&p->schedulingRequestConfig);
	_serNrSysFreeSQN_NR_TAG_Config_SQN_NR_MAC_CellGroupConfig_tag_Config_Optional(&p->tag_Config);
}

static void _serNrSysFreeNR_ASN1_MAC_CellGroupConfig_Type_Value(union NR_ASN1_MAC_CellGroupConfig_Type_Value* p, enum NR_ASN1_MAC_CellGroupConfig_Type_Sel d)
{
	if (d == NR_ASN1_MAC_CellGroupConfig_Type_R15) {
		_serNrSysFreeSQN_NR_MAC_CellGroupConfig(&p->R15);
		return;
	}
}

static void _serNrSysFreeNR_ASN1_MAC_CellGroupConfig_Type(struct NR_ASN1_MAC_CellGroupConfig_Type* p)
{
	_serNrSysFreeNR_ASN1_MAC_CellGroupConfig_Type_Value(&p->v, p->d);
}

static void _serNrSysFreeNR_ASN1_MAC_CellGroupConfig_Type_MAC_CellGroupConfig_Optional(struct NR_ASN1_MAC_CellGroupConfig_Type_MAC_CellGroupConfig_Optional* p)
{
	if (!p->d) return;
	_serNrSysFreeNR_ASN1_MAC_CellGroupConfig_Type(&p->v);
}

static void _serNrSysFreeSQN_NR_SetupRelease_PhysicalCellGroupConfig_pdsch_HARQ_ACK_CodebookList_r16_Value(union SQN_NR_SetupRelease_PhysicalCellGroupConfig_pdsch_HARQ_ACK_CodebookList_r16_Value* p, enum SQN_NR_SetupRelease_PhysicalCellGroupConfig_pdsch_HARQ_ACK_CodebookList_r16_Sel d)
{
	if (d == SQN_NR_SetupRelease_PhysicalCellGroupConfig_pdsch_HARQ_ACK_CodebookList_r16_setup) {
		if (p->setup.v) {
			serFree(p->setup.v);
		}
		return;
	}
}

static void _serNrSysFreeSQN_NR_SetupRelease_PhysicalCellGroupConfig_pdsch_HARQ_ACK_CodebookList_r16(struct SQN_NR_SetupRelease_PhysicalCellGroupConfig_pdsch_HARQ_ACK_CodebookList_r16* p)
{
	_serNrSysFreeSQN_NR_SetupRelease_PhysicalCellGroupConfig_pdsch_HARQ_ACK_CodebookList_r16_Value(&p->v, p->d);
}

static void _serNrSysFreeSQN_NR_SetupRelease_PhysicalCellGroupConfig_pdsch_HARQ_ACK_CodebookList_r16_SQN_NR_PhysicalCellGroupConfig_pdsch_HARQ_ACK_CodebookList_r16_Optional(struct SQN_NR_SetupRelease_PhysicalCellGroupConfig_pdsch_HARQ_ACK_CodebookList_r16_SQN_NR_PhysicalCellGroupConfig_pdsch_HARQ_ACK_CodebookList_r16_Optional* p)
{
	if (!p->d) return;
	_serNrSysFreeSQN_NR_SetupRelease_PhysicalCellGroupConfig_pdsch_HARQ_ACK_CodebookList_r16(&p->v);
}

static void _serNrSysFreeSQN_NR_PhysicalCellGroupConfig(struct SQN_NR_PhysicalCellGroupConfig* p)
{
	_serNrSysFreeSQN_NR_SetupRelease_PhysicalCellGroupConfig_pdsch_HARQ_ACK_CodebookList_r16_SQN_NR_PhysicalCellGroupConfig_pdsch_HARQ_ACK_CodebookList_r16_Optional(&p->pdsch_HARQ_ACK_CodebookList_r16);
}

static void _serNrSysFreeNR_ASN1_PhysicalCellGroupConfig_Type_Value(union NR_ASN1_PhysicalCellGroupConfig_Type_Value* p, enum NR_ASN1_PhysicalCellGroupConfig_Type_Sel d)
{
	if (d == NR_ASN1_PhysicalCellGroupConfig_Type_R15) {
		_serNrSysFreeSQN_NR_PhysicalCellGroupConfig(&p->R15);
		return;
	}
}

static void _serNrSysFreeNR_ASN1_PhysicalCellGroupConfig_Type(struct NR_ASN1_PhysicalCellGroupConfig_Type* p)
{
	_serNrSysFreeNR_ASN1_PhysicalCellGroupConfig_Type_Value(&p->v, p->d);
}

static void _serNrSysFreeNR_ASN1_PhysicalCellGroupConfig_Type_PhysicalCellGroupConfig_Optional(struct NR_ASN1_PhysicalCellGroupConfig_Type_PhysicalCellGroupConfig_Optional* p)
{
	if (!p->d) return;
	_serNrSysFreeNR_ASN1_PhysicalCellGroupConfig_Type(&p->v);
}

static void _serNrSysFreeNR_SpCell_CellGroupConfig_Type(struct NR_SpCell_CellGroupConfig_Type* p)
{
	_serNrSysFreeNR_CellIdList_Type_SCellList_Optional(&p->SCellList);
	_serNrSysFreeNR_ASN1_MAC_CellGroupConfig_Type_MAC_CellGroupConfig_Optional(&p->MAC_CellGroupConfig);
	_serNrSysFreeNR_ASN1_PhysicalCellGroupConfig_Type_PhysicalCellGroupConfig_Optional(&p->PhysicalCellGroupConfig);
}

static void _serNrSysFreeNR_SpCell_CellGroupConfig_Type_CellGroupConfig_Optional(struct NR_SpCell_CellGroupConfig_Type_CellGroupConfig_Optional* p)
{
	if (!p->d) return;
	_serNrSysFreeNR_SpCell_CellGroupConfig_Type(&p->v);
}

static void _serNrSysFreeNR_SpCellConfig_Type(struct NR_SpCellConfig_Type* p)
{
	_serNrSysFreeNR_SpCell_CellGroupConfig_Type_CellGroupConfig_Optional(&p->CellGroupConfig);
}

static void _serNrSysFreeNR_ServingCellConfig_Type_Value(union NR_ServingCellConfig_Type_Value* p, enum NR_ServingCellConfig_Type_Sel d)
{
	if (d == NR_ServingCellConfig_Type_SpCell) {
		_serNrSysFreeNR_SpCellConfig_Type(&p->SpCell);
		return;
	}
}

static void _serNrSysFreeNR_ServingCellConfig_Type(struct NR_ServingCellConfig_Type* p)
{
	_serNrSysFreeNR_ServingCellConfig_Type_Value(&p->v, p->d);
}

static void _serNrSysFreeNR_ServingCellConfig_Type_ServingCellConfig_Optional(struct NR_ServingCellConfig_Type_ServingCellConfig_Optional* p)
{
	if (!p->d) return;
	_serNrSysFreeNR_ServingCellConfig_Type(&p->v);
}

static void _serNrSysFreeNR_CellConfigInfo_Type(struct NR_CellConfigInfo_Type* p)
{
	_serNrSysFreeNR_CellConfigPhysicalLayer_Type_PhysicalLayer_Optional(&p->PhysicalLayer);
	_serNrSysFreeNR_BcchConfig_Type_BcchConfig_Optional(&p->BcchConfig);
	_serNrSysFreeNR_PcchConfig_Type_PcchConfig_Optional(&p->PcchConfig);
	_serNrSysFreeNR_RachProcedureConfig_Type_RachProcedureConfig_Optional(&p->RachProcedureConfig);
	_serNrSysFreeNR_DcchDtchConfig_Type_DcchDtchConfig_Optional(&p->DcchDtchConfig);
	_serNrSysFreeNR_ServingCellConfig_Type_ServingCellConfig_Optional(&p->ServingCellConfig);
}

static void _serNrSysFreeNR_CellConfigRequest_Type_Value(union NR_CellConfigRequest_Type_Value* p, enum NR_CellConfigRequest_Type_Sel d)
{
	if (d == NR_CellConfigRequest_Type_AddOrReconfigure) {
		_serNrSysFreeNR_CellConfigInfo_Type(&p->AddOrReconfigure);
		return;
	}
}

static void _serNrSysFreeNR_CellConfigRequest_Type(struct NR_CellConfigRequest_Type* p)
{
	_serNrSysFreeNR_CellConfigRequest_Type_Value(&p->v, p->d);
}

static void _serNrSysFreeQFI_List_Type_MappedQoS_Flows_Optional(struct QFI_List_Type_MappedQoS_Flows_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		serFree(p->v.v);
	}
}

static void _serNrSysFreeSdapConfig_Type(struct SdapConfig_Type* p)
{
	_serNrSysFreeQFI_List_Type_MappedQoS_Flows_Optional(&p->MappedQoS_Flows);
}

static void _serNrSysFreeSdapConfigInfo_Type_Value(union SdapConfigInfo_Type_Value* p, enum SdapConfigInfo_Type_Sel d)
{
	if (d == SdapConfigInfo_Type_SdapConfig) {
		_serNrSysFreeSdapConfig_Type(&p->SdapConfig);
		return;
	}
}

static void _serNrSysFreeSdapConfigInfo_Type(struct SdapConfigInfo_Type* p)
{
	_serNrSysFreeSdapConfigInfo_Type_Value(&p->v, p->d);
}

static void _serNrSysFreeSDAP_Configuration_Type_Value(union SDAP_Configuration_Type_Value* p, enum SDAP_Configuration_Type_Sel d)
{
	if (d == SDAP_Configuration_Type_Config) {
		_serNrSysFreeSdapConfigInfo_Type(&p->Config);
		return;
	}
}

static void _serNrSysFreeSDAP_Configuration_Type(struct SDAP_Configuration_Type* p)
{
	_serNrSysFreeSDAP_Configuration_Type_Value(&p->v, p->d);
}

static void _serNrSysFreeSDAP_Configuration_Type_Sdap_Optional(struct SDAP_Configuration_Type_Sdap_Optional* p)
{
	if (!p->d) return;
	_serNrSysFreeSDAP_Configuration_Type(&p->v);
}

static void _serNrSysFreeNR_RadioBearerConfigInfo_Type(struct NR_RadioBearerConfigInfo_Type* p)
{
	_serNrSysFreeSDAP_Configuration_Type_Sdap_Optional(&p->Sdap);
}

static void _serNrSysFreeNR_RadioBearerConfig_Type_Value(union NR_RadioBearerConfig_Type_Value* p, enum NR_RadioBearerConfig_Type_Sel d)
{
	if (d == NR_RadioBearerConfig_Type_AddOrReconfigure) {
		_serNrSysFreeNR_RadioBearerConfigInfo_Type(&p->AddOrReconfigure);
		return;
	}
}

static void _serNrSysFreeNR_RadioBearerConfig_Type(struct NR_RadioBearerConfig_Type* p)
{
	_serNrSysFreeNR_RadioBearerConfig_Type_Value(&p->v, p->d);
}

static void _serNrSysFreeNR_RadioBearer_Type(struct NR_RadioBearer_Type* p)
{
	_serNrSysFreeNR_RadioBearerConfig_Type(&p->Config);
}

static void _serNrSysFreeNR_SecurityActTimeList_Type_ActTimeList_Optional(struct NR_SecurityActTimeList_Type_ActTimeList_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i1 = 0; i1 < p->v.d; i1++) {
		}
		serFree(p->v.v);
	}
}

static void _serNrSysFreeNR_AS_IntegrityInfo_Type(struct NR_AS_IntegrityInfo_Type* p)
{
	_serNrSysFreeNR_SecurityActTimeList_Type_ActTimeList_Optional(&p->ActTimeList);
}

static void _serNrSysFreeNR_AS_IntegrityInfo_Type_Integrity_Optional(struct NR_AS_IntegrityInfo_Type_Integrity_Optional* p)
{
	if (!p->d) return;
	_serNrSysFreeNR_AS_IntegrityInfo_Type(&p->v);
}

static void _serNrSysFreeNR_AS_CipheringInfo_Type(struct NR_AS_CipheringInfo_Type* p)
{
	if (p->ActTimeList.v) {
		for (size_t i1 = 0; i1 < p->ActTimeList.d; i1++) {
		}
		serFree(p->ActTimeList.v);
	}
}

static void _serNrSysFreeNR_AS_CipheringInfo_Type_Ciphering_Optional(struct NR_AS_CipheringInfo_Type_Ciphering_Optional* p)
{
	if (!p->d) return;
	_serNrSysFreeNR_AS_CipheringInfo_Type(&p->v);
}

static void _serNrSysFreeNR_AS_SecStartRestart_Type(struct NR_AS_SecStartRestart_Type* p)
{
	_serNrSysFreeNR_AS_IntegrityInfo_Type_Integrity_Optional(&p->Integrity);
	_serNrSysFreeNR_AS_CipheringInfo_Type_Ciphering_Optional(&p->Ciphering);
}

static void _serNrSysFreeNR_AS_Security_Type_Value(union NR_AS_Security_Type_Value* p, enum NR_AS_Security_Type_Sel d)
{
	if (d == NR_AS_Security_Type_StartRestart) {
		_serNrSysFreeNR_AS_SecStartRestart_Type(&p->StartRestart);
		return;
	}
}

static void _serNrSysFreeNR_AS_Security_Type(struct NR_AS_Security_Type* p)
{
	_serNrSysFreeNR_AS_Security_Type_Value(&p->v, p->d);
}

static void _serNrSysFreeNR_PDCP_CountReq_Type_Value(union NR_PDCP_CountReq_Type_Value* p, enum NR_PDCP_CountReq_Type_Sel d)
{
	if (d == NR_PDCP_CountReq_Type_Set) {
		if (p->Set.v) {
			for (size_t i1 = 0; i1 < p->Set.d; i1++) {
			}
			serFree(p->Set.v);
		}
		return;
	}
}

static void _serNrSysFreeNR_PDCP_CountReq_Type(struct NR_PDCP_CountReq_Type* p)
{
	_serNrSysFreeNR_PDCP_CountReq_Type_Value(&p->v, p->d);
}

static void _serNrSysFreeSQN_NR_PagingRecordList_SQN_NR_Paging_pagingRecordList_Optional(struct SQN_NR_PagingRecordList_SQN_NR_Paging_pagingRecordList_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		for (size_t i1 = 0; i1 < p->v.d; i1++) {
		}
		serFree(p->v.v);
	}
}

static void _serNrSysFreeOCTET_STRING_SQN_NR_Paging_lateNonCriticalExtension_Optional(struct OCTET_STRING_SQN_NR_Paging_lateNonCriticalExtension_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		serFree(p->v.v);
	}
}

static void _serNrSysFreeSQN_NR_Paging(struct SQN_NR_Paging* p)
{
	_serNrSysFreeSQN_NR_PagingRecordList_SQN_NR_Paging_pagingRecordList_Optional(&p->pagingRecordList);
	_serNrSysFreeOCTET_STRING_SQN_NR_Paging_lateNonCriticalExtension_Optional(&p->lateNonCriticalExtension);
}

static void _serNrSysFreeSQN_NR_PCCH_MessageType_c1_Value(union SQN_NR_PCCH_MessageType_c1_Value* p, enum SQN_NR_PCCH_MessageType_c1_Sel d)
{
	if (d == SQN_NR_PCCH_MessageType_c1_paging) {
		_serNrSysFreeSQN_NR_Paging(&p->paging);
		return;
	}
}

static void _serNrSysFreeSQN_NR_PCCH_MessageType_c1(struct SQN_NR_PCCH_MessageType_c1* p)
{
	_serNrSysFreeSQN_NR_PCCH_MessageType_c1_Value(&p->v, p->d);
}

static void _serNrSysFreeSQN_NR_PCCH_MessageType_Value(union SQN_NR_PCCH_MessageType_Value* p, enum SQN_NR_PCCH_MessageType_Sel d)
{
	if (d == SQN_NR_PCCH_MessageType_c1) {
		_serNrSysFreeSQN_NR_PCCH_MessageType_c1(&p->c1);
		return;
	}
}

static void _serNrSysFreeSQN_NR_PCCH_MessageType(struct SQN_NR_PCCH_MessageType* p)
{
	_serNrSysFreeSQN_NR_PCCH_MessageType_Value(&p->v, p->d);
}

static void _serNrSysFreeSQN_NR_PCCH_Message(struct SQN_NR_PCCH_Message* p)
{
	_serNrSysFreeSQN_NR_PCCH_MessageType(&p->message);
}

static void _serNrSysFreeNR_SlotOffsetList_Type_SlotOffsetList_Optional(struct NR_SlotOffsetList_Type_SlotOffsetList_Optional* p)
{
	if (!p->d) return;
	if (p->v.v) {
		serFree(p->v.v);
	}
}

static void _serNrSysFreeNR_PagingTrigger_Type(struct NR_PagingTrigger_Type* p)
{
	_serNrSysFreeSQN_NR_PCCH_Message(&p->Paging);
	_serNrSysFreeNR_SlotOffsetList_Type_SlotOffsetList_Optional(&p->SlotOffsetList);
}

static void _serNrSysFreeNR_SystemRequest_Type_Value(union NR_SystemRequest_Type_Value* p, enum NR_SystemRequest_Type_Sel d)
{
	if (d == NR_SystemRequest_Type_Cell) {
		_serNrSysFreeNR_CellConfigRequest_Type(&p->Cell);
		return;
	}
	if (d == NR_SystemRequest_Type_CellAttenuationList) {
		if (p->CellAttenuationList.v) {
			for (size_t i1 = 0; i1 < p->CellAttenuationList.d; i1++) {
			}
			serFree(p->CellAttenuationList.v);
		}
		return;
	}
	if (d == NR_SystemRequest_Type_RadioBearerList) {
		if (p->RadioBearerList.v) {
			for (size_t i1 = 0; i1 < p->RadioBearerList.d; i1++) {
				_serNrSysFreeNR_RadioBearer_Type(&p->RadioBearerList.v[i1]);
			}
			serFree(p->RadioBearerList.v);
		}
		return;
	}
	if (d == NR_SystemRequest_Type_AS_Security) {
		_serNrSysFreeNR_AS_Security_Type(&p->AS_Security);
		return;
	}
	if (d == NR_SystemRequest_Type_PdcpCount) {
		_serNrSysFreeNR_PDCP_CountReq_Type(&p->PdcpCount);
		return;
	}
	if (d == NR_SystemRequest_Type_Paging) {
		_serNrSysFreeNR_PagingTrigger_Type(&p->Paging);
		return;
	}
}

static void _serNrSysFreeNR_SystemRequest_Type(struct NR_SystemRequest_Type* p)
{
	_serNrSysFreeNR_SystemRequest_Type_Value(&p->v, p->d);
}

static void _serNrSysFreeNR_SYSTEM_CTRL_REQ(struct NR_SYSTEM_CTRL_REQ* p)
{
	_serNrSysFreeNR_SystemRequest_Type(&p->Request);
}

void serNrSysProcessFree0Srv(struct NR_SYSTEM_CTRL_REQ* FromSS)
{
	if (FromSS) {
		_serNrSysFreeNR_SYSTEM_CTRL_REQ(FromSS);
	}
}

void serNrSysProcessFreeSrv(struct NR_SYSTEM_CTRL_REQ* FromSS)
{
	if (FromSS) {
		_serNrSysFreeNR_SYSTEM_CTRL_REQ(FromSS);
		serFree(FromSS);
	}
}

void serNrSysProcessInitSrv(unsigned char* _arena, size_t _aSize, struct NR_SYSTEM_CTRL_CNF** ToSS)
{
	serMem_t _mem = serMemInit(_arena, _aSize);

	*ToSS = (struct NR_SYSTEM_CTRL_CNF*)serMalloc(_mem, sizeof(struct NR_SYSTEM_CTRL_CNF));
	memset(*ToSS, 0, sizeof(struct NR_SYSTEM_CTRL_CNF));
}

static int _serNrSysEncConfirmationResult_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union ConfirmationResult_Type_Value* p, enum ConfirmationResult_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == ConfirmationResult_Type_Success) {
		HTON_8(&_buffer[*_lidx], p->Success, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == ConfirmationResult_Type_Error) {
		HTON_32(&_buffer[*_lidx], p->Error, _lidx);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncConfirmationResult_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct ConfirmationResult_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncConfirmationResult_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_CnfAspCommonPart_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_CnfAspCommonPart_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->CellId;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncNR_RoutingInfo_Type(_buffer, _size, _lidx, &p->RoutingInfo);
	_serNrSysEncTimingInfo_Type(_buffer, _size, _lidx, &p->TimingInfo);
	_serNrSysEncConfirmationResult_Type(_buffer, _size, _lidx, &p->Result);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_PDCP_CountCnf_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union NR_PDCP_CountCnf_Type_Value* p, enum NR_PDCP_CountCnf_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_PDCP_CountCnf_Type_Get) {
		HTON_32(&_buffer[*_lidx], p->Get.d, _lidx);
		for (size_t i1 = 0; i1 < p->Get.d; i1++) {
			_serNrSysEncNR_PdcpCountInfo_Type(_buffer, _size, _lidx, &p->Get.v[i1]);
		}
		return SIDL_STATUS_OK;
	}
	if (d == NR_PDCP_CountCnf_Type_Set) {
		HTON_8(&_buffer[*_lidx], p->Set, _lidx);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncNR_PDCP_CountCnf_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_PDCP_CountCnf_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncNR_PDCP_CountCnf_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncDeltaValues_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct DeltaValues_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	HTON_32(&_buffer[*_lidx], p->DeltaNRf1, _lidx);
	HTON_32(&_buffer[*_lidx], p->DeltaNRf2, _lidx);
	HTON_32(&_buffer[*_lidx], p->DeltaNRf3, _lidx);
	HTON_32(&_buffer[*_lidx], p->DeltaNRf4, _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncUE_NR_DeltaValues_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct UE_NR_DeltaValues_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncDeltaValues_Type(_buffer, _size, _lidx, &p->DeltaPrimaryBand);
	_serNrSysEncDeltaValues_Type(_buffer, _size, _lidx, &p->DeltaSecondaryBand);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_SystemConfirm_Type_Value(unsigned char* _buffer, size_t _size, size_t* _lidx, const union NR_SystemConfirm_Type_Value* p, enum NR_SystemConfirm_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_SystemConfirm_Type_Cell) {
		HTON_8(&_buffer[*_lidx], p->Cell, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == NR_SystemConfirm_Type_CellAttenuationList) {
		HTON_8(&_buffer[*_lidx], p->CellAttenuationList, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == NR_SystemConfirm_Type_RadioBearerList) {
		HTON_8(&_buffer[*_lidx], p->RadioBearerList, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == NR_SystemConfirm_Type_EnquireTiming) {
		HTON_8(&_buffer[*_lidx], p->EnquireTiming, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == NR_SystemConfirm_Type_AS_Security) {
		HTON_8(&_buffer[*_lidx], p->AS_Security, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == NR_SystemConfirm_Type_SystemIndCtrl) {
		HTON_8(&_buffer[*_lidx], p->SystemIndCtrl, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == NR_SystemConfirm_Type_PdcpCount) {
		_serNrSysEncNR_PDCP_CountCnf_Type(_buffer, _size, _lidx, &p->PdcpCount);
		return SIDL_STATUS_OK;
	}
	if (d == NR_SystemConfirm_Type_DciTrigger) {
		HTON_8(&_buffer[*_lidx], p->DciTrigger, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == NR_SystemConfirm_Type_MacCommandTrigger) {
		HTON_8(&_buffer[*_lidx], p->MacCommandTrigger, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == NR_SystemConfirm_Type_L1_TestMode) {
		HTON_8(&_buffer[*_lidx], p->L1_TestMode, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == NR_SystemConfirm_Type_PdcpHandoverControl) {
		HTON_8(&_buffer[*_lidx], p->PdcpHandoverControl, _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == NR_SystemConfirm_Type_DeltaValues) {
		_serNrSysEncUE_NR_DeltaValues_Type(_buffer, _size, _lidx, &p->DeltaValues);
		return SIDL_STATUS_OK;
	}
	if (d == NR_SystemConfirm_Type_SpsCg) {
		HTON_8(&_buffer[*_lidx], p->SpsCg, _lidx);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysEncNR_SystemConfirm_Type(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_SystemConfirm_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp = (size_t)p->d;
		HTON_32(&_buffer[*_lidx], _tmp, _lidx);
	}
	_serNrSysEncNR_SystemConfirm_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysEncNR_SYSTEM_CTRL_CNF(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_SYSTEM_CTRL_CNF* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncNR_CnfAspCommonPart_Type(_buffer, _size, _lidx, &p->Common);
	_serNrSysEncNR_SystemConfirm_Type(_buffer, _size, _lidx, &p->Confirm);

	return SIDL_STATUS_OK;
}

int serNrSysProcessEncSrv(unsigned char* _buffer, size_t _size, size_t* _lidx, const struct NR_SYSTEM_CTRL_CNF* ToSS)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysEncNR_SYSTEM_CTRL_CNF(_buffer, _size, _lidx, ToSS);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecConfirmationResult_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, union ConfirmationResult_Type_Value* p, enum ConfirmationResult_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == ConfirmationResult_Type_Success) {
		NTOH_8(p->Success, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == ConfirmationResult_Type_Error) {
		NTOH_32(p->Error, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecConfirmationResult_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct ConfirmationResult_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum ConfirmationResult_Type_Sel)_tmp;
	}
	_serNrSysDecConfirmationResult_Type_Value(_buffer, _size, _lidx, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_CnfAspCommonPart_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct NR_CnfAspCommonPart_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->CellId = (NR_CellId_Type)_tmp;
	}
	_serNrSysDecNR_RoutingInfo_Type(_buffer, _size, _lidx, &p->RoutingInfo);
	_serNrSysDecTimingInfo_Type(_buffer, _size, _lidx, &p->TimingInfo);
	_serNrSysDecConfirmationResult_Type(_buffer, _size, _lidx, &p->Result);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_PDCP_CountCnf_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union NR_PDCP_CountCnf_Type_Value* p, enum NR_PDCP_CountCnf_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_PDCP_CountCnf_Type_Get) {
		NTOH_32(p->Get.d, &_buffer[*_lidx], _lidx);
		p->Get.v = (struct NR_PdcpCountInfo_Type*)serMalloc(_mem, p->Get.d * sizeof(struct NR_PdcpCountInfo_Type));
		for (size_t i1 = 0; i1 < p->Get.d; i1++) {
			_serNrSysDecNR_PdcpCountInfo_Type(_buffer, _size, _lidx, &p->Get.v[i1]);
		}
		return SIDL_STATUS_OK;
	}
	if (d == NR_PDCP_CountCnf_Type_Set) {
		NTOH_8(p->Set, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecNR_PDCP_CountCnf_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_PDCP_CountCnf_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum NR_PDCP_CountCnf_Type_Sel)_tmp;
	}
	_serNrSysDecNR_PDCP_CountCnf_Type_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecDeltaValues_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct DeltaValues_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	NTOH_32(p->DeltaNRf1, &_buffer[*_lidx], _lidx);
	NTOH_32(p->DeltaNRf2, &_buffer[*_lidx], _lidx);
	NTOH_32(p->DeltaNRf3, &_buffer[*_lidx], _lidx);
	NTOH_32(p->DeltaNRf4, &_buffer[*_lidx], _lidx);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecUE_NR_DeltaValues_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, struct UE_NR_DeltaValues_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecDeltaValues_Type(_buffer, _size, _lidx, &p->DeltaPrimaryBand);
	_serNrSysDecDeltaValues_Type(_buffer, _size, _lidx, &p->DeltaSecondaryBand);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_SystemConfirm_Type_Value(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, union NR_SystemConfirm_Type_Value* p, enum NR_SystemConfirm_Type_Sel d)
{
	(void)_size; // TODO: generate boundaries checking

	if (d == NR_SystemConfirm_Type_Cell) {
		NTOH_8(p->Cell, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == NR_SystemConfirm_Type_CellAttenuationList) {
		NTOH_8(p->CellAttenuationList, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == NR_SystemConfirm_Type_RadioBearerList) {
		NTOH_8(p->RadioBearerList, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == NR_SystemConfirm_Type_EnquireTiming) {
		NTOH_8(p->EnquireTiming, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == NR_SystemConfirm_Type_AS_Security) {
		NTOH_8(p->AS_Security, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == NR_SystemConfirm_Type_SystemIndCtrl) {
		NTOH_8(p->SystemIndCtrl, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == NR_SystemConfirm_Type_PdcpCount) {
		_serNrSysDecNR_PDCP_CountCnf_Type(_buffer, _size, _lidx, _mem, &p->PdcpCount);
		return SIDL_STATUS_OK;
	}
	if (d == NR_SystemConfirm_Type_DciTrigger) {
		NTOH_8(p->DciTrigger, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == NR_SystemConfirm_Type_MacCommandTrigger) {
		NTOH_8(p->MacCommandTrigger, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == NR_SystemConfirm_Type_L1_TestMode) {
		NTOH_8(p->L1_TestMode, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == NR_SystemConfirm_Type_PdcpHandoverControl) {
		NTOH_8(p->PdcpHandoverControl, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}
	if (d == NR_SystemConfirm_Type_DeltaValues) {
		_serNrSysDecUE_NR_DeltaValues_Type(_buffer, _size, _lidx, &p->DeltaValues);
		return SIDL_STATUS_OK;
	}
	if (d == NR_SystemConfirm_Type_SpsCg) {
		NTOH_8(p->SpsCg, &_buffer[*_lidx], _lidx);
		return SIDL_STATUS_OK;
	}

	return SIDL_STATUS_ERROR;
}

static int _serNrSysDecNR_SystemConfirm_Type(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_SystemConfirm_Type* p)
{
	(void)_size; // TODO: generate boundaries checking

	{
		size_t _tmp;
		NTOH_32(_tmp, &_buffer[*_lidx], _lidx);
		p->d = (enum NR_SystemConfirm_Type_Sel)_tmp;
	}
	_serNrSysDecNR_SystemConfirm_Type_Value(_buffer, _size, _lidx, _mem, &p->v, p->d);

	return SIDL_STATUS_OK;
}

static int _serNrSysDecNR_SYSTEM_CTRL_CNF(const unsigned char* _buffer, size_t _size, size_t* _lidx, serMem_t _mem, struct NR_SYSTEM_CTRL_CNF* p)
{
	(void)_size; // TODO: generate boundaries checking

	_serNrSysDecNR_CnfAspCommonPart_Type(_buffer, _size, _lidx, &p->Common);
	_serNrSysDecNR_SystemConfirm_Type(_buffer, _size, _lidx, _mem, &p->Confirm);

	return SIDL_STATUS_OK;
}

int serNrSysProcessDecClt(const unsigned char* _buffer, size_t _size, unsigned char* _arena, size_t _aSize, struct NR_SYSTEM_CTRL_CNF** ToSS)
{
	(void)_size; // TODO: generate boundaries checking

	serMem_t _mem = serMemInit(_arena, _aSize);

	size_t __lidx = 0;
	size_t* _lidx = &__lidx;

	*ToSS = (struct NR_SYSTEM_CTRL_CNF*)serMalloc(_mem, sizeof(struct NR_SYSTEM_CTRL_CNF));
	_serNrSysDecNR_SYSTEM_CTRL_CNF(_buffer, _size, _lidx, _mem, *ToSS);

	return SIDL_STATUS_OK;
}

static void _serNrSysFreeNR_PDCP_CountCnf_Type_Value(union NR_PDCP_CountCnf_Type_Value* p, enum NR_PDCP_CountCnf_Type_Sel d)
{
	if (d == NR_PDCP_CountCnf_Type_Get) {
		if (p->Get.v) {
			for (size_t i1 = 0; i1 < p->Get.d; i1++) {
			}
			serFree(p->Get.v);
		}
		return;
	}
}

static void _serNrSysFreeNR_PDCP_CountCnf_Type(struct NR_PDCP_CountCnf_Type* p)
{
	_serNrSysFreeNR_PDCP_CountCnf_Type_Value(&p->v, p->d);
}

static void _serNrSysFreeNR_SystemConfirm_Type_Value(union NR_SystemConfirm_Type_Value* p, enum NR_SystemConfirm_Type_Sel d)
{
	if (d == NR_SystemConfirm_Type_PdcpCount) {
		_serNrSysFreeNR_PDCP_CountCnf_Type(&p->PdcpCount);
		return;
	}
}

static void _serNrSysFreeNR_SystemConfirm_Type(struct NR_SystemConfirm_Type* p)
{
	_serNrSysFreeNR_SystemConfirm_Type_Value(&p->v, p->d);
}

static void _serNrSysFreeNR_SYSTEM_CTRL_CNF(struct NR_SYSTEM_CTRL_CNF* p)
{
	_serNrSysFreeNR_SystemConfirm_Type(&p->Confirm);
}

void serNrSysProcessFree0Clt(struct NR_SYSTEM_CTRL_CNF* ToSS)
{
	if (ToSS) {
		_serNrSysFreeNR_SYSTEM_CTRL_CNF(ToSS);
	}
}

void serNrSysProcessFreeClt(struct NR_SYSTEM_CTRL_CNF* ToSS)
{
	if (ToSS) {
		_serNrSysFreeNR_SYSTEM_CTRL_CNF(ToSS);
		serFree(ToSS);
	}
}
